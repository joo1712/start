if(window.console === undefined){
	console = {log:function(){}};
}

QBOX = {
	config				: {
		locale	: "kr"
	},
	def					: {
		key		: {
			ENTER	: 13,
			ESC		: 27,
			BACKSPACE	: 8,
			SPACE	: 32,
			TAB		: 9,
			SHIFT	: 16,
			CTRL	: 17,
			ALT		: 18,
			PAGEUP	: 33,
			PAGEDOWN: 34,
			LEFT	: 37,
			UP		: 38,
			RIGHT	: 39,
			DOWN	: 40,
			F2		: 113,
			C		: 67,
			V		: 86,
			DELETE	: 46
		},
		which	: {
			LEFT_BUTTON		: 1,
			MIDDLE_BUTTON	: 2,
			RIGHT_BUTTON	: 3
		}
	},
	
	util				: {},
	
	st					: {},
	
	$					: ($ === undefined ? jQuery.noConflict() : $),
	
	_					: (_ === undefined ? _.noConflict() : _),
	
	s					: s,
	
	moment				: moment,
	
	browser				: this.$.browser,
	
	log					: function(type, widget, target, text){
		var d = new Date();
		console.log('[' + d.getHours() + ':' + d.getMinutes() + ':' + d.getSeconds() + '][' + widget + '][' + (type === 'err' ? 'ERROR][' : 'LOG][') + target + '()] ' + text);
	},
	
	hasInstance			: function(widget, id){
		return widget.storage.containsKey(id) ? true : false;
	},
	
	getInstance			: function(widget, id){
		if(widget.storage.containsKey(id)){
			return widget.storage.get(id);
		}
		return null;
	},
	
	getInstanceIDs		: function(widget){
		return widget.storage.keys();
	},
	
	deleteInstance		: function(widget, id){
		if(widget.storage.containsKey(id)){
			widget.storage.get(id).destroy();
			widget.storage.remove(id);
			return true;
		}
		return false;
	},
	
	deleteAllInstances	: function(widget){
		var result = true;
		widget.storage.each(function(id){
			if(widget.deleteInstance(id) === false){
				result = false;
			}
		});
		return result;
	},
	License : {
		'key' : 'RightTechLicense' ,
		'value' : 'U2FsdGVkX19T7Nd3e2J04HRtOdB87u87FU5w0bYRWmQ='
	},
	checkLicense : function (strLicense, strDomain){
		var strDecrypt = CryptoJS.AES.decrypt(strLicense, CryptoJS.AES.decrypt(QBOX.License.value,QBOX.License.key).toString(CryptoJS.enc.Utf8)).toString(CryptoJS.enc.Utf8);
		
		if(strDecrypt !== ""){
			if(strDecrypt === strDomain){
				return true;
			}				
		}
		return false;
	},
	decryptLicense : function (strLicense){
		return CryptoJS.AES.decrypt(strLicense, CryptoJS.AES.decrypt(QBOX.License.value,QBOX.License.key).toString(CryptoJS.enc.Utf8)).toString(CryptoJS.enc.Utf8);
	}
};

QBOX.st.asc = function(a, b){return a - b;};

QBOX.st.desc = function(a, b){return b - a;};

QBOX.st.eventProcess = function(event){
	var objWidget = event.data.target;
	if(objWidget && objWidget.tag() && objWidget.tag().indexOf('QBOX') > -1){
		objWidget._defaultAction.apply(objWidget, arguments);
	}
};

Array.prototype.indexOf = function(value, bIsSorted){
	return QBOX._.indexOf(this, value, bIsSorted);
};

Array.prototype.lastIndexOf = function(value, startIndex){
	return QBOX._.lastIndexOf(this, value, startIndex);
};

Array.prototype.swap = function(index1, index2){
	var temp = this[index1];
	this[index1] = this[index2];
	this[index2] = temp;
	temp = null;
};

Array.prototype.RT_insert = function(index, value){
	this.splice(index, 0, value);
};

Array.prototype.RT_insertArray = function(index, src){
	var arr = QBOX._.clone(src).reverse();
	for(var i = 0, len = arr.length; i < len; i++){
		this.RT_insert(index, arr[i]);
	}
};

Array.prototype.RT_clear = function(){
	while(this.length){
		this.pop();
	}
};

Array.prototype.RT_clone = function(){
	return QBOX._.clone(this);
};

Array.prototype.RT_union = function (target){
	//성능을 위해 binarySearch를 이용한 합집합 구현, 정렬되었다고 가정하고 사용할 것, 정렬되지 않은 배열의 합집합은 _.union() 사용 할 것
	var arrTemp = [];
	for (var i = 0; i < target.length; i++){
		if(QBOX._.indexOf(this, target[i], true) === -1){
			arrTemp.push(target[i]);
		}
	}
	return this.concat(arrTemp).sort(QBOX.st.asc);
};

Array.prototype.RT_intersection = function (target){
	//성능을 위해 정렬된 상태에서 교집합을 수행하는 intersection 내장함수 추가, 배열의 요소가 object인 경우는 지원하지 않는다.
	var result = [];
	while(this.length > 0 && target.length > 0){
		if(this[0] < target[0]){
			this.shift();
		} else if(this[0] > target[0]){
			target.shift();
		} else{/* they're equal */
			result.push(this.shift());
			target.shift();
		}
	}
	return result;
};

Array.prototype.RT_difference = function (target){
	//성능을 위해 binarySearch를 이용한 차집합 구현, 정렬되었다고 가정하고 사용할 것, 정렬되지 않은 배열의 차집합은 _.difference() 사용 할 것
	//두 배열은 정렬된 상태여야 한다. 배열의 요소가 object인 경우는 지원하지 않는다.
	for(var i = 0, nLength = target.length ; i < nLength ; i++){
		var idx = QBOX._.indexOf(this, target[i], true);
		
		if(idx > -1){
			this.splice(idx, 1);
		}
	}
	return this;
};

QBOX.util._extendSortMultiple = function () {
	/*
	 * ex) _extendSortMultiple('dept', 'asc', 'string');
	 * ex) _extendSortMultiple([['dept', 'asc', 'string'], ['name', 'desc', 'number']]);
	 * 
	 * asc = 1;
	 * desc = -1;
	 */
	
	if(arguments[1] instanceof Array){//다중 정렬
		var arrSortInfo = arguments[1];
		var arrProps = [];
		var arrSortOrder = [];
		var arrDataType = [];
		
		for(var i = 0 ; i < arrSortInfo.length ; i++){
			arrProps.push(arrSortInfo[i][0]);
			arrSortOrder.push((arrSortInfo[i][1] === undefined || (arrSortInfo[i][1] !== 'asc' && arrSortInfo[i][1] !== 'desc')) ? 'asc' : arrSortInfo[i][1]);
			arrDataType.push((arrSortInfo[i][2] === undefined || (arrSortInfo[i][2] !== 'string' && arrSortInfo[i][2] !== 'number')) ? 'string' : arrSortInfo[i][2]);
		}
		
		return function (obj1, obj2, datatype){
			var i = 0, result = 0, numberOfProperties = arrProps.length;
            while(result === 0 && i < numberOfProperties) {
                result = QBOX.util._extendSort(arrProps[i], arrSortOrder[i], arrDataType[i])(obj1, obj2, datatype);
                i++;
            }
            return result;
		};
	} else if(typeof arguments[1] == 'string' || typeof arguments[1] == 'number'){//단일 정렬
		var prop = arguments[1];
		var sortType = (arguments[2] === undefined || (arguments[2] !== 'asc' && arguments[2] !== 'desc')) ? 'asc' : arguments[2];
		var dataType = (arguments[3] === undefined || (arguments[3] !== 'string' && arguments[3] !== 'number')) ? 'string' : arguments[3];
		
		return function (obj1, obj2, datatype){
			return QBOX.util._extendSort(prop, sortType, dataType)(obj1, obj2, datatype);
		};
	}
};
QBOX.util._extendSort = function (prop, sortType, dataType) {
	/*
	 * ex) _extendSort('dept', 'asc', 'string');
	 * 
	 * asc = 1;
	 * desc = -1;
	 */
	
	if(sortType === 'asc'){
		sortType = 1;
	} else if(sortType === 'desc'){
		sortType = -1;
	}
	
	if(dataType === 'number'){
		return function(a, b){
			//property가 아예 없는 경우에 대한 고려
			var vala, valb;
			vala = a[prop];
			valb = b[prop];
			if(vala !== undefined && QBOX._.isString(vala)){
				vala = QBOX.util.replaceAll(vala,',','');
			}
			if(valb !== undefined && QBOX._.isString(valb)){
				valb = QBOX.util.replaceAll(valb,',','');
			}
			if(vala === undefined && valb !== undefined){
				return ('' - valb) * sortType;
			} else if(vala !== undefined && valb === undefined){
				return (vala - '') * sortType;
			} else{
				return (vala - valb) * sortType;
			}
		};
	} else{
		return function (a, b){
			//prop 없는 경우에 대한 고려
			if(a[prop] === undefined && b[prop] !== undefined){
				return (('' < b[prop]) ? -1 : ('' > b[prop]) ? 1 : 0) * sortType;
			} else if(a[prop] !== undefined && b[prop] === undefined){
				return ((a[prop] < '') ? -1 : (a[prop] > '') ? 1 : 0) * sortType;
			} else{
				return ((a[prop] < b[prop]) ? -1 : (a[prop] > b[prop]) ? 1 : 0) * sortType;
			}
		};
	}
};

Array.prototype.RT_sortBy = function(){
	return this.sort(QBOX.util._extendSortMultiple.apply(null, arguments));
};
QBOX.util.RT_sortBy = function(arr){
	return arr.sort(QBOX.util._extendSortMultiple.apply(null, arguments));
};

QBOX.util.rAF = null;
QBOX.util.cAF = null;

(function(){
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];
	for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x){
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
	
	QBOX.util.rAF = window.requestAnimationFrame ? function(callback){return window.requestAnimationFrame(callback);} : function(callback){
		var currTime = new Date().getTime();
		//var timeToCall = Math.max(0, 16 - (currTime - lastTime));
		var timeToCall = Math.max(0, 2 - (currTime - lastTime));
		var id = window.setTimeout(function(){
			callback(currTime + timeToCall);
		}, timeToCall);
		lastTime = currTime + timeToCall;
		return id;
	};
	
	QBOX.util.cAF = window.cancelAnimationFrame ? function(id){window.cancelAnimationFrame(id);} : function(id){window.clearTimeout(id);};
})();

QBOX.util.inherit = (function(){
	return function(C, P){
		C.prototype = new P();
	};
}());

//addMethod - By John Resig (MIT Licensed)
QBOX.util.addMethod = function(object, name, fn){
	var old = object[name];
	object[name] = function(){
		if (fn.length == arguments.length){
			return fn.apply(this, arguments);
		} else{
			if(typeof old == 'function'){
				return old.apply(this, arguments);
			}
		}
	};
};
QBOX.util.checkType = function(val, type){
	var result = false;
	switch(type){
		case 'array':		{result = QBOX._.isArray(val) ? true : false;	break;}
		case 'boolean':		{result = typeof val == 'boolean' ? true : false;	break;}
		case 'element':		{result = QBOX._.isElement(val) ? true : false;	break;}
		case 'function':	{result = QBOX._.isFunction(val) ? true : false;	break;}
		case 'jquery':		{result = val && val.jquery ? true : false;	break;}
		case 'number':		{result = typeof val == 'number' ? true : false;	break;}
		case 'object':		{result = typeof val == 'object' ? true : false;	break;}
		case 'string':		{result = typeof val == 'string' ? true : false;	break;}
	}
	return result;
};

QBOX.util.addClass = function (elems, value) {
	if (arguments.length < 2) {
		return;
	}
	if (value && (typeof value == 'string' || QBOX._.isArray(value))) {
		if (QBOX._.isElement(elems)) {
			elems = [elems];
		}
		if (QBOX._.isArray(elems)) {
			var classNames = (typeof value == 'string') ? value.split(/\s+/) : value;
			for (var i = 0, nLength = elems.length; i < nLength; i++) {
				var elem = elems[i];
				if (QBOX._.isElement(elem)) {
					if (!elem.className && classNames.length === 1) {
						elem.className = value;
					} else {
						var setClass = ' ' + elem.className + ' ';
						for (var c = 0, cl = classNames.length; c < cl; c++) {
							if (!~setClass.indexOf(' ' + classNames[c] + ' ')) {
								setClass += classNames[c] + " ";
							}
						}
						elem.className = QBOX.$.trim(setClass);
					}
				}
				elem = null;
			}
		}
	}
};

QBOX.util.removeClass = function (elems, value) {
	if (arguments.length < 1) {
		return;
	}
	
	if (value && (typeof value == 'string' || QBOX._.isArray(value)) || value === undefined) {
		if (QBOX._.isElement(elems)) {
			elems = [elems];
		}
		if (QBOX._.isArray(elems)) {
			var elem,
			className,
			classNames = (typeof value == 'string') ? (value || '').split(/\s+/) : value,
			rclass = /[\n\t\r]/g;
			
			for (var i = 0, nLength = elems.length; i < nLength; i++) {
				elem = elems[i];
				if (QBOX._.isElement(elem)) {
					if (value) {
						className = (' ' + elem.className + ' ').replace(rclass, ' ');
						for (var c = 0, cl = classNames.length; c < cl; c++) {
							className = className.replace(' ' + classNames[c] + ' ', ' ');
						}
						elem.className = QBOX.$.trim(className);
					} else {
						elem.className = '';
					}
				}
				elem = null;
			}
		}
	}
};

QBOX.util.hasClass = function (elem, value) {
	if (QBOX._.isElement(elem) && value && (typeof value == 'string' || QBOX._.isArray(value))) {
		var className = " " + ((typeof value == 'string') ? value : value.join().replace(/,/gi, " ")) + " ", rclass = /[\t\r\n\f]/g,
		i = 0;
		if(elem.nodeType === 1 && (" " + (elem.getAttribute("class") || "") + " ").replace(rclass, " ").indexOf(className) > -1){
			return true;
		}
	}
	return false;
};

QBOX.util.bind = function(elems, eventname, fn){
	if(QBOX._.isArray(QBOX._.isElement(elems) ? [elems] : elems)){
		QBOX._.each(elems, function(elem){
			if(elem.addEventListener){// all browsers except IE before version 9
				elem.addEventListener(eventname, fn, false);
			} else{
				if(elem.attachEvent){// IE before version 9
					elem.attachEvent(eventname, fn);
				}
			}
		});
		
		return true;
	}
	
	return false;
};

QBOX.util.addMethod(QBOX.util, 'textContent', function(elem){//getter
	//퍼포먼스를 위해 위해 _.isElement(elem)는 체크하지 않는다.
	return elem.textContent === undefined ? elem.innerText : elem.textContent;
});

QBOX.util.addMethod(QBOX.util, 'textContent', function(elem, value){//setter
	//퍼포먼스를 위해 위해 _.isElement(elem)는 체크하지 않는다.
	if(elem.textContent === undefined){
		elem.innerText = value;
	} else{
		elem.textContent = value;
	}
});

QBOX.util.empty = function (elem) {
	while(elem.firstChild) {
		elem.removeChild(elem.firstChild);
	}
};

QBOX.util.findCSSRule = function (selectorText) {
	return QBOX.$.stylesheet(selectorText).rules();
};

QBOX.util.createCSSRule = function (selectorText, styles) {
	var $ss = QBOX.$.stylesheet(selectorText);
	$ss.css(null).css(styles);
};

QBOX.util.removeCSSRule = function (selectorText) {
	var $ss = QBOX.$.stylesheet(selectorText);
	$ss.css(null);
};

_CheckMobile = {
		Android: function() {
			return navigator.userAgent.match(/Android/i);
		},
		BlackBerry: function() {
			return navigator.userAgent.match(/BlackBerry/i);
		},
		iOS: function() {
			return navigator.userAgent.match(/iPhone|iPad|iPod/i);
		},
		Opera: function() {
			return navigator.userAgent.match(/Opera Mini/i);
		},
		Windows: function() {
			return navigator.userAgent.match(/IEMobile/i);
		},
		any: function() {
			return (_CheckMobile.Android() || _CheckMobile.BlackBerry() || _CheckMobile.iOS() || _CheckMobile.Opera() || _CheckMobile.Windows());
		}
	};
QBOX.util.isMobile = function(){
	return _CheckMobile.any();
};

QBOX.util._dragElement = function(strid) {
	var elmnt = document.getElementById(strid);
	var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

	elmnt.onmousedown = dragMouseDown;

	function dragMouseDown(e) {
		if(!e.target.classList.contains( QBOX.QCELL.def.css.EXCLUDE_DRAGABLE)){
			e = e || window.event;
			e.preventDefault();
			// get the mouse cursor position at startup:
			pos3 = e.clientX;
			pos4 = e.clientY;
			document.onmouseup = closeDragElement;
			// call a function whenever the cursor moves:
			document.onmousemove = elementDrag;			
		}

		
	}

	function elementDrag(e) {
		e = e || window.event;
		e.preventDefault();
		
		pos1 = pos3 - e.clientX;
		pos2 = pos4 - e.clientY;
		pos3 = e.clientX;
		pos4 = e.clientY;

		elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
		elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
	}

	function closeDragElement() {
		document.onmouseup = null;
		document.onmousemove = null;
	}
};
QBOX.util.replaceAll = function (str, searchStr, replaceStr) {
	  return str.split(searchStr).join(replaceStr);
};

QBOX.util.strbyte = {
	getByteLength : function(s) {

		if (s === null || s.length === 0) {
			return 0;
		}
		var size = 0;

		for ( var i = 0; i < s.length; i++) {
			size += this.charByteSize(s.charAt(i));
		}

		return size;
	},
		
	cutByteLength : function(s, len) {

		if (s === null || s.length === 0) {
			return 0;
		}
		var size = 0;
		var rIndex = s.length;

		for ( var i = 0; i < s.length; i++) {
			size += this.charByteSize(s.charAt(i));
			if( size == len ) {
				rIndex = i + 1;
				break;
			} else if( size > len ) {
				rIndex = i;
				break;
			}
		}

		return s.substring(0, rIndex);
	},

	charByteSize : function(ch) {

		if (ch === null || ch.length === 0) {
			return 0;
		}

		var charCode = ch.charCodeAt(0);

		if (charCode <= 0x00007F) {
			return 1;
		} else if (charCode <= 0x0007FF) {
			return 2;
		} else if (charCode <= 0x00FFFF) {
			return 3;
		} else {
			return 4;
		}
	}
};

QBOX.Base = function(param){
	if(QBOX.util.checkType(param, 'object') === false){return null;}
	this._initGridProperties = function(param){
		var ret = QBOX._.clone(param),i;
		if(param.columns === undefined)
			return ret;
		
		ret.columns = [];
		for(i=0;i<param.columns.length;i++){
			ret.columns.push(QBOX._.clone(param.columns[i]));
		}
		
		return ret;
		
	};
	/* private member */
	var tag = "",
	types = [//미리 알파벳 순으로 넣을 것
		'array',
		'boolean',
		'element',
		'function',
		'jquery',
		'number',
		'object',
		'string'
	],
	props = param,
	initProps = this._initGridProperties(param),
	attr = new _QHashtable(),
	attrInfo = new _QHashtable(),//DATA TYPE 별 member 이름 정보
	typeInfo = new _QHashtable();//속성들의 타입 정보
	
	QBOX._.each(types, function(type){
		attrInfo.put(type, new _QHashSet());
	});
	attrInfo.put('all', new _QHashSet());
	
	/* public member */
	
	this.log = function(){console.log.apply(console, arguments);};
	this.getProperties = function(){return props;};
	this.setPropertiesColumn = function(arrCol) { props.columns = arrCol;};
	this.getInitProperties = function () {
		props.columns = [];
		for(var i=0; i < initProps.columns.length; i++){
			props.columns.push ( QBOX._.clone(initProps.columns[i]));
		} 
		return initProps; 
	};
	this.destroy = function(){
		var temp = this;
		
		this._clearAttrs();
		this.clear();
		attrInfo.clear();
		typeInfo.clear();
		
		QBOX._.each(QBOX._.keys(temp), function(key){
			delete temp[key];
		});
		
		types = props = attr = attrInfo = temp = null;
	};
	
	this.clear = function(){
		attrInfo.each(function(type, attrList){
			attrList.clear();
		});
		attr.clear();
	};
	
	this.removeAttr = function(key){
		if(typeInfo.containsKey(key)){
			var strAttrType = typeInfo.get(key);
			if(attrInfo.containsKey(strAttrType)){
				var attrList = attrInfo.get(strAttrType);
				if(attrList && attrList.contains(key)){
					attrList.remove(key);
				}
				typeInfo.remove(key);
				attrInfo.get('all').remove(key);
				attr.remove(key);
				return true;
			}
		}
		return false;
	};
	
	//Method Overloading 구현(private 멤버에 접근이 필요한 경우만 여기서 정의하고, 나머지는 _initMOL()에서 정의한다.)
	QBOX.util.addMethod(this, 'attr', function(key){
		return attr.get(key);
	});
	QBOX.util.addMethod(this, 'attr', function(key, val, type){
		try{
			if(val === undefined || val === null || QBOX.util.checkType(val, type)){//타입 체크
				if(attr.containsKey(key)){
					if(QBOX._.indexOf(types, type) > -1 && attrInfo.get(type).contains(key)){
						attr.put(key, val);
						return true;
					}
				} else if(QBOX._.indexOf(types, type) > -1){
					attrInfo.get(type).add(key);
					attr.put(key, val);
					attrInfo.get('all').add(key);
					typeInfo.put(key, type);
					return true;
				}
			}
			return false;
		} catch(e){
			console.log(e.message);
		}
	});
	
	QBOX.util.addMethod(this, 'attrList', function(){
		return attrInfo.get('all').values().sort();
	});
	
	QBOX.util.addMethod(this, 'attrList', function(type){
		return (QBOX._.indexOf(types, type, true) > -1 ? attrInfo.get(type).values().sort() : []);
	});
	
	QBOX.util.addMethod(this, 'tag', function(){
		return tag;
	});
	QBOX.util.addMethod(this, 'tag', function(tagname){
		if(QBOX._.isString(tagname)){
			tag = tagname;
			return true;
		}
		return false;
	});
	
	this._initTag();	//객체 생성 시 한 번만 세팅
	this._initMOL();	//객체 생성 시 한 번만 세팅
	this._init(param);	//재호출 가능성 있음
};

QBOX.Base.prototype._initMOL = function(){
	//Method Overloading 구현
	QBOX.util.addMethod(this, '_parent', function(){//getter
		return this.attr('parent');
	});
	QBOX.util.addMethod(this, '_parent', function(parent){//setter
		//상황에 따라 부모가 객체인 경우도 있고 element인 경우도 있으므로 setter부분은 객체에서 재정의하여 사용하는 경우도 있음
	});
};

QBOX.Base.prototype._initTag = function(param){
	this.tag('QBOX.Base');
};

QBOX.Base.prototype._init = function(param){
	this._initAttrs(param);
	this._setParent();
};

QBOX.Base.prototype._initAttrs = function(param){
	this.attr('id', param.id, 'string');
	this.attr('parentid', param.parentid, 'string');
	
	this.attr('parent', null, 'object');
	
	this.attr('prev_param',param,'object');
};

QBOX.Base.prototype._setParent = function(){};

QBOX.Base.prototype._clearAttrs = function(){
	//메모리 누수 방지를 위해 단순히 속성을 제거하여 링크를 끊어버리는 게 아니라 DOM을 삭제하거나, 자료구조를 비워줘야 하는 경우가 있다.
};

QBOX.Element = function(param){
	if(QBOX.util.checkType(param, 'object') === false){return null;}
	QBOX.Base.call(this, param);
};
QBOX.util.inherit(QBOX.Element, QBOX.Base);

QBOX.Element.prototype._initTag = function(param){
	this.tag('QBOX.Element');
};

QBOX.Element.prototype._init = function(param){
	QBOX.Base.prototype._init.call(this, param);
};

QBOX.Element.prototype._initAttrs = function(param){
	QBOX.Base.prototype._initAttrs.call(this, param);
	this.attr('element', null, 'element');
};

QBOX.Element.prototype._setElement = function(target){
	if(QBOX._.isElement(target)){
		this.attr('element', target, 'element');
		return true;
	}
	
	return false;
};

/** @namespace */
QBOX.QCELL = {
	/**
     * 위젯 이름
     * @type {String}
     * @ignore
     */
	name				: 'QCELL',
	
	/**
     * log4javascript를 이용하여 log를 기록합니다.
     * @type {function}
     * @param {String} type - 로그 타입 ("error" | "log")
     * @param {String} target - 로그 대상
     * @param {String} text - 로그 내용
     * @example
     * QCELL.log("err", "QCELL.create()", "Please check "id" property.");
     * @ignore
     */
	log					: function(type, target, text){
		QBOX.log(type, this.name, target, text);
	},
	
	/**
     * QCELL 객체 관리 저장소
     * @type {Hashtable}
     * @ignore
     */
	storage				: new _QHashtable(),
	
	/**
     * QCELL 라이브러리 모듈 상태 확인
     * @type {Object}
     * @namespace
     * @ignore
     */
	module				: {},
	
	/**
     * QCELL의 컬럼객체의 기본 속성값이 정의되어 있는 namespace
     * @type {Object}
     * @namespace
     * @ignore
     */
	colconfig			: {},
	
	/**
     * QCELL의 기본 속성값이 정의되어 있는 namespace
     * @type {Object}
     * @namespace
     * @ignore
     */
	config				: {
		locale	: QBOX.config.locale
	},
	
	/**
     * QCELL의 상수들의 namespace
     * @namespace
     * @ignore
     */
	def					: {
		/**
	     * QCELL에서 사용하는 message들이 정의되어 있는 namespace
	     * @type {Object}
	     * @namespace
	     * @ignore
	     */
		msg			: {},
	
		/**
	     * QCELL의 각 영역의 이름이 정의되어 있는 namespace
	     * @type {Object}
	     * @namespace
	     * @ignore
	     */
		areaname	: {},
		
		/**
	     * QCELL의 CSS 클래스명에 붙일 prefix가 정의되어 있는 속성
	     * @type {Object}
	     * @namespace
	     * @ignore
	     */
		cssprefix	: '',
		
		/**
	     * QCELL의 CSS 클래스명이 정의되어 있는 namespace
	     * @type {Object}
	     * @namespace
	     * @ignore
	     */
		css			: {},
		
		/**
	     * QCELL의 행 그룹 구분값들이 정의되어 있는 namespace
	     * @type {Object}
	     * @namespace
	     * @ignore
	     */
		rowgroup	: {},
		
		/**
	     * QCELL의 열 Type CSS 클래스명이 정의되어 있는 namespace
	     * @type {Object}
	     * @namespace
	     * @ignore
	     */
		type		: {}
	},
	
	/**
     * QCELL의 static 함수들의 namespace
     * @namespace
     * @ignore
     */
	st					: {
		replaceText2HeaderText: function(str){
			return QBOX._.escape(str).replace(/(\n|\r\n)/g, '<br>');
		}
	},
	
	/**
     * QCELL 객체를 생성합니다.
     * @type {function}
     * @param {Object} properties - QCELL 생성 정보
     * @param {String} properties.parentid - QCELL가 표시될 컨테이너의 id 설정
     * @param {String} properties.id - 생성 할 QCELL 객체의 id 설정
     * @returns {Boolean}
     * @example
     * QCELL._create({
     * 	"parentid"	: "sheetarea",
     * 	"id"		: "sheet1"
     * });
     * @ignore
     */
	_create				: function(properties){
		var qcell = null;
		var nState = -1,strDecrypt;
		if(window[QBOX.License.key] === undefined){
			nState = 0;
		}else if(QBOX._.isArray(window[QBOX.License.key])){
			var arrLicense = window[QBOX.License.key];
			arrLicense.forEach(function(item){
				strDecrypt = CryptoJS.AES.decrypt(item, CryptoJS.AES.decrypt(QBOX.License.value,QBOX.License.key).toString(CryptoJS.enc.Utf8)).toString(CryptoJS.enc.Utf8);
				
				if(strDecrypt !== ""){
					if(strDecrypt === window.location.hostname){
						nState = 1;
					}				
				}
			});
		}else if (QBOX._.isString(window[QBOX.License.key])){
			var strLicense = window[QBOX.License.key];
			
			strDecrypt = CryptoJS.AES.decrypt(strLicense, CryptoJS.AES.decrypt(QBOX.License.value,QBOX.License.key).toString(CryptoJS.enc.Utf8)).toString(CryptoJS.enc.Utf8);
			
			if(strDecrypt !== ""){
				if(strDecrypt === window.location.hostname){
					nState = 1;
				}				
			}
		}else{
			nState = 0;
		}
		QBOX._s = nState;
		
		switch(this.module){
			case 'basic'	: {
				qcell = QBOX.QCELL.BasicQCELL.create(properties);	break;
			}
			case 'normal'	: {
				qcell = QBOX.QCELL.NormalQCELL.create(properties);	break;
			}
			default			: {
				break;
			}
		}
		
		if(qcell !== null){
			if(qcell._createCols() && qcell._create()){
				this.storage.put(properties.id, qcell);
				qcell = null;
				return true;
			} else{
				qcell.destroy();
			}
		}
		qcell = null;
		
		return false;
	},
	
	/**
     * 입력한 ID에 해당하는 QCELL 객체의 존재 여부를 반환합니다.
     * @type {function}
     * @param {String} id - 존재 여부를 반환 할 QCELL 객체의 id 설정
     * @returns {Boolean}
     * @example
     * QCELL._hasInstance("sheet1");
     * @ignore
     */
	_hasInstance			: function(id){
		try{
			return QBOX.hasInstance(this, id);
		} catch(e){
			this.log('err', 'hasInstance', e.message);
		}
	},
	
	/**
     * QCELL 객체를 반환합니다.
     * @type {function}
     * @param {String} id - 반환 할 QCELL 객체의 id 설정
     * @returns {Object}
     * @example
     * var sheet1 = QCELL._getInstance("sheet1");
     * @ignore
     */
	_getInstance			: function(id){
		try{
			return QBOX.getInstance(this, id);
		} catch(e){
			this.log('err', 'getInstance', e.message);
		}
	},
	
	/**
     * QCELL 객체들의 id를 배열로 반환합니다.
     * @type {function}
     * @returns {Array}
     * @example
     * var arrSheetIDs = QCELL._getInstanceIDs();
     * @ignore
     */
	_getInstanceIDs		: function(){
		try{
			return QBOX.getInstanceIDs(this);
		} catch(e){
			this.log('err', 'getInstanceIDs', e.message);
		}
	},
	
	/**
     * QCELL 객체를 제거합니다.
     * @type {function}
     * @param {String} id - 제거 할 QCELL 객체의 id 설정
     * @returns {Boolean}
     * @example
     * QCELL._deleteInstance("sheet1");
     * @ignore
     */
	_deleteInstance		: function(id){
		try{
			return QBOX.deleteInstance(this, id);
		} catch(e){
			this.log('err', 'deleteInstance', e.message);
		}
	},
	
	/**
     * 모든 QCELL 객체들을 제거합니다.
     * @type {function}
     * @returns {Boolean}
     * @example
     * QCELL._deleteAllInstances();
     * @ignore
     */
	_deleteAllInstances	: function(){
		try{
			return QBOX.deleteAllInstances(this);
		} catch(e){
			this.log('err', 'deleteAllInstances', e.message);
		}
	}
};

/**
 * @since QCELL v1.0.0
 * @author seongdeuk1985
 * @description QCELL 객체를 생성합니다.
 * @param {Object} [properties] - QCELL 생성 정보
 * @param {string} [properties.parentid] - QCELL을 표시할 div 컨테이너의 ID
 * @param {string} [properties.id] - 생성할 QCELL 객체의 ID
 * @param {Object} [properties.data] - 표시할 데이터(JSON Array 타입)
 * @param {string} [properties.data.type="object"] - 표시할 데이터의 타입 ("object" | "array") 
 * @param {Object | Array} [properties.data.input] - 표시할 데이터 객체
 * @param {boolean} [properties.original=false] - 데이터의 백업 설정 여부 (v2.1.57 이상부터 지원)
 * @param {string} [properties.rowheader="none"] - 표시할 행번호 타입 ("none" | "sequence" | "reverse" | "checkbox" | "state")
 * @param {string} [properties.selectmode="cells"] - 선택 단위 ("rows" | "row" | "cols" | "col" | "cells" | "cell" | "group")
 * @param {number} [properties.highlightrepeat=0] - 행 스타일을 반복하여 적용하는 "hightlightrepeat" 속성의 행 반복 주기
 * @param {number} [properties.frozencols=0] - 틀고정 열 개수
 * @param {number} [properties.frozenrows=0] - 틀고정 행 개수
 * @param {number} [properties.frozenbottomrows=0] - 하단 틀고정 행 개수
 * @param {Object} [properties.rowheight] - 행 높이
 * @param {number} [properties.rowheight.header=40] - 헤더 영역의 높이 (단위: pixel)
 * @param {number} [properties.rowheight.data=40] - 데이터 표시 영역의 높이 (단위: pixel)
 * @param {boolean} [properties.copy=false] - ctrl+c 를 이용하여 선택된 셀들에 대한 클립보드 복사 기능 사용 여부 (v2.1.2 이상부터 지원)
 * @param {boolean} [properties.paste=false] - 클립보드 데이터를 ctrl+v 를 이용하여 그리드에 붙여넣기 기능 사용 여부 (v2.1.2 이상부터 지원)
 * @param {boolean} [properties.oneclickedit=false] - 텍스트 입력이 가능한 컬럼타입 사용시 마우스 원 클릭을 이용한 편집모드 전환 여부
 * @param {boolean} [properties.useGroupUI=false] - GROUP UI 사용 여부 (v2.1.45 이상부터 지원)
 * @param {boolean} [properties.bottompanel=false] - QCELL하단에 excel처럼 선택한 셀들의 갯수, 합계, 평균을 표시하시는 패널 표시 여부 (v2.1.66 이상부터 지원)
 * @param {boolean} [properties.bottompanelheight=40] - QCELL하단 패널 영역의 높이 (v2.1.66 이상부터 지원)
 * @param {string} [properties.onloadurl] - QCELL 생성시 통신할 URL 주소 (v2.1.2 이상부터 지원)
 * @param {string} [properties.emptymessage] - 데이터 없을 때 표시할 text (v2.1.6 이상부터 지원)
 * @param {Object} [properties.pagination] - pagination 설정 (v2.1.2 이상부터 지원)
 * @param {number} [properties.pagination.pageunit] - pagination 사용시 화면에 출력할 Data의 Row수
 * @param {Array} [properties.pagination.unitlist] - pagination 사용시 화면에 출력 설정이 가능한 Data의 Row수의 배열
 * @param {string} [properties.pagination.url] - pagination 사용시 server와 통신할 url주소
 * @param {boolean} [properties.pagination.loadonce=false] - pagination 사용시 url주소가 설정되어 있을 때 server와 통신을 처음 한번만 할 것인가 선택
 * @param {boolean} [properties.pagination.totalsort=false] - pagination 사용시 sort기능과 같이 사용할 때 전체 sort 설정 여부 (v2.1.4 이상부터 지원)
 * @param {Object} [properties.pagination.param] - pagination 사용시 url주소가 설정되어 있을 때 전달하고자하는 파라미터 정보
 * @param {string} [properties.pagination.mode="simple"] - pagination 사용 방법 설정 ("simple" || "extend") (v2.1.4 이상부터 지원)
 * @param {number} [properties.pagination.pagecount=5] - pagination mode 'extend' 일 때 하단에 표시할 페이지 갯수 설정 (v2.1.4 이상부터 지원)
 * @param {boolean} [properties.pagination.extendmove=false] - pagination mode 'extned' 일 때 하단에 이동할 페이지 입력 화면 표시 (v2.1.5 이상부터 지원)
 * @param {boolean} [properties.pagination.useProgress=false] - pagination url 일 경우 서버 통신 중 Progress 표시 여부 
 * @param {Array} [properties.columns] - 생성할 컬럼 정보
 * @param {string} [properties.columns.title] - 컬럼의 헤더 타이틀 (멀티 타이틀 설정 가능)
 * @param {string | number} [properties.columns.key] - 컬럼에 표시할 key값 (표시할 데이터의 타입이 "array"인 경우 "number"타입으로 설정)
 * @param {string} [properties.columns.type="static"] - 컬럼 타입 ("static" | "input" | "textarea" | "datepicker" | "selectmenu" | "checkbox" | "image" | "html" | "chart" | "multicheckbox" | "number" | "slider" | "button" | "editor") 
 * @param {string} [properties.columns.width="100px"] - 컬럼의 넓이 ("%" 사용 가능)
 * @param {string} [properties.columns.datatype="string"] - 컬럼 데이터 타입 ("string" | "number")
 * @param {boolean} [properties.columns.move=false] - 컬럼 이동 기능 사용 여부
 * @param {boolean} [properties.columns.sort=false] - 컬럼 정렬 기능 사용 여부. col type이 "checkbox"이고, properties.columns.options.wholeselect=true 일 때 혹은 properties.pagination.totalsort = true 와 properties.pagination.url 정보가 같이 설정되어 있으면 미동작 (v2.1.4 이상부터 지원)
 * @param {boolean} [properties.columns.resize=false] - 컬럼 너비 조절 기능 사용 여부 (v2.1.1 이상부터 지원)
 * @param {boolean} [properties.columns.search=false] - 컬럼 검색 기능 사용 여부 (v2.1.7 이상부터 지원)
 * @param {boolean} [properties.columns.tooltip=false] - 컬럼 툴팁 기능 사용 여부 (v2.1.8 이상부터 지원)
 * @param {boolean} [properties.columns.disabled=false] - "static", "html" 컬럼 타입 외의 모든 컬럼 타입 비활성화 여부 설정 (v2.1.8 이상부터 지원)
 * @param {boolean} [properties.columns.editor=false] - 컬럼의 스타일을 editor를 통해 설정 여부 (v2.1.50 이상부터 지원)
 * @param {Object} [properties.columns.styleclassname] - 컬럼 스타일 클래스 설정 (v2.1.3 이상부터 지원)
 * @param {string} [properties.columns.styleclassname.header] - 헤더 영역 스타일 클래스 이름
 * @param {string} [properties.columns.styleclassname.data] - 데이터 영역 스타일 클래스 이름
 * @param {Object} [properties.columns.style] - 컬럼 스타일 설정 (v2.1.50 이상부터 지원)
 * @param {Object} [properties.columns.style.header] - 헤더 영역 스타일 정보
 * @param {Object} [properties.columns.style.data] - 데이터 영역 스타일 정보
 * @param {Object} [properties.columns.options] - 컬럼타입 의존 속성 정보
 * @param {boolean} [properties.columns.options.mergecol] - merge type "col" 이용시 컬럼의 merge 실행 여부 (v2.1.72 이상부터 지원)
 * @param {Object} [properties.columns.options.format] - "static", "input" 컬럼타입 사용시 컬럼의 데이터에 대한 포멧
 * @param {string} [properties.columns.options.format.type] - "static", "input" 컬럼타입 사용시 포멧 타입 ("string" | "number" | "date" | "custom") 
 * @param {string} [properties.columns.options.format.origin] - "static", "input" 컬럼타입 사용시 데이터의 원본 날짜 포멧 ("date" 포멧 타입에서만 사용, ex> "YYYY-MM-DD a hh:mm:ss" | "YYYYMMDD") * 상세한 format 설정은 https://momentjs.com/docs/#/parsing/string-format/ 를 참조하여 주시길 바랍니다. (v2.1.3 부터 변경)
 * @param {string} [properties.columns.options.format.rule] - "static", "input" 컬럼타입 사용시 데이터를 출력할 포멧 ("custom" 포멧 타입 생략 가능, ex> "￦ #,###.##")
 * @param {string} [properties.columns.options.format.locale] - "static", "input" 컬럼타입 사용시 "type"이 "number" 나 "date"일 때 사용하려는 국가코드 입력, ex> "en" | "kr"
 * @param {Function} [properties.columns.options.format.callback] - "static", "input" 컬럼타입 사용시 "custom" 포멧 타입에서만 사용이 가능하며, 커스터마이징한 format 함수
 * @param {Function} [properties.columns.options.html.header] - 컬럼의 헤더 영역 renderer 콜백 함수
 * @param {Function} [properties.columns.options.html.data] - 컬럼의 데이터 영역 renderer 콜백 함수, (editor 컬럼에서도 같이 사용)
 * @param {Object} [properties.columns.options.mask] - "input" 컬럼타입 사용시 입력 형태 표시
 * @param {string} [properties.columns.options.mask.alias] - "input" 컬럼타입 사용시 입력 형태 (ex> "(999)-9999-9999")
 * @param {string} [properties.columns.options.numrange] - "input" 컬럼타입 사용시 입력 가능한 숫자 범위 지정 (ex> -100:100)
 * @param {number} [properties.columns.options.maxlength] - "input", "textarea" 컬럼타입 사용시 최대 입력 가능 수
 * @param {Object} [properties.columns.options.limit] - "input", "textarea" 컬럼타입 사용시 입력제한 방식 설정 (2.1.8 이상부터 지원, 2.1.9부터 Object형으로 변경)
 * @param {string} [properties.columns.options.limit.type] - 입력제한 타입 설정 ("all" | "string" | "number" | "other" ) * number는 '0부터9와 ,.-' 사용가능, string은 '0부터9'를 제외한 나머지 사용가능, other는 입력가능한 문자 설정 가능
 * @param {string} [properties.columns.options.limit.regexp] - 입력제한 타입이 "other" 일 때 사용, 입력 가능한 문자 설정
 * @param {Array} [properties.columns.options.exclude] 사용자가 입력 후 제거해야 할 문자 들 설정 ex ['"','\\']
 * @param {string} [properties.columns.options.textareawidth] - "textarea" 컬럼타입 사용시 textarea의 넓이
 * @param {string} [properties.columns.options.locale="ko"] - "datepicker" 컬럼타입 사용시 출력할 달력의 언어 ("ko" | "en")
 * @param {string} [properties.columns.options.dateformat="yymmdd"]  - "datepicker" 컬럼타입 사용시 원본 데이터의 날짜 포맷 (ex> "yy.mm.dd" | "ddmmyy")
 * @param {boolean} [properties.columns.options.changeyear=false]  - "datepicker" 컬럼타입 사용시 달력의 년 선택 가능 여부 (v2.1.2 이상부터 지원)
 * @param {boolean} [properties.columns.options.changemonth=false]  - "datepicker" 컬럼타입 사용시 달력의 월 선택 가능 여부 (v2.1.2 이상부터 지원)
 * @param {string} [properties.columns.options.yearrange="c-10:c+10"]  - "datepicker" 컬럼타입 사용시 달력 년도 선택 가능 기간 설정 (ex> "c-1000:c+1000" | "+100:-100" | "1900|2200") (v2.1.9 이상부터 지원)
 * @param {string} [properties.columns.options.timetype="none"] - "datepicker" 컬럼타입 사용시 timepicker의 사용 여부 ("none" | "with" | "only") (v2.1.44 이상부터 지원)
 * @param {string} [properties.columns.options.timeformat="HHmmss"] - "datepicker" 컬럼타입 사용시 timepicker의 시간 포맷 (ex> "h:m:s") H는 24시간, h는 12시간, m은 분, s는 초이며, HH와 같이 두 글자로 설정한 경우에만 앞에 0을 표시 (v2.1.44 이상부터 지원)
 * @param {string} [properties.columns.options.timeseparator=" "] - "datepicker" 컬럼타입 사용시 date 정보와 time 정보의 구분자 (ex > "20190505 153015") (v2.1.44 이상부터 지원)
 * @param {string} [properties.columns.options.dateimage=""] - "datepicker" 컬럼타입 사용시 컬럼에 출력할 calendar의 이미지 주소 (이미지의 크기는 기본 16x16으로 출력)
 * @param {string} [properties.columns.options.dateimageside="right"] - "datepicker" 컬럼타입 사용시 calendar의 좌우위치 설정 ("left" | "right")
 * @param {boolean} [properties.columns.options.dateimageonly=false] - "datepicker" 컬럼타입 사용시 click에 대한 동작을 calendar에만 할 것인지 설정 여부
 * @param {Object} [properties.columns.options.input] - "selectmenu", "multicheckbox" 컬럼타입 사용시 사용할 콤보 아이템 JSON Object의 레퍼런스
 * @param {number} [properties.columns.options.itemcount] - "selectmenu" 컬럼타입 사용시 표현할 콤보 아이템의 표시 개수
 * @param {boolean} [properties.columns.options.selectedEnd=false] - "selectmenu" 컬럼타입 사용시 아이템을 선택하면 종료의 설정 여부 (bind("selected")로 이벤트를 설정할 수 있으며, parameter는 (event, row, col, item)이다.)
 * @param {boolean} [properties.columns.options.selectclickopen=false] - "selectmenu" 컬럼타입 사용시 editmode 활성화시 selectmenu 펼쳐침 설정 여부 (v.2.1.63 이상부터 지원)
 * @param {boolean} [properties.columns.options.wholeselect=false] - "checkbox" 컬럼타입 사용시 전체 선택 checkbox 성생 여부, "likeradio"가 true일 때 미동작
 * @param {boolean | string} [properties.columns.options.checkedvalue=true] - "checkbox" 컬럼타입 사용시 선택했을 때의 데이터의 값
 * @param {boolean | string} [properties.columns.options.uncheckedvalue=false] - "checkbox" 컬럼타입 사용시 선택해제했을 때의 데이터의 값
 * @param {boolean} [properties.columns.options.likeradio=false] - "checkbox", "multicheckbox" 컬럼타입 사용시 동작을 "radio"와 같이 하나만 선택 가능
 * @param {string} [properties.columns.options.imagealt] - "image" 컬럼타입 사용시 image element 의 대체 문구
 * @param {string} [properties.columns.options.imageheight] - "image" 컬럼타입 사용시 image element의 높이
 * @param {string} [properties.columns.options.imagewidth] - "image" 컬럼타입 사용시 image element의 넓이
 * @param {Object} [properties.columns.options.imagestyle] - "image" 컬럼타입 사용시 image element의 스타일
 * @param {string} [properties.columns.options.imageclick] - "image" 컬럼타입 사용시 image element를 클릭할 때 동작할 event 콜백 함수명
 * @param {string} [properties.columns.options.imageuri] - "image" 컬럼타입 사용시 출력할 image의 경로
 * @param {string} [properties.columns.options.imageerroruri] - "image" 컬럼타입 사용시 에러가 발생할 경우 출력할 에러 image의 경로
 * @param {number} [properties.columns.options.min] - "number", "slider" 컬럼타입 사용시 표현할 값의 최소값 설정
 * @param {number} [properties.columns.options.max] - "number", "slider" 컬럼타입 사용시 표현할 값의 최대값 설정
 * @param {number} [properties.columns.options.step] - "number", "slider" 컬럼타입 사용시 변경할 값의 범위
 * @param {string} [properties.columns.options.buttonwidth] - "button" 컬럼타입 사용시 적용할 버튼의 넓이 (기본 단위: 'px')
 * @param {string} [properties.columns.options.buttonheight="20px"] - "button" 컬럼타입 사용시 적용할 버튼의 높이  (기본 단위: 'px')
 * @param {string} [properties.columns.options.buttonposition="left"] - "button" 컬럼타입 사용시 적용할 버튼의 위치
 * @param {string} [properties.columns.options.buttonlabel=""] - "button" 컬럼타입 사용시 적용할 버튼의 라벨
 * @param {Function} [properties.columns.options.buttonclick] - "button" 컬럼타입 사용시 버튼 클릭 시 동작할 함수
 * @param {Object} [properties.merge] - 병합 방법(JSON Array 타입)
 * @param {string} [properties.merge.header="none"] - 헤더 영역의 병합 방식 ("none" | "row" | "col" | "rowandcol" | "colandrow")
 * @param {string} [properties.merge.data="none"] - 데이터 영역의 병합 방식 ("none" | "row" | "col" | "group") (v.2.17 이상부터 기존 "viewport"에서 "data"로 변경)
 * @param {Object} [properties.contextmenu] - 생성할 contextmenu 정보 (v2.1.7 이상부터 지원, v2.1.46에서 변경)
 * @param {Object} [properties.contextmenu.header] -  header영역에서 생성할 contextmenu의 정보
 * @param {string} [properties.contextmenu.header.id] - contextmenu의 ID
 * @param {Array} [properties.contextmenu.header.contents] - contextmenu 구성 정보
 * @param {string} [properties.contextmenu.header.contents.icon] - 아이콘으로 사용할 이미지의 경로(fontawesome의 i Tag 지원)
 * @param {string} [properties.contextmenu.header.contents.label] - 출력할 메뉴명
 * @param {Function | string} [properties.header.contextmenu.contents.callback] - 메뉴 클릭시 동작할 콜백 함수
 * @param {Array} [properties.contextmenu.header.contents.items] - 현재 메뉴에서 생성할 하위 메뉴 정보
 * @param {booelan} [properties.contextmenu.header.contents.divine=false] - 메뉴 분리 표시 여부 (v2.1.8 이상부터 지원)
 * @param {booelan} [properties.contextmenu.header.contents.disabled=false] - 메뉴 비활성화 여부 (v2.1.8 이상부터 지원)
 * @param {Object} [properties.contextmenu.data] - data영역에서 생성할 contextmenu의 정보
 * @param {Object} [properties.contextmenu.data.base] - data영역에서 기본적으로 생성할 contextmenu의 정보
 * @param {string} [properties.contextmenu.data.base.id] - contextmenu의 ID
 * @param {Array} [properties.contextmenu.data.base.contents] - contextmenu 구성 정보
 * @param {string} [properties.contextmenu.data.base.contents.icon] - 아이콘으로 사용할 이미지의 경로(fontawesome의 i Tag 지원)
 * @param {string} [properties.contextmenu.data.base.contents.label] - 출력할 메뉴명
 * @param {Function | string} [properties.data.base.contextmenu.contents.callback] - 메뉴 클릭시 동작할 콜백 함수
 * @param {Array} [properties.contextmenu.data.base.contents.items] - 현재 메뉴에서 생성할 하위 메뉴 정보
 * @param {booelan} [properties.contextmenu.data.base.contents.divine=false] - 메뉴 분리 표시 여부 (v2.1.8 이상부터 지원)
 * @param {booelan} [properties.contextmenu.data.base.contents.disabled=false] - 메뉴 비활성화 여부 (v2.1.8 이상부터 지원)
 * @param {Array} [properties.contextmenu.data.except] - data영역에서 예외적으로 생성할 contextmenu의 정보
 * @param {number} [properties.contextmenu.data.except.col] - data영역에서 예외적으로 생성할 column의 index 
 * @param {string} [properties.contextmenu.data.except.id] - contextmenu의 ID
 * @param {Array} [properties.contextmenu.data.except.contents] - contextmenu 구성 정보
 * @param {string} [properties.contextmenu.data.except.contents.icon] - 아이콘으로 사용할 이미지의 경로(fontawesome의 i Tag 지원)
 * @param {string} [properties.contextmenu.data.except.contents.label] - 출력할 메뉴명
 * @param {Function | string} [properties.contextmenu.data.except.contents.callback] - 메뉴 클릭시 동작할 콜백 함수
 * @param {Array} [properties.contextmenu.data.except.contents.items] - 현재 메뉴에서 생성할 하위 메뉴 정보
 * @param {booelan} [properties.contextmenu.data.except.contents.divine=false] - 메뉴 분리 표시 여부 (v2.1.8 이상부터 지원)
 * @param {booelan} [properties.contextmenu.data.except.contents.disabled=false] - 메뉴 비활성화 여부 (v2.1.8 이상부터 지원)
 * @returns {void}
 * @example
 * QCELL.create({
 * 	"parentid"          : "QCellArea",
 * 	"id"                : "QCell1",
 * 	"data"              : {"input": cell_data},
 * 	"rowheader"         : "sequence",
 * 	"selectmode"        : "cell",
 * 	"highlightrepeat"   : 2,
 * 	"frozencols"        : 2,
 * 	"frozenrows"        : 3,
 * 	"frozenbottomrows"  : 2,
 * 	"rowheight"         : {header: 40, data: 40},
 * 	"oneclickedit"      : false,
 *  "onloadurl"         : "URL",
 * 	"columns"           : [ 
 * 	                        {title:["순번"], 		key:"seq"},
 * 	                        {title:["선택"], 		key:"checkbox", options: {checkedvalue: "ok", uncheckedvalue: "ng"}},
 * 	                        {title:["이름"], 		key:"name", 	type:"input", maxlength: 4}, 
 * 	                        {title:["나이"], 		key:"age", 	type:"input", options: {format: {type: "string", rule: "@ 세"}},
 * 	                        {title:["연락처"], 		key:"phone", 	type:"input", options: {mask: {alias: "999-9999-9999"}}},
 * 	                        {title:["주소"], 		key:"address", 	type:"textarea"},
 * 	                        {title:["입사일"], 		key:"regdate", 	type:"datepicker ", options:{locale:"kr", dateformat: "yy-mm-dd"}}} 
 * 			      ],
 *  "pagination"        : {pageunit: 10, unitlist: [10, 20, 30]},
 * 	"contextmenu"       : {
 *		base: {
 *			id: 'base-contextmenu',
 *			contents:
 *			[
 *				{icon: './add.png', label: 'a', action: function(){QCell1.addRow();}},
 *				{icon: './del.png', label: 'b', action: function(){QCell1.removeRow();}},
 *				{label: 'c', items: [{label: 'c-1'}, {label: 'c-2'}]},
 *				{label: 'd', items: [{label: 'd-1', items: [{label: 'd-1-1'}, {label: 'd-1-2'}]}, {label: 'd-2', items: [{label: 'd-2-1'}, {label: 'd-2-2'},]}]}
 *			]
 *		}
 *	}
 * });
 */
QBOX.QCELL.create = function(properties){
	return this._create(properties);
};


/**
 * 입력한 ID에 해당하는 QCELL 객체의 존재 여부를 반환합니다.
 * @type {function}
 * @param {String} id - 존재 여부를 반환 할 QCELL 객체의 id 설정
 * @returns {Boolean}
 * @example
 * QCELL.hasInstance("sheet1");
 */
QBOX.QCELL.hasInstance = function(id){
	return this._hasInstance(id);
};

/**
 * QCELL 객체를 반환합니다.
 * @type {function}
 * @param {String} id - 반환 할 QCELL 객체의 id 설정
 * @returns {Object}
 * @example
 * var sheet1 = QCELL.getInstance("sheet1");
 */
QBOX.QCELL.getInstance = function(id){
	return this._getInstance(id);
};

/**
 * QCELL 객체들의 id를 배열로 반환합니다.
 * @type {function}
 * @returns {Array}
 * @example
 * var arrSheetIDs = QCELL.getInstanceIDs();
 */
QBOX.QCELL.getInstanceIDs	= function(){
	return this._getInstanceIDs();
};

/**
 * QCELL 객체를 제거합니다.
 * @type {function}
 * @param {String} id - 제거 할 QCELL 객체의 id 설정
 * @returns {Boolean}
 * @example
 * QCELL.deleteInstance("sheet1");
 */
QBOX.QCELL.deleteInstance	= function(id){
	return this._deleteInstance(id);
};

/**
 * 모든 QCELL 객체들을 제거합니다.
 * @type {function}
 * @returns {Boolean}
 * @example
 * QCELL.deleteAllInstances();
 */
QBOX.QCELL.deleteAllInstances	= function(){
	return this._deleteAllInstances();
};

QBOX.QCELL.def.areaname = QBOX._.extend(QBOX.QCELL.def.areaname, {
	ROOT					: 'root',
	PANEL					: 'panel',
	CONTAINER				: 'container',
	PAGINATIONPANEL			: 'paginationpanel',
	SHEETPANEL				: 'sheetpanel',
	INPUTFORM				: 'inputform',
	
	VIEWPORT				: 'viewport',
	FOOTERROWHEADER			: 'frowheader',
	FOOTER					: 'footer',
	EDGEHEADER				: 'edgeheader',
	ROWHEADER				: 'rowheader',
	COLHEADER				: 'colheader',
	HSCROLLBAR				: 'hscrollbar',
	VSCROLLBAR				: 'vscrollbar',
	PAGINATION				: 'pagination',
	GROUPUI					: 'group-ui',
	COLSTYLEEDITOR			: 'colStyleEditor',
	
	STATIC					: 'static',
	GRANDTOTAL				: 'grandtotal',
	DATEPICKER				: 'datepicker'
	
});

QBOX.QCELL.def.cssprefix = 'rt-qc-';

QBOX.QCELL.def.css = QBOX._.extend(QBOX.QCELL.def.css, {
	ROOT							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROOT,
	PANEL							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PANEL,
	CONTAINER						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.CONTAINER,
	PAGINATIONPANEL					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATIONPANEL,
	SHEETPANEL						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.SHEETPANEL,
	
	INPUTFORM						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.INPUTFORM,
	INPUTFORM_INNER					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.INPUTFORM +'-inner',
	INPUTFORM_HEADER				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.INPUTFORM + '-header',
	INPUTFORM_ITEM					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.INPUTFORM + '-item',
	
	PAGINATION_INNER				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-inner',
	
	VIEWPORT						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.VIEWPORT,
	VIEWPORT_INNER					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.VIEWPORT + '-inner',

	FOOTERROWHEADER					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.FOOTERROWHEADER,
	FOOTERROWHEADER_INNER			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.FOOTERROWHEADER + '-inner',

	FOOTER							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.FOOTER,
	FOOTER_INNER					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.FOOTER + '-inner',

	EDGEHEADER						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.EDGEHEADER,
	EDGEHEADER_INNER				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.EDGEHEADER + '-inner',
	EDGEHEADER_CELL_CHECKBOX		: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.EDGEHEADER + '-cell-checkbox',
	EDGEHEADER_CELL_RADIO			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.EDGEHEADER + '-cell-radio',	

	ROWHEADER						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROWHEADER,
	ROWHEADER_INNER					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROWHEADER + '-inner',
	ROWHEADER_CELL_CHECKBOX			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROWHEADER + '-cell-checkbox',
	ROWHEADER_CELL_RADIO			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROWHEADER + '-cell-radio',
	ROWHEADER_STATE_INIT			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROWHEADER + '-state-init',
	ROWHEADER_STATE_INSERT			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROWHEADER + '-state-insert',
	ROWHEADER_STATE_UPDATE			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROWHEADER + '-state-update',	
	ROWHEADER_STATE_DELETE			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROWHEADER + '-state-delete',	
	ROWHEADER_CUSTOM				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.ROWHEADER + '-custom',
	
	COLHEADER						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.COLHEADER,
	COLHEADER_INNER					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.COLHEADER + '-inner',
	COLHEADER_CELL_CHECKBOX			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.COLHEADER + '-cell-checkbox',
	COLHEADER_CHECKBOX				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.COLHEADER + '-checkbox',
	COLHEADER_RADIO					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.COLHEADER + '-radio',
	COLHEADER_AREA					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.COLHEADER + '-area',

	HSCROLLBAR						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.HSCROLLBAR,
	HSCROLL_THUMB					: QBOX.QCELL.def.cssprefix + 'hsthumb',
	
	VSCROLLBAR						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.VSCROLLBAR,
	VSCROLL_THUMB					: QBOX.QCELL.def.cssprefix + 'vsthumb',
	
	CELL							: QBOX.QCELL.def.cssprefix + 'cell',
	
	CELL_FOCUS						: QBOX.QCELL.def.cssprefix + 'cell-focus',
	CELL_SELECT						: QBOX.QCELL.def.cssprefix + 'cell-select',
	CELL_HIGHLIGHTREPEAT			: QBOX.QCELL.def.cssprefix + 'cell-highlightrepeat',
	
	CELL_VIEWPORT					: QBOX.QCELL.def.cssprefix + 'cell-viewport',
	CELL_FOOTERROWHEADER			: QBOX.QCELL.def.cssprefix + 'cell-frowheader',
	CELL_FOOTER						: QBOX.QCELL.def.cssprefix + 'cell-footer',
	CELL_EDGEHEADER					: QBOX.QCELL.def.cssprefix + 'cell-edgeheader',
	CELL_ROWHEADER					: QBOX.QCELL.def.cssprefix + 'cell-rowheader',
	CELL_COLHEADER					: QBOX.QCELL.def.cssprefix + 'cell-colheader',
	
	CELL_HEADERROWS					: QBOX.QCELL.def.cssprefix + 'cell-headerrows',
	CELL_FROZENROWS					: QBOX.QCELL.def.cssprefix + 'cell-frozenrows',
	CELL_NORMALROWS					: QBOX.QCELL.def.cssprefix + 'cell-normalrows',
	CELL_FROZENBOTTOMROWS			: QBOX.QCELL.def.cssprefix + 'cell-frozenbottomrows',
	CELL_FROZENBOTTOMROWS_PANEL		: QBOX.QCELL.def.cssprefix + 'cell-frozenbottomrows-panel',
	CELL_FOOTERROWS					: QBOX.QCELL.def.cssprefix + 'cell-footerrows',
	
	CELL_HEADERCOLS					: QBOX.QCELL.def.cssprefix + 'cell-headercols',
	CELL_FROZENCOLS					: QBOX.QCELL.def.cssprefix + 'cell-frozencols',
	CELL_NORMALCOLS					: QBOX.QCELL.def.cssprefix + 'cell-normalcols',
	
	COLHEADER_DRAG_AND_DROP_AREA	: QBOX.QCELL.def.cssprefix + 'colheaderdndarea',
	COLMOVE_SHADOW					: QBOX.QCELL.def.cssprefix + 'colmoveshadow',
	COLMOVELINE						: QBOX.QCELL.def.cssprefix + 'colmoveline',
	
	GROUPTREEUI						: QBOX.QCELL.def.cssprefix + 'gtui',
	GROUPTREEUI_ARROW				: QBOX.QCELL.def.cssprefix + 'gtui-arrow',
	GROUPTREEUI_ARROW_EXPAND		: QBOX.QCELL.def.cssprefix + 'gtui-arrow-expand',
	GROUPTREEUI_ARROW_COLLAPSE		: QBOX.QCELL.def.cssprefix + 'gtui-arrow-collapse',
	GROUPTREEUI_FOLDER				: QBOX.QCELL.def.cssprefix + 'gtui-folder',
	GROUPTREEUI_FOLDER_EXPAND		: QBOX.QCELL.def.cssprefix + 'gtui-folder-expand',
	GROUPTREEUI_FOLDER_COLLAPSE		: QBOX.QCELL.def.cssprefix + 'gtui-folder-collapse',
	GROUPTREEUI_DOT					: QBOX.QCELL.def.cssprefix + 'gtui-dot',
	GROUPTREEUI_HEADER				: QBOX.QCELL.def.cssprefix + 'gtui-header',
	GROUPTREEUI_FOOTER				: QBOX.QCELL.def.cssprefix + 'gtui-footer',
	
	SORT_AREA						: QBOX.QCELL.def.cssprefix + 'sortarea',
	SORT_ASC						: QBOX.QCELL.def.cssprefix + 'sort-asc',
	SORT_DESC						: QBOX.QCELL.def.cssprefix + 'sort-desc',
	MULTI_SORT_ORDER				: QBOX.QCELL.def.cssprefix + 'multisort-order',
	SORTABLE						: QBOX.QCELL.def.cssprefix + 'sortable',
	
	COLRESIZE_AREA					: QBOX.QCELL.def.cssprefix + 'colresizearea',
	COLRESIZE_AREA_HOVER			: QBOX.QCELL.def.cssprefix + 'colresizearea-hover',
	COLRESIZELINE					: QBOX.QCELL.def.cssprefix + 'colresizeline',
	COLRESIZETOOLTIP				: QBOX.QCELL.def.cssprefix + 'colresizetooltip',
	
	EMPTYMESSAGE					: QBOX.QCELL.def.cssprefix + 'emptymessasge',
	
	PAGINATION_UI_CENTER			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-ui-center',
	PAGINATION_UI_RIGHT				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-ui-right',
	PAGINATION_NAV					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-nav',
	PAGINATION_NAV_BTN				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-nav-btn',
	PAGINATION_NAV_INPUT			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-nav-input',
	PAGINATION_NAV_SELECT			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-nav-select',
	PAGINATION_NAV_INFO				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-nav-info',
	PAGINATION_NAV_PAGER			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-nav-pager',
	PAGINATION_NAV_PAGER_NOW		: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-nav-pager-now',
	PAGINATION_NAV_PAGER_SKIP		: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-nav-pager-skip',
	PAGINATION_NAV_EXTEND_MOVE		: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.PAGINATION + '-nav-extend-move',
	
	CELL_ROWHEADER_CHECKBOX			: QBOX.QCELL.def.cssprefix + 'cell-rowheader-checkbox',
	CELL_ROWHEADER_RADIO			: QBOX.QCELL.def.cssprefix + 'cell-rowheader-radio',
	
	FILTER_AREA						: QBOX.QCELL.def.cssprefix + 'filterarea',
	FILTER_AREA_ADJUST				: QBOX.QCELL.def.cssprefix + 'filterarea-adjust',	
	FILTER_AREA_HOVER				: QBOX.QCELL.def.cssprefix + 'filterarea-hover',
	FILTER_TITLE_AREA				: QBOX.QCELL.def.cssprefix + 'filter-title-area',
	FILTER_TITLE_SPAN				: QBOX.QCELL.def.cssprefix + 'filter-title-span',
	FILTER_UI_AREA					: QBOX.QCELL.def.cssprefix + 'filter-ui-area',
	FILTER_UI_BTN					: QBOX.QCELL.def.cssprefix + 'filter-ui-btn',
	FILTER_UI_CLOSE					: QBOX.QCELL.def.cssprefix + 'filter-ui-close',
	FILTER_UI_ADDOPERATOR			: QBOX.QCELL.def.cssprefix + 'filter-ui-addoperator',
	FILTER_UI_ADDOPERATOR_CLOSE		: QBOX.QCELL.def.cssprefix + 'filter-ui-addoperator_close',	
	
	EXCLUDE_DRAGABLE				: QBOX.QCELL.def.cssprefix + 'exclude-dragable',	
	
	CONTEXTMENU						: QBOX.QCELL.def.cssprefix + 'contextmenu',
	CONTEXTMENU_AREA				: QBOX.QCELL.def.cssprefix + 'contextmenu-area',
	CONTEXTMENU_ROOT				: QBOX.QCELL.def.cssprefix + 'contextmenu-root',
	CONTEXTMENU_MENU				: QBOX.QCELL.def.cssprefix + 'contextmenu-menu',
	CONTEXTMENU_SUB_MENU			: QBOX.QCELL.def.cssprefix + 'contextmenu-sub-menu',
	CONTEXTMENU_ITEM				: QBOX.QCELL.def.cssprefix + 'contextmenu-item',
	CONTEXTMENU_ITEM_IMG			: QBOX.QCELL.def.cssprefix + 'contextmenu-item-img',
	CONTEXTMENU_ITEM_LABEL			: QBOX.QCELL.def.cssprefix + 'contextmenu-item-label',
	CONTEXTMENU_ITEM_SUB			: QBOX.QCELL.def.cssprefix + 'contextmenu-item-sub',
	CONTEXTMENU_DIVINE				: QBOX.QCELL.def.cssprefix + 'contextmenu-divine',
	CONTEXTMENU_HOVER				: QBOX.QCELL.def.cssprefix + 'contextmenu-hover',
	CONTEXTMENU_DISABLE				: QBOX.QCELL.def.cssprefix + 'contextmenu-disable',
	
	COLSEARCH_AREA					: QBOX.QCELL.def.cssprefix + 'colsearch-area',
	COLSEARCH_AREA_HOVER			: QBOX.QCELL.def.cssprefix + 'colsearch-area-hover',
	COLSEARCH_UI_AREA				: QBOX.QCELL.def.cssprefix + 'colsearch-ui-area',
	COLSEARCH_UI_BTN				: QBOX.QCELL.def.cssprefix + 'colsearch-ui-btn',
	COLSEARCH_UI_CLOSE				: QBOX.QCELL.def.cssprefix + 'colsearch-ui-close',
	
	PROGRESS_UI						: QBOX.QCELL.def.cssprefix + 'progress-ui',
	
	TOOLTIP							: QBOX.QCELL.def.cssprefix + 'tooltip',
	
	GROUPUI							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.GROUPUI,
	GROUPUI_INNER					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.GROUPUI + '-inner',
	
	UI_ICON							: QBOX.QCELL.def.cssprefix + 'ui-icon',
	UI_ICON_CLOSE					: QBOX.QCELL.def.cssprefix + 'ui-icon-close',
	
	EDITOR_AREA						: QBOX.QCELL.def.cssprefix + 'coleditor-area',
	EDITOR_AREA_HOVER				: QBOX.QCELL.def.cssprefix + 'coleditor-area-hover',
	EDITOR_UI_STYLE					: QBOX.QCELL.def.cssprefix + 'coleditor-ui-style',
	
	COLSTYLEEDITOR					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.COLSTYLEEDITOR,
	COLSTYLEEDITOR_WRAP				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.COLSTYLEEDITOR + '-wrap',
	
	STATIC_ROW						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.STATIC + '-row',
	GRANDTOTAL						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.GRANDTOTAL + '-row',
	
	TYPE_DATEPICKER					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.DATEPICKER + '-type',
	
	SHEETPANEL_INNER				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.SHEETPANEL + '-inner',
	SHEETPANEL_INNER_SPAN			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.areaname.SHEETPANEL + '-inner-span',
	
	REMOVE_AREA						: QBOX.QCELL.def.cssprefix + 'removearea',
});

QBOX.QCELL.def.rowgroup = QBOX._.extend(QBOX.QCELL.def.rowgroup, {
	FROZEN		: 1,	//FrozenRows영역에 표시할 행
	NORMAL		: 2,	//일반 데이터 영역에 표시 할 행
	FROZENBOTTOM: 3		//FrozenBottomRows영역에 표시할 행
});

QBOX.QCELL.module = 'basic';

/**
 * @since QCELL v1.0.0
 * @description 조회용 QCELL 클래스
 * @constructor
 */
QBOX.QCELL.BasicQCELL = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.Element.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.BasicQCELL, QBOX.Element);

QBOX.QCELL.BasicQCELL.prototype._initMOL = function(){
	QBOX.Element.prototype._initMOL.call(this);

	/* 행/열 카운트 관련 속성 */
	QBOX.util.addMethod(this, '_rows', function(){//getter
		return this.attr('rows');
	});
	QBOX.util.addMethod(this, '_rows', function(nRows){//setter
		if(QBOX._.isNumber(nRows)){
			this.attr('rows', nRows, 'number');
			return true;
		}
		return false;
	});

	QBOX.util.addMethod(this, '_cols', function(){//getter
		return this.attr('cols');
	});
	QBOX.util.addMethod(this, '_cols', function(nCols){//setter
		if(QBOX._.isNumber(nCols)){
			this.attr('cols', nCols, 'number');
			return true;
		}
		return false;
	});

	/* 셀 인덱스 관련 속성*/
	QBOX.util.addMethod(this, '_idx', function(/*row|col*/axis, /*cursor|drag|click|focus*/type){//getter
		return this._idx(axis, type, 'current');
	});
	QBOX.util.addMethod(this, '_idx', function(/*row|col*/axis, /*cursor|drag|click|focus*/type, /*previous|current*/point_of_time){//getter
		try{
			//ex> this._idx("row", "click", "previous");
			return this._getIdxInfo(type, axis)[point_of_time];
		} catch(e){
			return -1;
		}
	});
	QBOX.util.addMethod(this, '_idx', function(/*row|col*/axis, /*cursor|drag|click|focus*/type, /*previous|current*/point_of_time, val){//setter
		try{
			//ex> this._idx("row", "click", "previous", 1);
			this._getIdxInfo(type, axis)[point_of_time] = val;
			return true;
		} catch(e){
			return false;
		}
	});

	QBOX.util.addMethod(this, '_focusCell', function(heCell){
			var nFocusRow = parseInt(heCell.getAttribute('data-row')),
			nFocusCol = parseInt(heCell.getAttribute('data-col'));

			return this._focusCell(nFocusRow, nFocusCol, heCell);
	});
	QBOX.util.addMethod(this, '_focusCell', function(nFocusRow, nFocusCol){
		return this._focusCell(nFocusRow, nFocusCol, this._getCellDOM(nFocusRow, nFocusCol));
	});
	QBOX.util.addMethod(this, '_focusCell', function(nFocusRow, nFocusCol, heCell){
		if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
			var objIndex = this._findNextCell(nFocusRow, nFocusCol, 'up');

			nFocusRow = objIndex.row;
			nFocusCol = objIndex.col;
			heCell = this._getCellDOM(nFocusRow, nFocusCol);
		}

		if(this._updateIdx('focus', nFocusRow, nFocusCol)){
			this._clearFocusCSS();

			if(QBOX._.isElement(heCell)){
				this._addFocusStyleClass(heCell);
			}
			
			var target = this._getCellDOM(nFocusRow, nFocusCol);
			
			if(QBOX._.isElement(target) && QBOX.util.hasClass(target, QBOX.QCELL.def.css.CELL)){
				var css = QBOX.QCELL.def.css;
				
				this._updateIdx('cursor', nFocusRow, nFocusCol);
				
				if(QBOX.util.hasClass(target, css.CELL)){
					
					var nRow = parseInt(target.getAttribute('data-row')), nCol = parseInt(target.getAttribute('data-col'));
					
					if(QBOX.util.hasClass(target, css.CELL_VIEWPORT)){
						
						switch(this.attr('selectmode')){
							case 'rows'	:{
								if(event !== undefined && event.ctrlKey === true){
									this._selectRow(nRow);
								}else{
									this._clearSelection();
									this._selectRow(nRow);									
								}
								break;
							}
							case 'row'	:{
								this._clearSelection();
								this._selectRow(nRow);
								
								break;
							}
							case 'cols'	:{
								if(event !== undefined && event.ctrlKey === true){
									this._selectCol(nCol);
								}else{
									this._clearSelection();
									this._selectCol(nCol);									
								}
								
								break;
							}
							case 'col'	:{
								this._clearSelection();
								this._selectCol(nCol);
								
								break;
							}
							case 'cell'	:{
								this._clearSelection();
								this._selectCell(nRow, nCol);
								
								break;
							}
							default		:{//cells
								this._clearSelection();
								this._selectCell(nRow, nCol);
								
								break;
							}
						}
					}
				}
			}
			
			return true;
		}

		return false;
	});

	QBOX.util.addMethod(this, '_headerCellValue', function(nRow, nCol){//getter
		//직접 사용 금지, 반드시 _getCellValue()를 이용하여 호출 할 것!
		return this.attr('headertext')[nCol][nRow];
	});
	QBOX.util.addMethod(this, '_headerCellValue', function(nRow, nCol, val){//setter
		try{
			//직접 사용 금지, 반드시 _cellValue()를 이용하여 호출 할 것!
			var heCell = this._getCellDOM(nRow, nCol);

			val = val === undefined ? '' : val;

			this.attr('headertext')[nCol][nRow] = val;

			if(QBOX._.isElement(heCell)){
				//QBOX.util.textContent(heCell, val);
				heCell.innerHTML = this._getHeaderCellSpan(val,nRow,nCol);
			}

			return true;
		} catch(e){
			QCELL.log('err', 'QCELL.BasicQCELL._headerCellValue', e.message);
			return false;
		}
	});
	
	QBOX.util.addMethod(this, '_hiddenHeaderCellValue', function(nRow, key){//getter
		//직접 사용 금지, 반드시 _getCellValue()를 이용하여 호출 할 것!
		if(this.attr('hiddenheadertext').length >0){
			for(var i=0; i< this.attr('hiddenheadertext').length; i++){
				if(this.attr('hiddenheadertext')[i].key === key){
					return this.attr('hiddenheadertext')[i].title[nRow];
				}
			}
		}
		
		return null;
	});
	QBOX.util.addMethod(this, '_hiddenHeaderCellValue', function(nRow, key, val){//setter
		try{
			//직접 사용 금지, 반드시 _cellValue()를 이용하여 호출 할 것!			

			val = val === undefined ? '' : val;
			
			if(this.attr('hiddenheadertext').length >0){
				for(var i=0; i< this.attr('hiddenheadertext').length; i++){
					if(this.attr('hiddenheadertext')[i].key === key){
						this.attr('hiddenheadertext')[i].title[nRow] = val;
						return true;
					}
				}
			}
			return false;
		} catch(e){
			QCELL.log('err', 'QCELL.BasicQCELL._hiddenHeaderCellValue', e.message);
			return false;
		}
	});
	QBOX.util.addMethod(this, '_dataCellValue', function(nRow, nCol){//getter
		//직접 사용 금지, 반드시 _getCellValue()를 이용하여 호출해야 함.
		return this.attr('currentdata')[nRow - this.attr('headerrows')][this._getKeyOfCol(nCol)];
	});
	QBOX.util.addMethod(this, '_dataCellValue', function(nRow, nCol, val){//setter
		try{
			//직접 사용 금지, 반드시 _cellValue()를 이용하여 호출해야 함.
			var heCell = this._getCellDOM(nRow, nCol);

			this.attr('currentdata')[nRow - this.attr('headerrows')][this._getKeyOfCol(nCol)] = val;

			if(QBOX._.isElement(heCell)){
				QBOX.util.textContent(heCell, val === undefined ? '' : val);
			}

			return true;
		} catch(e){
			QCELL.log('err', 'QCELL.BasicQCELL._dataCellValue', e.message);
			return false;
		}
	});
	QBOX.util.addMethod(this, '_cellValue', function(nRow, nCol){//getter
		var nHeaderRows = this.attr('headerrows'),
		nRows = this.attr('rows'),
		nHeaderCols = this.attr('headercols'),
		nCols = this.attr('cols');

		if(nRow >= 0 && nRow < nHeaderRows && nCol >= nHeaderCols && nCol < nCols){
			return this._headerCellValue(nRow, nCol);
		} else if(nRow >= nHeaderRows && nRow < nRows && nCol >= nHeaderCols && nCol < nCols){
			return this._dataCellValue(nRow, nCol);
		} else{
			return undefined;
		}
	});
	QBOX.util.addMethod(this, '_cellValue', function(nRow, nCol, val){//setter
		var nHeaderRows = this.attr('headerrows'),
		nRows = this.attr('rows'),
		nHeaderCols = this.attr('headercols'),
		nCols = this.attr('cols');

		if(nRow >= 0 && nRow < nHeaderRows && nCol >= nHeaderCols && nCol < nCols){
			return this._headerCellValue(nRow, nCol, val);
		} else{
			if(nRow >= nHeaderRows && nRow < nRows && nCol >= nHeaderCols && nCol < nCols){
				return this._dataCellValue(nRow, nCol, val);
			}
		}

		return false;
	});
};

QBOX.QCELL.BasicQCELL.prototype._initTag = function(){
	this.tag('QBOX.QCELL.BasicQCELL');
};

QBOX.QCELL.BasicQCELL.prototype._init = function(properties){
	QBOX.Element.prototype._init.call(this, properties);
};

QBOX.QCELL.BasicQCELL.prototype._initAttrs = function(properties){
	QBOX.Element.prototype._initAttrs.call(this, properties);
	this.removeAttr('parent');//"BasicQCELL"에서 "parent"속성은 "object"타입이 아닌 "element"타입으로 사용해야 하므로  제거하고 다시 초기화한다.

	this.attr('locale', QBOX.QCELL.config.locale, 'string');
	this.attr('msg', QBOX.QCELL.def.msg[this.attr('locale')], 'object');

	/* size 관련 속성 */
	this.attr('width', properties.width, 'string');
	this.attr('height', properties.height, 'string');
	this.attr('lineheight', 3, 'number');
	this._initAttr('rowheight', properties.rowheight, 'object');
	this.attr('dynamicrowheight', new _QHashtable(), 'object');	//동적으로 높이를 변경한 행들의 정보
	this.attr('headercolwidth', 50, 'number');		//rowheaders영역에 해당하는 컬럼의 default width값
	this.attr('colwidths', [], 'array');			//컬럼 width 정보
	this.attr('colwidthsperpixel', [], 'array');	//컬럼 width 정보(pixel단위)
	this.attr('scrollbarwidth', 17,  'number');		//scrollbar의 width
	this.attr('layoutsize', {						//block영역의 size 저장
		root	: {},
		panel	: {},
		sheetpanel	: {},
		container	: {},
		edgeheader	: {},
		rowheader	: {},
		colheader	: {},
		viewport	: {},
		footerrowheader	: {},
		footer			: {},
		hscrollbar		: {},
		vscrollbar		: {}
	}, 'object');
	this.attr('percentwidth', properties.width.indexOf('%') > -1 ? true : false, 'boolean');	//QCELL의 width가 %인 경우 true로 설정
	this.attr('percentheight', properties.height.indexOf('%') > -1 ? true : false, 'boolean');	//QCELL의 height가 %인 경우 true로 설정
	this.attr('percentcolwidth', false, 'boolean');	//컬럼의 width중에 하나라도 %사용 시 true로 설정

	/* 컬럼 정보 관련 속성 */
	this.attr('qcellcols', [], 'array');
	for(var i=0;i<properties.columns.length;i++){
		if(properties.columns[i].style !== undefined && properties.columns[i].style_backup === undefined){
			properties.columns[i].style_backup = QBOX._.clone(properties.columns[i].style);
		}
	}
	this._initAttr('colsprops', properties.columns, 'array');	//sheet 생성 시 설정한 컬럼들의 생성 정보
	this._initAttr('hiddencolsprops', properties.hiddencolumns, 'array');	//sheet 생성 시 설정한 컬럼들의 생성 정보
	this.attr('colkeys', [], 'array');
	/*
	colkeys : ['name', 'age', 'email', 'age']		//중복 가능성 있음
	*/
	this.attr('colids', [], 'array');
	/*
	colids : ['col_0', 'col_1', 'col_2', 'col_3']	//중복 가능성 없음
	*/
	this.attr('colkeysinfo', new _QHashtable(), 'object');
	/*
	colkeysinfo : {									//key와 매핑되어 있는 컬럼이 여러개일 가능성 있음
		'name'	: [0],
		'age'	: [1,3],
		'email'	: [2]
	}
	*/
	this.attr('colidsinfo', {}, 'object');
	/*
	colidsinfo : {									//colid와 매핑되어 있는 컬럼이 여러개일 가능성 없음
		'col_0' :	0
		'col_1' : 	1,
		'col_2' : 	2,
		'col_3' : 	3
	}
	*/

	/* 행/열 카운트 관련 속성 */
	this.attr('rows', 0, 'number');//헤더 영역을 포함한 전체 행의 수
	this.attr('cols', 0, 'number');//헤더 영역을 포함한 전체 열의 수

	/* 셀 인덱스 관련 속성*/
	this.attr('idxinfo', {
		cursor:		{							//마우스 커서가 위치한 셀의 인덱스 정보, CUD발생 시 업데이트 필요없음
			row: {previous:-1, current:-1},
			col: {previous:-1, current:-1}
		},
		drag:		{							//drag 이벤트가 발생한 셀의 인덱스 정보, CUD발생 시 업데이트 필요없음
			row: {previous:-1, current:-1},
			col: {previous:-1, current:-1}
		},
		click:		{							//마우스로 클릭 한 셀의 인덱스 정보, CUD발생 시 업데이트 필요없음
			row: {previous:-1, current:-1},
			col: {previous:-1, current:-1}
		},
		focus:		{							//포커스가 있는 셀의 인덱스 정보, CUD발생 시 업데이트 필요없음
			row: {previous:-1, current:-1},
			col: {previous:-1, current:-1}
		},
		dblclick:	{
			row: {previous:-1, current:-1},
			col: {previous:-1, current:-1}
		},
		/*
		 * 셀 단위 선택 시
		 * selected => {
		 * 		row : {
		 * 			3 : [5]
		 * 		},
		 * 		col : {
		 * 			5 : [3]
		 * 		}
		 * }
		 *
		 * 행 단위 선택 시
		 * selected => {
		 * 		row : {
		 * 			3 : true
		 * 		},
		 * 		col : {}
		 * }
		 *
		 * 열 단위 선택 시
		 * selected => {
		 * 		row : {},
		 * 		col : {
		 * 			5 : true
		 * 		}
		 * }
		 * */
		selected : {							//선택된 셀들의 인덱스 정보, CUD발생 시 업데이트 필요없음
			row : new _QHashtable(),
			col : new _QHashtable()
		},
		/*
		 * style => {
		 * 		row : {
		 * 			3 : {
		 * 				5 : {"background-color":"red"}
		 * 			},
		 * 			7 : {
		 * 				3 : {"background-color":"blue"}
		 * 			},
		 * 		},
		 * 		col : {
		 * 			3 : {
		 * 				7 : {"background-color":"blue"}
		 * 			}
		 * 			5 : {
		 * 				3 : {"background-color":"red"}
		 * 			}
		 * 		}
		 * }
		 * */
		style : {							//스타일이 적용된 셀들의 인덱스와 스타일 정보
			row : new _QHashtable(),
			col : new _QHashtable()
		},
		/*마우스 무브 시점 인덱스 추가함 */
		hover : {
			row : new _QHashtable(),
			col : new _QHashtable()
		}
	}, 'object');

	/* 상태정보 관련 속성 */
	this.attr('syncinfo', {
		row : new _QHashtable(),
		col : new _QHashtable()
	}, 'object');
	/*
	 * syncinfo => {
	 * 		row : {
	 * 			3 : [
	 * 				'style'
	 * 			]
	 * 		},
	 * 		col : {
	 * 			5 : [
	 * 				'style', 'sort'
	 * 			]
	 * 		}
	 * }
	 * */

	/* selection 관련 속성 */
	this._initAttr('selectmode', properties.selectmode, 'string');

	/* 이벤트 관련 속성 */
	this.attr('eventparam', {target : this}, 'object');		//이벤트 콜백에서 QCELL객체를 추출하기 위한 parameter
	this.attr('mousedown', false, 'boolean');				//마우스 왼쪽 버튼의 눌림 상태를 확인
	this.attr('usereventinfo', QBOX._.clone(properties.events), 'object');		//사용자가 바인딩한 이벤트 정보 저장

	/* drag and drop 관련 속성 */
	this.attr('dragging', false, 'boolean');	//Dragging 상태를 확인
	this.attr('hdhandle', null, 'number');		//가로 dragging시 사용되는 setInterval()의 반환값을 저장하는 속성
	this.attr('vdhandle', null, 'number');		//세로 dragging시 사용되는 setInterval()의 반환값을 저장하는 속성
	this.attr('hdcount', 0, 'number');			//dragging시 가로스크롤바 이동 속도를 저장
	this.attr('vdcount', 0, 'number');			//dragging시 세로스크롤바 이동 속도를 저장

	/* 컬럼 이동 관련 속성 */
	this.attr('colmove', false, 'boolean');				//컬럼 이동을 위한 Dragging 상태를 확인
	this.attr('colmoveexecution', false, 'boolean');	//컬럼 이동 수행 여부 확인
	this.attr('colheaderdndarea', null, 'jquery');		//컬럼 이동 UI 아이콘 표시 영역
	this.attr('colmoveshadow', null, 'jquery');			//Drag and Drop을 이용한 컬럼 이동 시 표시하는 잔영
	this.attr('colmoveline', null, 'jquery');			//Drag and Drop을 이용한 컬럼 이동 시 이동할 위치를 표시하는 경계선

	/* 컬럼 너비 조절 관련 속성 */
	this.attr('colresize', false, 'boolean');			//컬럼 너비 조절 위한 Dragging 상태를 확인
	this.attr('colresizearea', null, 'jquery');			//컬럼 너비 조절 UI 아이콘 표시 영역
	this.attr('colresizeline', null, 'jquery');			//Drag and Drop을 이용한 컬럼 너비 조절시 조절 위치를 표시하는 경계선
	this.attr('colresizetooltip', null, 'jquery');		//Drag and Drop을 이용한 컬럼 너비 조절시 변경될 너비를 시각적으로 표시하는 영역

	/* 정렬 관련 속성 */
	this.attr('sortinfo', [], 'array');					//QCELL의 정렬 정보를 저장
	this.attr('defaultsortarea', null, 'jquery');		//기본 정렬 UI 아이콘 표시 영역
	
	/* 필터 관련 속성 */
	this.attr('dataindexpool', new _QHashtable(), 'object');	//필터 기능을 위한 색인 정보 저장소
	this.attr('filterarea', null, 'jquery');				//필터 UI 아이콘 표시 영역
	this.attr('filteruiarea', null, 'jquery');				//필터 UI 창 기본  영역
	this.attr('filteruivisible', false, 'boolean');			//필터 UI 표시여부
	
	/* 헤더 관련 속성 */
	this.attr('headerrows', 0, 'number');
	this.attr('headercols', 0, 'number');
	this.attr('headertext', [], 'array');
	this.attr('hiddenheadertext', {}, 'object');
	this._initAttr('rowheaders', properties.rowheaders, 'array');	
	this._initAttr('rowheaderstitle', properties.rowheaderstitle,'array' );
	this._initAttr('rowheaderssort', properties.rowheaderssort,'array' );
	
	this._initAttr('rowheaderstitlekey', properties.rowheaderstitlekey,'array' );
	
	this._initAttr('rowheaderoptions', properties.rowheaderoptions,'array' );	

	/* 틀고정 관련 속성 */
	this._initAttr('frozencols', properties.frozencols, 'number');
	this._initAttr('frozenrows', properties.frozenrows, 'number');
	this._initAttr('frozenbottomrows', properties.frozenbottomrows, 'number');
	
	this._initAttr('frozenbottomstyle', properties.frozenbottomstyle, 'string');
	this._initAttr('makefrozenbottomdata', properties.makefrozenbottomdata, 'boolean');

	/* 스타일 관련 속성 */
	this._initAttr('highlightrepeat', properties.highlightrepeat, 'number');

	/* 병합 관련 속성 */
	this._initAttr('merge', QBOX._.clone(properties.merge), 'object');	//merge 정보 설정
	this.attr('merge_header_info',[],'array');				//header merge 정보를 저장
	this.attr('merge_data_info', [], 'array');			//data merge 정보를 저장

	/* footer 관련 속성 */
	this.attr('footerrows', 0, 'number');

	/* element 관련 속성 */
	this.attr('parent', null, 'element');
	this.attr('elementpool', new _QHashtable(), 'object');
	this.attr('cellmatrix', new _QHashtable(), 'object');
	this.attr('focuscell', null, 'element');

	/* 데이터 관련 속성 */
	this.attr('currentdata', [], 'array');
	if(properties.data === undefined){
		properties.data = {type:'object', input:[]};
	}
	this._initAttr('data', properties.data, 'object');
	
	this._initAttr('original', properties.original, 'boolean');
	this._initAttr('origindata', [], 'array');
	this._initAttr('originstate', {
		i: [],
		d: []
	}, 'object');

	this.attr('rowheaderdata', [], 'array');

	/* 스크롤 관련 속성 */
	this.attr('accumulatedwheel', 0, 'number');	//QCELL의 mousewheel 이벤트를 이용하여 세로 스크롤바를 움직일 경우 화면 갱신이 끝나기 전에  연속된 휠동작을 누적 해 놓았다가 처리하기 위한 속성
	this.attr('hsinfo', {}, 'object');
	this.attr('vsinfo', {}, 'object');
	this.attr('adjustrow', false, 'boolean'); //스크롤바에 걸처진 셀을 클릭했을 경우 보정해주는 로직 '_adjustRow' 의 동작 여부를 확인
	this.attr('adjustcol', false, 'boolean'); //스크롤바에 걸처진 셀을 클릭했을 경우 보정해주는 로직 '_adjustCol' 의 동작 여부를 확인
	this._initHSInfo();
	this._initVSInfo();

	/* 브라우저 resizing 관련 속성 */
	this.attr('timeoutid', null, 'number');		//setTimetout(), clearTimeout()의 timeoutID값을 저장하는 속성

	/* 복사 & 붙여넣기 관련 속성 */
	this._initAttr('copy', properties.copy, 'boolean');
	this._initAttr('paste', properties.paste, 'boolean');

	/* 생성시 통신할 URL주소 속성 */
	this.attr('onloadurl', properties.onloadurl, 'string');
	this.attr('onloadurlparam', properties.onloadurlparam, 'object');
	this.attr('onloadurlsucesscallback', properties.onloadurlsucesscallback, 'function');
	this.attr('onloadurlfailcallback', properties.onloadurlfailcallback, 'function');

	/* pagination 관련 속성 */
	this.attr('paginationinfo', properties.pagination, 'object');
	this.attr('pagesyncorgindata' , properties.pagination !== undefined && properties.pagination.syncorgindata !== undefined ? properties.pagination.syncorgindata : false , 'boolean');

	/* group 관련 속성 */
	this.attr('groupinfo', {
		showpanel	: properties.group.showpanel,							//Drag and Drop을 이용한 그룹화 기능을 제공하는 UI 패널 사용 여부
		type		: properties.group.type,									//그룹화 타입 설정, "normal" or "tree"
		expand		: QBOX._.clone(properties.group.expand),	//<expand여부를 설정 할 그룹 컬럼들의 key값, expand여부>
		header		: QBOX._.clone(properties.group.header),	//<그룹헤더 행을 갖는 그룹 컬럼들의 key값, 그룹헤더 행 정보>
		footer		: QBOX._.clone(properties.group.footer)		//<그룹푸터 행을 갖는 그룹 컬럼들의 key값, 그룹푸터 행 정보>
	}, 'object');
	
	this.attr('groupstate', {
		grouped		: false,
		type		: 'normal',
		data		: [],
		columnsinfo	: new _QHashtable(),
		nodes		: new _QHashtable(),
		treeuirows		: [],
		treeuirownodes	: [],
		headerrows		: [],
		headerrownodes	: [],
		footerrows		: [],
		footerrownodes	: []
	}, 'object');
	
	this.attr('treestate', {
		grouped		: false,
		type		: 'tree',
		data		: [],
		columnsinfo	: new _QHashtable(),
		nodes		: new _QHashtable(),
		treeuirows		: [],
		treeuirownodes	: [],
		headerrows		: [],
		headerrownodes	: [],
		footerrows		: [],
		footerrownodes	: [],
		state			: {}
	}, 'object');
	
	
	this.attr('hierachystate', {
		grouped		: false,
		type		: 'tree',
		data		: [],
		columninfo	: {},
		nodes		: new _QHashtable(),
		headerrows		: [],
		headerrownodes	: [],
		footerrows		: [],
		footerrownodes	: [],
		state			: {}
	}, 'object');
	this.attr('useGroupUI', properties.useGroupUI, 'boolean');
	this.attr('groupuiinfo', [], 'array'); // 그룹UI의 컬럼저장
	
	/* emptymessage 관련 속성 */
	this.attr('emptymessage', properties.emptymessage, 'string');
	this.attr('useemptymessage',properties.useemptymessage,'boolean');
	
	/* contextmenu 속성 */
	this.attr('contextmenu', properties.contextmenu, 'object');
	this.attr('contextmenuheader', properties.contextmenu.header, 'object');
	this.attr('contextmenudata', properties.contextmenu.data, 'object');
	this.attr('contextmenudisable', [], 'array');
	this.attr('contextmenuheaderdisable', [], 'array');
	this.attr('contextmenudatadisable', [], 'array');
	this.attr('contextmneuui', null, 'jquery');
	this.attr('contextmenuid', '', 'string');
	
	/* colsearch 속성 */
	this.attr('colsearcharea', null, 'jquery');					// 컬럼 검색 아이콘 표시 영역
	this.attr('colsearchuiarea', null, 'jquery');				// 컬럼 검색 UI 기본 영역
	this.attr('colsearchuivisible', false, 'boolean');			// 컬럼 검색 UI표시 여부
	this.attr('colsearchinfo', {}, 'object');					// 컬럼 검색 정보를 저장
	
	/* tooltip 관련 속성*/
	this.attr('tooltipvisible', false, 'boolean'); // tooltip 출력 여부
	/*scroll 해야 하는지 여부 */ 
	this.attr('isscrollleft', false, 'boolean');
	
	/* col style editor */
	this.attr('colstyleeditorarea', null, 'jquery');
	this.attr('colstyleeditorui', null, 'jquery');
	this.attr('colstyleeditor', {}, 'object');
	
	this.attr('groupdata', properties.groupdata, 'object');
	//this.attr('colstyleeditorvisivle', false, 'boolean');
	
	this._initAttr('bottompanel', properties.bottompanel, 'boolean');
	this._initAttr('bottompanelheight', properties.bottompanelheight, 'number');
	this._initAttr('bottompanelstyle', properties.bottompanelstyle, 'string');
	this.attr('bottompanelcallback', properties.bottompanelcallback, 'function');
	
	/* rowheader중 checkbox의 바깥div의 click event실행 여부 */
	this.attr('rowheadercheckboxclick', [], 'array');
	
	this._initAttr('excelexportwithformat', properties.excelexportwithformat, 'boolean');
	
	this.attr('beforepastecallback', properties.beforepastecallback , 'function' );
	
	this.attr('additionaldataindex', properties.additionaldataindex , 'array');
	
	if(properties.rowheaderwidth !== undefined && QBOX._.isNumber(properties.rowheaderwidth)){
		this.attr('headercolwidth',properties.rowheaderwidth,'number');
	}
	this._initAttr('usetooltipinellipsis', properties.usetooltipinellipsis , 'boolean');
	
	this._initAttr('policy',properties.policy, 'string');
	this.attr('useall' , this.attr('policy') === 'dynamic' ? false : true, 'boolean');
	if(QBOX.QCELL.isForceDynamic === true){
		this.attr('useall' ,false,'boolean');
		QBOX.QCELL.isForceDynamic = false;
	}
	this.attr('isfirstsort' , false, 'boolean');
};

QBOX.QCELL.BasicQCELL.prototype._initAttr = function(key, val, type){//사용자가 속성값을 입력하지 않은 경우  default값을 config 설정값으로 설정하는 함수
	this.attr(key, val === undefined ? QBOX.QCELL.config[key] : val, type);
};

QBOX.QCELL.BasicQCELL.prototype._setParent = function(){
	var heParent = document.getElementById(this.attr('parentid'));
	this.attr('parent', QBOX._.isElement(heParent) ? heParent : null, 'element');
};

QBOX.QCELL.BasicQCELL.prototype._clearAttrs = function(){
	var strID = this.attr('id');

	QBOX._.each(this.attr('qcellcols'), function(objQCellCol){
		objQCellCol.destroy();
	});

	if(QBOX._.isElement(this.attr('parent'))){
		QBOX.$(this.attr('parent')).empty();
	}
	
	QBOX.$(window).off(this._getUserEventName('resize'));
	QBOX.$(document).off('mouseup.' + strID).off('mousemove.' + strID);
};

QBOX.QCELL.BasicQCELL.prototype._rebuild = function(bUsePrevData){
	try{
		//rebuild 시 기존  bind API 로 메핑된 이벤트 정보 사라지는 현상 수정 함.
		var userEvent = this.getUserEventInfo();		
		this._clearAttrs();
		if(bUsePrevData !== undefined && bUsePrevData === true){
			this.attr('bRebuildWithPrevData',true,'boolean');
			this.attr('bLoadurlstop',true,'boolean' );
			this.attr('arrBackupData', QBOX._.clone(this.attr('currentdata')),'array');
			this.attr('objBackupIdx', QBOX._.clone(this.attr('idxinfo')),'object');
			this.attr('arrBackupDeletedrowsdata' , QBOX._.clone(this.attr('deletedrowsdata')),'array');
			
		}
		var obj = this.attr('useInitProp') === true || (this.attr('useRemoveUI') === true && this.attr('useRebuildAPI') === true)? this.getInitProperties() : this.getProperties();
		
		this._init(obj);
		
		this.attr('usereventinfo' , userEvent, 'object');				
		
		this._createCols();
		this._create();
		this.attr('bRebuildWithPrevData',false,'boolean');
		
		if(bUsePrevData === true && this.attr('prevcontextmenu') !== null){
			this._setContextMenu(this.attr('prevcontextmenu'));
		}
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._refresh', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._refresh = function(){
	try{
		//아직 스펙 미결정
		//다량의 스타일변경과 같은 동적 변경 시 성능개선을 위해 정보만 세팅하고 세팅한 정보를 바탕으로 한 번에 반영하는 경우
		//데이터는 변경되지 않았다고 가정한다.
		//데이터가 변경되었을 때는 _setData()를 사용해야 한다.
		this._refreshRs();
		this._refreshCs();
		this._refreshDRs();
		this._refreshDCs();

		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._refresh', e.message);
		return false;
	}
};
QBOX.QCELL.BasicQCELL.QCellCol = function(props){
	if(QBOX.util.checkType(props, 'object') === false){return null;}
	QBOX.Base.call(this, props);
};
QBOX.util.inherit(QBOX.QCELL.BasicQCELL.QCellCol, QBOX.Base);

QBOX.util.addMethod(QBOX.QCELL.BasicQCELL.QCellCol, 'create', function(properties){
	return new QBOX.QCELL.BasicQCELL.QCellCol(this._adjustProps(properties));
});
QBOX.util.addMethod(QBOX.QCELL.BasicQCELL.QCellCol, 'create', function(col, properties){
	return this._create(col, properties);
});

QBOX.QCELL.BasicQCELL.QCellCol.prototype._initMOL = function(){
	QBOX.Base.prototype._initMOL.call(this);
	
	/* styleinfo 관련 속성 */
	QBOX.util.addMethod(this, '_styleInfo', function(group, key){//getter
		return this.attr('styleinfo')[group][key];
	});
	QBOX.util.addMethod(this, '_styleInfo', function(group, key, val){//setter
		this.attr('styleinfo')[group][key] = val;
	});
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._initTag = function(){
	this.tag('QBOX.QCELL.BasicQCELL.QCellCol');
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._init = function(props){
	QBOX.Base.prototype._init.call(this, props);
	
	this._initStyleInfo();
	this._initStyle();
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._initAttrs = function(props){
	QBOX.Base.prototype._initAttrs.call(this, props);
	this.removeAttr('parentid');//QCELL객체 생성 도중에  QCellCol객체를 생성하기 때문에 "parentid"를 가지고 QBOX.QCELL.getInstance를 통해 객체를 가져 올 수가 없어 QCellCol에서는 "parentid"를 사용하지 않고 "parent"를 통해 직접 QCELL객체에 접근한다.   
	
	this.attr('parent', props.parent, 'object');
	this.attr('styleinfo', {
		header	: {
			classname	: '',
			rule		: '',
			css			: {}
		},
		data	: {
			classname	: '',
			rule		: '',
			css			: {}
		}
	}, 'object');
	
	this._initAttr('width', props.width, 'string');
	this._initAttr('title', props.title, 'array');
	this._initAttr('key', props.key, QBOX._.isFunction(this.attr('parent').attr) && this.attr('parent').attr('data').type === 'array' ? 'number' : 'string');
	this._initAttr('styleclassname', props.styleclassname, 'object');
	this._initAttr('move', props.move, 'boolean');
	this._initAttr('resize', props.resize, 'boolean');
	
	this._initAttr('options', props.options, 'object');
	this._initAttr('format', props.options.format, 'object');
	this._initAttr('formatstatic', {}, 'object');
	
	this._initAttr('datatype', props.datatype, 'string');
	
	this._initAttr('sort', props.sort, 'boolean');
	this.attr('sortinfoofcol', {				//현재 컬럼에 적용되어 있는 정렬 정보 저장
		sorttype	: 'none',					//정렬 타입 ('none' | 'asc' | 'desc')
		order		: 0							//다중정렬 순서
	}, 'object');			
	this.attr('colsortarea', null, 'jquery');			//컬럼별 정렬 UI 아이콘 표시 영역	

	this._initAttr('filter', props.filter, 'boolean');
	this._initAttr('search', props.search, 'boolean');	//컬럼별 검색 사용 여부
	
	this._initAttr('tooltip', props.tooltip, 'boolean'); // 컬럼별 tooltip 사용 여부
	
	this._initAttr('tooltipcallback', props.options.tooltipcallback, 'function'); // 컬럼별 tooltip 사용 여부
	
	var bWordwrap =  QBOX._.isUndefined(props.options.wordwrap) ? false : props.options.wordwrap;	
	this._initAttr('wordwrap', bWordwrap, 'boolean'); // 컬럼별 wordwrap 사용 여부
	
	var bRequired =  QBOX._.isUndefined(props.options.required) ? false : props.options.required;
	this._initAttr('required',  bRequired, 'boolean');
	
	this.attr('type', 'static', 'string');
	
	if(props.style.header !== undefined){
		if(props.style.header['text-align'] === 'center'){
			delete props.style.header['text-align'];
		}
	}

	if(QCELL.config.excludeStyle !== undefined){
		var strKey;
		if(QCELL.config.excludeStyle.header !== undefined){
			if(props.style.header !== undefined){
				for(strKey in QCELL.config.excludeStyle.header){
					if(props.style.header[strKey] === QCELL.config.excludeStyle.header[strKey]){
						delete props.style.header[strKey];
					}
				}
			}
		}
		if(QCELL.config.excludeStyle.data !== undefined){
			if(props.style.data !== undefined){
				for(strKey in QCELL.config.excludeStyle.data){
					if(props.style.data[strKey] === QCELL.config.excludeStyle.data[strKey]){
						delete props.style.data[strKey];
					}
				}
			}
		}
	}
	
	this.attr('usedatatextalign', false, 'boolean');
	
	if(props.style !== undefined){
		if(props.style_backup !== undefined){
			var key = '';
			if(props.style_backup.header !== undefined){
				props.style.header = {};
				for (key in props.style_backup.header ){
					props.style.header[key] =  props.style_backup.header[key];
				}
			}
			if(props.style_backup.data !== undefined){
				props.style.data = {};
				for (key in props.style_backup.data ){
					props.style.data[key] =   props.style_backup.data[key];
				}
			}
		}
		
		if(props.style.header !== undefined){
			if(props.style.header['text-align'] !== undefined){
				this.attr('header_text_algin', props.style.header['text-align'],'string');				
				delete props.style.header['text-align'];
			}
		}
		if(props.style.data !== undefined){
			if(props.style.data['text-align'] !== undefined){				
				this.attr('data_text_algin', props.style.data['text-align'],'string');
				this.attr('usedatatextalign', true, 'boolean');
				delete props.style.data['text-align'];
			}			
		}		
	}
	
	if(this.attr('header_text_algin') === null){
		this._initAttr('header_text_algin',undefined, 'string');
	}
	if(this.attr('data_text_algin') === null){
		this._initAttr('data_text_algin',undefined, 'string');
	}	
	
	this._initAttr('style', props.style, 'object');
	this._initAttr('editor', props.editor, 'boolean');
	this.attr('colstyleeditorvisivle', false, 'boolean');
	this.attr('colstyleeditorbdata', 'QCELL_COL_DATA', 'string');
	this.attr('colstyleeditordata', '', 'string');
	
	var bMergeCol = QBOX._.isUndefined(props.options.mergecol) ? true : props.options.mergecol;
	this._initAttr('mergecol', bMergeCol, 'boolean');
	
	this.attr('exportdatatype',props.options === undefined ? '' : props.options.exportdatatype ,'string');
	
	this.attr('colremovearea', null, 'jquery');
	this._initAttr('remove', props.remove, 'boolean');
	this._initAttr('removecallback', props.options.removecallback, 'function'); // 컬럼별 tooltip 사용 여부
	
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._initAttr = function(key, val, type){
	this.attr(key, val === undefined ? QBOX.QCELL.colconfig[key] : val, type);
};

/* BasicQCELL.QCellCol의 속성 초기값 정의 */
QBOX.QCELL.colconfig = QBOX._.extend(QBOX._.clone(QBOX.QCELL.colconfig), {
	title				: [''],
	type				: 'static',
	width				: '100px',
	key					: '',
	styleclassname		: {
		header			: '',
		data			: ''
	},
	style				: {},
	move				: false,
	resize				: false,
	sort				: false,
	search				: false,
	tooltip				: false,
	editor				: false,
	format				: {
		type			: '',
		rule			: '',
		origin			: '',
		callback		: null
	},
	datatype			: 'string',
	options				: {},
	header_text_align	: 'center',
	data_text_align		: 'left',
	remove				: false
});

/*
QBOX.QCELL.BasicQCELL.QCellCol.create = function(col, properties){
	return this._create(col, properties);
};
*/
QBOX.QCELL.BasicQCELL.QCellCol._create = function(col, properties){
	if(this._checkRequiredProps(col, properties) && this._checkValidationOfProps(col, properties)){
		return new QBOX.QCELL.BasicQCELL.QCellCol(this._adjustProps(properties));
	}
	return null;
};

QBOX.QCELL.BasicQCELL.QCellCol._checkRequiredProps = function(col, properties){
	var result = true;
	if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
		var arrRequiredProps = ['id', 'parent'];
		for(var i = 0, nLength = arrRequiredProps.length; i < nLength; i++ ){
			var key = arrRequiredProps[i];
			if(properties[key] === undefined){
				QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '" property.');
				result = false;
				break;
			}
		}
		arrRequiredProps.RT_clear();
		arrRequiredProps = null;
	} else{
		QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + ']"\'s type is "object".');
		result = false;
	}
	return result;
};

QBOX.QCELL.BasicQCELL.QCellCol._checkValidationOfProps = function(col, properties){
	var result = true;
	QBOX.$.each(properties, function(key, val){
		result = QBOX.QCELL.BasicQCELL.QCellCol._checkValidationOfProp(col, key, val);
		return result;
	});
	return result;
};

QBOX.QCELL.BasicQCELL.QCellCol._checkValidationOfProp = function(col, key, val){
	var result = true, defaultmsg = true, datatype = '';
	switch(key){
		/* *************** 필수 속성 체크 *************** */
		/* string type */
		case 'width': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				if(key !== 'width' || QBOX._.isNumber(val) === false){//'width'값이 string이나 number가 아닌 경우
					result = false;
				}
			} else{
				if(key === 'width' && (val.replace(/[-\.0-9]/g, '').replace(/px/, '').replace(/%/, '').length > 0)){//width값 체크(숫자, 'px', '%')
					 QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '" property. This property can use "number" or "px" or "%" as value.');
					 result = false;
				}
			}
			break;
		}
		
		/* *************** 선택 속성 체크 *************** */
		/* string type */
		case 'datatype': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			} else{
				switch(val){
					case 'string': case 'number': {
						break;
					}
					default: {
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '" property. This property can use "string" or "number" as value.');
						result = false;
						defaultmsg = false;
						break;
					}
				}
			}
			break;
		}
		
		/* boolean type */
		case 'move': {
			datatype = 'boolean';
			if(QBOX._.isBoolean(val) === false){
				result = false;
			}
			
			break;
		}
		
		case 'resize': {
			datatype = 'boolean';
			if(QBOX._.isBoolean(val) === false){
				result = false;
			}
			
			break;
		}
		
		case 'editor': {
			datatype = 'boolean';
			if(QBOX._.isBoolean(val) === false){
				result = false;
			}
			break;
		}
		
		case 'search': {
			datatype = 'boolean';
			if(QBOX._.isBoolean(val) === false){
				result = false;
			}
			break;
		}
		
		case 'tooltip': {
			datatype = 'boolean';
			if(QBOX._.isBoolean(val) === false){
				result = false;
			}
			break;
		}
		
		/* array type */
		
		/* object type */
		case 'styleclassname': {
			datatype = 'object';
			if(QBOX._.isArray(val) || QBOX._.isObject(val) === false){
				result = false;
			} else{
				if(QBOX._.every(QBOX._.keys(val), function(key_of_style){return key_of_style === 'header' || key_of_style === 'data';}) === false){
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '" property. This property can use "header" or "data" as key.');
					result = false;
					defaultmsg = false;
				} else{
					QBOX.$.each(val, function(key_of_style, val_of_style){
						if(QBOX._.isString(val_of_style) === false){
							QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.' + key_of_style + '" property. This property\'s type is "string".');
							result = false;
							defaultmsg = false;
						}
					});
				}
			}
			break;
		}
		
		case 'style': {
			datatype = 'object';
			if(QBOX._.isArray(val) || QBOX._.isObject(val) === false){
				result = false;
			} else{
				if(QBOX._.every(QBOX._.keys(val), function(key_of_style){return key_of_style === 'header' || key_of_style === 'data';}) === false){
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '" property. This property can use "header" or "data" as key.');
					result = false;
					defaultmsg = false;
				} else{
					QBOX.$.each(val, function(key_of_style, val_of_style){
						if(QBOX._.isObject(val_of_style) === false){
							QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.' + key_of_style + '" property. This property\'s type is "object".');
							result = false;
							defaultmsg = false;
						}
					});
				}
			}
			break;
		}
		
		case 'options': {
			if(val !== undefined && QBOX._.isObject(val) === false || QBOX._.isArray(val) === true){
				datatype = 'object';
				result = false;
			}
			else {
				if( val.format !== undefined && val.format !== null ) {
					if(val.format.type !== undefined && QBOX._.isString(val.format.type) === false) {
						datatype = 'string';
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.format.type'+ '"\'s type is "' + datatype + '".');
						result = false;
						defaultmsg = false;
					} else {
						switch(val.format.type) {
							case 'date': {
								if( val.format.origin === undefined && QBOX._.isString(val.format.origin) === false ) {
									datatype = 'string';
									QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.format.origin'+ '"\'s type is "' + datatype + '".');
									result = false;
									defaultmsg = false;
								} else if( val.format.rule === undefined && QBOX._.isString(val.format.rule) === false ) {
									datatype = 'string';
									QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.format.rule'+ '"\'s type is "' + datatype + '".');
									result = false;
									defaultmsg = false;
								}
								break;
							} 
							case 'number': {
								if( val.format.rule === undefined && QBOX._.isString(val.format.rule) === false ) {
									datatype = 'string';
									QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.format.rule'+ '"\'s type is "' + datatype + '".');
									result = false;
									defaultmsg = false;
								}
								break;
							}
							case 'string': {
								if( val.format.rule === undefined && QBOX._.isString(val.format.rule) === false ) {
									datatype = 'string';
									QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.format.rule'+ '"\'s type is "' + datatype + '".');
									result = false;
									defaultmsg = false;
								}
								break;
							}
							case 'custom': {
								if( val.format.callback === undefined && QBOX._.isFunction(val.format.origin) === false ) {
									datatype = 'callback';
									QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.format.origin'+ '"\'s type is "' + datatype + '".');
									result = false;
									defaultmsg = false;
								}
								break;
							}
							default: {
								break;
							}
						}
					}
				}
			}
			break;
		}
		default : break;
	}
	
	if(result === false && defaultmsg){
		QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '"\'s type is "' + datatype + '".');
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.QCellCol._adjustProps = function(properties){
	//QBOX.QCELL.colconfig: 기본 컬럼 속성값
	//properties: 사용자가 입력한 속성
	//QBOX.QCELL.BasicQCELL.QCellCol._adjustProp()을 이용하여 사용자가 입력한 속성값을 보정 후 사용자가 입력하지 않은 속성들은 기본값으로 설정되도록 QBOX.QCELL.colconfig와 합쳐준다. 
	return QBOX._.extendOwn(QBOX._.clone(QBOX.QCELL.colconfig), QBOX._.mapObject(properties, function(val, key){
		return QBOX.QCELL.BasicQCELL.QCellCol._adjustProp(key, val);
	}));
};

QBOX.QCELL.BasicQCELL.QCellCol._adjustProp = function(key, val){
	var result = null;
	if(val === undefined){
		result = this._getDefaultValueOfProp(key);
	} else{
		switch(key){
			/* *************** 선택 속성 체크 *************** */
			//case로 정의되어 있지 않은 속성들은 default:{}부분으로 동작한다.
			/* string type */
			case 'width': {
				result = QBOX._.isNumber(val) ? val + '' : val;
				break;
			}
			/* boolean type */
			case 'move': 
			case 'resize': 
			case 'sort': 
			case 'search': 
			case 'tooltip':
			case 'editor': {
				if(QBOX._.isBoolean(val) === true) {
					result = val;
				} else {
					result = false; //초기값 false로 설정
				}
				
				break;
			}
			/* number type */
			/* array type */
			/* object type */
			case 'styleclassname':	{
				result = {
					header	: val.header === undefined ? this._getDefaultValueOfProp('styleclassname').header : val.header,
					data	: val.data === undefined ? this._getDefaultValueOfProp('styleclassname').data : val.data
				};
				break;
			}
			
			case 'styler': {
				if(QBOX._.isFunction(val) === true) {
					result = val;
				} else {
					result = null; //초기값 null로 설정
				}
				break;
			}
			
			default: {
				result = val;
				break;
			}
		}
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.QCellCol._getDefaultValueOfProp = function(key){
	var result = QBOX.QCELL.colconfig[key];
	
	if(QBOX._.isArray(result) || QBOX._.isObject(result) && QBOX._.isArray(result) === false){
		return QBOX._.clone(result);
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._setSortInfoOfCol = function(strSortType, nOrder){
	var result = false;
	
	if(strSortType === 'asc' || strSortType === 'desc' || strSortType === 'none'){
		if(nOrder > -1){
			this.attr('sortinfoofcol', {sorttype:strSortType, order:nOrder}, 'object');
			
			result = true;
		}
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._initStyleInfo = function(){
	var def = QBOX.QCELL.def,
	strComma = ',',
	strPeriod = '.',
	strStyleClassName = def.cssprefix + this.attr('parent').attr('id') + '-' + this.attr('id') + '-',
	strStyleHeaderClassName, strStyleDataClassName;
	
	strStyleHeaderClassName = strStyleClassName + 'header-style';
	this._styleInfo('header', 'classname', strStyleHeaderClassName);
	this._styleInfo('header', 'rule', strPeriod + strStyleHeaderClassName + strComma + strPeriod + def.css.CELL_COLHEADER + strPeriod + strStyleHeaderClassName);
	
	strStyleDataClassName = strStyleClassName + 'data-style';
	this._styleInfo('data', 'classname', strStyleDataClassName);
	
	this._styleInfo('data', 'rule',//frozen 스타일, highlightrepeat 스타일이 함께 적용된 경우를 고려해야 한다.
		strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_FROZENCOLS + strPeriod + def.css.CELL_FROZENROWS		+ strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_FROZENCOLS + strPeriod + def.css.CELL_NORMALROWS		+ strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_FROZENCOLS + strPeriod + def.css.CELL_FROZENBOTTOMROWS	+ strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_FROZENCOLS + strPeriod + def.css.CELL_FROZENBOTTOMROWS_PANEL	+ strPeriod + strStyleDataClassName + strComma +		
		strPeriod + def.css.CELL_NORMALCOLS + strPeriod + def.css.CELL_FROZENROWS		+ strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_NORMALCOLS + strPeriod + def.css.CELL_NORMALROWS		+ strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_NORMALCOLS + strPeriod + def.css.CELL_FROZENBOTTOMROWS	+ strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_NORMALCOLS + strPeriod + def.css.CELL_FROZENBOTTOMROWS_PANEL	+ strPeriod + strStyleDataClassName + strComma +		
		strPeriod + def.css.CELL_FROZENCOLS + strPeriod + def.css.CELL_FROZENROWS		+ strPeriod + def.css.CELL_HIGHLIGHTREPEAT + strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_FROZENCOLS + strPeriod + def.css.CELL_NORMALROWS		+ strPeriod + def.css.CELL_HIGHLIGHTREPEAT + strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_FROZENCOLS + strPeriod + def.css.CELL_FROZENBOTTOMROWS	+ strPeriod + def.css.CELL_HIGHLIGHTREPEAT + strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_FROZENCOLS + strPeriod + def.css.CELL_FROZENBOTTOMROWS_PANEL	+ strPeriod + def.css.CELL_HIGHLIGHTREPEAT + strPeriod + strStyleDataClassName + strComma +		
		strPeriod + def.css.CELL_NORMALCOLS + strPeriod + def.css.CELL_FROZENROWS		+ strPeriod + def.css.CELL_HIGHLIGHTREPEAT + strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_NORMALCOLS + strPeriod + def.css.CELL_NORMALROWS		+ strPeriod + def.css.CELL_HIGHLIGHTREPEAT + strPeriod + strStyleDataClassName + strComma +
		strPeriod + def.css.CELL_NORMALCOLS + strPeriod + def.css.CELL_FROZENBOTTOMROWS	+ strPeriod + def.css.CELL_HIGHLIGHTREPEAT + strPeriod + strStyleDataClassName +
		strPeriod + def.css.CELL_NORMALCOLS + strPeriod + def.css.CELL_FROZENBOTTOMROWS_PANEL	+ strPeriod + def.css.CELL_HIGHLIGHTREPEAT + strPeriod + strStyleDataClassName		
	);
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._initStyle = function(){
	return this._removeStyle('all') && this._setStyle(this.attr('style').header, 'header') && this._setStyle(this.attr('style').data, 'data');
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._getStyle = function(/*header|data*/strType){
	if(strType === 'header' || strType === 'data'){
		return QBOX._.clone(this._styleInfo(strType, 'css'));
	}
	
	return {};
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._setStyle = function(objStyle, /*all|header|data*/strType){
	var result = false;
	
	if(strType === 'header' || strType === 'all'){
		if(QBOX._.size(objStyle) > 0){
			this.attr('usercolstyle_header', objStyle, 'object');
			this._styleInfo('header', 'css', QBOX._.extend(QBOX._.clone(this._styleInfo('header', 'css')), objStyle));
			QBOX.util.createCSSRule(this._styleInfo('header', 'rule'), this._styleInfo('header', 'css'));
		}
		
		result = true;
	}
	
	if(strType === 'data' || strType === 'all'){
		if(QBOX._.size(objStyle) > 0){
			this.attr('usercolstyle_data', objStyle, 'object');
			this._styleInfo('data', 'css', QBOX._.extend(QBOX._.clone(this._styleInfo('data', 'css')), objStyle));
			QBOX.util.createCSSRule(this._styleInfo('data', 'rule'), this._styleInfo('data', 'css'));
		}
		
		result = true;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype._removeStyle = function(/*all|header|data*/strType){
	var result = false;
	
	if(strType === 'header' || strType === 'all'){
		if(QBOX._.size(this._styleInfo('header', 'css')) > 0){
			QBOX.util.removeCSSRule(this._styleInfo('header', 'rule'));
			this._styleInfo('header', 'css', {});
		}
		
		result = true;
	}
	
	if(strType === 'data' || strType === 'all'){
		if(QBOX._.size(this._styleInfo('data', 'css')) > 0){
			QBOX.util.removeCSSRule(this._styleInfo('data', 'rule'));
			this._styleInfo('data', 'css', {});
		}
		
		result = true;
	}
	
	return result;
};
QBOX.QCELL.BasicQCELL.QCellCol.prototype._initUserColStyle = function(){
	if(this.attr('usercolstyle_header') !== null ){
		 this._removeStyle('header');
		 this._setStyle(this.attr('usercolstyle_header'),'header');
	}
	if(this.attr('usercolstyle_data') !== null ){
		 this._removeStyle('data') ;
		 this._setStyle(this.attr('usercolstyle_data'),'data');
	}
};
QBOX.QCELL.BasicQCELL.QCellCol.prototype.getStyleClassName = function(strGroup){
	return this.attr('styleclassname')[strGroup];
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype.setStyleClassName = function(strGroup, strStyleClassName){
	this.attr('styleclassname')[strGroup] = strStyleClassName;
	
	return true;
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype.setSortInfoOfCol = function(sorttype, order){
	return this._setSortInfoOfCol(sorttype, order);
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype.getStyleInfo = function(/*header|data*/group, key){
	return this._styleInfo(group, key);
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype.initStyle = function(){
	return this._initStyle();
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype.getStyle = function(/*header|data*/type){
	return this._getStyle(type);
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype.setStyle = function(style, /*all|header|data*/type){
	return this._setStyle(style, type);
};

QBOX.QCELL.BasicQCELL.QCellCol.prototype.removeStyle = function(/*all|header|data*/type){
	return this._removeStyle(type);
};

QBOX.QCELL.BasicQCELL.prototype.onKeyWidth = function(keyCode,nRow,nCol){
	var THAT = this;
	var nColWidth =this.getColWidth(nCol);
	nGap = keyCode === QBOX.def.key.LEFT ? -20 : 20;
	setTimeout(function (){
		THAT.setColWidth(nCol,nColWidth + nGap);
		setTimeout(function(){
			QBOX.$(THAT._getCellDOM(nRow,nCol)).focus();					
			
		});
	});	
};
QBOX.QCELL.BasicQCELL.prototype.onKeyDown = function(event){
	try	{
		var target = event.target,
		keyCode = event.keyCode,
		css = QBOX.QCELL.def.css,
		nRow = this._idx('row', 'focus'), nCol = this._idx('col', 'focus'),THAT = this,nGap,objHSInfo,objVSInfo;
		
		if(this.attr('useall') || this.attr('usetreeall')){
			if(!QBOX.$(event.target).hasClass('rt-qc-ui-selectmenu-button') ){
				if((keyCode === QBOX.def.key.LEFT || keyCode === QBOX.def.key.RIGHT) && !event.ctrlKey){
					objHSInfo = this.attr('hsinfo');
					if(QBOX.$(event.target).hasClass ('rt-qc-radio-cell-style'))
						return;			
					
					if(objHSInfo.bHScroll === true){
						if(keyCode === QBOX.def.key.LEFT){
							nGap = objHSInfo.nLeft + objHSInfo.nLengthPerCol;
							if(nGap >0)
								nGap = 0;
						}else{
							nGap = objHSInfo.nLeft - objHSInfo.nLengthPerCol;
							if(nGap > objHSInfo.nLength)
								nGap = objHSInfo.nLength;
							
						}
						setTimeout(function(){
							THAT.attr('elementpool').get('$jqhscrollbar').rt_qc_mCSbar('scrollTo', nGap);	
						},100);
						event.preventDefault();
						event.stopPropagation();
						return;
					}else{
						event.preventDefault();
						event.stopPropagation();					
					}
				}else if(keyCode === QBOX.def.key.UP || keyCode === QBOX.def.key.DOWN){
					objVSInfo = this.attr('vsinfo');
					if(QBOX.$(event.target).hasClass ('rt-qc-radio-cell-style'))
						return;			
					
					if(objVSInfo.bVScroll === true){
						if(keyCode === QBOX.def.key.UP){
							nGap = objVSInfo.nTop + objVSInfo.nLengthPerRow *3;
							if(nGap >0)
								nGap = 0;
						}else{
							nGap = objVSInfo.nTop - objVSInfo.nLengthPerRow *3;
							if(nGap > objVSInfo.nLength)
								nGap = objVSInfo.nLength;
							
						}
						setTimeout(function(){
							THAT.attr('elementpool').get('$jqvscrollbar').rt_qc_mCSbar('scrollTo', nGap);	
						},10);
						event.preventDefault();
						event.stopPropagation();
						return;
					}else{
						event.preventDefault();
						event.stopPropagation();
					}
				}else if(keyCode === QBOX.def.key.TAB){

					return;
				}
				
			}
		}
		
		if(nRow === -1 && nCol === -1){
			if(this.getRows() - this.getRows('header') <= 0){
				if(keyCode === QBOX.def.key.LEFT || keyCode === QBOX.def.key.RIGHT){
					objHSInfo = this.attr('hsinfo');
					if(objHSInfo.bHScroll === true){
						if(keyCode === QBOX.def.key.LEFT){
							nGap = objHSInfo.nLeft + objHSInfo.nLengthPerCol;
							if(nGap >0)
								nGap = 0;
						}else{
							nGap = objHSInfo.nLeft - objHSInfo.nLengthPerCol;
							if(nGap > objHSInfo.nLength)
								nGap = objHSInfo.nLength;
							
						}
						THAT.attr('elementpool').get('$jqhscrollbar').rt_qc_mCSbar('scrollTo', nGap);
						return;
					}
				}				
			}

		}
		var orHe = null;
		if(QBOX.util.hasClass(target, css.TYPE_INPUT_EDIT_STYLE)){
			if(event.ctrlKey)
				orHe = target;
			target =target.parentElement;
		}
		if((this.attr('useall') || this.attr('usetreeall')) && QBOX.util.hasClass(target, 'rt-qc-container') && nRow !== -1 && nCol !== -1){
			target = this._getCellDOM(nRow,nCol);
		}
		
		if(QBOX.util.hasClass(target, css.CELL)){
			if(nRow >= this.attr('headerrows') && nCol >= this.attr('headercols')){
				if(this._getQCellCol(nCol).attr('resize') && event.ctrlKey === true &&
						(keyCode === QBOX.def.key.LEFT || keyCode === QBOX.def.key.RIGHT)){
					this.onKeyWidth(keyCode,nRow,nCol);
					
					return;
				}
				
				switch(keyCode){
					case QBOX.def.key.LEFT: {
						this._leftKey(event.shiftKey, event.ctrlKey);
						if(event.ctrlKey)
							this.onKeyWidth(keyCode,nRow,nCol);
						break;
					}
					case QBOX.def.key.RIGHT: {
						this._rightKey(event.shiftKey, event.ctrlKey);
						if(event.ctrlKey)
							this.onKeyWidth(keyCode,nRow,nCol);						
						break;
					}
					case QBOX.def.key.UP: {
						this._upKey(event.shiftKey, event.ctrlKey);
						break;
					}
					case QBOX.def.key.DOWN: {
						this._downKey(event.shiftKey, event.ctrlKey);
						event.stopPropagation();						
						event.preventDefault();						
						break;
					}
					case QBOX.def.key.PAGEUP: {
						this._pageUpKey(event.shiftKey, event.ctrlKey);
						break;
					}
					case QBOX.def.key.PAGEDOWN: {
						this._pageDownKey(event.shiftKey, event.ctrlKey);
						break;
					}
					case QBOX.def.key.TAB :{
						this._tabKey(event.shiftKey, event.ctrlKey);
						event.stopPropagation();						
						event.preventDefault();
						break;
					}					
					case QBOX.def.key.C: {
						if(this.attr('copy')){
							if(event.ctrlKey){
								this.onCopy();
								event.stopPropagation();						
								//event.preventDefault();								
							}
						}
						break;
					}
					case QBOX.def.key.V: {
						if(this.attr('paste')){
							if(event.ctrlKey){
								this.onPaste();
								event.stopPropagation();						
							//	event.preventDefault();
							}
						}
						break;
					}
				}
			}
		} else {
			if(QBOX.util.hasClass(target, css.PAGINATION_NAV) && QBOX.util.hasClass(target, css.PAGINATION_NAV_INPUT)) {
				if(keyCode === QBOX.def.key.ENTER) {
					this._movePage(Number(QBOX.$(target).val()));
				}
			}
		}
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL.onKeyDown', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype.onCopy = function(){
	var strSelectMode = this.attr('selectmode'),
	arrSelectedRows = this._getSelectedRows(),
	arrSelectedCols = this._getSelectedCols();
	
	if(arrSelectedRows.length > 0 || arrSelectedCols.length > 0){
		var strData = '',
		i, j, nRow, nCol;
		
		switch(strSelectMode){
			case 'cell': case 'cells': {
				/*
				 * 다중 선택 범위에서는 복사, 붙여넣기 동작 제한
				 */
				var isMultiSelect = false;
				
				//다중선택 여부 확인
				if(this._idx('row', 'focus', 'current') !== arrSelectedRows[arrSelectedRows.length - 1] &&
						this._idx('col', 'focus', 'current') !== arrSelectedCols[arrSelectedCols.length - 1]){
					isMultiSelect = true;
				}
				
				if(isMultiSelect){
					alert('다중 선택 범위에서는 클립보드 복사를 사용할 수 없습니다.');
				} else{
					arrSelectedRows.sort(QBOX.st.asc);
					arrSelectedCols.sort(QBOX.st.asc);
					
					for(i = 0; i < arrSelectedRows.length; i++){
						nRow = arrSelectedRows[i];
						
						if(i > 0){
							strData += '\n';
						}
						
						for(j = 0; j < arrSelectedCols.length; j++){
							nCol = arrSelectedCols[j];
							
							if(j > 0){
								strData += '\t';
							}
							
							strData += this._cellValue(nRow, nCol) === undefined? '' : this._cellValue(nRow, nCol);
						}
					}
					
					this._copy(strData);
				}
				
				break;
			}
			case 'row': case 'rows': {
				var nStartCol = this.attr('headercols'),
				nEndCol = this.attr('cols');
				
				arrSelectedRows.sort(QBOX.st.asc);
				
				for(i = 0; i < arrSelectedRows.length; i++){
					nRow = arrSelectedRows[i];
					
					if(i > 0){
						strData += '\n';
					}
					
					for(j = nStartCol; j < nEndCol; j++){
						if(j > nStartCol){
							strData += '\t';
						}
						
						strData += this._cellValue(nRow, j) === undefined? '' : this._cellValue(nRow, j);
					}
				}
				
				this._copy(strData);
				
				break;
			}
			case 'col': case 'cols': {
				/* 성능이 안나옴 */
				
//				var nStartRow = this.attr('headerrows'),
//				nEndRow = this.attr('rows');
//				
//				arrSelectedCols.sort(QBOX.st.asc);
//				
//				for(i = nStartRow; i < nEndRow; i++){
//					if(i > nStartRow){
//						strData += '\n';
//					}
//					
//					for(j = 0; j < arrSelectedCols.length; j++){
//						nCol = arrSelectedCols[j];
//						
//						if(j > 0){
//							strData += '\t';
//						}
//						
//						strData += this._cellValue(i, nCol);
//					}
//				}
//				
//				this._copy(strData);
				
				break;
			}
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype.onPaste = function(){
	var nCurrentDataCount = this.attr('currentdata').length;
	
	if(nCurrentDataCount > 0){
		if(window.clipboardData){
			this._paste(window.clipboardData.getData('text'));
		} else{
			//크롬, 파이어폭스, 오페라, 엣지 브라우저
			var heClipboardDiv = null, heClipboardTextarea = null, strData = '',
			objQCell = this, heRoot = this.attr('elementpool').get('root');
			heClipboardDiv = document.createElement('div');
			heClipboardDiv.setAttribute('id', 'clipboardDataDiv');
			heClipboardTextarea = document.createElement('textarea');
			heClipboardTextarea.style.height = heClipboardTextarea.style.width = '0px';
			heClipboardDiv.appendChild(heClipboardTextarea);
			heRoot.appendChild(heClipboardDiv);
			heClipboardTextarea.focus();
			
			window.setTimeout(function(){
				strData = heClipboardTextarea.value;
				
				heRoot.removeChild(document.getElementById('clipboardDataDiv'));
				if(QBOX._.isFunction(objQCell.attr('beforepastecallback'))){
					var nStartRow = objQCell._idx('row', 'focus', 'current'),
					nStartCol = objQCell._idx('col', 'focus', 'current');
					strData = objQCell.attr('beforepastecallback')(nStartRow,nStartCol,strData);
				}
				objQCell._paste(strData);
				objQCell._trigger('paste',strData);
			}, 100);
		}
	}
	
};

QBOX.QCELL.BasicQCELL.prototype._copy = function(strData){
	var heClipboardDiv = null, heClipboardTextarea = null, heRoot = this.attr('elementpool').get('root');
	
	if(window.clipboardData){
		window.clipboardData.setData('text', strData);
	} else{
		heClipboardDiv = document.createElement('div');

		heClipboardDiv.style.position = 'absolute';
		heClipboardDiv.style.left =this.attr('elementpool').get('root').offsetLeft + "px";
		heClipboardDiv.style.top =this.attr('elementpool').get('root').offsetTop + "px" ;		
		QBOX.util.addClass(heClipboardDiv,'rt-qc-clipboard');		
		
		heClipboardDiv.setAttribute('id', 'clipboardDataDiv');
		heClipboardTextarea = document.createElement('textarea');
		
		QBOX.util.addClass(heClipboardTextarea,'rt-qc-clipboard-textarea');
		
		heClipboardTextarea.style.height = heClipboardTextarea.style.width = '0px';
		heClipboardTextarea.value = strData;
		heClipboardDiv.appendChild(heClipboardTextarea);
		heRoot.appendChild(heClipboardDiv);
		heClipboardTextarea.focus();
		heClipboardTextarea.select();
		
		window.setTimeout(function(){
			heRoot.removeChild(document.getElementById('clipboardDataDiv'));
		}, 100);
	}
};

QBOX.QCELL.BasicQCELL.prototype._paste = function(strData){
	var nStartRow = this._idx('row', 'focus', 'current'),
	nStartCol = this._idx('col', 'focus', 'current'),
	arrClipboardData, i, j, arrRowData, strCellData, regPattern;
	
	arrClipboardData = strData.split('\n');
	
	if(QBOX._.isArray(arrClipboardData)){
		if(arrClipboardData[arrClipboardData.length - 1] === ''){
			arrClipboardData.pop();
		}
		
		if(nStartRow < this.attr('headerrows') || nStartRow >= this.attr('rows')){return;}
		if(nStartCol < this.attr('headercols') || nStartCol >= this.attr('cols')){return;}
		
		regPattern = /[\r\n|\n\r]$/;
		
		for(i = 0; i < arrClipboardData.length; i++){
			arrRowData = arrClipboardData[i].split('\t');
			
			for(j = 0; j < arrRowData.length; j++){
				strCellData = arrRowData[j];
				
				if(j === arrRowData.length - 1){
					if(regPattern.test(strCellData)){
						strCellData = strCellData.replace(strCellData, '');						
					}
					

				}
				if(nStartCol + j >= this.getCols())
					break;
				
				var objCol = this._getColElement(nStartCol + j);
				
				if(objCol !== null && objCol !== undefined){
					if(!QBOX._.isNull(objCol.attr('maxbyte')) && !QBOX._.isUndefined(objCol.attr('maxbyte')) && QBOX.util.strbyte.getByteLength(strCellData) > objCol.attr('maxlength')){
						strCellData = QBOX.util.strbyte.cutByteLength(strCellData , objCol.attr('maxbyte'));	
						
					}else if(!QBOX._.isNull(objCol.attr('maxlength')) && !QBOX._.isUndefined(objCol.attr('maxlength')) && strCellData.length > objCol.attr('maxlength')){
						strCellData = strCellData.slice(0,objCol.attr('maxlength'));	
						
					}					
					
				}
				
				var objCellDisabled = this._getQCellCol(nStartCol + j).attr('celldisabled')[nStartRow + i];
				objCellDisabled = objCellDisabled ===undefined ? false:objCellDisabled;
				
				if(objCellDisabled !== true)
					this._cellValue(nStartRow + i, nStartCol + j, strCellData);
				
				if(this.attr('selectmode') === 'cells'){
					this._selectCell(nStartRow + i, nStartCol + j);
				}
			}
			
			if(this.attr('selectmode') === 'rows'){
				this._selectRow(nStartRow + i);
			}
		}
		
		regPattern = null;
		
	}
};

QBOX.QCELL.BasicQCELL.prototype.onMouseWheel = function(event){
	try{
		var objVSInfo = this.attr('vsinfo'), objQCell = this;
		
		if(objVSInfo.bVScroll){
			// 스크롤이 존재할 때만 영역밖의 Mouse Wheel event 방지
			event.stopPropagation();
			event.preventDefault();
			
			//스크롤바가 처음이나 끝인 경우 더이상 이동 할 필요가 없다.
			if((event.deltaY < 0 && objVSInfo.nPos < objVSInfo.nLastPos) || (event.deltaY > 0 && objVSInfo.nPos > 0)){
				var nAccumulatedWheel = this.attr('accumulatedwheel') + event.deltaY;
				
				//nAccumulatedWheel값만큼 스크롤바 이동 시 스크롤바 이동범위를 벗어나는 경우가 발생 할 수 있으니 보정한다. 
				if(objVSInfo.nPos - nAccumulatedWheel > objVSInfo.nLastPos){
					nAccumulatedWheel = objVSInfo.nPos - objVSInfo.nLastPos;
				} else if(objVSInfo.nPos - nAccumulatedWheel < 0){
					nAccumulatedWheel = objVSInfo.nPos;
				}
				
				this.attr('elementpool').get('$jqvscrollbar').rt_qc_mCSbar('scrollTo', objVSInfo.nTop + (nAccumulatedWheel * objVSInfo.nLengthPerRow), '', {ignorecallback:true});
				this.attr('accumulatedwheel', nAccumulatedWheel, 'number');
				
				QBOX.util.rAF(function(){
					var accumulatedwheel = objQCell.attr('accumulatedwheel');
					if(accumulatedwheel !== 0){
						objVSInfo.nBeforeTop = objVSInfo.nTop;
						objVSInfo.nTop += accumulatedwheel * objVSInfo.nLengthPerRow;//세로스크롤바가 nLengthPerRow값 단위로 딱딱 맞아떨어지게 이동하면 좋겠지만 그렇지 않기 때문에 nScrollTop값으로 설정하면 안되고, 이동한 행 수 만큼 nLengthPerRow값을 곱한 값을 더 해 줘야 한다.
						objVSInfo.nPos = -(objVSInfo.nTop / objVSInfo.nLengthPerRow);
						objQCell._syncVSInfo();
						objQCell._updateNRs();
						objQCell.attr('accumulatedwheel', 0, 'number');
						
						if(objQCell.attr('useall') || objQCell.attr('usetreeall')){
							if(objVSInfo.nTopRow > objVSInfo.nStartRow){
								QBOX.$('#'+objQCell.getID()+'_vsbp').prop('disabled' , false);
							}else{
								QBOX.$('#'+objQCell.getID()+'_vsbp').prop('disabled' , true);
							}
							if(objVSInfo.nBottomRow === objVSInfo.nEndRow){
								QBOX.$('#'+objQCell.getID()+'_vsbn').prop('disabled' , true);
							}else{
								QBOX.$('#'+objQCell.getID()+'_vsbn').prop('disabled' , false);
							}
							
						}	
						
						objQCell._trigger("scrollmove");
					}
				});
			}
		}
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL.onMouseWheel', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype.onMouseDown = function(event){
	try{
		var target = event.target,
		css = QBOX.QCELL.def.css,
		$colResizeLine = this.attr('colresizeline'),
		heParent = this.attr('parent'),
		bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false;
		
		// mousedown 이벤트 발생시 내부에 contextmenu가 존재하면 삭제
		this._removeContextMenu();
		
		if(QBOX.util.hasClass(target, css.CELL) || QBOX.util.hasClass(target, css.TYPE_DATEPICKER)){
			if(QBOX.util.hasClass(target, css.TYPE_DATEPICKER)){ // normal의 datepicker 타입일 때 동작
				if(QBOX.util.hasClass(target.parentNode, css.CELL)){
					target = target.parentNode;
				}else if(QBOX.util.hasClass(target.parentNode.parentNode, css.CELL)){
					target = target.parentNode.parentNode;
				}
			}
			
			var nRow = parseInt(target.getAttribute('data-row')), nCol = parseInt(target.getAttribute('data-col'));
			
			
			if(this._isBottomPanel(target))
				return;
			
			if(QBOX.util.hasClass(target, css.CELL_VIEWPORT)){
				
				if(event.which === QBOX.def.which.LEFT_BUTTON){
					switch(this.attr('selectmode')){
						case 'rows'	:{
							if(event.ctrlKey === event.shiftKey){//ctrl키와 shift키 둘 다 눌렀거나 둘 다 누르지 않은 경우
								this._focusCell(target);
								
								this._clearSelection();
								this._selectRow(nRow);
							} else{
								if(event.ctrlKey){//ctrl키만 눌렀을 때
									this._focusCell(target);
									this._selectRow(nRow);
								} else{//shift키만 눌렀을 때
									var nFocusRow = this._idx('row', 'focus'),
									arrSelectedRows;
									
									if(nFocusRow < nRow){
										arrSelectedRows = QBOX._.range(nFocusRow, nRow + 1);
									} else{
										arrSelectedRows = QBOX._.range(nRow, nFocusRow + 1).reverse();
									}
									
									//deselect된 행만 해제하기 위해 계산하는 것보다 전체 클리어 한 후 다시 선택하는 게 더 빠르다.
									this._clearSelection();
									this._selectRows(arrSelectedRows);
								}
							}
							
							break;
						}
						case 'row'	:{
							this._focusCell(target);
							
							if(this._getSelectedRows()[0] !== nRow){
								this._clearSelection();
								this._selectRow(nRow);
							}
							
							break;
						}
						case 'cols'	:{
							if(event.ctrlKey === event.shiftKey){//ctrl키와 shift키 둘 다 눌렀거나 둘 다 누르지 않은 경우
								this._focusCell(target);
								
								this._clearSelection();
								this._selectCol(nCol);
							} else{
								if(event.ctrlKey){//ctrl키만 눌렀을 때
									this._focusCell(target);
									this._selectCol(nCol);
								} else{//shift키만 눌렀을 때
									var nFocusCol = this._idx('col', 'focus'),
									arrSelectedCols;
									
									if(nFocusCol < nCol){
										arrSelectedCols = QBOX._.range(nFocusCol, nCol + 1);
									} else{
										arrSelectedCols = QBOX._.range(nCol, nFocusCol + 1).reverse();
									}
									
									//deselect된 열만 해제하기 위해 계산하는 것보다 전체 클리어 한 후 다시 선택하는 게 더 빠르다.
									this._clearSelection();
									this._selectCols(arrSelectedCols);
								}
							}
							
							break;
						}
						case 'col'	:{
							this._focusCell(target);
							
							if(this._getSelectedCols()[0] !== nCol){
								this._clearSelection();
								this._selectCol(nCol);
							}
							
							break;
						}
						case 'cell'	:{
							this._focusCell(target);
						
							this._clearSelection();
							this._selectCell(nRow, nCol);
							
							break;
						}
						case 'group' :{
							this._focusCell(target);
							
							this._clearSelection();
							this._selectGroup(nRow, nCol);
							break;
						}
						default		:{//cells
							if(event.ctrlKey === event.shiftKey){//ctrl키와 shift키 둘 다 눌렀거나 둘 다 누르지 않은 경우
								this._focusCell(target);
								
								this._clearSelection();
								this._selectCell(nRow, nCol);
							} else{
								if(event.ctrlKey){//ctrl키만 눌렀을 때
									this._focusCell(target);
									this._selectCell(nRow, nCol);
								} else{//shift키만 눌렀을 때
									this._clearSelection();
									this._selectCellRange(this._idx('row', 'focus'), this._idx('col', 'focus'), nRow, nCol);
								}
							}
							
							break;
						}
					}
				}
			}
		} else{ // 그리드 셀이 아닌 영역 클릭
			/*
			if(QBOX.util.hasClass(target, css.VIEWPORT_INNER) || QBOX.util.hasClass(target, css.COLHEADER_INNER)){
				//console.log("그리드 셀이 아닌 영역 클릭");
			}
			*/
		}
		
		if(event.which === QBOX.def.which.RIGHT_BUTTON){
			if(!this._isContextMenu()){
				this._createContextMenu(event);
			}
		}
		
		//컬럼 너비 조절 처리
		if(this.attr('colresize')){
			if($colResizeLine !== null){
				var $colResizeTooltip = this.attr('colresizetooltip'),
				nTargetCol = parseInt(target.parentNode.getAttribute('data-col')),
				nViewportOffsetLeft = this.attr('layoutsize').viewport.offsetLeft,
				nTargetLeft = target.parentNode.offsetLeft + nViewportOffsetLeft,//colMoveLine이 viewport가 아닌 container에 들어가 있으므로 container기준으로 left값을 구해야 한다.
				nTargetColWidth = this._getColWidth(nTargetCol);
				
				if($colResizeLine.css('display') === 'none'){
					$colResizeLine.css('display', 'block');
				}
				
				$colResizeLine.css('left', (nTargetLeft + nTargetColWidth - 1) + 'px');
				
				$colResizeLine.attr({
					'data-targetcol': nTargetCol,
					'originleft'	: parseInt($colResizeLine.css('left')),		//최초 컬럼 resizeLine 표시될때의 left 값 저장
					'client-x'		: event.clientX								//현재 clienX 값을 저장
				});
				
				//컬럼 너비 조절시 시각적 표현 위한 tooltip 영역 처리
				if($colResizeTooltip.css('display') === 'none'){
					$colResizeTooltip.css('display', 'block');
				}
				
				$colResizeTooltip.css('left', (nTargetLeft + nTargetColWidth - 1) + 'px');
				$colResizeTooltip.text('width : ' + nTargetColWidth + 'px');
				
				QBOX.$(target).addClass(css.COLRESIZE_AREA_HOVER);
			}
		}
		
		//filterUI 관련 처리
		if(QBOX.util.hasClass(target, css.FILTER_AREA) === false && 
				QBOX.util.hasClass(target, css.FILTER_AREA_ADJUST) === false && 
				QBOX.util.hasClass(target, css.FILTER_UI_AREA) === false && 
				QBOX.util.hasClass(target, css.FILTER_UI_BTN) === false && 
				QBOX.util.hasClass(QBOX.$(target).parents('.'+css.FILTER_UI_AREA)[0], css.FILTER_UI_AREA) === false){
			if(this.attr('filteruivisible')){
				this._removeFilterUIArea();
			}
		}
		
		//마우스 왼쪽 버튼의 눌림 상태를 true로 설정
		if(event.which === QBOX.def.which.LEFT_BUTTON){
			this.attr('mousedown', true, 'boolean');
		}
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL.onMouseDown', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype.onMouseUp = function(event){
	var def = QBOX.QCELL.def, strID = this.attr('id'),
	spanId = '#'+def.areaname.SHEETPANEL + '-span-' + strID,
	rows = this.getSelectedRows(), cols = this.getSelectedCols(),
	nRow = -1, nCol = -1,
	nHeaderrows = this.attr('headerrows'), nHeadercols = this.attr('headercols'),
	nRows = this.attr('rows'), nCols = this.attr('cols'),
	cnt = 0, sum = 0, avg = 0, ncnt = 0,
	r = 0, c = 0, text = '',
	THAT = this;
	
	if(this.attr('bottompanel') === false)
		return;
	
	if(this.attr('bottompanelstyle') === 'excel'){
		switch(this.attr('selectmode')){
			case 'row': case 'rows': {
				for(r = 0; r < rows.length; r++){
					for(c = nHeadercols; c < nCols; c++){
						if(!isNaN(parseInt(THAT._cellValue(rows[r], c)))){
							sum += parseInt(THAT._cellValue(rows[r], c));
							ncnt++;
						}
						cnt++;
					}
				}
				avg = parseFloat(sum / ncnt);
				text = '평균 : ' + avg + ', ' + '개수 : ' + cnt + ', ' + '합계 : ' + sum;
				
				if(sum === 0){
					text = '개수 : ' + cnt;
				}
				
				break;
			}
			case 'col': case 'cols': {
				for(c = 0; c < cols.length; c++){
					for(r = nHeaderrows; r < nRows; r++){
						if(!isNaN(parseInt(THAT._cellValue(r, cols[c])))){
							sum += parseInt(THAT._cellValue(r, cols[c]));
							ncnt++;
						}
						cnt++;
					}
				}
				avg = parseFloat(sum / ncnt);
				text = '평균 : ' + avg + ', ' + '개수 : ' + cnt + ', ' + '합계 : ' + sum;
				
				if(sum === 0){
					text = '개수 : ' + cnt;
				}
				break;
			}
			case 'group' : {
				if(rows.length === 0 && cols.length === 0){
					nRow = THAT.getIdx('row');
					nCol = THAT.getIdx('col');
					
					text = this._cellValue(nRow, nCol);
				} else {
					for(r = 0; r < rows.length; r++){
						nRow = rows[r];
						for(c = 0 ; c < cols.length; c++){
							nCol =  cols[c];
							
							if(!isNaN(parseInt(THAT._cellValue(nRow, nCol)))){
								sum += parseInt(THAT._cellValue(nRow, nCol));
								ncnt++;
							}
							cnt++;
						}
					}
					
					avg = parseFloat(sum / ncnt);
					text = '평균 : ' + avg + ', ' + '개수 : ' + cnt + ', ' + '합계 : ' + sum;
					
					if(sum === 0){
						text = '개수 : ' + cnt;
					}
				}
				break;
			}
			default: {
				if(rows.length === 1 && cols.length === 1){
					nRow = rows[0];
					nCol = cols[0];
					
					text = this.getCellLabel(nRow, nCol);
				} else {
					for(r = 0; r < rows.length; r++){
						nRow = rows[r];
						for(c = 0 ; c < cols.length; c++){
							nCol =  cols[c];
							
							if(!isNaN(parseInt(THAT._cellValue(nRow, nCol)))){
								sum += parseInt(THAT._cellValue(nRow, nCol));
								ncnt++;
							}
							cnt++;
						}
					}
					
					avg = parseFloat(sum / ncnt);
					text = '평균 : ' + avg + ', ' + '개수 : ' + cnt + ', ' + '합계 : ' + sum;
					
					if(sum === 0){
						text = '개수 : ' + cnt;
					}
				}
				break;
			}
		}		
	}else if(this.attr('bottompanelstyle') === 'index'){
		nRow = THAT.getIdx('row');
		text = '[ ' + (nRow - this.getRows('header') +1) + ' / ' + (nRows  - this.getRows('header')) + ' ]'; 
	}else if(this.attr('bottompanelstyle') === 'custom'){
		nRow = THAT.getIdx('row');
		nCol = THAT.getIdx('col');		
		text = this._cellValue(nRow, nCol);
	}else if(this.attr('bottompanelstyle') === 'board'){
		return;		
	}
	
	
	if(this.attr('bottompanelcallback') !== null && QBOX._.isFunction(this.attr('bottompanelcallback'))){
		nRow = THAT.getIdx('row');
		nCol = THAT.getIdx('col');		
		
		text = this.attr('bottompanelcallback').call(this,nRow,nCol,text);
	}
	
	QBOX.$(spanId).html(text);
	
	//console.log("onMouseUp");
//	try{
//		var css = QBOX.QCELL.def.css,
//		target = event.target;
//		
//		if(this.attr('dragging')){//dragging 중일 때
//			if(QBOX.util.hasClass(target, css.CELL_VIEWPORT)){//target이 viewport 셀인 경우에만
//				var nRow, nCol;
//				
//				nRow = parseInt(target.getAttribute('data-row'));
//				nCol = parseInt(target.getAttribute('data-col'));
//				
//				this._updateIdx('drag', nRow, nCol);
//			}
//			
//			this.onDrop(event);
//		}
//		
//		//마우스 왼쪽 버튼의 눌림 상태를 false로 설정
//		this.attr('mousedown', false, 'boolean');
//	} catch(e){
//		QCELL.log('err', 'QCELL.BasicQCELL.onMouseUp', e.message);
//	}
	
	/*
	try {
		var css = QBOX.QCELL.def.css,
		heParent = this.attr('parent');
		
		var contextDOM = document.getElementsByClassName(css.CONTEXTMENU_AREA);
		console.log('contextDOM length:'+contextDOM.length);
		if(contextDOM.length > 0){
			for(var i=0; i<contextDOM.length; i++){
				heParent.removeChild(contextDOM[i]);
			}
		}
	} catch (e) {
		QCELL.log('err', 'QCELL.BasicQCELL.onMouseUp', e.message);
	}
	*/
};

QBOX.QCELL.BasicQCELL.prototype.onClick = function(event){
	try{
		//firefox, safari에서는 dragging시 "click"이벤트가 발생하지 않는다. 나중에 문제가 된다면 "click" 인덱스 설정위치를 "mouseup"으로 옮겨야 할 듯
		
		var target = event.target,
		css = QBOX.QCELL.def.css,
		nRow, nCol,
		bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false;
		
		//console.log('on click');
		//console.log(target);		
		if(QBOX.util.hasClass(target, 'rt-qc-colheader-area') && QBOX.QCELL.config.useheadersort &&
				this._getQCellCol(this.getIdx('col','cursor')).attr('sort') &&
				(this._getQCellCol(this.getIdx('col','cursor')).attr('options').wholeselect === false || this._getQCellCol(this.getIdx('col','cursor')).attr('options').wholeselect === undefined)){// 클릭한 헤더 셀의 컬럼이 정렬을 사용할 경우
			this._sortProcess(event);					
		}else if((QBOX.util.hasClass(target, css.CELL) && QBOX.util.hasClass(target, css.SORTABLE) === false) || (QBOX.util.hasClass(target.parentElement, css.CELL) && target.tagName ==="SPAN")){
			if(target.hasChildNodes()){
				if(target.childNodes[0].type === "checkbox" && target.childNodes[0].className === css.CELL_ROWHEADER_CHECKBOX) { // rowheader checkbox cell click
					nRow = target.getAttribute('data-row');
					nCol = target.getAttribute('data-col');
					if(this.attr('rowheadercheckboxclick')[nRow][nCol]){
						this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
						if(target.childNodes[0].checked) {
							this._rowheaderCheckboxClick(this._idx('row', 'cursor'), this._idx('col', 'cursor'), false);
						} else {
							this._rowheaderCheckboxClick(this._idx('row', 'cursor'), this._idx('col', 'cursor'), true);
						}
					}
				}else if(target.childNodes[0].type === "radio" && target.childNodes[0].className === css.CELL_ROWHEADER_RADIO) { // rowheader checkbox cell click
					nRow = target.getAttribute('data-row');
					nCol = target.getAttribute('data-col');
					if(this.attr('rowheadercheckboxclick')[nRow][nCol]){
						this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
						if(target.childNodes[0].checked) {
							this._rowheaderCheckboxClick(this._idx('row', 'cursor'), this._idx('col', 'cursor'), false);
						} else {
							this._rowheaderCheckboxClick(this._idx('row', 'cursor'), this._idx('col', 'cursor'), true);
						}
					}
				}
			}
			
			nRow = this._idx('row', 'cursor');
			nCol = this._idx('col', 'cursor');
			
			if(this._isBottomPanel(target))
				return;

			
			this._updateIdx('click', nRow,nCol);
			
			if(QBOX.util.hasClass(target, css.CELL_VIEWPORT) || QBOX.util.hasClass(target.parentElement, css.CELL_VIEWPORT)){
				var THAT = this;
			
				if(this.attr('useall') !== true && this.attr('usetreeall') !== true){
					setTimeout(function(){
						if(THAT._idx('row', 'focus') !== nRow || THAT._idx('col', 'focus') !== nCol){
							THAT._focusCell(nRow,nCol);

						}
						
						THAT._scrollToFocusCell(THAT._idx('row', 'focus'), THAT._idx('col', 'focus'));
						THAT.attr('isClick', false , 'boolean');

						},100);
					
					this.attr('isClick', true , 'boolean');
					
				}
				
			}
		} else if(QBOX.util.hasClass(target, css.SORT_AREA) ||
				QBOX.util.hasClass(target, css.MULTI_SORT_ORDER)){// 클릭한 헤더 셀의 컬럼이 정렬을 사용할 경우
			this._sortProcess(event);			
			
		} else if(QBOX.util.hasClass(target, css.CELL_ROWHEADER_CHECKBOX)) { //rowheader checkbox click
			nRow = target.parentNode !== null ? target.parentNode.getAttribute('data-row') : this._idx('row', 'cursor');
			nCol = target.parentNode !== null ? target.parentNode.getAttribute('data-col') : this._idx('col', 'cursor');
			if(this.attr('rowheadercheckboxclick')[nRow][nCol]){
				this._updateIdx('click', nRow, nCol);
				if(target.checked) {
					this._rowheaderCheckboxClick(Number(target.parentNode.getAttribute('data-row')), Number(target.parentNode.getAttribute('data-col')), true);
				} else {
					this._rowheaderCheckboxClick(Number(target.parentNode.getAttribute('data-row')), Number(target.parentNode.getAttribute('data-col')), false);
				}
			}
		}else if(QBOX.util.hasClass(target, css.CELL_ROWHEADER_RADIO)) { //rowheader checkbox click
			nRow = target.parentNode !== null ? target.parentNode.getAttribute('data-row') : this._idx('row', 'cursor');
			nCol = target.parentNode !== null ? target.parentNode.getAttribute('data-col') : this._idx('col', 'cursor');
			if(this.attr('rowheadercheckboxclick')[nRow][nCol]){
				this._updateIdx('click', nRow, nCol);
				if(target.checked) {
					this._rowheaderCheckboxClick(Number(target.parentNode.getAttribute('data-row')), Number(target.parentNode.getAttribute('data-col')), true);
				} else {
					this._rowheaderCheckboxClick(Number(target.parentNode.getAttribute('data-row')), Number(target.parentNode.getAttribute('data-col')), false);
				}
			}
		} else if(QBOX.util.hasClass(target, css.EDITOR_AREA)) {
			this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
		} else if(QBOX.util.hasClass(target, css.TYPE_DATEPICKER)) {
			this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
		} else if(QBOX.util.hasClass(target, css.COLHEADER_CHECKBOX)){
			nRow = target.parentNode !== null ? target.parentNode.getAttribute('data-row') : this._idx('row', 'cursor');
			nCol = target.parentNode !== null ? target.parentNode.getAttribute('data-col') : this._idx('col', 'cursor');
			
			this._updateIdx('click', Number(nRow), Number(nCol));
		} else if(QBOX.util.hasClass(target.parentElement, css.TYPE_IMAGE_STYLE)){
			this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
		}  else if(QBOX.util.hasClass(target, css.REMOVE_AREA)){
			var objQCell = this;
			nCol = this._idx('col', 'cursor');
			setTimeout(function(){
				objQCell.removeColumn(nCol);
			});
		}else{
			this._updateIdx('click', -1, -1);
		}
		if(event.target.getElementsByClassName(css.TYPE_INPUT_EDIT_STYLE).length){
			//event.target.getElementsByClassName(css.TYPE_INPUT_EDIT_STYLE)[0].focus();
		}

	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL.onClick', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype.onDblClick = function(event){
	var target = event.target,
	css = QBOX.QCELL.def.css;
	
	if(this.attr('isscrollleft') !== false){
		if(QBOX.util.hasClass(target, css.CELL)){
			this._updateIdx('dblclick', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype.onMouseEnter = function(event){
	//그리드로 마우스 커서가 들어왔을 때 발생, target은 중요하지 않다.
	//console.log('onMouseEnter');
};

QBOX.QCELL.BasicQCELL.prototype.onMouseLeave = function(event){
	//그리드 밖으로 마우스 커서가 나갔을 때 발생, target은 중요하지 않다.
	//console.log('onMouseLeave');
};

QBOX.QCELL.BasicQCELL.prototype.onMouseMove = function(event){
	try{
		var css = QBOX.QCELL.def.css,
		target = event.target,
		$colMoveLine = this.attr('colmoveline'),
		$colResizeLine = this.attr('colresizeline'),
		nRow = -1, nCol = -1;
		
		//event.stopPropagation();//QCELL에서 "mousemove" 이벤트 발생 시 window에 건 mousemove가 동작되지 않도록 제어
		
		if(QBOX.util.hasClass(target, css.CELL)){//target이 셀인 경우에만
			nRow = parseInt(target.getAttribute('data-row'));
			nCol = parseInt(target.getAttribute('data-col'));
			
			//var target = event.target,
			
			//console.log('nRow:'+nRow+', nCol:'+nCol);
			//console.log("this._idx('row', 'cursor'):"+this._idx('row', 'cursor'));
			//console.log("this._idx('col', 'cursor'):"+this._idx('col', 'cursor'));
			if(this._idx('row', 'cursor') != nRow || this._idx('col', 'cursor') != nCol){
				this._updateIdx('cursor', nRow, nCol);//cursor 인덱스를 갱신			

				if(event.buttons !== 0 && event.which === QBOX.def.which.LEFT_BUTTON && this.attr('mousedown')){//drag 이벤트 발생
					if(this.attr('hdhandle') === null && this.attr('vdhandle') === null){
						this.onDrag(event);
					}
				}
			}
			
			//위치 변경하여 언제나 저장 하도록 함
			this._updateIdx('hover', nRow, nCol);//cursor 인덱스를 갱신
			
			if(nRow >= this.attr('headerrows') && nCol >= this.attr('headercols') ){ // viewport영역에서만 동작
				var objQCell = this, $target = QBOX.$(target);
				var fnTooltip = function(bIsCallback){
					if(objQCell.attr('tooltipvisible') === false){ // tooltip이 생성되지 않았을 때만
						
						var strData;
						
						if(bIsCallback){
							strData = objQCell.getCellData(nRow,nCol);
							strData = objQCell._getQCellCol(nCol).attr('tooltipcallback')(nRow,nCol,strData);
						}else{
							strData = objQCell.getCellData(nRow,nCol);
							if(strData === undefined || strData === '')
								return;
						}
						
						var objGroupState =  objQCell.attr('groupstate').grouped ? objQCell.attr('groupstate') : objQCell.attr('treestate'),
								strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '';
								
						if(objGroupState.grouped === true){
							if(objQCell._getColID(nCol) === strFirstGroupColID){
								var heCell = objQCell._getCellDOM(nRow,nCol);
								if(heCell !== null && heCell !== undefined){
									strData = heCell.textContent === undefined ? '' : heCell.textContent;
								}
							}
						}
						
						//console.log(target.offsetWidth + ' ' + target.scrollWidth);
						
						if(objQCell.attr('usetooltipinellipsis') === true){
							if(target.offsetWidth < target.scrollWidth)
								objQCell._createTooltip($target, event,strData);		
						}else{
							objQCell._createTooltip($target, event,strData);
						}
						
						$target.on('mouseleave mousewheel DOMMouseScroll', function(){ // 현재 element에서 mouseleave나 mousewheel event가 실행되면 tooltip제거
							objQCell._removeTooltip();
						});
					}
					else {
						objQCell._moveTooltip(QBOX.$(target), event);
					}
				};
				
				if(this._getQCellCol(nCol).attr('tooltip') && this._getQCellCol(nCol).attr('tooltipcallback') !== undefined){
					fnTooltip(true);
					
				}else if(this._getQCellCol(nCol).attr('tooltip') && this._getQCellCol(nCol).attr('type') !== 'checkbox' && this._getQCellCol(nCol).attr('type') !== 'html'&& this._getQCellCol(nCol).attr('type') !== 'image' && this._getQCellCol(nCol).attr('type') !== 'chart'){ // html, checkbox, image type에서는 미동작
					fnTooltip(false);
				}
			}
		}else{
			// Cell 영역이 아니면 Row, Col -1 설정
			if(this._idx('row', 'hover') != nRow || this._idx('col', 'hover') != nCol){
				this._updateIdx('hover', nRow, nCol);//cursor 인덱스를 갱신
			}
		}
		
		//컬럼 이동 처리
		if(this.attr('colmove') && this.attr('colresize') !== true){			
			if(this.attr('hdhandle') === null){//스크롤바가 이동중이면 비동기상태이므로 스크롤바 이동중이 아닌 경우에만
				if(nCol >= this.attr('headercols')){
					//console.log('컬럼 이동 중');
					if($colMoveLine !== null){
						var nBeforeCol = parseInt(this.attr('colmoveshadow').attr('data-col')),
						nColWidth = this._getColWidth(nCol),
						nViewportOffsetLeft = this.attr('layoutsize').viewport.offsetLeft,
						nContainerClientX = this.attr('layoutsize').container.clientX,
						nTargetLeft = target.offsetLeft + nViewportOffsetLeft;//colMoveLine이 viewport가 아닌 container에 들어가 있으므로 container기준으로 left값을 구해야 한다.
						
						//console.log('nTargetLeft:', nTargetLeft);
						//console.log('cursor\'s clientX:', event.clientX);
						
						if($colMoveLine.css('display') === 'none'){
							$colMoveLine.css('display', 'block');
						}
						
						if(event.clientX > nTargetLeft + (nColWidth / 2)  + nContainerClientX){
							$colMoveLine.css('left', (nTargetLeft + nColWidth - 1) + 'px');
							
							if(nCol > nBeforeCol){//nCol이 이동되는 컬럼의 원래 인덱스보다 큰 경우만 컬럼을 오른쪽으로 이동 가능
								//console.log(nCol, '위치로 오른쪽 컬럼 이동');
								this.attr('colmoveexecution', true, 'boolean');
								
								$colMoveLine.attr({
									'data-beforecol': nBeforeCol,
									'data-aftercol'	: nCol
								});
							}
						} else{
							$colMoveLine.css('left', (nTargetLeft - 1) + 'px');
							
							if(nCol < nBeforeCol){//nCol이 이동되는 컬럼의 원래 인덱스보다 작은 경우만 컬럼을 왼쪽으로 이동 가능
								//console.log(nCol, '위치로 왼쪽 컬럼 이동');
								this.attr('colmoveexecution', true, 'boolean');
								
								$colMoveLine.attr({
									'data-beforecol': nBeforeCol,
									'data-aftercol'	: nCol
								});
							}
						}
					}
				}
			}
		}
		
		//컬럼 너비 조절 처리
		if(this.attr('colresize')){
			this.attr('colmove' , false, 'boolean') ;
			if($colResizeLine !== null){
				var $colResizeTooltip = this.attr('colresizetooltip'),
				nClientX = parseInt($colResizeLine.attr('client-x')),
				nColResizeLineLeft = parseInt($colResizeLine.css('left')),
				nTargetCol = parseInt($colResizeLine.attr('data-targetcol')),
				nOriginLeft = parseInt($colResizeLine.attr('originleft')),
				nTargetColWidth = this._getColWidth(nTargetCol);
				
				nClientX -= event.clientX;
				
				if($colResizeLine.css('display') === 'none'){
					$colResizeLine.css('display', 'block');
				}
				
				//컬럼 너비 조절시 시각적 표현 위한 tooltip 영역 처리
				if($colResizeTooltip.css('display') === 'none'){
					$colResizeTooltip.css('display', 'block');
				}
				
				var nLeft = nColResizeLineLeft - nClientX;
				
				$colResizeLine.css('left', nLeft + 'px');
				
				$colResizeLine.attr({
					'client-x': event.clientX			//현재 clienX 값을 저장
				});
				
				$colResizeTooltip.text('width : ' + (nTargetColWidth + (nLeft - nOriginLeft)) + 'px');
			}
		}
		
		if(this.attr('dragging')){//dragging을 이용한 스크롤바 이동
			if(this.attr('colmove')){
				if(this.attr('hdhandle')){//스크롤바가 이동중인 경우
					this.attr('colmoveexecution', false, 'boolean');
					
					if($colMoveLine !== null && $colMoveLine.css('display') !== 'none'){
						$colMoveLine.css('display', 'none');
					}
				}
			} else{
				if(this.attr('colresize') === false){
					this._MoveVScrollbarToDragging(event);
				}
			}
			
			if(this.attr('colresize') === false){
				this._MoveHScrollbarToDragging(event);
			}
		}
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL.onMouseMove', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype.onDrag = function(event){
	try{
		var nFocusRow = this._idx('row', 'focus'),
		nFocusCol = this._idx('col', 'focus'),
		nCursorRow = this._idx('row', 'cursor'),
		nCursorCol = this._idx('col', 'cursor'),
		nDragRow = nCursorRow >= this.attr('headerrows') ? nCursorRow : this._idx('row', 'drag'),
		nDragCol = nCursorCol >= this.attr('headercols') ? nCursorCol : this._idx('col', 'drag');
		
		this._updateIdx('drag', nDragRow, nDragCol);
		
		if(this.attr('startdragpos') === null){
			this.attr('startdragpos' , { nRow: this._idx('row', 'cursor','previous') , nCol : this._idx('col', 'cursor','previous') }, 'object');
		}
		
		if(this.attr('colmove') === false && this.attr('colresize') === false){
			this._selectDragArea(event);
		}
		
		if(this.attr('colmove') === false && this.attr('colresize') !== true ){
			if(event.which === 1 && event.button === 0 && QBOX.QCELL.config.useheadercolmove === true){
				var css = QBOX.QCELL.def.css,
					objLayoutSize = this.attr('layoutsize'),
					arrColCellDOMs = [],
					$colMoveLineEx,
					$colMoveShadow,					
					nHeaderRows = this.attr('headerrows'),
					nFrozenBottomRows = this.attr('frozenbottomrows'),
					nRows = this.attr('rows'),
					nAdjustHeight = 0,
					nAdjustHeight2 = 0,
					heDiv = document.createElement('div');
				
				nRow = this.attr('startdragpos').nRow;
				nCol = this.attr('startdragpos').nCol;
				
				if(nRow < this.getRows('header') && nCol >= this.getCols('header') && this._getQCellCol(nCol).attr('move')){
					this.attr('colmove', true, 'boolean');
					this.attr('colmoveexecution', false, 'boolean');
		
					QBOX._.each(this._getColCellDOMs(Number(nCol)), function(heOriginCell, idx){
						var heCell = heOriginCell.cloneNode(true);
						nRow = parseInt(heCell.getAttribute('data-row'));
						
						heCell.style.left = '0px';
						//heCell.style.width = '100%';
						//heCell.style.borderLeftWidth = '1px';
						heCell.style.display = 'block';
						
						//"colMoveShadow" div에 표시하기 위해 colheader, viewport, footer 영역에 있던 셀 div들의 top값을 보정
						if(isNaN(nRow)){//footerRows
							heCell.style.top = (parseInt(heCell.style.top) + nAdjustHeight2) + 'px';
						} else{
							if(nRow < nHeaderRows){//HeaderRows
								heCell.style.top = nAdjustHeight + 'px';
								
								nAdjustHeight += parseInt(heCell.style.height);
							} else{
								heCell.style.top = (parseInt(heCell.style.top) + nAdjustHeight) + 'px';
								
								if(nRow >= nRows - nFrozenBottomRows){
									nAdjustHeight2 = parseInt(heCell.style.top) + parseInt(heCell.style.height);
								}
							}
						}
						
						arrColCellDOMs.push(heCell);
					});
		
					//최하단의 셀이 frozenbottomrows나 footerrows인 경우 border-bottom이 없어 채워준다.
					QBOX._.last(arrColCellDOMs).style.borderBottomWidth = '1px';
		
					$colMoveShadow = QBOX.$(heDiv.cloneNode()).addClass(css.COLMOVE_SHADOW).attr('data-col', Number(nCol))
					.css({display: 'none'}).append(arrColCellDOMs).appendTo(document.body);
		
					this.attr('colmoveshadow', $colMoveShadow, 'jquery');
		
					$colMoveLineEx = QBOX.$(heDiv.cloneNode()).addClass(css.COLMOVELINE).css({
						'display'	: 'none',
						'height'	: objLayoutSize.colheader.offsetHeight + objLayoutSize.viewport.offsetHeight + objLayoutSize.footer.offsetHeight
					}).appendTo(this.attr('elementpool').get('container'));
		
					this.attr('colmoveline', $colMoveLineEx, 'jquery');					
				}
			}
		}
		
		this.attr('dragging', true, 'boolean');
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL.onDrag', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype.onDrop = function(event){
	if(this.attr('colmove') === false && this.attr('colresize') === false){
		this._selectDragArea(event);
	}
	
	this.attr('dragging', false, 'boolean');
	this._updateIdx('drag', -1, -1);
	
	this.attr('startdragpos',null,'object');
	
	if(this.attr('hdhandle') !== null){
		//console.log('clearInterval 3');
		clearInterval(this.attr('hdhandle'));
		this.attr('hdhandle', null, 'number');
		this.attr('hdcount', 0, 'number');
	}
	
	if(this.attr('vdhandle') !== null){
		//console.log('clearInterval 3');
		clearInterval(this.attr('vdhandle'));
		this.attr('vdhandle', null, 'number');
		this.attr('vdcount', 0, 'number');
	}
};

QBOX.QCELL.BasicQCELL.prototype._clickCell = function(nRow, nCol){
	//웹표준을 벗어나는 문제가 있지만, 고객의 요청이 많아 셀을 클릭한 것과 동일한 효과를 내는 기능을 지원
	//사용자가 바인딩한 이벤트들도 호출되지만, 실제 이벤트가 발생했을 때의 event parameter와 _clickCell() 수행 시의 event parameter를 동일하게 맞춰주기는 힘들다.  
	var target = this._getCellDOM(nRow, nCol);
	
	if(QBOX._.isElement(target) && QBOX.util.hasClass(target, QBOX.QCELL.def.css.CELL)){
		var event = {
			'target'	: target,
			'ctrlKey'	: false,
			'altKey'	: false,
			'shiftKey'	: false,
			'which'		: QBOX.def.which.LEFT_BUTTON
		},
		$defaultEventTarget = this._getEventTarget('default');
		
		target.focus();
		
		this._updateIdx('cursor', nRow, nCol);//cursor 인덱스를 갱신
		
		this.onMouseDown(QBOX._.extend(jQuery.Event('mousedown'), event));
		
		if($defaultEventTarget !== null)
			$defaultEventTarget.trigger(QBOX._.extend(jQuery.Event(this._getUserEventName('mousedown')), event));
		
		this.onMouseUp(QBOX._.extend(jQuery.Event('mouseup'), event));
		if($defaultEventTarget !== null)
			$defaultEventTarget.trigger(QBOX._.extend(jQuery.Event(this._getUserEventName('mouseup')), event));
		
		this.onClick(QBOX._.extend(jQuery.Event('click'), event));
		if($defaultEventTarget !== null)
			$defaultEventTarget.trigger(QBOX._.extend(jQuery.Event(this._getUserEventName('click')), event));
		
		return true;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._dblClickCell = function(nRow, nCol){
	//웹표준을 벗어나는 문제가 있지만, 고객의 요청이 많아 셀을 더블클릭한 것과 동일한 효과를 내는 기능을 지원
	//사용자가 바인딩한 이벤트들도 호출되지만, 실제 이벤트가 발생했을 때의 event parameter와 _dblClickCell() 수행 시의 event parameter를 동일하게 맞춰주기는 힘들다.
	var target = this._getCellDOM(nRow, nCol);
	
	if(QBOX._.isElement(target) && QBOX.util.hasClass(target, QBOX.QCELL.def.css.CELL)){
		var event = {
			'target'	: target,
			'ctrlKey'	: false,
			'altKey'	: false,
			'shiftKey'	: false,
			'which'		: QBOX.def.which.LEFT_BUTTON
		},
		$defaultEventTarget = this._getEventTarget('default');
		
		target.focus();
		
		this._updateIdx('cursor', nRow, nCol);//cursor 인덱스를 갱신
		
		for(var i = 0; i < 2; i++){
			this.onMouseDown(QBOX._.extend(jQuery.Event('mousedown'), event));
			if($defaultEventTarget !== null)
				$defaultEventTarget.trigger(QBOX._.extend(jQuery.Event(this._getUserEventName('mousedown')), event));
			
			this.onMouseUp(QBOX._.extend(jQuery.Event('mouseup'), event));
			if($defaultEventTarget !== null)
				$defaultEventTarget.trigger(QBOX._.extend(jQuery.Event(this._getUserEventName('mouseup')), event));
			
			this.onClick(QBOX._.extend(jQuery.Event('click'), event));
			if($defaultEventTarget !== null)
				$defaultEventTarget.trigger(QBOX._.extend(jQuery.Event(this._getUserEventName('click')), event));
		}
		
		this.onDblClick(QBOX._.extend(jQuery.Event('dblclick'), event));
		if($defaultEventTarget !== null)
			$defaultEventTarget.trigger(QBOX._.extend(jQuery.Event(this._getUserEventName('dblclick')), event));
		
		return true;
	}
	
	return false;
};
QBOX.QCELL.BasicQCELL.prototype._setInputformData = function(nRow){
	var objRowData = this._getRowData(nRow), strID = this.attr('id'),
	nHeaderCols = this.attr('headercols'),nCols = this.attr('cols'),i,strInputId;
	if(objRowData === null)
		return;
	
	if(this.attr('jqDialog') === null)
		return;
	this.attr('isInputForm',true,'boolean');	
	this.attr('jqDialog').dialog('open');

	for(i=nHeaderCols; i< nCols;i++){
		var strKey = this._getKeyOfCol(i), heElement;
		strInputId = strID+'_'+strKey+'_'+this.getColID(i);
		heElement = document.getElementById(strInputId);
		
		if(this._getColType(i) === 'image'){
			heElement.setAttribute('src', objRowData[strKey]);
		}else if(this._getColType(i) === 'checkbox')
			heElement.checked = objRowData[strKey];
		else if(this._getColType(i) === 'datepicker'){
			var strFormat = QBOX.moment(objRowData[strKey], 'YYYYMMDD').format('YYYY-MM-DD');
			if(strFormat !== 'Invalid date')
				heElement.value = strFormat;
		}
			
		else{
			QBOX.$(heElement).val(objRowData[strKey]);
		}
		
		
		
	}
	this.attr('inputformdatarow',nRow,'number');
	this.attr('inputformdata',objRowData,'object');
};
QBOX.QCELL.BasicQCELL.prototype.onTab = function(event, target){
	if(QBOX.$(target).hasClass('rt-qc-cell') || 
			QBOX.$(target).hasClass('rt-qc-cell-rowheader-checkbox')|| 
			QBOX.$(target).hasClass('rt-qc-cell-rowheader-radio')|| 
			QBOX.$(target).hasClass('rt-qc-colheader-checkbox')|| 
			QBOX.$(target).hasClass('rt-qc-datepicker-type') ){
			var currentElement = QBOX.$(target).hasClass('rt-qc-datepicker-type') ? target.parentElement : target;
			var nRow = parseInt(currentElement.getAttribute('data-row')),
			nCol = parseInt(currentElement.getAttribute('data-col'));

			if(!isNaN(nRow) && !isNaN(nCol)){
				this.clickCell(nRow,nCol);
			}											
		}
	
};
QBOX.QCELL.BasicQCELL.prototype.onLongTab = function(event, target){
	if(QBOX.$(target).hasClass('rt-qc-cell') || 
			QBOX.$(target).hasClass('rt-qc-cell-rowheader-checkbox')|| 
			QBOX.$(target).hasClass('rt-qc-colheader-checkbox')|| 
			QBOX.$(target).hasClass('rt-qc-cell-rowheader-radio')|| 
			QBOX.$(target).hasClass('rt-qc-datepicker-type') ){
			var currentElement = QBOX.$(target).hasClass('rt-qc-datepicker-type') ? target.parentElement : target;
			var nRow = parseInt(currentElement.getAttribute('data-row')),
			nCol = parseInt(currentElement.getAttribute('data-col'));

			if(!isNaN(nRow) && !isNaN(nCol)){
				this._setInputformData(nRow);
			}											
		}
	
};
QBOX.QCELL.BasicQCELL.prototype.onSwipe = function(event, direction, distance, duration, fingerCount, fingerData){
	try{
		if(event.type === "touchend" || event.type ==="touchmove"){
			var objQCell = this;
			var d = 0,nAccumulated = 0;
			switch(direction){
				case "up" :
				case "down" :

						var objVSInfo = this.attr('vsinfo');
						
						if(objVSInfo.bVScroll){
							// 스크롤이 존재할 때만 영역밖의 Mouse Wheel event 방지
							event.stopPropagation();
							event.preventDefault();
							
							setTimeout(function(){
								//스크롤바가 처음이나 끝인 경우 더이상 이동 할 필요가 없다.
								if((direction === "up" && objVSInfo.nPos < objVSInfo.nLastPos) || (direction === "down" && objVSInfo.nPos > 0)){
									d = direction === "down" ? 1 : -1;
									nAccumulated = Math.floor((distance/3) / objVSInfo.nLengthPerRow) *d;
									
									//nAccumulatedWheel값만큼 스크롤바 이동 시 스크롤바 이동범위를 벗어나는 경우가 발생 할 수 있으니 보정한다. 
									if(objVSInfo.nPos - nAccumulated > objVSInfo.nLastPos){
										nAccumulated = objVSInfo.nPos - objVSInfo.nLastPos;
									} else if(objVSInfo.nPos - nAccumulated < 0){
										nAccumulated = objVSInfo.nPos;
									}
									
									objQCell.attr('elementpool').get('$jqvscrollbar').rt_qc_mCSbar('scrollTo', objVSInfo.nTop + (nAccumulated * objVSInfo.nLengthPerRow), '', {ignorecallback:true});
									objQCell.attr('accumTouch', nAccumulated, 'number');											
									QBOX.util.rAF(function(){
										var nAccumulated = objQCell.attr('accumTouch');
										if(nAccumulated !== 0){
											objVSInfo.nBeforeTop = objVSInfo.nTop;
											objVSInfo.nTop += nAccumulated * objVSInfo.nLengthPerRow;//세로스크롤바가 nLengthPerRow값 단위로 딱딱 맞아떨어지게 이동하면 좋겠지만 그렇지 않기 때문에 nScrollTop값으로 설정하면 안되고, 이동한 행 수 만큼 nLengthPerRow값을 곱한 값을 더 해 줘야 한다.
											objVSInfo.nPos = -(objVSInfo.nTop / objVSInfo.nLengthPerRow);
											objQCell._syncVSInfo();
											objQCell._updateNRs();
											objQCell.attr('accumTouch', 0, 'number');
										}
									});
								}
							},0);
							
							
						}

					break;
				case "left" :
				case "right" :
					var objHSInfo = this.attr('hsinfo');
					if(objHSInfo.bHScroll){
						event.stopPropagation();
						event.preventDefault();
						
						setTimeout(function(){
							if((direction === "right" && objHSInfo.nLeft !== 0) || (direction === "left" && Math.abs(objHSInfo.nLeft) < Math.abs(objHSInfo.nLength))){	
								d = direction === "right" ? 1 : -1;
								nAccumulated = (Math.floor(distance / objHSInfo.nLengthPerCol) === 0 ? 1 : Math.floor(distance / objHSInfo.nLengthPerCol)) *d * objHSInfo.nLengthPerCol;
								var nLeft = objHSInfo.nLeft;
								
								if( direction === "left" && Math.abs(nLeft +  nAccumulated)> Math.abs(objHSInfo.nLength)){
									nLeft = -(objHSInfo.nLength);
								}else if( direction === "right" && (nLeft +  nAccumulated)> 0){
									nLeft = 0;
								}else{
									nLeft += nAccumulated;
								}						
								objQCell.attr('elementpool').get('$jqhscrollbar').rt_qc_mCSbar('scrollTo', nLeft);
							}
						},0);
						
						
					}
					break;
			}
			

		}else{
			event.stopPropagation();
			event.preventDefault();
		}
	//	event.stopPropagation();						
	//	event.preventDefault();
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL.onSwipe', e.message);
	}
};	

QBOX.QCELL.BasicQCELL.prototype.onResize = function(event){
	try{
		if(this.attr('percentwidth') || this.attr('percentheight')){//QCELL의 크기가 %로 설정된 경우에만
			clearTimeout(this.attr('timeoutid'));//반복 호출 방지
			
			var objQCell = this;
			
			this.attr('timeoutid', setTimeout(function(){
				//console.log('onResize');
				if(objQCell.attr('isInputForm')=== true)
					return;
				
				objQCell.attr('isResizing' , true , 'boolean');
				
				var objHSInfo = objQCell.attr('hsinfo'),
				objVSInfo = objQCell.attr('vsinfo'),
				nLeftCol,
				nTopRow,		
				nFocusRow = objQCell._idx('row', 'focus', 'current'),
				nFocusCol = objQCell._idx('col', 'focus', 'current');
				
				//1. 스크롤바 위치 백업
				nLeftCol = objHSInfo.nLeftCol;
				nTopRow = objVSInfo.nTopRow;
				
				//2. 스크롤바 정보 초기화
				objQCell._initHSInfo();						//가로스크롤바 정보 초기화
				objQCell._initVSInfo();						//세로스크롤바 정보 초기화
				
				//3. DOM 재생성
				if(objQCell._createElement()){
					//4. 전체 화면 갱신(동적 변경사항 반영)
					objQCell._refresh();
					
					//5. 스크롤바 위치 복원
					if(nLeftCol !== objHSInfo.nLeftCol){
						objQCell._scrollLeft(nLeftCol);
					}
					if(nTopRow !== objVSInfo.nTopRow){
						objQCell._scrollTop(nTopRow);
					}
					
					objQCell._updateIdx('focus', -1,-1);
					objQCell._focusCell(nFocusRow,nFocusCol);
				}
			}, 0), 'number');
		}
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL.onResize', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype._initCellMatrix = function(){
	try{
		var htCellMatrix = this.attr('cellmatrix'), arrRowCellMatrix, arrColCellMatrix;
		
		if(htCellMatrix.containsKey('row')){
			arrRowCellMatrix = htCellMatrix.get('row');
			arrRowCellMatrix.RT_clear();
		} else{
			htCellMatrix.put('row', []);
		}
		
		if(htCellMatrix.containsKey('col')){
			arrColCellMatrix = htCellMatrix.get('col');
			arrColCellMatrix.RT_clear();
		} else{
			htCellMatrix.put('col', []);
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._initCellMatrix', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._syncCellMatrix = function(strSource){
	var htCellMatrix = this.attr('cellmatrix');
	
	if(strSource === 'col'){
		htCellMatrix.put('row', QBOX._.unzip(htCellMatrix.get('col')));
	} else{
		htCellMatrix.put('col', QBOX._.unzip(htCellMatrix.get('row')));
	}
};

QBOX.QCELL.BasicQCELL.prototype._getCellDOM = function(nRow, nCol){
	var arrRowCellDOMs = this._getRowCellDOMs(nRow);
	
	if(arrRowCellDOMs !== undefined && arrRowCellDOMs.length > 0){
		if(nCol >= 0 && nCol < this.attr('cols')){
			var nHeaderCols = this.attr('headercols'),
			nFrozenCols = this.attr('frozencols');
			
			if(nCol < nHeaderCols + nFrozenCols){
				return arrRowCellDOMs[nCol];
			} else{
				var objHSInfo = this.attr('hsinfo');
				if(nCol >= objHSInfo.nLeftCol && nCol <= objHSInfo.nRightCol){
					return arrRowCellDOMs[nHeaderCols + nFrozenCols + nCol - objHSInfo.nLeftCol];
				}
			}
		}
	}
	
	return null;
};

QBOX.QCELL.BasicQCELL.prototype._getRowCellDOMs = function(nRow){
	var objVSInfo = this.attr('vsinfo'),
	nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'), nRows = this.attr('rows'),
	bPanel = this._isPanel();
	
	if(bPanel === true && objVSInfo.bVScroll === false && nRow > objVSInfo.nEndRow){
		return this._getCellGroupDOMs('row', 'frozenbottom')[nRow - objVSInfo.nEndRow - 1];
	}
	
	if(nRow >= 0 && nRow < nRows){
		if(nRow < nHeaderRows){
			return this._getCellGroupDOMs('row', 'header')[nRow];
		} else if(nRow < nHeaderRows + nFrozenRows){//frozenrows
			return this._getCellGroupDOMs('row', 'frozen')[nRow - nHeaderRows];
		} else if(nRow < nRows - nFrozenBottomRows){//normalrows
			if(nRow >= objVSInfo.nTopRow && nRow <= objVSInfo.nBottomRow){
				return this._getCellGroupDOMs('row', 'normal')[nRow - objVSInfo.nTopRow];
			}
		} else{//frozenbottomrows
			return this._getCellGroupDOMs('row', 'frozenbottom')[nRow - objVSInfo.nEndRow - 1];
		}
	}
	
	return [];
};

QBOX.QCELL.BasicQCELL.prototype._getColCellDOMs = function(nCol){
	var objHSInfo = this.attr('hsinfo'),
	nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'), nCols = this.attr('cols');
	
	if(nCol >= 0 && nCol < nCols){
		if(nCol < nHeaderCols){
			return this._getCellGroupDOMs('col', 'header')[nCol];
		} else if(nCol < nHeaderCols + nFrozenCols){//frozencols
			return this._getCellGroupDOMs('col', 'frozen')[nCol - nHeaderCols];
		} else{//normalcols
			if(nCol >= objHSInfo.nLeftCol && nCol <= objHSInfo.nRightCol){
				return this._getCellGroupDOMs('col', 'normal')[nCol - objHSInfo.nLeftCol];
			}
		}
	}
	
	return [];
};

QBOX.QCELL.BasicQCELL.prototype._getCellGroupDOMs = function(axis, group){
	var htCellMatrix = this.attr('cellmatrix'),
	arrCellGroupDOMs = [],
	nStartIdx, nDeleteCount;
	
	if(axis === 'row'){
		var arrRowCellMatrix = htCellMatrix.get('row'),
		nHeaderRows = this.attr('headerrows'),
		nFrozenRows = this.attr('frozenrows'),
		nFrozenBottomRows = this.attr('frozenbottomrows'),
		nFooterRows = this.attr('footerrows');
		
		switch(group){
			case 'header':		{
				nStartIdx = 0;
				nDeleteCount = nHeaderRows;
				break;
			}
			case 'frozen':		{
				nStartIdx = nHeaderRows;
				nDeleteCount = nFrozenRows;
				break;
			}
			case 'normal':		{
				nStartIdx = nHeaderRows + nFrozenRows;
				nDeleteCount = arrRowCellMatrix.length - nHeaderRows - nFrozenRows - nFrozenBottomRows - nFooterRows;
				break;
			}
			case 'frozenbottom':{
				nStartIdx = arrRowCellMatrix.length - nFrozenBottomRows - nFooterRows;
				nDeleteCount = nFrozenBottomRows;
				break;
			}
			case 'footer':		{
				nStartIdx = arrRowCellMatrix.length - nFooterRows;
				nDeleteCount = nFooterRows;
				break;
			}
			default:			{
				break;
			}
		}
		
		arrCellGroupDOMs = arrRowCellMatrix.splice(nStartIdx, nDeleteCount);
		arrRowCellMatrix.RT_insertArray(nStartIdx, arrCellGroupDOMs);
		
	} else if(axis === 'col'){
		var arrColCellMatrix = htCellMatrix.get('col'),
		nHeaderCols = this.attr('headercols'),
		nFrozenCols = this.attr('frozencols');
		
		switch(group){
			case 'header':	{
				nStartIdx = 0;
				nDeleteCount = nHeaderCols;
				break;
			}
			case 'frozen':	{
				nStartIdx = nHeaderCols;
				nDeleteCount = nFrozenCols;
				break;
			}
			case 'normal':	{
				nStartIdx = nHeaderCols + nFrozenCols;
				nDeleteCount = arrColCellMatrix.length - nHeaderCols - nFrozenCols;
				break;
			}
			default:		{
				break;
			}
		}
		
		arrCellGroupDOMs = arrColCellMatrix.splice(nStartIdx, nDeleteCount);
		arrColCellMatrix.RT_insertArray(nStartIdx, arrCellGroupDOMs);
	}
	
	return arrCellGroupDOMs;
};

QBOX.QCELL.BasicQCELL.prototype._setCellGroupDOMs = function(axis, group, arrDOMs){
	var htCellMatrix = this.attr('cellmatrix'),
	arrCellGroupDOMs = null,
	nStartIdx, nDeleteCount;
	
	if(axis === 'row'){
		var arrRowCellMatrix = htCellMatrix.get('row'),
		nHeaderRows = this.attr('headerrows'),
		nFrozenRows = this.attr('frozenrows'),
		nFrozenBottomRows = this.attr('frozenbottomrows'),
		nFooterRows = this.attr('footerrows');
		
		switch(group){
			case 'header':		{
				nStartIdx = 0;
				nDeleteCount = nHeaderRows;
				break;
			}
			case 'frozen':		{
				nStartIdx = nHeaderRows;
				nDeleteCount = nFrozenRows;
				break;
			}
			case 'normal':		{
				nStartIdx = nHeaderRows + nFrozenRows;
				nDeleteCount = arrRowCellMatrix.length - nHeaderRows - nFrozenRows - nFrozenBottomRows - nFooterRows;
				break;
			}
			case 'frozenbottom':{
				nStartIdx = arrRowCellMatrix.length - nFrozenBottomRows - nFooterRows;
				nDeleteCount = nFrozenBottomRows;
				break;
			}
			case 'footer':		{
				nStartIdx = arrRowCellMatrix.length - nFooterRows;
				nDeleteCount = nFooterRows;
				break;
			}
			default:			{
				break;
			}
		}
		
		arrRowCellMatrix.splice(nStartIdx, nDeleteCount);
		arrRowCellMatrix.RT_insertArray(nStartIdx, arrDOMs);
		
	} else if(axis === 'col'){
		var arrColCellMatrix = htCellMatrix.get('col'),
		nHeaderCols = this.attr('headercols'),
		nFrozenCols = this.attr('frozencols');
		
		switch(group){
			case 'header':	{
				nStartIdx = 0;
				nDeleteCount = nHeaderCols;
				break;
			}
			case 'frozen':	{
				nStartIdx = nHeaderCols;
				nDeleteCount = nFrozenCols;
				break;
			}
			case 'normal':	{
				nStartIdx = nHeaderCols + nFrozenCols;
				nDeleteCount = arrColCellMatrix.length - nHeaderCols - nFrozenCols;
				break;
			}
			default:		{
				break;
			}
		}
		
		arrColCellMatrix.splice(nStartIdx, nDeleteCount);
		arrColCellMatrix.RT_insertArray(nStartIdx, arrDOMs);
	}
	
	return true;
};
QBOX.QCELL.BasicQCELL.prototype._isPanel = function(){
	return this.attr('frozenbottomstyle') === 'panel' ? true : false;
};
QBOX.QCELL.BasicQCELL.prototype._setCellGroupCSS = function(axis, group){
	var css = QBOX.QCELL.def.css,
	arrCellDOMs = this._getCellGroupDOMs(axis, group),
	arrAddClassNames = [], arrRemoveClassNames = [],
	bPanel = this._isPanel();
	
	if(axis === 'row'){
		switch(group){
			case 'header':		{
				arrRemoveClassNames = [css.CELL_FROZENROWS, css.CELL_NORMALROWS, css.CELL_FROZENBOTTOMROWS,css.CELL_FROZENBOTTOMROWS_PANEL, css.CELL_FOOTERROWS];
				arrAddClassNames.push(css.CELL_HEADERROWS);
				break;
			}
			case 'frozen':		{
				arrRemoveClassNames = [css.CELL_HEADERROWS, css.CELL_NORMALROWS, css.CELL_FROZENBOTTOMROWS,css.CELL_FROZENBOTTOMROWS_PANEL, css.CELL_FOOTERROWS];
				arrAddClassNames.push(css.CELL_FROZENROWS);
				break;
			}
			case 'normal':		{
				arrRemoveClassNames = [css.CELL_HEADERROWS, css.CELL_FROZENROWS, css.CELL_FROZENBOTTOMROWS,css.CELL_FROZENBOTTOMROWS_PANEL, css.CELL_FOOTERROWS];
				arrAddClassNames.push(css.CELL_NORMALROWS);
				break;
			}
			case 'frozenbottom':{
				arrRemoveClassNames = [css.CELL_HEADERROWS, css.CELL_FROZENROWS, css.CELL_NORMALROWS, css.CELL_FOOTERROWS];
				arrAddClassNames.push(css.CELL_FROZENBOTTOMROWS);
				if(bPanel === true)
					arrAddClassNames.push(css.CELL_FROZENBOTTOMROWS_PANEL);
				else
					arrAddClassNames.push(css.CELL_FROZENBOTTOMROWS);
				break;
			}
			case 'footer':		{
				arrRemoveClassNames = [css.CELL_HEADERROWS, css.CELL_FROZENROWS, css.CELL_NORMALROWS, css.CELL_FROZENBOTTOMROWS,css.CELL_FROZENBOTTOMROWS_PANEL];
				arrAddClassNames.push(css.CELL_FOOTERROWS);
				break;
			}
			default:			{
				break;
			}
		}
	} else if(axis === 'col'){
		switch(group){
			case 'header':		{
				arrRemoveClassNames = [css.CELL_FROZENCOLS, css.CELL_NORMALCOLS];
				arrAddClassNames.push(css.CELL_HEADERCOLS);
				break;
			}
			case 'frozen':		{
				arrRemoveClassNames = [css.CELL_HEADERCOLS, css.CELL_NORMALCOLS];
				arrAddClassNames.push(css.CELL_FROZENCOLS);
				break;
			}
			case 'normal':		{
				arrRemoveClassNames = [css.CELL_HEADERCOLS, css.CELL_FROZENCOLS];
				arrAddClassNames.push(css.CELL_NORMALCOLS);
				break;
			}
			default:			{
				break;
			}
		}
	}
	
	if(arrCellDOMs.length > 0){
		var arrTargetCellDOMs = QBOX._.flatten(arrCellDOMs);
		
		if(arrRemoveClassNames.length > 0){
			QBOX.util.removeClass(arrTargetCellDOMs, arrRemoveClassNames);
		}
		
		if(arrAddClassNames.length > 0){
			QBOX.util.addClass(arrTargetCellDOMs, arrAddClassNames);
		}
		
		return true;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._addDynamicRows = function(nCount){
	var objVSInfo = this.attr('vsinfo'),
	arrRowCellMatrix = this.attr('cellmatrix').get('row'),
	nHeaderRows = this.attr('headerrows'), nFooterRows = this.attr('footerrows');
	
	if(nCount > 0){
		var css = QBOX.QCELL.def.css,
		objHSInfo = this.attr('hsinfo'),
		heDiv = document.createElement('div'),
		heRowHeaderInner = this.attr('elementpool').get('rowheaderinner'),
		heViewPortInner = this.attr('elementpool').get('viewportinner'),
		heCell,
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nDynamicCols = objHSInfo.nDynamicCols,
		nAdjustHeight = arrRowCellMatrix.length - nFooterRows === nHeaderRows ? 0 : this._getSumOfRowHeight(nHeaderRows, arrRowCellMatrix.length - nFooterRows - 1),//top값 설정을 위해 현재 생성되어 있는 dynamicRows의 height 합을 계산
		j;
		
		for(var i = 0; i < nCount; i++){
			//동적 행(DynamicRow)추가 후 반드시 화면갱신을 해야되므로 화면갱신 시 변경되는 nRow값과 셀 데이터는 세팅 해 주지 않아도 된다.
			var nColWidth,
			nRow = (objVSInfo.nEndRow === -1) ? nHeaderRows + i : ((objVSInfo.nBottomRow === -1) ? nHeaderRows + i : /*objVSInfo.nEndRow*/objVSInfo.nBottomRow + i + 1),
			nRowHeight = this._getRowHeight(nRow),
			nCellTop = nAdjustHeight,
			nBeforeCellWidth = 0,bTab;
			
			arrRowCellMatrix.RT_insert(arrRowCellMatrix.length - nFooterRows, []);
			
			for(j = 0; j < nHeaderCols; j++){
				nColWidth = this._getColWidth(j);
								
				heCell = this._createCell(heDiv);
				heCell.style.width = nColWidth + 'px';
				heCell.style.height = nRowHeight + 'px';
				if(this._getColWordwrap(j)){
					heCell.style.whiteSpace = 'pre-wrap';
				}else{
					heCell.style.lineHeight = (nRowHeight - 2) + 'px';
				}
 
				heCell.style.left = nBeforeCellWidth + 'px';
				heCell.style.top = nCellTop + 'px';
				heCell.className += ' ' + css.CELL_ROWHEADER + ' ' + css.CELL_HEADERCOLS;
				heCell.setAttribute('data-col', j);
				
				heRowHeaderInner.appendChild(heCell);
				
				arrRowCellMatrix[arrRowCellMatrix.length - nFooterRows - 1].push(heCell);
				
				nBeforeCellWidth += parseFloat(nColWidth);
			}
			
			for(j = 0; j < nDynamicCols; j++){
				var nCol = j < nFrozenCols ? (nHeaderCols + j) : (objHSInfo.nLeftCol - nFrozenCols + j);
				
				nColWidth = this._getColWidth(nCol);
				bTab = this._getColTabindex(nCol);
				heCell = this._createCell(heDiv,bTab);
				heCell.style.width = nColWidth + 'px';
				heCell.style.height = nRowHeight + 'px';
				if(this._getColWordwrap(nCol)){
					heCell.style.whiteSpace = 'pre-wrap';
				}else{
					heCell.style.lineHeight = (nRowHeight - 2) + 'px';
				}
				heCell.style.left = arrRowCellMatrix[arrRowCellMatrix.length - nFooterRows - 2][arrRowCellMatrix[arrRowCellMatrix.length - nFooterRows - 1].length].style.left;//추가하는 행 위의 행의 같은 열 인텍스의 셀 left와 동일하게 설정 
				heCell.style.top = nCellTop + 'px';
				heCell.setAttribute('data-col', nCol);
				heCell.className += ' ' + css.CELL_VIEWPORT + ' ' + (j < nFrozenCols ? css.CELL_FROZENCOLS : css.CELL_NORMALCOLS) + ' ' + this._getColStyleClassName(nCol, 'data');
				
				var colStyle = this._getColStyle(nCol, 'data');
				if(!QBOX._.isEmpty(colStyle) && !QBOX._.isUndefined(colStyle) && !QBOX._.isNull(colStyle)){// style data로 추가한 사항 적용
					QBOX.$(heCell).css(colStyle);
				}
				
				heViewPortInner.appendChild(heCell);
				
				arrRowCellMatrix[arrRowCellMatrix.length - nFooterRows - 1].push(heCell);
			}
			
			nAdjustHeight += nRowHeight;
		}
		
		this._syncCellMatrix('row');				//row의 cellMatrix 기준으로 col의 cellMatrix 동기화
		
		return true;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._removeDynamicRows = function(nCount){
	var arrRowCellMatrix = this.attr('cellmatrix').get('row');
	
	if(nCount > 0){
		var arrRemovedRowsCellDOMs = arrRowCellMatrix.splice(arrRowCellMatrix.length - this.attr('footerrows') - nCount, nCount);
		
		QBOX.$(QBOX._.flatten(arrRemovedRowsCellDOMs)).remove();
		
		this._syncCellMatrix('row');				//row의 cellMatrix 기준으로 col의 cellMatrix 동기화
		
		return true;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._addDynamicCols = function(nCount){
	var objHSInfo = this.attr('hsinfo'),
	arrColCellMatrix = this.attr('cellmatrix').get('col'),
	nHeaderCols = this.attr('headercols'),
	bPanel =this._isPanel();
	
	if(nCount > 0){
		var css = QBOX.QCELL.def.css,
		objVSInfo = this.attr('vsinfo'),
		heDiv = document.createElement('div'),
		heColHeaderInner = this.attr('elementpool').get('colheaderinner'),
		heViewPortInner = this.attr('elementpool').get('viewportinner'),
		heCell,
		nHighlightRepeat = this.attr('highlightrepeat'),
		nRows = this.attr('rows'), nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'),
		nDynamicRows = objVSInfo.nDynamicRows,
		nAdjustWidth = arrColCellMatrix.length === nHeaderCols ? 0 : this._getSumOfColWidth(nHeaderCols, arrColCellMatrix.length - 1),//left값 설정을 위해 현재 생성되어 있는 dynamicCols의 width 합을 계산
		i;
		
		for(var j = 0; j < nCount; j++){
			//동적 열(DynamicCol)추가 후 반드시 화면갱신을 해야되므로 화면갱신 시 변경되는 nCol값과 셀 데이터는 세팅 해 주지 않아도 된다.
			var nRowHeight,
			nCol = (objHSInfo.nEndCol === -1) ? nHeaderCols + j : (/*objHSInfo.nEndCol*/objHSInfo.nRightCol + j + 1),
			nColWidth = this._getColWidth(nCol),
			nCellLeft = nAdjustWidth,
			nBeforeCellHeight = 0,bTab;
			
			if(objHSInfo.nEndCol === objHSInfo.nRightCol)
				nCol = objHSInfo.nRightCol;
			
			if(nCol > objHSInfo.nEndCol)
				break;
			
			arrColCellMatrix.push([]);
			
			for(i = 0; i < nHeaderRows; i++){
				nRowHeight = this._getRowHeight(i);
				bTab = this._getColTabindex(nCol);
				heCell = this._createCell(heDiv,bTab);
				heCell.style.width = nColWidth + 'px';
				heCell.style.height = nRowHeight + 'px';

				if(this._getColWordwrap(nCol)){
					heCell.style.whiteSpace = 'pre-wrap';
				}else{
					heCell.style.lineHeight = (nRowHeight - 2) + 'px';
				}

				heCell.style.left = nCellLeft + 'px';
				heCell.style.top = nBeforeCellHeight + 'px';
				heCell.className += ' ' + css.CELL_COLHEADER + ' ' + css.CELL_HEADERROWS;//colStyleClassName은 화면갱신 시 박히기 때문에 추가 할 필요가 없다.
				heCell.setAttribute('data-row', i);
				
				heColHeaderInner.appendChild(heCell);
				
				arrColCellMatrix[arrColCellMatrix.length - 1].push(heCell);
				
				nBeforeCellHeight += parseFloat(nRowHeight);
			}
			
			for(i = 0; i < nDynamicRows; i++){
				var nRow = i < nFrozenRows ? (nHeaderRows + i) : (i >= nDynamicRows - nFrozenBottomRows ? (nRows - nDynamicRows + i) : (objVSInfo.nTopRow - nFrozenRows + i));
				
				nRowHeight = this._getRowHeight(i);
				bTab = this._getColTabindex(nCol);
				
				heCell = this._createCell(heDiv,bTab);
				heCell.style.width = nColWidth + 'px';
				heCell.style.height = nRowHeight + 'px';

				if(this._getColWordwrap(nCol)){
					heCell.style.whiteSpace = 'pre-wrap';
				}else{
					heCell.style.lineHeight = (nRowHeight - 2) + 'px';
				}

				heCell.style.left = nCellLeft + 'px';
				heCell.style.top = arrColCellMatrix[arrColCellMatrix.length - 2][arrColCellMatrix[arrColCellMatrix.length - 1].length].style.top;//추가하는 열 이전 열의 같은 행 인텍스의 셀 top와 동일하게 설정
				heCell.setAttribute('data-row', nRow);
				heCell.className += ' ' + css.CELL_VIEWPORT;//colStyleClassName은 화면갱신 시 박히기 때문에 추가 할 필요가 없다.
				
				if(i < nFrozenRows){
					heCell.className += ' ' + css.CELL_FROZENROWS;
				} else if(i >= nDynamicRows - nFrozenBottomRows){
					if(bPanel === true)
						heCell.className += ' ' + css.CELL_FROZENBOTTOMROWS_PANEL;
					else
						heCell.className += ' ' + css.CELL_FROZENBOTTOMROWS;
				} else{
					heCell.className += ' ' + css.CELL_NORMALROWS;
				}
				
				if(nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0)){
					heCell.className += ' ' + css.CELL_HIGHLIGHTREPEAT;
				}
					
				heViewPortInner.appendChild(heCell);
				
				arrColCellMatrix[arrColCellMatrix.length - 1].push(heCell);
			}
			
			nAdjustWidth += nColWidth;
		}
		
		this._syncCellMatrix('col');				//col의 cellMatrix 기준으로 row의 cellMatrix 동기화
		
		return true;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._removeDynamicCols = function(nCount){
	var arrColCellMatrix = this.attr('cellmatrix').get('col');
	
	if(nCount > 0){
		var arrRemovedColsCellDOMs = arrColCellMatrix.splice(arrColCellMatrix.length - nCount, nCount);
		
		QBOX.$(QBOX._.flatten(arrRemovedColsCellDOMs)).remove();
		
		this._syncCellMatrix('col');				//col의 cellMatrix 기준으로 row의 cellMatrix 동기화
		
		return true;
	}
	
	return false;
};
/*
QBOX.QCELL.BasicQCELL.prototype._makeRowUI = function(nCount,bKeep){
	try{
		var objVSInfo = this.attr('vsinfo'),
		nHeaderRows = this.attr('headerrows'),bPanel = this._isPanel();
		
		//1. 데이터 추가 전 세로스크롤바 표시 여부 확인
		if(objVSInfo.bVScroll === false){
			if(bPanel){
				var THAT= this;
				setTimeout(function(){
					THAT.rebuild(true);	
				});
				
				return true;
			}
				
				
			var objHSInfo = this.attr('hsinfo'),
			bHScroll = objHSInfo.bHScroll;
			
			//1-1. 데이터 추가 후 스크롤바의 생성여부 확인
			this._initLayoutSize();
			
			//1-2. DynamicRows 계산
			this._calculateDynamicRows();
			
			//1-3. 데이터 추가 후 세로스크롤바 표시 여부 확인
			if(objVSInfo.bVScroll){
				var arrRowCellMatrix = this.attr('cellmatrix').get('row'),
				nFooterRows = this.attr('footerrows');
				
				//1-3-1. 동적 행(DynamicRows) 추가 
				if(arrRowCellMatrix.length - nHeaderRows - nFooterRows + nCount > objVSInfo.nDynamicRows){
					//동적 행(DynamicRow)은 추가할 수 만큼 추가되지 않고, 전체 동적 행의 수가 objVSInfo.nDynamicRows값과 같을 때까지만 추가된다.
					this._addDynamicRows(objVSInfo.nDynamicRows - (arrRowCellMatrix.length - nHeaderRows - nFooterRows));
				} else{
					this._addDynamicRows(nCount);
				}
				
				//1-3-2. 스크롤바 존재 여부에 따른 틀고정 행 기능 사용 가능 여부 보정
				this._adjustFrozenRowsCount();//_setVSRange() 재수행
				
				//1-3-3. "row" 단위 셀 그룹 업데이트
				if(this.attr('frozenrows') > 0 || this.attr('frozenbottomrows') > 0){
					//1-3-3-1. "row" 단위 셀 그룹 CSS 클래스 갱신 -> headerRows, frozenRows, normalRows, frozenBottomRows
					this._setCellGroupCSS('row', 'frozen');
					this._setCellGroupCSS('row', 'frozenbottom');
					
					//1-3-3-2. frozenBottomRows에 해당하는 셀들의 TOP값 보정
					//frozenRows의 Top값은 움직이지 않기 때문에 보정 할 필요가 없다.
					this._adjustFrozenBottomRowsTop();
				}
				this._setCellGroupCSS('row', 'normal');
				
				//1-3-4. 가로스크롤바 길이 갱신
				this._resizeHScrollbar();
				
				//1-3-5. hsinfo 정보 갱신(nLeftCol, nRightCol, nAdjustedLeft 설정)
				this._updateHSInfo();
				
				//1-3-6. 데이터 추가 후 가로스크롤바 표시 여부 확인
				if(bHScroll && objHSInfo.bHScroll && objHSInfo.nPos === objHSInfo.nLastPos){//가로스크롤바가 원래 있었고, 가로스크롤바가 마지막까지 움직인 상태에서 세로스크롤바가 생겼을 때
					var nScrollBarWidth = this.attr('scrollbarwidth');
					
					QBOX._.each(QBOX._.flatten(this._getCellGroupDOMs('col', 'normal')), function(heCell){
						heCell.style.left = (parseFloat(heCell.style.left) - nScrollBarWidth) + 'px';//세로스크롤바의 width만큼 nomalCols 셀들의 left값을 보정한다.
						//console.log(heCell);
					});
				}
			} else{
				//1-3-1. 동적 행(DynamicRows) 추가 
				this._addDynamicRows(nCount);
			}
		}
		
		this._resizeVScrollbar(bKeep);	//세로스크롤바 길이 갱신
		this._updateVSInfo();		//vsinfo 정보 갱신(nTopRow, nBottomRow 설정)
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._makeRowUI', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._removeRowUI = function(nCount,bKeep){
	try{
		var objVSInfo = this.attr('vsinfo'),
		arrCurrentData = this.attr('currentdata'),bPanel = this._isPanel();
		var THAT= this;
		//1. 데이터 삭제 전 세로스크롤바 표시 여부 확인
		if(objVSInfo.bVScroll){
			if(bPanel){
				
				setTimeout(function(){
					THAT.rebuild(true);	
				});
				
				return true;
			}
			var nDynamicRows = objVSInfo.nDynamicRows,
			objHSInfo = this.attr('hsinfo'),
			bHScroll = objHSInfo.bHScroll;
			
			//1-1. 데이터 추가 후 스크롤바의 생성여부 확인
			this._initLayoutSize();
			
			//1-2. DynamicRows 계산
			this._calculateDynamicRows();
			
			//1-3. 데이터 삭제 후 세로스크롤바 표시 여부 확인
			if(objVSInfo.bVScroll === false){
				//1-3-1. 동적 행(DynamicRows) 제거 
				if(arrCurrentData.length < nDynamicRows){
					//동적 행(DynamicRow)은 삭제할 수 만큼 삭제되지 않고, 삭제한 후의 전체 데이터의 수가 삭제 전의 nDynamicRows보다 작은 경우에만 그 차이만큼 동적 행(DynamicRow)을 삭제한다.
					this._removeDynamicRows(nDynamicRows - arrCurrentData.length);
				}
				
				//1-3-2. 스크롤바 존재 여부에 따른 틀고정 행 기능 사용 가능 여부 보정
				this._adjustFrozenRowsCount();
				
				//1-3-3. "row" 단위 셀 그룹 업데이트
				//스크롤바가 없는 경우 frozenRows, frozenBottomRows는 없다.
				this._setCellGroupCSS('row', 'normal');
				
				//1-3-4. normalRows에 해당하는 셀들의 TOP값 보정
				//frozenRows의 Top값은 움직이지 않기 때문에 보정 할 필요가 없다.
				this._adjustNormalRowsTop();
				
				//1-3-5. 데이터 삭제 후 가로스크롤바 표시 여부 확인
				if(objHSInfo.nPos === objHSInfo.nLastPos){//가로스크롤바가 끝까지 이동한 상태에서 행 삭제 후세로스크롤바가 사라진 경우
					var nScrollBarWidth = this.attr('scrollbarwidth');
					
					QBOX._.each(QBOX._.flatten(this._getCellGroupDOMs('col', 'normal')), function(heCell){
						heCell.style.left = (parseFloat(heCell.style.left) + nScrollBarWidth) + 'px';//세로스크롤바의 width만큼 nomalCols 셀들의 left값을 보정한다.
					});
				}
				
				//1-3-6. 가로스크롤바 길이 갱신
				this._resizeHScrollbar();
				
				//1-3-7. hsinfo 정보 갱신(nLeftCol, nRightCol, nAdjustedLeft 설정)
				this._updateHSInfo();
			}
		} else{//데이터 삭제 전에 세로스크롤바가 없던 경우
			this._removeDynamicRows(nCount);
			
			if(bPanel){
				setTimeout(function(){
					THAT.rebuild(true);	
				});
				
				return true;
			}
		}
		
		this._resizeVScrollbar(bKeep);	//세로스크롤바 길이 갱신
		this._updateVSInfo();		//vsinfo 정보 갱신(nTopRow, nBottomRow 설정)
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._removeRowUI', e.message);
		return false;
	}
};
*/
QBOX.QCELL.BasicQCELL.prototype._makeRowUI = function(nCount,bKeep){
	try{
		var objVSInfo = this.attr('vsinfo'),
		nHeaderRows = this.attr('headerrows'),bPanel = this._isPanel(),
		objGroupState = this.attr('groupstate').grouped === true ? this.attr('groupstate') : this.attr('treestate');
		objGroupState = this.attr('hierachystate').grouped === true ? this.attr('hierachystate'):objGroupState; 
		//1. 데이터 추가 전 세로스크롤바 표시 여부 확인
		if(objVSInfo.bVScroll === false/* || this.attr('usetreeall')*/){
			if(objGroupState && objGroupState.grouped !== true && bPanel){
				var THAT= this;
				if(this.attr('isSorting') !== true){
					setTimeout(function(){
						THAT.rebuild(true);	
					});		
					
				}
				return true;
			}	
				
			var objHSInfo = this.attr('hsinfo'),
			bHScroll = objHSInfo.bHScroll;
			
			//1-1. 데이터 추가 후 스크롤바의 생성여부 확인
			this._initLayoutSize();
			
			//1-2. DynamicRows 계산
			this._calculateDynamicRows();
			
			//1-3. 데이터 추가 후 세로스크롤바 표시 여부 확인
			if(objVSInfo.bVScroll){
				var arrRowCellMatrix = this.attr('cellmatrix').get('row'),
				nFooterRows = this.attr('footerrows');
				
				//1-3-1. 동적 행(DynamicRows) 추가 
				if(arrRowCellMatrix.length - nHeaderRows - nFooterRows + nCount > objVSInfo.nDynamicRows){
					//동적 행(DynamicRow)은 추가할 수 만큼 추가되지 않고, 전체 동적 행의 수가 objVSInfo.nDynamicRows값과 같을 때까지만 추가된다.
					this._addDynamicRows(objVSInfo.nDynamicRows - (arrRowCellMatrix.length - nHeaderRows - nFooterRows));
				} else{
					this._addDynamicRows(nCount);
				}
				
				//1-3-2. 스크롤바 존재 여부에 따른 틀고정 행 기능 사용 가능 여부 보정
				this._adjustFrozenRowsCount();//_setVSRange() 재수행
				
				//1-3-3. "row" 단위 셀 그룹 업데이트
				if(this.attr('frozenrows') > 0 || this.attr('frozenbottomrows') > 0){
					this._setCellGroupCSS('row', 'normal');
					this._adjustNormalRowsTop();
					//1-3-3-1. "row" 단위 셀 그룹 CSS 클래스 갱신 -> headerRows, frozenRows, normalRows, frozenBottomRows
					this._setCellGroupCSS('row', 'frozen');
					this._setCellGroupCSS('row', 'frozenbottom');
					
					//1-3-3-2. frozenBottomRows에 해당하는 셀들의 TOP값 보정
					//frozenRows의 Top값은 움직이지 않기 때문에 보정 할 필요가 없다.
					this._adjustFrozenBottomRowsTop();
				}
				this._setCellGroupCSS('row', 'normal');
				
				//1-3-4. 가로스크롤바 길이 갱신
				this._resizeHScrollbar();
				
				//1-3-5. hsinfo 정보 갱신(nLeftCol, nRightCol, nAdjustedLeft 설정)
				this._updateHSInfo();
				
				//1-3-6. 데이터 추가 후 가로스크롤바 표시 여부 확인
				if(bHScroll && objHSInfo.bHScroll && objHSInfo.nPos === objHSInfo.nLastPos){//가로스크롤바가 원래 있었고, 가로스크롤바가 마지막까지 움직인 상태에서 세로스크롤바가 생겼을 때
					var nScrollBarWidth = this.attr('scrollbarwidth');
					
					QBOX._.each(QBOX._.flatten(this._getCellGroupDOMs('col', 'normal')), function(heCell){
						heCell.style.left = (parseFloat(heCell.style.left) - nScrollBarWidth) + 'px';//세로스크롤바의 width만큼 nomalCols 셀들의 left값을 보정한다.
						//console.log(heCell);
					});
				}
			} else{
				//1-3-1. 동적 행(DynamicRows) 추가 
				this._addDynamicRows(nCount);
				
				//1-3-3. "row" 단위 셀 그룹 업데이트
				if(this.attr('frozenrows') > 0 || this.attr('frozenbottomrows') > 0){
					//1-3-3-1. "row" 단위 셀 그룹 CSS 클래스 갱신 -> headerRows, frozenRows, normalRows, frozenBottomRows
					this._setCellGroupCSS('row', 'normal');
					this._adjustNormalRowsTop();
					this._setCellGroupCSS('row', 'frozen');
					this._setCellGroupCSS('row', 'frozenbottom');
					
					//1-3-3-2. frozenBottomRows에 해당하는 셀들의 TOP값 보정
					//frozenRows의 Top값은 움직이지 않기 때문에 보정 할 필요가 없다.
					this._adjustFrozenBottomRowsTop();
				}				
			}
		}
		
		this._resizeVScrollbar(bKeep);	//세로스크롤바 길이 갱신
		this._updateVSInfo();		//vsinfo 정보 갱신(nTopRow, nBottomRow 설정)
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._makeRowUI', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._removeRowUI = function(nCount,bKeep){
	try{
		var objVSInfo = this.attr('vsinfo'),
		arrCurrentData = this.attr('currentdata'),bPanel = this._isPanel(),
		objGroupState = this.attr('groupstate').grouped === true ? this.attr('groupstate') : this.attr('treestate');
		objGroupState = this.attr('hierachystate').grouped === true ? this.attr('hierachystate'):objGroupState; 
		
		var THAT= this;
		//1. 데이터 삭제 전 세로스크롤바 표시 여부 확인
		if(objVSInfo.bVScroll){
			if(objGroupState && objGroupState.grouped !== true && bPanel){
				
				if(this.attr('isSorting') !== true){
					setTimeout(function(){
						THAT.rebuild(true);	
					});		


				}				
				return true;
			}
			var nDynamicRows = objVSInfo.nDynamicRows,
			objHSInfo = this.attr('hsinfo'),
			bHScroll = objHSInfo.bHScroll;
			
			//1-1. 데이터 추가 후 스크롤바의 생성여부 확인
			this._initLayoutSize();
			
			//1-2. DynamicRows 계산
			this._calculateDynamicRows();
			
			//1-3. 데이터 삭제 후 세로스크롤바 표시 여부 확인
			if(objVSInfo.bVScroll === false/*|| this.attr('usetreeall')*/){
				//1-3-1. 동적 행(DynamicRows) 제거 
				if(arrCurrentData.length < nDynamicRows){
					//동적 행(DynamicRow)은 삭제할 수 만큼 삭제되지 않고, 삭제한 후의 전체 데이터의 수가 삭제 전의 nDynamicRows보다 작은 경우에만 그 차이만큼 동적 행(DynamicRow)을 삭제한다.
					this._removeDynamicRows(nDynamicRows - arrCurrentData.length);
				}
				
				//1-3-2. 스크롤바 존재 여부에 따른 틀고정 행 기능 사용 가능 여부 보정
				this._adjustFrozenRowsCount();
				
				//1-3-3. "row" 단위 셀 그룹 업데이트
				//스크롤바가 없는 경우 frozenRows, frozenBottomRows는 없다.
				this._setCellGroupCSS('row', 'normal');
				
				//1-3-4. normalRows에 해당하는 셀들의 TOP값 보정
				//frozenRows의 Top값은 움직이지 않기 때문에 보정 할 필요가 없다.
				this._adjustNormalRowsTop();
				if(bPanel && (this.attr('frozenrows') > 0 || this.attr('frozenbottomrows') > 0)){
					//1-3-3-1. "row" 단위 셀 그룹 CSS 클래스 갱신 -> headerRows, frozenRows, normalRows, frozenBottomRows
					this._setCellGroupCSS('row', 'normal');
					this._adjustNormalRowsTop();
					this._setCellGroupCSS('row', 'frozen');
					this._setCellGroupCSS('row', 'frozenbottom');
					
					//1-3-3-2. frozenBottomRows에 해당하는 셀들의 TOP값 보정
					//frozenRows의 Top값은 움직이지 않기 때문에 보정 할 필요가 없다.
					this._adjustFrozenBottomRowsTop();
				}					
				
				//1-3-5. 데이터 삭제 후 가로스크롤바 표시 여부 확인
				if(/*this.attr('usetreeall') !== true &&*/objHSInfo.nPos === objHSInfo.nLastPos){//가로스크롤바가 끝까지 이동한 상태에서 행 삭제 후세로스크롤바가 사라진 경우
					var nScrollBarWidth = this.attr('scrollbarwidth');
					
					QBOX._.each(QBOX._.flatten(this._getCellGroupDOMs('col', 'normal')), function(heCell){
						heCell.style.left = (parseFloat(heCell.style.left) + nScrollBarWidth) + 'px';//세로스크롤바의 width만큼 nomalCols 셀들의 left값을 보정한다.
					});
				}
				
				//1-3-6. 가로스크롤바 길이 갱신
				this._resizeHScrollbar();
				
				//1-3-7. hsinfo 정보 갱신(nLeftCol, nRightCol, nAdjustedLeft 설정)
				this._updateHSInfo();
			}
		} else{//데이터 삭제 전에 세로스크롤바가 없던 경우
			this._removeDynamicRows(nCount);
			
			if(objGroupState && objGroupState.grouped !== true && bPanel){
				if(this.attr('isSorting') !== true){
					setTimeout(function(){
						THAT.rebuild(true);	
					});	
					
				}
				return true;
			}else{
				if(bPanel && (this.attr('frozenrows') > 0 || this.attr('frozenbottomrows') > 0)){
					//1-3-3-1. "row" 단위 셀 그룹 CSS 클래스 갱신 -> headerRows, frozenRows, normalRows, frozenBottomRows
					this._setCellGroupCSS('row', 'normal');
					this._adjustNormalRowsTop();
					this._setCellGroupCSS('row', 'frozen');
					this._setCellGroupCSS('row', 'frozenbottom');
					
					//1-3-3-2. frozenBottomRows에 해당하는 셀들의 TOP값 보정
					//frozenRows의 Top값은 움직이지 않기 때문에 보정 할 필요가 없다.
					this._adjustFrozenBottomRowsTop();
				}				
				
			}
		}
		
		this._resizeVScrollbar(bKeep);	//세로스크롤바 길이 갱신
		this._updateVSInfo();		//vsinfo 정보 갱신(nTopRow, nBottomRow 설정)
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._removeRowUI', e.message);
		return false;
	}
};
QBOX.QCELL.BasicQCELL.prototype._adjustFrozenRowsTop = function(){
	var nFrozenRows = this.attr('frozenrows');
	
	if(nFrozenRows > 0){
		var objQCell = this,
		arrFrozenRowsCellDOMs = this._getCellGroupDOMs('row', 'frozen'),
		nHeaderRows = this.attr('headerrows');
		
		QBOX._.each(arrFrozenBottomRowsCellDOMs, function(arrFrozenBottomRowCellDOMs, i){
			var nRow = nHeaderRows + i;
			QBOX._.each(arrFrozenBottomRowCellDOMs, function(heCell){
				heCell.style.top = (objQCell._getSumOfRowHeight(nHeaderRows, nRow - 1)) + 'px';
			});
		});
		
		return true;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._adjustFrozenBottomRowsTop = function(){
	var nFrozenBottomRows = this.attr('frozenbottomrows');
	
	if(nFrozenBottomRows > 0){
		var objQCell = this,
		arrFrozenBottomRowsCellDOMs = this._getCellGroupDOMs('row', 'frozenbottom'),
		nRows = this.attr('rows'),
		nViewPortClientHeight = this.attr('layoutsize').viewport.clientHeight;
		
		QBOX._.each(arrFrozenBottomRowsCellDOMs, function(arrFrozenBottomRowCellDOMs, i){
			var nRow = nRows - nFrozenBottomRows + i;
			QBOX._.each(arrFrozenBottomRowCellDOMs, function(heCell){
				heCell.style.top = (nViewPortClientHeight - objQCell._getSumOfRowHeight(nRow, nRows - 1)) + 'px';
			});
		});
		
		return true;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._adjustNormalRowsTop = function(){
	if(this.attr('currentdata').length > 0){
		var objQCell = this,
		arrNormalRowsCellDOMs = this._getCellGroupDOMs('row', 'normal'),
		nAdjustHeight = 0,
		nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'),
		nViewPortClientHeight = this.attr('layoutsize').viewport.clientHeight;
		
		QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, i){
			var nRow = nHeaderRows + nFrozenRows + i,
			nRowHeight = objQCell._getRowHeight(nRow),
			nCellTop = nAdjustHeight;
			
			QBOX._.each(arrNormalRowCellDOMs, function(heCell){
				heCell.style.top = nCellTop + 'px';
			});
			
			nAdjustHeight += nRowHeight;
		});
		
		return true;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._getQCellCol = function(nCol){
	return this.attr('qcellcols')[nCol];
};

QBOX.QCELL.BasicQCELL.prototype._getColDataMergeCol = function(nCol){
	if(this._getQCellCol(nCol) !== undefined && this._getQCellCol(nCol) !== null)
		return this._getQCellCol(nCol).attr('mergecol');
	
	return true;
};

QBOX.QCELL.BasicQCELL.prototype._getColDataType = function(nCol){
	return this._getQCellCol(nCol).attr('datatype');
};

QBOX.QCELL.BasicQCELL.prototype._setColDataTypeNumber = function(nCol){
	return this._getQCellCol(nCol).attr('datatype', 'number', 'string');
};

QBOX.QCELL.BasicQCELL.prototype._setColsDataType = function(data){
	if(QBOX._.isUndefined(data) === false && data.length > 0) {
		var obj = data[0], nData = [],
		nCols = this.attr('cols'),
		nHeaderCols = this.attr('headercols'),
		arrColsKeys = this.attr('colkeys');
		
		for(var i = nHeaderCols; i < nCols; i++){
			nData.push(obj[arrColsKeys[i]]);
		}
		
		for(var j = 0; j < nData.length; j++){
			if(typeof nData[j] == "number"){
				this._setColDataTypeNumber((j+nHeaderCols));
			}
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._getColFormat = function(nCol){
	return this._getQCellCol(nCol).attr('format');
};

QBOX.QCELL.BasicQCELL.prototype._getColOptions = function(nCol){
	return this._getQCellCol(nCol).attr('options');
};

QBOX.QCELL.BasicQCELL.prototype._getColWordwrap = function(nCol){
	return this._getQCellCol(nCol).attr('wordwrap');
};
QBOX.QCELL.BasicQCELL.prototype._showDisableText = function(heCell, nRow,nCol){
	var objCellDisabled = this._getQCellCol(nCol).attr('celldisabled')[nRow];
	if(objCellDisabled === true){
		var objRow = this.getRowData(nRow);
		var strDKey = this._getKeyOfCol(nCol);
		
		if(objRow['_rt_qc_d_' + strDKey] !== undefined){
			QBOX.util.textContent(heCell,objRow['_rt_qc_d_' + strDKey]);
			return true;
		}
						
	}		
	
	return false;
};
QBOX.QCELL.BasicQCELL.prototype._showDataFormat = function(nRow,nCol, cellData,useBeforeformat) {
	var strResult = '';
	try {
		if(this._getQCellCol(nCol).attr('celldisabled')[nRow] === true){
			var objRow = this.getRowData(nRow);
			var strDKey = this._getKeyOfCol(nCol);
			
			if(objRow['_rt_qc_d_' + strDKey] !== undefined)
				return objRow['_rt_qc_d_' + strDKey];
		}
		
		var objFormat = this._getColFormat(nCol);
		if(QBOX.$.trim(cellData) !== '' && !(QBOX._.isUndefined(cellData))){			
			if( !(QBOX._.isUndefined(objFormat)) && !(QBOX._.isNull(objFormat)) ) {
				var result = true, errormsg = "",bBF = false;
				if(useBeforeformat === undefined  && objFormat.beforeformat !== undefined && QBOX._.isFunction(objFormat.beforeformat)){
					
					cellData = objFormat.beforeformat(cellData,this.getRowData(nRow,nCol));
					bBF = true;
				}
				switch(objFormat.type) {
					case'string': {
						var tgtStr = "@";

						if(QBOX._.isString(cellData)){								
							
							var arrSplit = objFormat.rule.split(tgtStr);
							
							for(var x=0; x< arrSplit.length; x++){
								if(arrSplit[x] === '')
									continue;
								cellData = QBOX.util.replaceAll(cellData,arrSplit[x],'');
							}					
						}						
						
						strResult = objFormat.rule.replace(tgtStr, cellData);
						break;
					}
					case 'number': {
						var rule = {format:objFormat.rule, locale: objFormat.locale === undefined ? this.attr('locale') : objFormat.locale};
						strResult = QBOX.$.formatNumber(QBOX.util.replaceAll(cellData+"",',',''), rule);
						
						if ( strResult === '0' && isNaN(Number(cellData)) && objFormat.useinvaliddata === true){
							strResult = cellData;
						}else{
							if (QBOX._.isNumber(cellData+"")) {
								strResult = 0;
							} else if ( cellData === 0 || cellData === '0' || cellData === ''){
								strResult = QBOX.util.replaceAll(strResult,'.','');
								strResult = QBOX.util.replaceAll(strResult,'0','');
								strResult =  strResult + '0';
							}  
							if(objFormat.rule.indexOf('.') !== -1){
								if(strResult.indexOf('.') === 0 && objFormat.rule.indexOf('.') !== 0){
									strResult = '0' + strResult;
								}							
							}
						}
						
						
						break;
					}
					case 'date': {
						moment.locale(objFormat.locale === undefined ? this.attr('locale') === 'kr' ? 'ko' : this.attr('locale') : objFormat.locale);
						strResult = QBOX.moment(cellData, objFormat.origin).format(objFormat.rule);
						if(strResult === 'Invalid date')
							strResult = '';						
						break;
					}
					case 'custom': {
						strResult = objFormat.callback(String(cellData));
						break;
					}
					default: {
						strResult = cellData;
						break;
					}
				}
				
				if(useBeforeformat === undefined  && objFormat.afterformat !== undefined && QBOX._.isFunction(objFormat.afterformat)){
					strResult = objFormat.afterformat(strResult,this.getRowData(nRow,nCol));
				}
				
				if(bBF === true){
					var key = this._getKeyOfCol(nCol);
					if(key !== undefined && key !== null){
						var obj = this.attr('currentdata')[nRow - this.attr('headerrows')];
						
						if(obj !== undefined){
							var strKey = '_rt_qc_bf_' + key;
							obj[strKey] = strResult;
						}
					}
				}
				
				if( !result ) {
					QCELL.log('err', 'QCELL.BasicQCELL._showDataFormat', errormsg);
					strResult = cellData;
				}
			} else {
				strResult = cellData;
			}
		} else {
			if(!(QBOX._.isUndefined(objFormat)) && !(QBOX._.isNull(objFormat))){
				if(objFormat.type === 'custom' && objFormat.allowemptydata === true){
					return objFormat.callback(String(cellData));					 
				}				
			}
			strResult = cellData;
		}
		
		
	} catch (e) {
		QCELL.log('err', 'QCELL.BasicQCELL._showDataFormat', e.message);
		strResult = '';
	}
	
	
	
	return strResult;
};

QBOX.QCELL.BasicQCELL.prototype._getColFormatStatic = function(nCol){
	return this._getQCellCol(nCol).attr('formatstatic');
};

QBOX.QCELL.BasicQCELL.prototype._showDataFormatStatic = function(nCol, cellData) {
	var strResult = '';
	try {
		if(QBOX.$.trim(cellData) !== '' && !(QBOX._.isUndefined(cellData))){
			var objFormat = this._getColFormatStatic(nCol);
			if( !(QBOX._.isUndefined(objFormat)) && !(QBOX._.isNull(objFormat)) ) {
				var result = true, errormsg = "";
				switch(objFormat.type) {
					case'string': {
						var tgtStr = "@";
						strResult = objFormat.rule.replace(tgtStr, cellData);
						break;
					}
					case 'number': {
						var rule = {format:objFormat.rule, locale: objFormat.locale === undefined ? this.attr('locale') : objFormat.locale};
						strResult = QBOX.$.formatNumber(cellData+"", rule);
						if(parseInt(cellData+"") === 0){
							strResult = 0;
						}
						break;
					}
					case 'date': {
						moment.locale(objFormat.locale === undefined ? this.attr('locale') === 'kr' ? 'ko' : this.attr('locale') : objFormat.locale);
						strResult = QBOX.moment(cellData, objFormat.origin).format(objFormat.rule);
						break;
					}
					case 'custom': {
						strResult = objFormat.callback(String(cellData));
						break;
					}
					default: {
						strResult = cellData;
						break;
					}
				}
				
				if( !result ) {
					QCELL.log('err', 'QCELL.BasicQCELL._showDataFormatStatic', errormsg);
					strResult = cellData;
				}
			} else {
				strResult = cellData;
			}
		} else {
			strResult = cellData;
		}
	} catch (e) {
		QCELL.log('err', 'QCELL.BasicQCELL._showDataFormatStatic', e.message);
		strResult = '';
	}
	
	return strResult;
};

QBOX.QCELL.BasicQCELL.prototype._getColWidth = function(nCol){
	return this.attr('colwidthsperpixel')[nCol];
};

QBOX.QCELL.BasicQCELL.prototype._setColWidth = function(nCol, nColWidth){
	try{
		var arrColWidths = this.attr('colwidths'),
		arrColWidthsPerPixel = this.attr('colwidthsperpixel'),
		objHSInfo = this.attr('hsinfo'),
		nPrevHScroll = objHSInfo.bHScroll,
		nDynamicCols = objHSInfo.nDynamicCols,
		nHeaderCols = this.attr('headercols');
		
		if(nColWidth < 15){
			nColWidth = 15;
		} else{
			var nFrozenCols = this.attr('frozencols'),
			nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth,
			nAdjustWidth = 0;
			
			if(nCol < nHeaderCols + nFrozenCols){//frozenCols인 경우
				nAdjustWidth = this._getSumOfColWidth(nHeaderCols, nCol - 1);
			} else{
				nAdjustWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1);
			}
			
			if(nColWidth > nViewPortOffsetWidth - nAdjustWidth){
				nColWidth = nViewPortOffsetWidth - nAdjustWidth;
			}
		}
		
		//1. nCol 컬럼의 width정보 갱신
		arrColWidthsPerPixel[nCol] = nColWidth;
		
		for(var j = nHeaderCols, nCols = this.attr('cols'); j < nCols; j++){
			arrColWidths[j] = arrColWidthsPerPixel[j] + 'px';
		}
		
		//2. _setColWidth()가 호출되는 순간 컬럼의 width로 "%"를 사용하지 않는다고 판단한다.
		this.attr('percentcolwidth', false, 'boolean');
		
		this._initLayoutSize();
		
		//3. dynamicCols를 재계산한다. -> 현재 보이는 화면이 최악의 경우 일 수 있으므로 재계산하여 dynamiccols의 수를 조정한다.
		this._calculateDynamicCols();
		
		//4. dynamicCols 증가/감소에 따른 DOM 생성|제거
		if(nDynamicCols > objHSInfo.nDynamicCols){//nDynamicCols 수가 감소한 경우
			//console.log('nDynamicCols 수가 감소한 경우');
			this._removeDynamicCols(nDynamicCols - objHSInfo.nDynamicCols);
		} else if(nDynamicCols < objHSInfo.nDynamicCols){//nDynamicCols 수가 증가한 경우
			//console.log('nDynamicCols 수가 증가한 경우');
			this._addDynamicCols(objHSInfo.nDynamicCols - nDynamicCols);
		}
		
		//"col" 단위 셀 그룹 업데이트
		if(this.attr('frozencols') > 0){
			this._setCellGroupCSS('col', 'frozen');
		}
		this._setCellGroupCSS('col', 'normal');
		
		//5. 가로스크롤바 길이 갱신
		this._resizeHScrollbar();	//가로스크롤바 길이, nAdjustCols 갱신
		
		//6. hsinfo 정보 갱신(nLeftCol, nRightCol, nAdjustedLeft 설정)
		this._updateHSInfo();
		
		//7. Dynamic CSS 제거
		this._clearDynamicCSS('col', 'data');
		
		//8. 화면 갱신
		if(nPrevHScroll !== objHSInfo.bHScroll)
			this._createElement();
		this.refresh();
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._setColWidth', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._getKeyOfCol = function(nCol){
	return this.attr('colkeys')[nCol];
};

QBOX.QCELL.BasicQCELL.prototype._getKeyOfColID = function(strColID){
	var objColIDsInfo = this.attr('colidsinfo');
	
	if(QBOX._.has(objColIDsInfo, strColID)){
		return this._getKeyOfCol(objColIDsInfo[strColID]);
	}
	
	return -1;
};

QBOX.QCELL.BasicQCELL.prototype._getColsOfKey = function(key){
	var objColKeysInfo = this.attr('colkeysinfo');
	
	return objColKeysInfo.containsKey(key) ? objColKeysInfo.get(key).values() : [];
};

QBOX.QCELL.BasicQCELL.prototype._getColID = function(nCol){
	return this.attr('colids')[nCol];
};
//filter 위해 추가.
QBOX.QCELL.BasicQCELL.prototype._getColFilltered = function(nCol){
	return this._getQCellCol(nCol).attr('fillter_prev');
};
QBOX.QCELL.BasicQCELL.prototype._setColFilltered = function(nCol,objFilter){
	this._getQCellCol(nCol).attr('fillter_prev',objFilter,'object');
};

QBOX.QCELL.BasicQCELL.prototype._getColOfID = function(strColID){
	return this.attr('colidsinfo')[strColID];
};

QBOX.QCELL.BasicQCELL.prototype._moveCols = function(nBeforeCol, nCount, nAfterCol, /*컬럼의 move속성을 체크하지 않고 강제로 이동시키기 위한 옵션*/bForce){
	var objQCell = this,
	arrTargetCols = QBOX._.range(nBeforeCol, nBeforeCol + nCount),
	nCols = this.attr('cols'), 
	nHeaderCols = this.attr('headercols'),x;
	
	if(nBeforeCol !== nAfterCol && (nAfterCol < nBeforeCol || nAfterCol >= nBeforeCol + nCount) && QBOX._.every(arrTargetCols, function(nCol){
		return nCol >= nHeaderCols && nCol < nCols && (bForce ? true : objQCell._getQCellCol(nCol).attr('move'));
	})){
		var arrQCellCols = this.attr('qcellcols'),
		arrAfterCols,		//컬럼 이동 완료 후 이동된 컬럼들의 인덱스 번호 집합
		arrAfterCellDOMs,	//컬럼 이동 완료 후 animation 효과를 적용할 셀들의 집합
		htColKeysInfo = this.attr('colkeysinfo'),
		objHSInfo = this.attr('hsinfo'),
		nFrozenCols = this.attr('frozencols'),
		nDynamicCols = objHSInfo.nDynamicCols,arrTextAlign=[];
		
		var nSCol = nBeforeCol < nAfterCol? nBeforeCol : nAfterCol;
		var nEcol = nBeforeCol < nAfterCol? nAfterCol : nBeforeCol;
		for(x=nSCol ; x<= nEcol ; x++){
			this._removeColStyleClassName(x);
		}
		var arrColProps = [], 
			objColStyle = this._getQCellCol(nBeforeCol).attr('style'),
			nRows = this.attr('rows'),k,heCell,keys;
		
		if(!QBOX._.isEmpty(objColStyle)){
			if(QBOX._.isObject(objColStyle.header)){
				keys = Object.keys(objColStyle.header);
				for( k = 0; k < keys.length; k++){
					for(x = 0;  x < this.attr('headerrows'); x++){
						heCell = this._getCellDOM(x,nBeforeCol);				
						if(heCell !== null)					
							QBOX.$(heCell).css(keys[k], '');
					}
				}
			}			
			if(QBOX._.isObject(objColStyle.data)){
				keys = Object.keys(objColStyle.data);
				for(k = 0; k < keys.length; k++){
					for(x = this.attr('headerrows') ; x < nRows; x++){
						heCell = this._getCellDOM(x,nBeforeCol);				
						if(heCell !== null)					
							QBOX.$(heCell).css(keys[k], '');
					}
				}
			}			
		}
		
		if(this.attr('useRemoveUI') === true){

			var objCol = this.getProperties().columns[nBeforeCol - nHeaderCols];
			
			if(nBeforeCol > nAfterCol){
				this.getProperties().columns.splice(nBeforeCol - nHeaderCols,1);
				this.getProperties().columns.RT_insert(nAfterCol - nHeaderCols, objCol);
			}else{
				this.getProperties().columns.RT_insert(nAfterCol +1 - nHeaderCols, objCol);
				this.getProperties().columns.splice(nBeforeCol - nHeaderCols,1);
			}
			
			for(x=0;x<this.getProperties().columns.length ; x++){
				arrColProps.push( QBOX._.clone(this.getProperties().columns[x]));
			}
			
			
		}
		//2. 컬럼 관련 속성들을 동기화한다.
		QBOX._.each([arrQCellCols,
			this.attr('colsprops'),
			this.attr('colwidths'),
			this.attr('colwidthsperpixel'),
			this.attr('colkeys'),
			this.attr('colids'),
			this.attr('headertext')
		], function(arr){
			arr.RT_insertArray(nAfterCol - (nBeforeCol < nAfterCol ? (nCount - 1) : 0), arr.splice(nBeforeCol, nCount));
		});
		
		if(this.attr('useRemoveUI') === true){
			this.attr('colsprops', arrColProps, 'array');
			this.setPropertiesColumn(arrColProps);
		}
		
		htColKeysInfo.clear();
		QBOX._.each(this.attr('colkeys'), function(key, nCol){//colkeysinfo, 컬럼 이동/추가/삭제 시 동기화 필요
			if(htColKeysInfo.containsKey(key) === false){
				htColKeysInfo.put(key, new _QHashSet());
			}
			htColKeysInfo.get(key).add(nCol);
		});
		
		this.attr('colidsinfo', QBOX._.object(QBOX._.map(arrQCellCols, function(objQCellCol){return objQCellCol.attr('id');}), QBOX._.range(0, nCols)), 'object');//colidsinfo, 컬럼 이동/추가/삭제 시 동기화 필요
		
		//3. dynamicCols를 재계산한다. -> 현재 보이는 화면이 최악의 경우 일 수 있으므로 재계산하여 dynamiccols의 수를 조정한다.
		this._calculateDynamicCols();
		
		//4. dynamicCols 증가/감소에 따른 DOM 생성|제거
		if(nDynamicCols > objHSInfo.nDynamicCols){//nDynamicCols 수가 감소한 경우
			//console.log('nDynamicCols 수가 감소한 경우');
			this._removeDynamicCols(nDynamicCols - objHSInfo.nDynamicCols);
		} else if(nDynamicCols < objHSInfo.nDynamicCols){//nDynamicCols 수가 증가한 경우
			//console.log('nDynamicCols 수가 증가한 경우');
			this._addDynamicCols(objHSInfo.nDynamicCols - nDynamicCols);
		}
		//"col" 단위 셀 그룹 업데이트
		if(this.attr('frozencols') > 0){
			this._setCellGroupCSS('col', 'frozen');
		}
		this._setCellGroupCSS('col', 'normal');
		
		//5. 가로스크롤바 길이 갱신
		this._resizeHScrollbar();	//가로스크롤바 길이, nAdjustCols 갱신
		
		//6. hsinfo 정보 갱신(nLeftCol, nRightCol, nAdjustedLeft 설정)
		this._updateHSInfo();
		
		//7. Dynamic CSS 제거
		this._clearDynamicCSS('col', 'data');
		
		//8. syncinfo(col), idxinfo(style, colstate) 동기화
		var htSyncInfoOfCol = this._getSyncInfo('col'),
		arrColSyncInfos = this._popColSyncInfos(nBeforeCol, nCount);//이동된 컬럼들의 동기화 정보를 자료구조에서 지우고 백업 해 둔다.
		
		if(nBeforeCol < nAfterCol){//컬럼을 오른쪽으로 이동하는 경우
			/*
			ex> 3,4,5컬럼을 이동 전 화면 기준 인덱스 7 위치로 이동 시
			3은 5가 되고, 4는 6이 되고, 5는 7이 된다.
			인덱스 번호를 업데이트 해 줘야 하는 컬럼들(6-7)의 인덱스를 3씩 감소시킨다.
			*/
			//인덱스 번호를 업데이트 해 줘야 하는 컬럼들의 sync정보 동기화
			var arrPulledCols = QBOX._.range(nBeforeCol + nCount, nAfterCol + 1);
			//console.log('pull된 컬럼들 중에서 syncinfo가 있는 컬럼들:', QBOX._.filter(arrPulledCols, function(nCol){return htSyncInfoOfCol.containsKey(nCol);}));
			this._pullColSyncInfo(QBOX._.filter(arrPulledCols, function(nCol){return htSyncInfoOfCol.containsKey(nCol);}), nCount);
			
			//이동 전 백업했던 sync 정보들을 이용하여 이동한 컬럼들의 sync정보 동기화
			arrAfterCols = QBOX._.range(nAfterCol - (nCount - 1), nAfterCol + 1);
			this._putColSyncInfos(arrAfterCols, arrColSyncInfos);

		} else{//컬럼을 왼쪽으로 이동하는 경우
			/*
			ex> 3,4,5컬럼을 이동 전 화면 기준 인덱스 1 위치로 이동 시
			3은 1이 되고, 4는 2가 되고, 5는 3이 된다.
			인덱스 번호를 업데이트 해 줘야 하는 컬럼들(1-2)의 인덱스를 3씩 증가시킨다.
			*/
			//인덱스 번호를 업데이트 해 줘야 하는 컬럼들의 sync정보 동기화
			var arrPushedCols = QBOX._.range(nAfterCol, nBeforeCol).sort(QBOX.st.desc);
			//console.log('push된 컬럼들 중에서 syncinfo가 있는 컬럼들:', QBOX._.filter(arrPushedCols, function(nCol){return htSyncInfoOfCol.containsKey(nCol);}));
			this._pushColSyncInfo(QBOX._.filter(arrPushedCols, function(nCol){return htSyncInfoOfCol.containsKey(nCol);}), nCount);
			
			//이동 전 백업했던 sync 정보들을 이용하여 이동한 컬럼들의 sync정보 동기화
			arrAfterCols = QBOX._.range(nAfterCol, nAfterCol + nCount);
			this._putColSyncInfos(arrAfterCols, arrColSyncInfos);			
		}		

		
		//9. 화면 갱신
		this._refreshDCs();
		
		if(!bForce){
			//10. animation 효과
			QBOX._.each(arrAfterCols, function(nCol){
				arrAfterCellDOMs = QBOX._.union(arrAfterCellDOMs, QBOX._.flatten(objQCell._getColCellDOMs(nCol)));
			});
			
			QBOX.$(arrAfterCellDOMs).effect('bounce', {distance:'5', times:1});
		}
		
		this._resetAriaLabel();
		for(x=nSCol ; x<= nEcol ; x++){
			this._setRoleTitle(x);
		}
		
		
		setTimeout(function(){
			objQCell._trigger('aftermovecol' ,{'beforecol' : nBeforeCol, 'cound':nCount, 'aftercol': nAfterCol});
		});
		
		return true;
	}
	
	return false;
};

//QBOX.QCELL.BasicQCELL.prototype._moveCol = function(nBeforeCol, nAfterCol){
//	console.log("nBeforeCol:", nBeforeCol, ", nAfterCol:", nAfterCol);
//	if(this._getQCellCol(nBeforeCol).attr('move')){
//		if(nBeforeCol !== nAfterCol){
//			var nCols = this.attr('cols'), 
//			nHeaderCols = this.attr('headercols'),
//			nFrozenCols = this.attr('frozencols');
//			
//			if(nBeforeCol >= nHeaderCols && nAfterCol >= nHeaderCols && nBeforeCol < nCols && nAfterCol < nCols){
//				var arrQCellCols = this.attr('qcellcols'),
//				objQCell = this,
//				objColKeysInfo = this.attr('colkeysinfo'),
//				objHSInfo = this.attr('hsinfo'),
//				nDynamicCols = objHSInfo.nDynamicCols;
//				
//				//2. 컬럼 관련 속성들을 동기화한다.
//				QBOX._.each([arrQCellCols,
//				             this.attr('colsprops'),
//				             this.attr('colwidths'),
//				             this.attr('colwidthsperpixel'),
//				             this.attr('colkeys'),
//				             this.attr('colids'),
//				             this.attr('headertext')
//				             ], function(arr){
//					arr.splice(nAfterCol, 0, arr.splice(nBeforeCol, 1)[0]);
//				});
//				
//				_.each(this.attr('colkeys'), function(key, nCol){//colkeysinfo, 컬럼 이동/추가/삭제 시 동기화 필요
//					if(objColKeysInfo.containsKey(key) === false){
//						objColKeysInfo.put(key, new HashSet());
//					}
//					objColKeysInfo.get(key).add(nCol);
//				});
//				
//				this.attr('colidsinfo', _.object(_.map(arrQCellCols, function(objQCellCol){return objQCellCol.attr('id');}), _.range(0, nCols)), 'object');//colidsinfo, 컬럼 이동/추가/삭제 시 동기화 필요
//				
//				//3. dynamiccols를 재계산한다. -> 현재 보이는 화면이 최악의 경우 일 수 있으므로 재계산하여 dynamiccols의 수를 조정한다.
//				this._calculateDynamicCols();
//				
//				//4. dynamicCols 증가/감소 처리
//				if(nDynamicCols > objHSInfo.nDynamicCols){//nDynamicCols 수가 감소한 경우
//					//console.log('nDynamicCols 수가 감소한 경우');
//					this._removeDynamicCols(nDynamicCols - objHSInfo.nDynamicCols);
//				} else if(nDynamicCols < objHSInfo.nDynamicCols){//nDynamicCols 수가 증가한 경우
//					//console.log('nDynamicCols 수가 증가한 경우');
//					this._addDynamicCols(objHSInfo.nDynamicCols - nDynamicCols);
//				}
//				
//				//5. "col" 단위 셀 그룹 업데이트
//				if(this.attr('frozencols') > 0){
//					this._setCellGroupCSS('col', 'frozen');
//				}
//				this._setCellGroupCSS('col', 'normal');
//				
//				//6. 가로스크롤바 길이 갱신
//				this._resizeHScrollbar();	//가로스크롤바 길이, nAdjustCols 갱신
//				
//				//7. hsinfo 정보 갱신(nLeftCol, nRightCol, nAdjustedLeft 설정)
//				this._updateHSInfo();
//				
//				//8. Dynamic CSS 제거
//				this._clearDynamicCSS('col', 'data');
//				
//				//9. syncinfo(col), idxinfo(style, colstate) 동기화
//				//컬럼이 이동된 위치 기준 오른쪽 컬럼들은 변동사항이 없다.
//				//이동된 컬럼의 기존 열 인덱스 위치보다 오른쪽에 있으면서 이동된 열 인덱스 위치보다 왼쪽에 있는 컬럼들은 열 인덱스가 1씩 감소한다.
//				
//				//10. 삽입한 열 인덱스의 state 정보 업데이트
//				
//				//11. 화면 갱신
//				this._refreshDCs();
//				
//				return true;
//			}
//		}
//	}
//	
//	return false;
//};

QBOX.QCELL.BasicQCELL.prototype._setFormatStatic = function(nCol, formatstatic){
	//var strDataFormatStatic = this._showDataFormatStatic(nCol, cellData),
	bool = true;
	try{
		if(formatstatic.type !== undefined && QBOX._.isString(formatstatic.type) === false) {
			datatype = 'string';
			QBOX.QCELL.log('err', 'QCELL.create', 'Please check "formatstatic.type'+ '"\'s type is "' + datatype + '".');
			bool = false;
		} else {
			switch(formatstatic.type) {
				case 'date': {
					if( formatstatic.origin === undefined && QBOX._.isString(formatstatic.origin) === false ) {
						datatype = 'string';
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "formatstatic.origin'+ '"\'s type is "' + datatype + '".');
						bool = false;
					} else if( formatstatic.rule === undefined && QBOX._.isString(formatstatic.rule) === false ) {
						datatype = 'string';
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "formatstatic.rule'+ '"\'s type is "' + datatype + '".');
						bool = false;
					}
					break;
				} 
				case 'number': {
					if( formatstatic.rule === undefined && QBOX._.isString(formatstatic.rule) === false ) {
						datatype = 'string';
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "formatstatic.rule'+ '"\'s type is "' + datatype + '".');
						bool = false;
					}
					break;
				}
				case 'string': {
					if( formatstatic.rule === undefined && QBOX._.isString(formatstatic.rule) === false ) {
						datatype = 'string';
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "formatstatic.rule'+ '"\'s type is "' + datatype + '".');
						bool = false;
					}
					break;
				}
				case 'custom': {
					if( formatstatic.callback === undefined && QBOX._.isFunction(formatstatic.origin) === false ) {
						datatype = 'callback';
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "formatstatic.origin'+ '"\'s type is "' + datatype + '".');
						bool = false;
					}
					break;
				}
				default: {
					break;
				}
			}
		}
		
		if(bool){
			this._getQCellCol(nCol).attr('formatstatic', formatstatic, 'object');
			this._refreshDCs();
		}
		
		bool = true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._setCellLabel', e.message);
		bool = false;
	}
	return bool;
};

QBOX.QCELL.BasicQCELL.prototype._getColExportDataType = function(nCol){
	try{
		return this._getQCellCol(nCol).attr('exportdatatype');	
	}catch (e){
		return '';
	}
	
};
QBOX.QCELL.BasicQCELL.prototype._getHeaderTextAlign = function(nCol){
	return this._getQCellCol(nCol).attr('header_text_algin');
};
QBOX.QCELL.BasicQCELL.prototype._getDataTextAlign = function(nCol){
	return (this._getQCellCol(nCol).attr('data_text_algin') === undefined || this._getQCellCol(nCol).attr('data_text_algin') === null) ? 'left': this._getQCellCol(nCol).attr('data_text_algin');
};
QBOX.QCELL.BasicQCELL.prototype._useDataTextAlign = function(nCol){
	return this._getQCellCol(nCol).attr('usedatatextalign') ;
};
QBOX.QCELL.BasicQCELL.prototype._getColPrevProperty = function(nCol){
	if(this._getQCellCol(nCol) !== undefined && this._getQCellCol(nCol) !== null)
		return this._getQCellCol(nCol).attr('prev_param');
	
	return true;
};
QBOX.QCELL.BasicQCELL.prototype._getColTabindex = function(nCol){
	return this._getQCellCol(nCol).attr('tabindex') ;
};

// contextmenu가 존재할 경우 삭제
QBOX.QCELL.BasicQCELL.prototype._removeContextMenu = function(){
	if(QBOX._.isNull(this.attr('contextmneuui')) === false){
		if(this.attr('contextmneuui') === undefined)
			return;
		// event 제거
		this.attr('contextmneuui').off('mousemove');
		this.attr('contextmneuui').off('mouseleave');
		
		this.attr('contextmneuui').remove();
		this.attr('contextmneuui', null, 'jquery');
		this.attr('contextmenuid', '', 'string');
	}
};

// contextmenu 초기화
QBOX.QCELL.BasicQCELL.prototype._initContextMenu = function(){
	var strAPI = this.attr('id') + '._setContextMenu';
	try {
		this._removeContextMenu();
		
		this.attr('contextmenu', {}, 'object');
		this.attr('contextmenuheader', {}, 'object');
		this.attr('contextmenudata', {}, 'object');
		this.attr('contextmenudisable', [], 'array');
		this.attr('contextmenuheaderdisable', [], 'array');
		this.attr('contextmenudatadisable', [], 'array');
		
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._setContextMenu = function(obj){
	var strAPI = this.attr('id') + '._setContextMenu';
	try {
		this.attr('contextmenu', obj, 'object');
		this.attr('contextmenuheader', obj.header, 'object');
		this.attr('contextmenudata', obj.data, 'object');
		
		this.attr('prevcontextmenu', QBOX._.clone(obj), 'object');
		this._createContextMenu();
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};

// contextmenu 생성

QBOX.QCELL.BasicQCELL.prototype._createContextMenu = function(event){
	var objQCell = this,
	containerClientX = this.attr('layoutsize').container.clientX,
	containerClientY = this.attr('layoutsize').container.clientY,
	colheaderHeight = this.attr('layoutsize').colheader.offsetHeight,
	colheaderLeft = this.attr('layoutsize').colheader.offsetLeft,
	rowheaderWidth = this.attr('layoutsize').rowheader.offsetWidth,
	layoutRoot = this.attr('layoutsize').root,
	rootWidth = layoutRoot.offsetWidth + containerClientX,
	rootHeight = layoutRoot.offsetHeight + containerClientY,
	css = QBOX.QCELL.def.css,
	contextmenuheader = this.attr('contextmenuheader'),
	contextmenudata = this.attr('contextmenudata'),
	strId = this.getID();
	//console.log('_createContextMenu ' + strId);
	// 마우스 우클릭
	QBOX.$(document).bind('contextmenu', function(event){
		
		objQCell = QCELL.getInstance(strId);
		//console.log('contextmenu ' + strId);
		// colheader와 rowheader영역 외에서 동작, rootHeight와 rootWidth영역 내에서 동작
		if(event.pageY > colheaderHeight + containerClientY && event.pageY < rootHeight && event.pageX > colheaderLeft + containerClientX && event.pageX < rootWidth){
			if(QBOX._.isNull(contextmenudata) || QBOX._.isUndefined(contextmenudata)){
				//console.log('contextmenu data null');
				return true;
			} 
			else {
				if(event.target.className.indexOf(css.CONTEXTMENU) > -1){ // contextmenu 영역 안에서 마우스 우클릭시 미작동 처리
				//	console.log('contextmenu data is exist');
					event.preventDefault();
				}
				else{ // contextmenu 가 아닌 영역에서 마우스 우클릭시 contextmenu 생성
				//	console.log('contextmenu data is create');
					objQCell._removeContextMenu();
					event.preventDefault();
					
					if(QBOX._.isNull(objQCell.attr('contextmneuui'))){  // ui가 null이면 ui구조 생성
						objQCell.attr('contextmneuui', objQCell._createContextMenuLayout(document.createElement('ul'), event), 'jquery');
					}
					objQCell._calculateContextMenuPosition(event, objQCell.attr('contextmneuui')); // 출력할 위치 계산
					objQCell.attr('contextmneuui').appendTo(objQCell.attr('parent')); // ui를 부모영역에 추가
					
					objQCell.attr('contextmneuui').on('mousemove', function(e){ // contextmenu 내부에서 마우스 이동시 현재 커서가 위치한 menu의 id저장
						var target = e.target,
						menu = target.parentNode;
						
						if(QBOX.util.hasClass(menu, css.CONTEXTMENU_MENU) || QBOX.util.hasClass(menu, css.CONTEXTMENU_SUB_MENU)){ // event가 일어난 영역의 class가 menu나 sub_menu일 때
							objQCell.attr('contextmenuid', QBOX.$(menu).attr('id'), 'string');
						}
						else { // i tag나 img tag 
							menu = menu.parentNode; // 2depth 고려
							if(QBOX.util.hasClass(menu, css.CONTEXTMENU_MENU) || QBOX.util.hasClass(menu, css.CONTEXTMENU_SUB_MENU)){
								objQCell.attr('contextmenuid', QBOX.$(menu).attr('id'), 'string');
							}
						}
					});
					
					objQCell.attr('contextmneuui').on('mouseleave', function(e){ // contextmenu에서 mouse leave시 contextmenu id 제거
						objQCell.attr('contextmenuid', '', 'string');
					});
				}
			}
		}
		// header영역에서 contextmenu 생성
		// colheaderLeft + --- edge헤더 영역
		//else if(event.pageY > containerClientY && event.pageY < (colheaderHeight + containerClientY) && event.pageX > colheaderLeft + containerClientX && event.pageX < rootWidth){
		else if(event.pageY > containerClientY && event.pageY < (colheaderHeight + containerClientY) && event.pageX > containerClientX && event.pageX < rootWidth){
			if(QBOX._.isNull(contextmenuheader) || QBOX._.isUndefined(contextmenuheader)){
				//console.log('contextmenu header is null');
				return true;
			} else {
				if(event.target.className.indexOf(css.CONTEXTMENU) > -1){ // contextmenu 영역 안에서 마우스 우클릭시 미작동 처리 
				//	console.log('contextmenu header is exist');
					event.preventDefault();
				}
				else{ // contextmenu 가 아닌 영역에서 마우스 우클릭시 contextmenu 생성
				//	console.log('contextmenu header is create');
					objQCell._removeContextMenu();
					event.preventDefault();
					
					if(QBOX._.isNull(objQCell.attr('contextmneuui'))){  // ui가 null이면 ui구조 생성
						var heUl = document.createElement('ul'),
						heCUl = heUl.cloneNode();
						heCUl.id = contextmenuheader.id;
						heCUl.className += css.CONTEXTMENU_AREA + ' ' + css.CONTEXTMENU_ROOT;
						
						objQCell.attr('contextmneuui', QBOX.$(objQCell._createContextMenuContents(heCUl, contextmenuheader.contents, 1, contextmenuheader.id + "-")), 'jquery');
					}
					objQCell._calculateContextMenuPosition(event, objQCell.attr('contextmneuui')); // 출력할 위치 계산
					objQCell.attr('contextmneuui').appendTo(objQCell.attr('parent')); // ui를 부모영역에 추가
					
					objQCell.attr('contextmneuui').on('mousemove', function(e){ // contextmenu 내부에서 마우스 이동시 현재 커서가 위치한 menu의 id저장
						var target = e.target,
						menu = target.parentNode;
						
						if(QBOX.util.hasClass(menu, css.CONTEXTMENU_MENU) || QBOX.util.hasClass(menu, css.CONTEXTMENU_SUB_MENU)){ // event가 일어난 영역의 class가 menu나 sub_menu일 때
							objQCell.attr('contextmenuid', QBOX.$(menu).attr('id'), 'string');
						}
						else { // i tag나 img tag 
							menu = menu.parentNode; // 2depth 고려
							if(QBOX.util.hasClass(menu, css.CONTEXTMENU_MENU) || QBOX.util.hasClass(menu, css.CONTEXTMENU_SUB_MENU)){
								objQCell.attr('contextmenuid', QBOX.$(menu).attr('id'), 'string');
							}
						}
					});
					
					objQCell.attr('contextmneuui').on('mouseleave', function(e){ // contextmenu에서 mouse leave시 contextmenu id 제거
						objQCell.attr('contextmenuid', '', 'string');
					});
				}
			}
		}
		else{
			//console.log('contextmenu terminate');
			return true;
		}
	});
};

/*
//contextmenu의 left, top 위치 조정
QBOX.QCELL.BasicQCELL.prototype._calculateContextMenuPosition = function(event, $heUl){
	if($heUl === undefined )
		return;
	
	var css = QBOX.QCELL.def.css, 
	containerClientX = this.attr('layoutsize').container.clientX,
	containerClientY = this.attr('layoutsize').container.clientY,
	rootOffHeight = this.attr('layoutsize').root.offsetHeight + containerClientY,
	rootOffWidth = this.attr('layoutsize').root.offsetWidth + containerClientX,
	ulHeight = QBOX.$('.'+css.CONTEXTMENU_ROOT).height() + this.attr('layoutsize').hscrollbar.offsetHeight,
	ulWidth = QBOX.$('.'+css.CONTEXTMENU_ROOT).width() + this.attr('layoutsize').vscrollbar.offsetWidth,
	nTop = parseInt(event.pageY),
	nLeft = parseInt(event.pageX),
	top, left;
	
	// left값
	if(rootOffWidth < nLeft + ulWidth){
		left = rootOffWidth - ulWidth + 'px';
	}
	else {
		left = nLeft + 'px';
	}
	
	// top값
	if(rootOffHeight < nTop + ulHeight){
		top = rootOffHeight - ulHeight + 'px';
	}
	else {
		top = (nTop - containerClientY) + 'px';
		//top = (nTop) + 'px';
	}
	
	//console.log('_calculateContextMenuPosition');
	//console.log($heUl);

	
};
*/	
//contextmenu의 left, top 위치 조정
QBOX.QCELL.BasicQCELL.prototype._calculateContextMenuPosition = function(event, $heUl){
	if($heUl === undefined )
		return;
	
	var css = QBOX.QCELL.def.css, 
	containerClientX = this.attr('layoutsize').container.clientX,
	containerClientY = this.attr('layoutsize').container.clientY,
	rootOffHeight = this.attr('layoutsize').root.offsetHeight + containerClientY,
	rootOffWidth = this.attr('layoutsize').root.offsetWidth + containerClientX,
	ulHeight = QBOX.$('.'+css.CONTEXTMENU_ROOT).height() + this.attr('layoutsize').hscrollbar.offsetHeight,
	ulWidth = QBOX.$('.'+css.CONTEXTMENU_ROOT).width() + this.attr('layoutsize').vscrollbar.offsetWidth,
	nTop = parseInt(event.pageY),
	nLeft = parseInt(event.pageX),
	top, left,nGab =0 ;
	
	if(this.attr('useall') || this.attr('usetreeall'))
		nGab = containerClientX;
		
	// left값
	if(rootOffWidth < nLeft + ulWidth){
		left = rootOffWidth - ulWidth + 'px';
	}
	else {
		left =( nLeft - nGab  )+ 'px';
	}
	
	// top값
	if(rootOffHeight < nTop + ulHeight){
		top = rootOffHeight - ulHeight + 'px';
	}
	else {
		top = (nTop - containerClientY + this.attr('layoutsize').root.offsetTop) + 'px';
		//top = (nTop) + 'px';
	}
	
	//console.log('_calculateContextMenuPosition');
	//console.log($heUl);
	$heUl.css({'left': left, 'top': top});
};
// contextmenu layout 생성
QBOX.QCELL.BasicQCELL.prototype._createContextMenuLayout = function(heUl, e){
	var css = QBOX.QCELL.def.css,
	heCUl = heUl.cloneNode(),
	contextmenu = this.attr('contextmenu'),
	contextmenudata = this.attr('contextmenudata'),
	target = event.target,
	//nRow = parseInt(target.getAttribute('data-row')),
	nCol = parseInt(target.getAttribute('data-col'));
	
	heCUl.id = contextmenu.id;
	heCUl.className += css.CONTEXTMENU_AREA + ' ' + css.CONTEXTMENU_ROOT;
	
	if((QBOX._.isNull(contextmenudata.except) || QBOX._.isUndefined(contextmenudata.except)) && !QBOX._.isNull(contextmenudata.base) && !QBOX._.isUndefined(contextmenudata.base)){ // data중 except(예외)가 없음
		return QBOX.$(this._createContextMenuContents(heCUl, contextmenudata.base.contents, 1, contextmenudata.base.id + "-"));
	} 
	else if(!QBOX._.isNull(contextmenudata.except) && !QBOX._.isUndefined(contextmenudata.except)){ // data중 except 가 있음
		var objExcept = null, isExcept = false;
		for(var i = 0; i < contextmenudata.except.length; i++){
			var tempExcept = contextmenudata.except[i];
			if(nCol === tempExcept.col){
				isExcept = true;
				objExcept = tempExcept;
				break;
			}
		}
		
		if(isExcept){ // mouse 우클릭 위치가 except 설정 중 하나라면
			return QBOX.$(this._createContextMenuContents(heCUl, objExcept.contents, 1, objExcept.id + "-"));
		}
		else{ // 그 외
			return QBOX.$(this._createContextMenuContents(heCUl, contextmenudata.base.contents, 1, contextmenudata.base.id + "-"));
		}
	}
};

// contextmenu 구현
QBOX.QCELL.BasicQCELL.prototype._createContextMenuContents = function(heUl, contextmenu_arr, depth, id){
	var css = QBOX.QCELL.def.css,
	heCUl = heUl.cloneNode(),
	objContextmenuDis = this.attr('contextmenudisable'),
	nCount = 1;
	
	heCUl.style.zIndex = depth;
	
	for(var i=0; i<contextmenu_arr.length; i++){
		var objContext = contextmenu_arr[i],
		heMenu = document.createElement('li'),
		heMenuImg = document.createElement('span'),
		heMenuLabel = heMenuImg.cloneNode(),
		heMenuSub = heMenuImg.cloneNode(),
		strId = id + nCount,
		strBlank = '\u00A0'; // 공백문자 입력 /u00A0 = &nbsp;
		
		if(objContext.disabled === true){
			if(QBOX._.contains(objContextmenuDis, strId) === false){
				objContextmenuDis.push(strId);
			}
		}
		
		if(QBOX._.isUndefined(objContext.divine) === false){
			if(QBOX._.isBoolean(objContext.divine) && objContext.divine === true){
				heMenu.className += css.CONTEXTMENU_DIVINE;
			}
		}
		else{
			nCount++;
			heMenu.id = strId;
			heMenu.className += css.CONTEXTMENU_ITEM;
			
			heMenuImg.className += css.CONTEXTMENU_ITEM_IMG;
			heMenuLabel.className += css.CONTEXTMENU_ITEM_LABEL;
			heMenuSub.className += css.CONTEXTMENU_ITEM_SUB;
			
			// icon이 설정되어 있을 경우
			if(QBOX._.isUndefined(objContext.icon) === false){
				heMenuImg.appendChild(this._createFontAwesomeElementImg(objContext.icon));
			}
			// icon이 설정되어 있지 않을 경우
			else {
				heMenuImg.appendChild(document.createTextNode(strBlank));
			}
			
			// label값 표시
			if(QBOX._.isUndefined(objContext.label) === false){
				heMenuLabel.appendChild(document.createTextNode(objContext.label));
			}
			else {
				heMenuLabel.appendChild(document.createTextNode(strBlank));
			}
			
			heMenuSub.appendChild(document.createTextNode(strBlank));
			
			heMenu.appendChild(heMenuImg);
			heMenu.appendChild(heMenuLabel);
			heMenu.appendChild(heMenuSub);
			
			// callback이 설정되어 있을 경우
			if(QBOX._.isUndefined(objContext.callback) === false){
				if(QBOX._.isFunction(objContext.callback)){
					this._addContextMenuClickEvent(heMenu, objContext.callback, objContext);
				}
				else if(QBOX._.isString(objContext.callback)){
					this._addContextMenuStringClickEvent(heMenu, objContext.callback, objContext);
				}
			}
			
			// 메뉴 클릭시 contextmenu 삭제
			this._addContextMenuClickEventInit(heMenu);
			
			// 하위 메뉴가 없는 경우
			if(QBOX._.isUndefined(objContext.items) === true){
				heMenu.className += ' ' + css.CONTEXTMENU_MENU;
			}
			// 하위메뉴가 있을 경우
			else{ 
				var heSubUl = document.createElement('ul');
				heSubUl.className += css.CONTEXTMENU_AREA;
				// 재귀 함수를 통해 하위 메뉴를 추가
				heSubUl = this._createContextMenuContents(heSubUl, objContext.items, depth + 1, strId + "-");
				
				heMenu.className += ' ' + css.CONTEXTMENU_SUB_MENU;
				heMenu.appendChild(heSubUl);
			}
			
			for(var j=0; j<objContextmenuDis.length; j++){ // 속성 contextmenudisable에 속해있으면 event모두 삭제 및 CONTEXTMENU_DISABLE class 추가
				if(strId === objContextmenuDis[j]){
					heMenu.className += ' ' + css.CONTEXTMENU_DISABLE;
					
					if(QBOX._.isUndefined(objContext.callback) === false){
						if(QBOX._.isFunction(objContext.callback)){
							QBOX.$(heMenu).off('click', objContext.callback);
						}
					}
					
					// 메뉴 클릭시 contextmenu 삭제 이벤트 제거 - contextmenu 유지
					QBOX.$(heMenu).off('click');
				}
			}
			
			// heMenu에 mouse move event 추가 
			this._addContextMenuMouseMoveEvent(heMenu, css);
		}
		
		heCUl.appendChild(heMenu);
	}
	
	return heCUl;
};

// 이미지 영역에 fontawesome 적용
QBOX.QCELL.BasicQCELL.prototype._createFontAwesomeElementImg = function(img){
	var compare_st = "<i", compare_ed = "</i>",
	result;
	
	if(img.indexOf(compare_st) > -1 && img.indexOf(compare_ed) > -1){ // img내용에 i tag 존재여부 확인(태그 닫기까지 필요)
		var compare_quote = "\"",
		i_str = img.substr(img.indexOf(compare_st), img.lastIndexOf(compare_ed))+compare_ed, // i tag영역만 추출
		i_class = i_str.slice(i_str.indexOf(compare_quote) + 1, i_str.lastIndexOf(compare_quote)); // i tag영역에 class이름만 추출
		
		result = document.createElement('i'); // i tag element 생성
		result.className += i_class;
	}
	else{
		result = document.createElement('img'); // img tag element 생성
		result.src = img;
	}
	
	return result;
} ;

// html element에 mouse click 이벤트 추가
QBOX.QCELL.BasicQCELL.prototype._addContextMenuClickEvent = function(heMenu, callback, objContext){
	QBOX.$(heMenu).on('click', this.attr('eventparam'), function(event){
		callback(objContext);
	});
};

//html element에 mouse click 이벤트 추가
QBOX.QCELL.BasicQCELL.prototype._addContextMenuStringClickEvent = function(heMenu, callback, objContext){
	QBOX.$(heMenu).on('click', this.attr('eventparam'), function(event){
		window[callback](objContext);
	});
};

QBOX.QCELL.BasicQCELL.prototype._addContextMenuClickEventInit = function(heMenu){
	var objQCell = this;
	
	QBOX.$(heMenu).on('click', this.attr('eventparam'), function(event){
		objQCell._removeContextMenu();
	});
};

// html element에 mouseover, mouseout 이벤트 추가
QBOX.QCELL.BasicQCELL.prototype._addContextMenuMouseMoveEvent = function(heMenu, css){
	var children, i;
	
	// 해당 element에 mouse가 들어왔을 때 (mouse enter)
	QBOX.$(heMenu).mouseenter(function(event){
		var width = QBOX.$(this.parentNode).width(),
		siblings = QBOX.$(this).parent().children(),
		nDivine = 0;
		
		children = QBOX.$(this).children();
		
		for(i=0; i<siblings.length; i++){
			if(siblings[i] === QBOX.$(this).get(0)){
				if(i < siblings.length-1){ // 마지막 행이 아니라면 border에 의한 높이 조정 -1px
					nDivine = -1;
				}
				break;
			}
		}
		
		for(i=0; i<children.length; i++){
			var $child = QBOX.$(children[i]);
			if($child.hasClass(css.CONTEXTMENU_AREA)){
				if($child.css('left') === 'auto'){ // 생성될 위치 조정 최초에 한번만
					$child.css({'left': width + 'px', 'top': nDivine + 'px'});
				}
				$child.css({'display': 'inline-block'});
			}
		}
	});
	
	// 해당 element에 mouse가 빠져나갔을 때
	QBOX.$(heMenu).mouseleave(function(event){
		children = QBOX.$(this).children();
		
		for(i=0; i<children.length; i++){
			
			var $child = QBOX.$(children[i]);
			
			if($child.hasClass(css.CONTEXTMENU_AREA)){
				$child.css({'display': 'none'});
			}
		}
	});
};

// 사용하지 못하게 할 contextmenu중 id값 추가 설정
QBOX.QCELL.BasicQCELL.prototype._setDisableContextmenu = function(ids){
	var objContextmenuDis = this.attr('contextmenudisable'),
	arrCheck = [], i;
	
	// 비활성화할 데이터 역순 정렬
	ids = ids.sort().reverse();
	
	for(i=0; i<objContextmenuDis.length; i++){
		for(var j=ids.length; j>-1; j--){
			if(objContextmenuDis[i] === ids[j]){
				arrCheck.push(ids[j]);
			}
		}
	}
	
	// 뒤에서 부터 겹치는 배열 제거
	if(arrCheck.length > 0){
		for(i=0; i<arrCheck.length; i++){
			ids.splice(arrCheck[i], 1);
		}
	}
	
	for(i=0; i<ids.length; i++){
		objContextmenuDis.push(ids[i]);
	}
	
	// 비활성화 배열 정렬
	objContextmenuDis.sort();
	
	this._removeContextMenu();
	
	return true;
};

// 사용하지 못하게 할 contextmenu중 id값 제거 설정
QBOX.QCELL.BasicQCELL.prototype._setAbleContextmenu = function(ids){
	var objContextmenuDis = this.attr('contextmenudisable'),
	arrCheck = [], i;
	
	// 활성화할 데이터 역순 정렬
	ids = ids.sort().reverse();
	
	for(i=0; i<objContextmenuDis.length; i++){
		for(var j=ids.length; j>-1; j--){
			if(objContextmenuDis[i] === ids[j]){
				arrCheck.push(ids[j]);
			}
		}
	}
	
	// 뒤에서 부터 겹치는 배열 제거
	for(i=0; i<ids.length; i++){
		objContextmenuDis.splice(arrCheck[i], 1);
	}
	
	this._removeContextMenu();
	
	return true;
};

QBOX.QCELL.BasicQCELL.prototype._getContextmenuId = function(){
	return this.attr('contextmenuid');
};
QBOX.QCELL.BasicQCELL.prototype._isContextMenu = function(){
	try{
		return QBOX._.isEmpty(this.attr('contextmenu').data);
		//QBOX._.isEmpty(this.attr('contextmenu').header)
	}catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._isContextMenu', e.message);
		return false;
	}
	
	return true;	
};
QBOX.QCELL.BasicQCELL.prototype._createCols = function(){
	var result = true, colsprops = this.attr('colsprops'), j, cols = colsprops.length, arrQCellCols = this.attr('qcellcols'),
	nHeaderCols = this.attr('rowheaders').length,
	objQCellCol;
	
	for( j = 0 ; j < nHeaderCols ; j++){
		objQCellCol = this._createHeaderCol({key:this.attr('data').type === 'array' ? -1 : ''});
		if(objQCellCol === null){
			result = false;
			break;
		} else{
			arrQCellCols.push(objQCellCol);
		}
	}
	
	if(result){
		for( j = 0; j < cols; j++ ){
			objQCellCol = this._createCol(j, colsprops[j]);
			if(objQCellCol === null){
				result = false;
				break;
			} else{
				arrQCellCols.push(objQCellCol);
			}
		}
		
		if(result){
			this._setHSRange();//가로스크롤바 이동 범위 설정(nStartCol, nEndCol 설정)
		}
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._createHeaderCol = function(colprops){
	try{
		return QBOX.QCELL.BasicQCELL.QCellCol.create(QBOX._.extend(QBOX._.clone(colprops), {
			parent		: this,
			id			: 'col_' + this.attr('qcellcols').length,
			width		: this.attr('headercolwidth') + 'px',
			move		: false
		}));
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createHeaderCol', e.message);
		return null;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createCol = function(col, colprops){
	try{
		return QBOX.QCELL.BasicQCELL.QCellCol.create(col, QBOX._.extend(QBOX._.clone(colprops), {
			parent		: this,
			id			: 'col_' + this.attr('qcellcols').length
		}));
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createCol', e.message);
		return null;
	}
};

QBOX.QCELL.BasicQCELL.prototype._create = function(){
	if(this._initProps() && this._initData() && this._initRowheaderData() && this._createElement()){
		if(this.attr('groupdata') !== undefined){
			this.setGroup(this.attr('groupdata'));
		}
		var THAT = this;
		
		if(this.attr('bRebuildWithPrevData') !== true){
			setTimeout(function (){
				THAT._trigger('aftercreated');			
			},0);
		}
		
		setTimeout(function(){
			THAT._trigger('viewport_changed');
		},0);

		return true;
	}
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._createElement = function(){
	try{
		return this._createHeaderMergeInfo() &&
		this._removeElement() &&	//1. Element 제거
		this._createLayout() &&			//2. Layout 생성
		//this._setHSRange() &&			//가로스크롤바 이동 범위 설정
		//this._setVSRange() &&			//세로스크롤바 이동 범위 설정
		this._initLayoutSize() &&		//3. 스크롤바 생성 여부 확인, root, panel, container의 사이즈, 위치  설정, 스크롤바 생성 여부 확인(DOM이 박혀있어야만 정확하게 세팅이 가능하다.)
		this._adjustFrozenCount() &&	//4. 스크롤바 존재 여부에 따른 틀고정 기능 사용 가능 여부 보정
		this._calculateDynamicCols() && //5. DynamicCols 계산, 몇 개의 열 div를 만들 것인지 계산한다.
		this._calculateDynamicRows() && //6. DynamicRows 계산, 몇 개의 행 div를 만들 것인지 계산한다.
		this._createFlesh() &&		//7. cell DOM 생성, 각 block에 셀들을 생성한다.
		this._resizeHScrollbar() &&		//8. 가로스크롤바사이즈 조정, 가로스크롤바 길이 갱신
		this._resizeVScrollbar() &&		//9. 세로스크롤바사이즈 조정, 세로스크롤바 길이 갱신
		this._updateHSInfo() &&			//10. 가로스크롤바 정보 갱신, hsinfo 정보 갱신(nLeftCol, nRightCol, nAdjustedLeft 설정)
		this._updateVSInfo() &&			//11. 세로스크롤바 정보 갱신, vsinfo 정보 갱신(nTopRow, nBottomRow 설정)
		
		/*merge********************************************************************/
		this._createDataMergeInfo() &&
		this._updateMerge();
		/*merge********************************************************************/
		
//		this._removeElement();
//		
//		//1. Layout 생성
//		if(this._createLayout()){
//			//2. 스크롤바 이동 범위 설정
//			this._setHSRange();				//가로스크롤바 이동 범위 설정
//			this._setVSRange();				//세로스크롤바 이동 범위 설정
//			
//			//3. 스크롤바 생성 여부 확인
//			this._initLayoutSize();			//root, panel, container의 사이즈, 위치  설정, 스크롤바 생성 여부 확인(DOM이 박혀있어야만 정확하게 세팅이 가능하다.)
//			
//			//4. 스크롤바 존재 여부에 따른 틀고정 기능 사용 가능 여부 보정
//			this._adjustFrozenCount();
//			
//			//block의 크기가 정해졌으면
//			
//			//5. DynamicCols, DynamicRows 계산
//			this._calculateDynamicCols();	//몇 개의 열 div를 만들 것인지 계산한다.
//			this._calculateDynamicRows();	//몇 개의 행 div를 만들 것인지 계산한다.
//			
//			//6. cell DOM 생성
//			this._createFlesh();		//각 block에 셀들을 생성한다.
//			
//			//7. 스크롤바 사이즈 조정
//			this._resizeHScrollbar();		//가로스크롤바 길이 갱신
//			this._resizeVScrollbar();		//세로스크롤바 길이 갱신
//			
//			//8. 스크롤바 정보 갱신
//			this._updateHSInfo();			//hsinfo 정보 갱신
//			this._updateVSInfo();			//vsinfo 정보 갱신
//			
//			return true;
//		}
//		return false;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._removeElement = function(){
	try{
		//스클로바 UI 제거, _createLayout() 이후의 상태에서는 스크롤바UI를 생성하지 않은 시점이다.
		if(this._removeScrollbarUI()){
			this.attr('parent').innerHTML = '';
			this.attr('elementpool').clear();
			this.attr('cellmatrix').clear();
			this.attr('focuscell', null, 'element');
			
			return true;
		}
		
		return false;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._removeElement', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._removeScrollbarUI = function(){
	try{
		var objHSInfo = this.attr('hsinfo'),
		objVSInfo = this.attr('vsinfo'),
		htElementPool = this.attr('elementpool');
		
		if(objHSInfo.bHScroll){
			if(htElementPool.containsKey('$jqhscrollbar')){
				htElementPool.get('$jqhscrollbar').rt_qc_mCSbar('destroy');
			}
		}
		
		if(objVSInfo.bVScroll){
			if(htElementPool.containsKey('$jqvscrollbar')){
				htElementPool.get('$jqvscrollbar').rt_qc_mCSbar('destroy');
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._removeScrollbarUI', e.message);
		return false;
	}
};
QBOX.QCELL.BasicQCELL.prototype._setRoleTitle = function(){
	if(this.attr('useall') || this.attr('usetreeall')){
		var heParent = this.attr('parent');
		if(QBOX._.isElement(heParent)){
			heParent.setAttribute('role' ,'grid');
			
			var str = '';
			var strHeader = '',j,arrRowHeadersTitle = this.attr('rowheaderstitle');
			
			if(arrRowHeadersTitle !== undefined && arrRowHeadersTitle !== null){
				for( j = 0; j<arrRowHeadersTitle.length ; j++){
					if(str !== '')
						str = str + ',';
					strHeader = arrRowHeadersTitle[j];
					
					str = str + strHeader;
					
				}
				
			}
			for(j=this.getCols('header'); j<this.getCols();j++){
				
				strHeader = this._getTitleHeader(j);
				if(strHeader === '')
					continue;
				
				if(str !== '')
					str = str + ',';
				
				
				str = str + strHeader;
			}
			str = '그리드 테이블 ' + str; 
			heParent.setAttribute('aria-label' ,str);						
			
		}
		
	}
};
QBOX.QCELL.BasicQCELL.prototype._createLayout = function(){
	var heParent = this.attr('parent');
	
	if(QBOX._.isElement(heParent)){
		heParent.appendChild(this._createRoot(document.createElement('div')));
		if(this._initEvent()){
			this._setRoleTitle();
			return true;
		} else{
			QBOX.$(heParent).empty();
		}
	}
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._createRoot = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heRoot = heDiv.cloneNode();
	/*
	<div class="def.css.ROOT" id="def.areaname.ROOT-strID">
			<div class="def.css.PANEL " id="def.areaname.PANEL-strID"></div>
			<div class="def.css.CONTAINER" id="def.areaname.CONTAINER-strID"></div>
	</div>
	 */
	
	heRoot.className += def.css.ROOT;
	heRoot.setAttribute('id', def.areaname.ROOT + '-' + strID);
	heRoot.appendChild(this._createPanel(heDiv));
	heRoot.appendChild(this._createContainer(heDiv));
	heRoot.appendChild(this._createPaginationPanel(heDiv));
	heRoot.appendChild(this._createSheetPanel(heDiv));
	
	htElementPool.put('root', heRoot);
	htElementPool.put('$root', QBOX.$(heRoot));
	
	return heRoot;
};

QBOX.QCELL.BasicQCELL.prototype._createPanel = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	hePanel = heDiv.cloneNode();
	/*
		<div class="def.css.PANEL " id="def.areaname.PANEL-strID"></div>
	*/
	hePanel.className += def.css.PANEL;
	hePanel.setAttribute('id', def.areaname.PANEL + '-' + strID);
	
	hePanel.appendChild(this._createGroupUIArea(heDiv));
	
	htElementPool.put('panel', hePanel);
	htElementPool.put('$panel', QBOX.$(hePanel));
	
	return hePanel;
};

QBOX.QCELL.BasicQCELL.prototype._createGroupUIArea = function(heDiv){
	var strID = this.attr('id'), def = QBOX.QCELL.def,
	heGroupUI = heDiv.cloneNode();
	
	heGroupUI.className += def.css.GROUPUI;
	heGroupUI.setAttribute('id', def.areaname.GROUPUI + '-' + strID);
	
	QBOX.$(heGroupUI).droppable({
		hoverClass:  "hover" // 마우스오면 강조효과
	});
	
	heGroupUI.appendChild(this._createGroupUIInner());
	
	return heGroupUI;
};

QBOX.QCELL.BasicQCELL.prototype._createGroupUIInner = function(){
	var heDndArea = document.createElement('ol'),
	strID = this.attr('id'), def = QBOX.QCELL.def,
	id = def.css.GROUPUI_INNER + '-' + strID,
	THAT = this;
	
	heDndArea.className += def.css.GROUPUI_INNER;
	heDndArea.setAttribute('id', id);
	
	heDndArea.appendChild(this._createGroupUIPlaceholder());
	
	QBOX.$(heDndArea).sortable({
		axis: "x",
		containment: "parent",
		stop: function( event, ui ) {
			if(!ui.item.hasClass('.placeholder')){
				var nCol = Number(ui.item.attr('data-col')),
				colkey = THAT.attr('colkeys')[nCol];
				
				THAT.attr('groupuiinfo', [], 'array'); // sort전 groupuiinfo 정보 초기화
				QBOX.$(this).find('li.placeholder').remove(); // 최초 생성되어 있던 class placeholder의 li tag 제거
				if(QBOX.$(ui.item).hasClass(QBOX.QCELL.def.css.CELL)){
					QBOX.$(ui.item).remove(); // drag로 가져온 tag제거			
				}
				
				if(QBOX.$(this).find('li[data-column='+colkey+']').length === 0){ // 동일한 이름의 li가 존재하는 지 확인
					// span tag생성 및 close icon click시 Group에서 해당 컬럼의 키 제거
					// 영역안의 li가 0개가 되면 초기 placeholder tag생성
					var heSpan = QBOX.$('<span></span>')
					.addClass(QBOX.QCELL.def.css.UI_ICON + ' ' + QBOX.QCELL.def.css.UI_ICON_CLOSE)
					.on('click', function(e){
						var heTarget = e.target,
						heTargetParent = heTarget.parentNode,
						heInner = event.target;
						
						QBOX.$(heTargetParent).remove();
						
						if(QBOX.$(heInner).find('li').length === 0){ // 모든 li가 사라지면 기본 li.placeholder 생성
							heInner.appendChild(THAT._createGroupUIPlaceholder());
							THAT._clearGroup();
						} else { // 남아있는 li의 정보를 가지고 group처리
							THAT.attr('groupuiinfo', [], 'array');
							THAT._setGroupUIInfo(QBOX.$(heInner).find('li').not('.placeholder'));
						}
					}), 
					heLi = QBOX.$("<li></li>")
					.attr('data-column', colkey)
					.attr('data-col', nCol)
					.append(heSpan)
					.append(ui.item[0].innerText);
					QBOX.$(event.target).append(heLi);
				}
				
				// class가 placeholder가 아닌 li들의 정보를 가지고 group처리
				THAT._setGroupUIInfo(QBOX.$(this).find('li').not('.placeholder'));
			}
		}
	});
	
	return heDndArea;
};

QBOX.QCELL.BasicQCELL.prototype._createGroupUIPlaceholder = function(){
	var hePlaceholder = document.createElement('li');
	
	hePlaceholder.className = "placeholder";
	hePlaceholder.innerHTML = '이곳에 그룹화할 컬럼을 드롭해 주십시오';
	
	return hePlaceholder;
};

QBOX.QCELL.BasicQCELL.prototype._createContainer = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heContainer = heDiv.cloneNode();
	/*
		<div class="def.css.CONTAINER" id="css.CONTAINER-strID">
				<div class="def.css.VIEWPORT" id="def.areaname.VIEWPORT-strID"></div>
				<div class="def.css.FOOTERROWHEADER" id="def.areaname.FOOTERROWHEADER-strID"></div>
				<div class="def.css.FOOTER" id="def.areaname.FOOTER-strID"></div>
				<div class="def.css.EDGEHEADER" id="def.areaname.EDGEHEADER-strID"></div>
				<div class="def.css.ROWHEADER" id="def.areaname.ROWHEADER-strID"></div>
				<div class="def.css.COLHEADER" id="def.areaname.COLHEADER-strID"></div>
				<div class="def.css.HSCROLLBAR" id="def.areaname.HSCROLLBAR-strID"></div>
				<div class="def.css.VSCROLLBAR" id="def.areaname.VSCROLLBAR-strID"></div>
		</div>
	*/
	heContainer.className += def.css.CONTAINER;
	heContainer.setAttribute('id', def.areaname.CONTAINER + '-' + strID);
	//if(this.attr('useall') !== true)
		heContainer.setAttribute('tabindex', '0');
	heContainer.appendChild(this._createViewPort(heDiv));
	heContainer.appendChild(this._createFooterRowHeader(heDiv));
	heContainer.appendChild(this._createFooter(heDiv));
	heContainer.appendChild(this._createEdgeHeader(heDiv));
	heContainer.appendChild(this._createRowHeader(heDiv));
	heContainer.appendChild(this._createColHeader(heDiv));
	heContainer.appendChild(this._createHScrollbar(heDiv));
	heContainer.appendChild(this._createVScrollbar(heDiv));
	
	htElementPool.put('container', heContainer);
	htElementPool.put('$container', QBOX.$(heContainer));
	
	return heContainer;
};

QBOX.QCELL.BasicQCELL.prototype._createSheetPanel = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heSheetPanel = heDiv.cloneNode();
	/*
	<div class="def.css.SHEETPANEL " id="def.areaname.SHEETPANEL-strID"></div>
	 */
	heSheetPanel.className += ' ' + def.css.SHEETPANEL;
	heSheetPanel.setAttribute('id', def.areaname.SHEETPANEL + '-' + strID);
	
	heSheetPanel.appendChild(this._createSheetPanelInner(heDiv));
	
	htElementPool.put('sheetpanel', heSheetPanel);
	htElementPool.put('$sheetpanel', QBOX.$(heSheetPanel));
	
	return heSheetPanel;
};

QBOX.QCELL.BasicQCELL.prototype._createSheetPanelInner = function(heDiv){
	var def = QBOX.QCELL.def,
	strID = this.attr('id'), 
	heSheetPanelInner = heDiv.cloneNode(),
	heSpan = document.createElement('span');
	
	heSpan.className += ' ' + def.css.SHEETPANEL_INNER_SPAN;
	heSpan.setAttribute('id', def.areaname.SHEETPANEL + '-span-' + strID);
	heSheetPanelInner.appendChild(heSpan);
	
	heSheetPanelInner.className += ' ' + def.css.SHEETPANEL_INNER;
	
	return heSheetPanelInner;
};

QBOX.QCELL.BasicQCELL.prototype._createPaginationPanel = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	hePaginationPanel = heDiv.cloneNode(), objPaginationInfo = this.attr('paginationinfo');
	
	/*
	<div class="def.css.PAGINATIONPANEL" id="def.areaname.PAGINATIONPANEL-strID"></div>
	 */
	
	hePaginationPanel.className += def.css.PAGINATIONPANEL;
	hePaginationPanel.setAttribute('id', def.areaname.PAGINATIONPANEL + '-' + strID);
	
	htElementPool.put('paginationpanel', hePaginationPanel);
	htElementPool.put('$paginationpanel', QBOX.$(hePaginationPanel));
	
	if(QBOX._.isUndefined(objPaginationInfo.pageunit) === false){
		this._calculatePaginationInfoCreate();
		
		hePaginationPanel.appendChild(this._createPaginationInner(heDiv));
		
		this._updateCurrentData(QBOX._.clone(objPaginationInfo.result));
		
		// pagination을 통해 current data를 셋팅 한 이후 rowheaderdata를 초기화 한다.                                     
		this._initRowheaderData();
	}
	
	return hePaginationPanel;
};

QBOX.QCELL.BasicQCELL.prototype._createPaginationInner = function(heDiv){
	var def = QBOX.QCELL.def,
	hePaginationInner = heDiv.cloneNode();
	
	hePaginationInner.className += def.css.PAGINATION_INNER;
	hePaginationInner.style.width = hePaginationInner.style.height = '100%';

	hePaginationInner.appendChild(this._createPaginationCenterUI(heDiv.cloneNode()));
	hePaginationInner.appendChild(this._createPaginationRightUI(heDiv.cloneNode()));
	
	return hePaginationInner;
};

QBOX.QCELL.BasicQCELL.prototype._createPaginationCenterUI = function(heDiv){
	var def = QBOX.QCELL.def,
	objEventParam = this.attr('eventparam'),
	objPaginationInfo = this.attr('paginationinfo'),
	hePaginationCenterUI = heDiv.cloneNode(),
	heSpan = document.createElement('span'),
	heFirst = heSpan.cloneNode(),
	hePrev = heSpan.cloneNode(),
	heNext = heSpan.cloneNode(),
	heLast = heSpan.cloneNode(),
	heNow = document.createElement('input'),
	heInput = heNow.cloneNode(),
	heContents = heSpan.cloneNode(),
	hePageUnit = document.createElement('select'),
	fnPaginationButtonClick,
	fnPageUnitChanged,
	heNum,
	pagest = Math.floor((objPaginationInfo.pageindex - 1) / objPaginationInfo.pagecount),
	pageed = Math.floor(objPaginationInfo.lastindex / objPaginationInfo.pagecount),
	stnum = (pagest * objPaginationInfo.pagecount),
	ednum = (pagest * objPaginationInfo.pagecount) + objPaginationInfo.pagecount > objPaginationInfo.lastindex ? objPaginationInfo.lastindex : (pagest * objPaginationInfo.pagecount) + objPaginationInfo.pagecount;
	
	fnPaginationButtonClick = function(event){
		var objQCell = event.data.target,
		movepageIndex = parseInt(event.target.getAttribute('movepage')),
		moveState = event.target.getAttribute('movestate');
		
		if(objQCell){
			objQCell._movePage(movepageIndex);
			objQCell._trigger('movepage', moveState);
		}
	};
	fnPageUnitChanged = function(event){
		var objQCell = event.data.target;
		
		if(objQCell){
			objQCell._movePage(objQCell.attr('paginationinfo').pageindex, Number(QBOX.$(event.target).val()));
		}
	};
	
	// jqgrid 기준 pagination 정보 영역
	hePaginationCenterUI.className += def.css.PAGINATION_UI_CENTER;
	
	heFirst.appendChild(document.createTextNode('<<'));
	heFirst.className += def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_BTN;
	heFirst.style.color = "#ffffff";
	heFirst.setAttribute('id', 'rt-qc-pagination-nav-first');
	
	if(objPaginationInfo.firstpage){
		heFirst.style.cursor = 'pointer';
		heFirst.setAttribute('movepage', 1);
		heFirst.setAttribute('movestate','move-first');
		QBOX.$(heFirst).on('click', objEventParam, fnPaginationButtonClick);
	} else { // 비활성화 시 불투명화 처리
		heFirst.style.opacity = '0.3';
	}
	
	hePrev.appendChild(document.createTextNode('<'));
	hePrev.className += def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_BTN;
	hePrev.style.color = "#ffffff";
	hePrev.setAttribute('id', 'rt-qc-pagination-nav-prev');
	if(objPaginationInfo.prevpage){
		hePrev.style.cursor = 'pointer';
		if(objPaginationInfo.mode === 'simple') { // 기본 pagination 타입일 때 다음 페이지는 현재 페이지 - 1
			hePrev.setAttribute('movepage', (objPaginationInfo.pageindex - 1) );
		} else { // pagination mode 'extend' 일 때 다음 페이지는 표시되는 페이지 넘버의 첫번째 번호 - 1
			if(pagest > 0) { // 이전 버튼은 첫 페이지가 존재할 때는 동작하지 않는다.
				hePrev.setAttribute('movepage', stnum);
			}
			// 현재 페이지 - 페이지 숫자
			//hePrev.setAttribute('movepage', (objPaginationInfo.pageindex - objPaginationInfo.pagecount > 0 ? objPaginationInfo.pageindex - objPaginationInfo.pagecount : 1) );
		}
		hePrev.setAttribute('movestate','move-prev');
		QBOX.$(hePrev).on('click', objEventParam, fnPaginationButtonClick);
	} else { // 비활성화 시 불투명화 처리
		hePrev.style.opacity = '0.3';
	}
	
	heNext.appendChild(document.createTextNode('>'));
	heNext.className += def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_BTN;
	heNext.style.color = "#ffffff";
	heNext.setAttribute('id', 'rt-qc-pagination-nav-next');
	if(objPaginationInfo.nextpage){
		heNext.style.cursor = 'pointer';
		if(objPaginationInfo.mode === 'simple') { // 기본 pagination 타입일 때 다음 페이지는 현재 페이지 + 1
			heNext.setAttribute('movepage', (objPaginationInfo.pageindex + 1) );
		} else { // pagination mode 'extend' 일 때 다음 페이지는 표시되는 페이지 넘버의 마지막 번호 + 1
			if(pagest < pageed) { // 다음 버튼은 마지막 페이지가 존재할 때는 동작하지 않는다.
				heNext.setAttribute('movepage', (ednum + 1) );
			}
			
			// 현재 페이지 + 페이지 숫자
			//heNext.setAttribute('movepage', (objPaginationInfo.pageindex + objPaginationInfo.pagecount < objPaginationInfo.lastindex ? objPaginationInfo.pageindex + objPaginationInfo.pagecount : objPaginationInfo.lastindex) );
		}
		heNext.setAttribute('movestate','move-next');
		QBOX.$(heNext).on('click', objEventParam, fnPaginationButtonClick);
	} else { // 비활성화 시 불투명화 처리
		heNext.style.opacity = '0.3';
	}
	
	heLast.appendChild(document.createTextNode('>>'));
	heLast.className = def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_BTN;
	heLast.style.color = "#ffffff";
	heLast.setAttribute('id', 'rt-qc-pagination-nav-last');
	if(objPaginationInfo.lastpage){
		heLast.style.cursor = 'pointer';
		heLast.setAttribute('movepage', (objPaginationInfo.lastindex) );
		heLast.setAttribute('movestate','move-last');
		QBOX.$(heLast).on('click', objEventParam, fnPaginationButtonClick);
	} else { // 비활성화 시 불투명화 처리
		heLast.style.opacity = '0.3';
	}
	
	hePaginationCenterUI.appendChild(heFirst);
	hePaginationCenterUI.appendChild(hePrev);
	
	if(objPaginationInfo.mode === 'simple') { // pagination mode 'simple'
		heNow.className += def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_INPUT;
		heNow.setAttribute('value', objPaginationInfo.pageindex);
		heNow.setAttribute('size', String(objPaginationInfo.lastindex).length);
		heNow.setAttribute('maxlength', String(objPaginationInfo.lastindex).length);
		heNow.style.textAlign = "right";
		QBOX.$(heNow).on('keydown', objEventParam, QBOX.st.eventProcess);
		
		heContents.className += def.css.PAGINATION_NAV;
		heContents.style.color = "#ffffff";
		heContents.appendChild(document.createTextNode(' / ' + objPaginationInfo.lastindex));
		
		hePaginationCenterUI.appendChild(heNow);
		hePaginationCenterUI.appendChild(heContents);
	} else { // pagination mode 'extend'
		
		//console.log('현재 페이지 번호:'+objPaginationInfo.pageindex);
		//console.log('pagest:'+pagest+', pageed:'+pageed+', stnum:'+stnum+', ednum:'+ednum);
		
		if(objPaginationInfo.pageindex > 0) { // pagecount 만큼 화면에 출력할 페이지 번호 생성
			/*
			if(pagest > 0) {
				heNum = heSpan.cloneNode();
				heNum.appendChild(document.createTextNode( '' + 1));
				heNum.className = def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_PAGER + ' ';
				heNum.style.cursor = 'pointer';
				heNum.setAttribute('movepage', 1);
				QBOX.$(heNum).on('click', objEventParam, fnPaginationButtonClick);
				hePaginationCenterUI.appendChild(heNum);
				
				heNum = heSpan.cloneNode();
				heNum.appendChild(document.createTextNode('...'));
				heNum.className = def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_PAGER_SKIP + ' ';
				hePaginationCenterUI.appendChild(heNum);
			}
			*/
			
			for(var i = stnum; i < ednum; i++) {
				heNum = heSpan.cloneNode();
				heNum.appendChild(document.createTextNode((i+1)));
				heNum.className = def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_PAGER + ' ';
				
				if(objPaginationInfo.pageindex === (i+1)){ // 현재 페이지일 경우
					heNum.className += def.css.PAGINATION_NAV_PAGER_NOW;
				} else { // 그 외 페이지일 경우 - click event 추가
					heNum.style.cursor = 'pointer';
					heNum.setAttribute('movepage', (i+1) );
					heNum.setAttribute('movestate', 'move-'+(i+1) );
					QBOX.$(heNum).on('click', objEventParam, fnPaginationButtonClick);
				}
				
				hePaginationCenterUI.appendChild(heNum);
			}
			
			/*
			if(pagest < pageed) { // 마지막 페이지 표시, 페이지 생략 표시
				heNum = heSpan.cloneNode();
				heNum.appendChild(document.createTextNode('...'));
				heNum.className = def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_PAGER_SKIP + ' ';
				hePaginationCenterUI.appendChild(heNum);
				
				heNum = heSpan.cloneNode();
				heNum.appendChild(document.createTextNode(objPaginationInfo.lastindex));
				heNum.className = def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_PAGER + ' ';
				heNum.style.cursor = 'pointer';
				heNum.setAttribute('movepage', objPaginationInfo.lastindex );
				QBOX.$(heNum).on('click', objEventParam, fnPaginationButtonClick);
				hePaginationCenterUI.appendChild(heNum);
			}
			*/
			
		} else { // data가 존재하지 않을 때, 즉 pageindex가 0일 때
			heNum = heSpan.cloneNode();
			heNum.appendChild(document.createTextNode(1));
			heNum.className = def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_NOW_BTN;
			
			hePaginationCenterUI.appendChild(heNum);
		}
	}
	
	hePaginationCenterUI.appendChild(heNext);
	hePaginationCenterUI.appendChild(heLast);
	
	if(QBOX._.isUndefined(this.attr('paginationinfo').unitlist) === false && QBOX._.isArray(this.attr('paginationinfo').unitlist)) {
		hePageUnit.className += def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_SELECT;
		hePageUnit.title = 'QCELL Datas in Page';
		
		QBOX._.each(this.attr('paginationinfo').unitlist, function(val){
			var options = document.createElement('option');
			options.setAttribute('value', val);
			options.appendChild(document.createTextNode(val));
			
			if(val === objPaginationInfo.pageunit){
				options.setAttribute('selected', true);
			}
			hePageUnit.appendChild(options);
		});
		QBOX.$(hePageUnit).on('change', objEventParam, fnPageUnitChanged);
		
		hePaginationCenterUI.appendChild(hePageUnit);
	}
	
	if(objPaginationInfo.extendmove === true && objPaginationInfo.mode === 'extend'){
		heInput.className += def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_INPUT + ' ' + def.css.PAGINATION_NAV_EXTEND_MOVE;
		heInput.setAttribute('value', objPaginationInfo.pageindex === 0 ? 1 : objPaginationInfo.pageindex);
		heInput.setAttribute('size', String(objPaginationInfo.lastindex).length);
		heInput.setAttribute('maxlength', String(objPaginationInfo.lastindex).length);
		heInput.style.textAlign = "right";
		QBOX.$(heInput).on('keydown', objEventParam, QBOX.st.eventProcess);
		
		hePaginationCenterUI.appendChild(heInput);
	}
	
	return hePaginationCenterUI;
};

QBOX.QCELL.BasicQCELL.prototype._createPaginationRightUI = function(heDiv){
	var def = QBOX.QCELL.def,
	objPaginationInfo = this.attr('paginationinfo'),
	hePaginationRightUI = heDiv.cloneNode(),
	heInfo = document.createElement('span'),
	firstData = objPaginationInfo.pageindex > 0 ? ((objPaginationInfo.pageunit * (objPaginationInfo.pageindex - 1)) + 1) : objPaginationInfo.pageindex, 
	lastData = (objPaginationInfo.pageindex * objPaginationInfo.pageunit) > objPaginationInfo.datacount ? objPaginationInfo.datacount : (objPaginationInfo.pageindex * objPaginationInfo.pageunit),
	text = firstData + ' - ' + lastData + ' of ' +  objPaginationInfo.datacount;
	
	// jqgrid 기준 pagination 정보 영역
	hePaginationRightUI.className += def.css.PAGINATION_UI_RIGHT;
	
	heInfo.className += def.css.PAGINATION_NAV + ' ' + def.css.PAGINATION_NAV_INFO;
	heInfo.appendChild(document.createTextNode(text));
	
	hePaginationRightUI.appendChild(heInfo);
	
	return hePaginationRightUI;
};

QBOX.QCELL.BasicQCELL.prototype._createViewPort = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heViewPort = heDiv.cloneNode();
	/*
		<div class="def.css.VIEWPORT" id="def.areaname.VIEWPORT-strID">
				<div class="def.css.VIEWPORT_INNER"></div>
		</div>
	*/
	heViewPort.className += def.css.VIEWPORT;
	heViewPort.setAttribute('id', def.areaname.VIEWPORT + '-' + strID);
	
	htElementPool.put('viewport', heViewPort);
	htElementPool.put('$viewport', QBOX.$(heViewPort));
	
	return heViewPort;
};

QBOX.QCELL.BasicQCELL.prototype._createFooterRowHeader = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heFooterRowHeader = heDiv.cloneNode();
	/*
		<div class="def.css.FOOTERROWHEADER" id="def.areaname.FOOTERROWHEADER-strID">
				<div class="def.css.FOOTERROWHEADER_INNER"></div>
		</div>
	*/
	heFooterRowHeader.className += def.css.FOOTERROWHEADER;
	heFooterRowHeader.setAttribute('id', def.areaname.FOOTERROWHEADER + '-' + strID);
	
	htElementPool.put('footerrowheader', heFooterRowHeader);
	htElementPool.put('$footerrowheader', QBOX.$(heFooterRowHeader));
	
	return heFooterRowHeader;
};

QBOX.QCELL.BasicQCELL.prototype._createFooter = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heFooter = heDiv.cloneNode();
	/*
		<div class="def.css.FOOTER" id="def.areaname.FOOTER-strID">
				<div class="def.css.FOOTER_INNER"></div>
		</div>
	*/
	heFooter.className += def.css.FOOTER;
	heFooter.setAttribute('id', def.areaname.FOOTER + '-' + strID);
	
	htElementPool.put('footer', heFooter);
	htElementPool.put('$footer', QBOX.$(heFooter));
	
	return heFooter;
};

QBOX.QCELL.BasicQCELL.prototype._createEdgeHeader = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heEdgeHeader = heDiv.cloneNode();
	/*
		<div class="def.css.EDGEHEADER" id="def.areaname.EDGEHEADER-strID">
				<div class="def.css.EDGEHEADER_INNER"></div>
		</div>
	*/
	heEdgeHeader.className += def.css.EDGEHEADER;
	heEdgeHeader.setAttribute('id', def.areaname.EDGEHEADER + '-' + strID);
	if(this.attr('useall') || this.attr('usetreeall')){
		heEdgeHeader.setAttribute('aria-hidden' , 'true');
	}
	
	htElementPool.put('edgeheader', heEdgeHeader);
	htElementPool.put('$edgeheader', QBOX.$(heEdgeHeader));
	
	return heEdgeHeader;
};

QBOX.QCELL.BasicQCELL.prototype._createRowHeader = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heRowHeader = heDiv.cloneNode();
	/*
		<div class="def.css.ROWHEADER" id="def.areaname.ROWHEADER-strID">
				<div class="def.css.ROWHEADER_INNER"></div>
		</div>
	*/
	heRowHeader.className += def.css.ROWHEADER;
	heRowHeader.setAttribute('id', def.areaname.ROWHEADER + '-' + strID);
	if(this.attr('useall') || this.attr('usetreeall')){
		heRowHeader.setAttribute('aria-hidden' , 'true');
	}
	//heContainer.style.height = /*QCELL의 height*/parseFloat(this.attr('height')) - /*panel의 height*/0 - /*root의 border-top-width + root의 border-bottom-width*/2 + 'px';
	
	htElementPool.put('rowheader', heRowHeader);
	htElementPool.put('$rowheader', QBOX.$(heRowHeader));
	
	return heRowHeader;
};

QBOX.QCELL.BasicQCELL.prototype._createColHeader = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heColHeader = heDiv.cloneNode();
	/*
		<div class="def.css.heColHeader" id="def.areaname.heColHeader-strID">
				<div class="def.css.heColHeader_INNER"></div>
		</div>
	*/
	heColHeader.className += def.css.COLHEADER + ' ' + def.css.COLHEADER_AREA;
	heColHeader.setAttribute('id', def.areaname.COLHEADER + '-' + strID);
	
	htElementPool.put('colheader', heColHeader);
	htElementPool.put('$colheader', QBOX.$(heColHeader));
	
	return heColHeader;
};

QBOX.QCELL.BasicQCELL.prototype._createHScrollbar = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heHScrollbar;
	/*
		<div class="def.css.HSCROLLBAR" id="def.areaname.HSCROLLBAR-strID">
			<div class="def.css.JQSCROLLBAR"></div>
		</div>
	*/
	heHScrollbar = heDiv.cloneNode();
	heHScrollbar.className += def.css.HSCROLLBAR;
	heHScrollbar.setAttribute('id', def.areaname.HSCROLLBAR + '-' + strID);
	
	htElementPool.put('hscrollbar', heHScrollbar);
	htElementPool.put('$hscrollbar', QBOX.$(heHScrollbar));
	
	heHScrollbar.appendChild(this._createJqHScrollbar(heDiv));
	
	return heHScrollbar;
};

QBOX.QCELL.BasicQCELL.prototype._createVScrollbar = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heVScrollbar;
	/*
		<div class="def.css.VSCROLLBAR" id="def.areaname.VSCROLLBAR-strID">
		</div>
	*/
	heVScrollbar = heDiv.cloneNode();
	heVScrollbar.className += def.css.VSCROLLBAR;
	heVScrollbar.setAttribute('id', def.areaname.VSCROLLBAR + '-' + strID);
	
	htElementPool.put('vscrollbar', heVScrollbar);
	htElementPool.put('$vscrollbar', QBOX.$(heVScrollbar));
	
	heVScrollbar.appendChild(this._createJqVScrollbar(heDiv));
	
	return heVScrollbar;
};

QBOX.QCELL.BasicQCELL.prototype._createJqHScrollbar = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heJqHScrollbar = heDiv.cloneNode();
	/*
		<div class="def.css.HSCROLLBAR" id="def.areaname.HSCROLLBAR-strID">
			<div class="def.css.JQSCROLLBAR"></div>
		</div>
	*/
	//heJqHScrollbar.className += def.css.JQSCROLLBAR;
	htElementPool.put('jqhscrollbar', heJqHScrollbar);
	htElementPool.put('$jqhscrollbar', QBOX.$(heJqHScrollbar));
	
	//heJqHScrollbar.appendChild(this._createHScrollWrapper(heDiv));
	
	return heJqHScrollbar;
};

QBOX.QCELL.BasicQCELL.prototype._createJqVScrollbar = function(heDiv){
	var htElementPool = this.attr('elementpool'), strID = this.attr('id'), def = QBOX.QCELL.def,
	heJqVScrollbar;
	/*
		<div class="def.css.HSCROLLBAR" id="def.areaname.HSCROLLBAR-strID">
			<div class="def.css.JQSCROLLBAR"></div>
		</div>
	*/
	heJqVScrollbar = heDiv.cloneNode();
	//heJqVScrollbar.className += def.css.JQSCROLLBAR;
	
	htElementPool.put('jqvscrollbar', heJqVScrollbar);
	htElementPool.put('$jqvscrollbar', QBOX.$(heJqVScrollbar));
	
	//heJqVScrollbar.appendChild(this._createVScrollWrapper(heDiv));
	
	return heJqVScrollbar;
};

QBOX.QCELL.BasicQCELL.prototype._createHScrollThumb = function(heDiv){
	try{
		var htElementPool = this.attr('elementpool'), def = QBOX.QCELL.def,
		heJQHScrollbar = htElementPool.get('jqhscrollbar'),
		heHScrollThumb = heDiv.cloneNode();
		/*
			<div class="def.css.HSCROLLBAR" id="def.areaname.HSCROLLBAR-strID">
				<div class="def.css.JQSCROLLBAR">
					<div class="def.css.HSCROLL_THUMB"></div>
				</div>
			</div>
		*/
		
		heHScrollThumb.className += def.css.HSCROLL_THUMB;
		heHScrollThumb.style.height = '1px';
		//heHScrollThumb.style.position = 'absolute';
		//heHScrollThumb.style.width = '10000px';
		
		htElementPool.put('hscrollthumb', heHScrollThumb);
		htElementPool.put('$hscrollthumb', QBOX.$(heHScrollThumb));
		
		heJQHScrollbar.appendChild(heHScrollThumb);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createHScrollThumb', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createVScrollThumb = function(heDiv){
	try{
		var htElementPool = this.attr('elementpool'), def = QBOX.QCELL.def,
		heJQVScrollbar = htElementPool.get('jqvscrollbar'),
		heVScrollThumb = heDiv.cloneNode();
		/*
			<div class="def.css.VSCROLLBAR" id="def.areaname.VSCROLLBAR-strID">
				<div class="def.css.JQSCROLLBAR">
					<div class="def.css.VSCROLL_THUMB"></div>
				</div>
			</div>
		*/
		heVScrollThumb.className += def.css.VSCROLL_THUMB;
		heVScrollThumb.style.width = '1px';
		//heVScrollThumb.style.position = 'absolute';
		//heVScrollThumb.style.height = '1000px';
		
		htElementPool.put('vscrollthumb', heVScrollThumb);
		htElementPool.put('$vscrollthumb', QBOX.$(heVScrollThumb));
		
		heJQVScrollbar.appendChild(heVScrollThumb);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createVScrollThumb', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createFlesh = function(){
	try{
		var bResult = false;
		
		if(this._initCellMatrix()){
			var nHeaderCols = this.attr('headercols'),
			nFooterRows = this.attr('footerrows'),
			arrInnerList = [],
			DF = document.createDocumentFragment(),
			htElementPool = this.attr('elementpool'),
			heDiv = document.createElement('div'),
			heRoot = htElementPool.get('root'),
			heContainer = htElementPool.get('container'),
			heSheetPanel = htElementPool.get('sheetpanel'),
			hePage = htElementPool.get('paginationpanel') ;
			
			DF.appendChild(heContainer);
			
			if(nHeaderCols > 0){
				arrInnerList.push('edgeheader');			//1. edgeheader_inner 생성
				arrInnerList.push('rowheader');				//2. rowheader_inner 생성
			}
			
			arrInnerList.push('colheader');					//3. colheader_inner 생성
			arrInnerList.push('viewport');					//4. viewport_inner 생성
			
			if(nFooterRows > 0){
				if(nHeaderCols > 0){
					arrInnerList.push('footerrowheader');	//5. footerheader_inner 생성
				}
				
				arrInnerList.push('footer');				//6. footer_inner 생성
			}
			
			arrInnerList.push('hscrollthumb');				//8. hscrollbar thumb 생성
			arrInnerList.push('vscrollthumb');				//9. vscrollbar thumb 생성
			
			for(var i = 0, nLength = arrInnerList.length; i < nLength; i++){
				var strInnerName = arrInnerList[i];
				
				if(strInnerName === 'edgeheader'){
					bResult = this._createEdgeHeaderInner(heDiv);
				} else if(strInnerName === 'rowheader'){
					bResult = this._createRowHeaderInner(heDiv);
				} else if(strInnerName === 'colheader'){
					bResult = this._createColHeaderInner(heDiv);
				} else if(strInnerName === 'viewport'){
					bResult = this._createViewPortInner(heDiv);
				} else if(strInnerName === 'footerrowheader'){
					bResult = this._createFooterRowHeaderInner(heDiv);
				} else if(strInnerName === 'footer'){
					bResult = this._createFooterInner(heDiv);
				} else if(strInnerName === 'hscrollthumb'){
					bResult = this._createHScrollThumb(heDiv);
				} else if(strInnerName === 'vscrollthumb'){
					bResult = this._createVScrollThumb(heDiv);
				}
				
				if(bResult === false){
					break;
				}
			}
			
			if(bResult){
				this._syncCellMatrix('row');			//row의 cellMatrix 기준으로 col의 cellMatrix 동기화
//				heRoot.insertBefore(DF, heSheetPanel);	//실제 Document에 추가
				heRoot.insertBefore(DF, hePage);	//실제 Document에 추가
				
			}

		}
		
		return bResult;
//		var DF = document.createDocumentFragment(),
//		htElementPool = this.attr('elementpool'),
//		heDiv = document.createElement('div'),
//		heRoot = htElementPool.get('root'), heContainer = htElementPool.get('container'), heSheetPanel = htElementPool.get('sheetpanel');
//		DF.appendChild(heContainer);
//		
//		this._initCellMatrix();
//		
//		if(this.attr('headercols') > 0){
//			this._createEdgeHeaderInner(heDiv);			//1. edgeheader_inner 생성
//			this._createRowHeaderInner(heDiv);			//2. rowheader_inner 생성
//			this._createColHeaderInner(heDiv);			//3. colheader_inner 생성
//			this._createViewPortInner(heDiv);			//4. viewport_inner 생성
//			
//			if(this.attr('footerrows') > 0){
//				this._createFooterRowHeaderInner(heDiv);	//5. footerheader_inner 생성
//				this._createFooterInner(heDiv);				//6. footer_inner 생성
//			}
//		} else{
//			this._createColHeaderInner(heDiv);			//1. colheader_inner 생성
//			this._createViewPortInner(heDiv);			//2. viewport_inner 생성
//			
//			if(this.attr('footerrows') > 0){
//				this._createFooterInner(heDiv);			//3. footer_inner 생성
//			}
//		}
//		
//		this._syncCellMatrix('row');				//row의 cellMatrix 기준으로 col의 cellMatrix 동기화
//		
//		heRoot.insertBefore(DF, heSheetPanel);		//실제 Document에 추가
//		
//		this._createHScrollThumb(heDiv);			//hscrollbar thumb 생성
//		this._createVScrollThumb(heDiv);			//vscrollbar thumb 생성
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createFlesh', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createEdgeHeaderInner = function(heDiv){
	try{
		var objLayoutSize = this.attr('layoutsize'), htElementPool = this.attr('elementpool'), strID = this.attr('id'), css = QBOX.QCELL.def.css,
		heEdgeHeader = htElementPool.get('edgeheader'), heEdgeHeaderInner = heDiv.cloneNode(), heCell;
		
		heEdgeHeaderInner.className += css.EDGEHEADER_INNER;
		heEdgeHeaderInner.style.width = objLayoutSize.edgeheader.clientWidth + 'px';
		heEdgeHeaderInner.style.height = objLayoutSize.edgeheader.clientHeight + 'px';
		
		htElementPool.put('edgeheaderinner', heEdgeHeaderInner);
		htElementPool.put('$edgeheaderinner', QBOX.$(heEdgeHeaderInner));
		
		if(this._createEdgeHeaderCells(heDiv)){
			heEdgeHeader.appendChild(heEdgeHeaderInner);
			return true;
		}
		
		return false;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createEdgeHeaderInner', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createRowHeaderInner = function(heDiv){
	try{
		var objLayoutSize = this.attr('layoutsize'), htElementPool = this.attr('elementpool'), strID = this.attr('id'), css = QBOX.QCELL.def.css,
		heRowHeader = htElementPool.get('rowheader'), heRowHeaderInner = heDiv.cloneNode();
		
		heRowHeaderInner.className += css.ROWHEADER_INNER;
		heRowHeaderInner.style.width = objLayoutSize.rowheader.clientWidth + 'px';
		heRowHeaderInner.style.height = objLayoutSize.rowheader.clientHeight + 'px';
		
		htElementPool.put('rowheaderinner', heRowHeaderInner);
		htElementPool.put('$rowheaderinner', QBOX.$(heRowHeaderInner));
		
		if(this._createRowHeaderCells(heDiv)){
			heRowHeader.appendChild(heRowHeaderInner);
			return true;
		}
		
		return false;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createRowHeaderInner', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createColHeaderInner = function(heDiv){
	try{
		var objLayoutSize = this.attr('layoutsize'), htElementPool = this.attr('elementpool'), strID = this.attr('id'), css = QBOX.QCELL.def.css,
		heColHeader = htElementPool.get('colheader'), heColHeaderInner = heDiv.cloneNode();
		
		heColHeaderInner.className += css.COLHEADER_INNER + ' ' + css.COLHEADER_AREA;
		heColHeaderInner.style.width = objLayoutSize.colheader.clientWidth + 'px';
		heColHeaderInner.style.height = objLayoutSize.colheader.clientHeight + 'px';
		heColHeaderInner.setAttribute('id','colheader_inner_' + this.getID());
		
		htElementPool.put('colheaderinner', heColHeaderInner);
		htElementPool.put('$colheaderinner', QBOX.$(heColHeaderInner));
		
		if(this._createColHeaderCells(heDiv)){
			heColHeader.appendChild(heColHeaderInner);
			return true;
		}
		
		return false;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createColHeaderInner', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createViewPortInner = function(heDiv){
	try{
		var objLayoutSize = this.attr('layoutsize'), htElementPool = this.attr('elementpool'), strID = this.attr('id'), css = QBOX.QCELL.def.css,
		heViewPort = htElementPool.get('viewport'), heViewPortInner = heDiv.cloneNode();
		
		heViewPortInner.className += css.VIEWPORT_INNER;
		heViewPortInner.style.width = objLayoutSize.viewport.clientWidth + 'px';
		heViewPortInner.style.height = objLayoutSize.viewport.clientHeight + 'px';
		
		heViewPortInner.setAttribute('id','viewport_inner_' + this.getID());

		if(QBOX._s === 0 || QBOX._s === -1  || QBOX._s === undefined){
			heViewPortInner.style.backgroundImage = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXYAAAGkCAYAAAFSrz7XAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAFxAAABcQARhhEdsAAHYGSURBVHhe7Z0HfBzF+fdvyzVVF3XJkqUrKpZs2RhTDTgkIYH0ENKAkJ6QQAoJqW/AIY0ECAnpBQglBVKoIflTDAnF4CLZVr0iybK6XGSVq1veZ04jReX67fXn++HwPM+e7vZmn/3NM7Ozs6p4YLdPyOTV23vsk9QVFxj6b8zs2bOHr67e5KXmKgyGEsW+awFFPpDUMi0GRZaZM43G4v3UjJmYdj7cnV6JUkchqg+xWkdvZlnuJmpGTaw/IuI/DlXbdXXFLMMwi++xWsdeZVl2BzVXIUnyUZOpdCM1IyLsnQ+20zqdN7eystJBzYAE+wxBcFXV11cPUzMsQu481Nw/oebeTM1VRHroe3qGP6pWq39HzVVE8nks/TcgsOOFtLiKaGK2oaHy9xAsZdSMiZA7H4hYTjaDoWxclmWBmlET1c6H2nGbbfQym21ijJp+MRpL1bQYNVHXfCDISckw3BMMoyol5T17+nV00yrgPd+ixaiIeOclSXiSFpdBdtSfmlRX5zoDqUxdXckttBgVEe+8yVTxFlqMiJ6eY7+kRcVQPGwSCe68P4gixSKn4RD3mic/wOORNlNTUSLe+UDKMT7uyqHFVTQ2lh1paNjwaWoqhmI1f+651U5Sy9ByzlFXSAJVRLhEtfMWy+hrtLgKaDnz4h3rC0S18xzHnUmLSSXqsIn1kCtByJ2HEDiPFleh9A8QBM+HaTEswo5Ni+V4AcdJp6m5ilBxDufJIITbBkmSfmkylV1LfEt/fDTnScR/AD2rHuig1FMzasjOkp2P5eSO+g9jDZmVHfVoiHrnF4j0R4ii8KzZXPF6asZEzDtPsFpHN7Es10HNgMQSIv5Q9MPs9nEvfCRPzUWU3mkEiYFlsbhyjH16+vRPt241fY6ay1ipMk5nsba5mfGQcjAFGhoavKugoPjXBQV63wnu73xY+HtBENvq68u3+Zx+WEwPyB+svDhQUFB4/codgZbyO/52Tq+fdAfb6Xjg2/mlXwq/1peXT01N3Uddy7ZDE/8NWvTVGnmJouSiLlVX19HFcciF7UtfF164/Xq6OWaWJWbkw+Ew+XpEZ5xh/hCxfRuA7u5jdy39EUu3mc1lepfLeQXxNTXVfIy64w7b1ma7nZb9Ioqi7zKMRqP9rM8BLN3xBTZtqnmYFhchP3bli25SBFaSxKto2S8ez4ldtJhysBDDzbTsF72+ZIYWF+noGPwALQaFHKGVL7pJEdjWVuMELatstnGf1C0wOjqaS4u+HXE4HH8gZb1e96DPuYSFsOjsPGqlrrjjq4kjR/qvzcnJ/bnPE4CFWgsVt+R9od4zPe1sXtD5aFjYF5/atLTU/mJ2dvYdpLwSp9O5c+nhJmXoDfnduaXvSwR+v2xlzSV6pxSB/IiOjqNBwwlJZ8gRXnjt379/8VrVyvAlts028V9qhh63SQQLIjA4WKzevn27d+GHkG1dXcPbFuz+ftvHfX9ASYmd98f/REIKeGk/ZXd+AchY82gRQZRA8ZYTpOxhhlFdTsrxbpkV+/AFafNHvH5EzB/a03PsFrVa+01qBkXpHxH1h8myzPb1TYrUDBv4O7fRWBpwMkUkRLXzwUIkXNxuR0VT08ZRakZFRDsfaqehVr8Htbo4NNLdPVmh0chB543FEkph/SEoyKWgIH6nqhDC2QGbbeQTDMP/mpqriOZHhEwPSG0H2vH77vs5F+6XGo0Vvwn2XvI95DyiZliE/OJAoRLL4Q70mXV1xRzDMBI1QxJVYiaKgq8RipZYfvhSotp5s7nib7Tol1AnNgHy93fSYtREHDbBruLZbOMibFtWIaHinBZ9xD1s/O14b+/IBWRHVu44gfit1tHFrpuSRBU2K+F5/gVa9AvLcufT4jLU6sBzdMJBkZ2PlurqaictRkVSdz5W4rbz5ESVJHnxikk8iGvNm0yl+mBqY7GMRjRFZSWK7HyoRifQdo7j7qbFqIh450H27qTFZZAdDPUjlCbinQfZ83tddgHyA5zOCS01AxJOKxyKqMIm1Bc3Nzcvu8ISL6KOeUgF3LSYNELuPCRQPbS4DEgFNEoc+qVEktcQwj7Bgu0opMifhkzzV9T0y8LfL5zUSz8v2hM94j9SsrbhqN5tMpV9lJoRE9Uv7u8fL5MkJqaevxKyGtMHQMd8Dvq3EWWGSrYFinxQOKGkxFTElShWCwR/P0KW5ZNGY+l6aiJIslkW8729w7M8r14204MWl3HkyMCDOTk5i9NWIK4liGuOlPftO2JYt67U5tvgB/KZKxuslYTavoAvPdizR+bJHyzdcQLxkeEMavogvqU7TiCjBgtfmEh8O19dPbk4q+/EiTED/OLFnIfs2IED1utIeekOer3ed5CaIRJIXavUhmxf+aKbFGFZjZEP37Fjcx8UffPavV6Pb07MmjWFPyX/LkC2NTRUPkrKRLuJ7XK5XlR650KxWGv+vrihoaqFFlUvv3zo+7Tol02bqnfS4iKkYpa+2tv/N3NKCRZ3PhRFRcXvpcWUYXHnQTFWTR1fislUbqDFsCFHc+mrtbU87BvAwoFMTfSpSV/f/07aBZaeD0vzkqV+QkfH4H8WQoO6EoIvzkN96dLzIdh7BUEYnZ4+sTOYzk9Ojn+juLj0u9RcxfT09H0FBQVXU3MVS/fFFzZLHStZuS3Qex0Ox/n19RUV1AwIywbPLE+ePB52P2HVjhw+3Hd9bm7eT6ipmptzbt+8ueYANdODm26Sk9JqIolkQamWHunnn993KSSA/dT0sTISwm6k4smCCJB/V/6IlfZSUmLnVxJA0Vb5UnLn/QG1H9FoGoIEwG9Tnwr09Y2eJcvcXmoGJdIr56lASlU8uWUFKjCmBYegW/IXo7H0fdRMWZJa8QMDE+XQERqhZlw4cOB5/oorroh4DmK8SXjF22xjgwzDbqBmQhEE79fr6yuDDoEkirhXvNU6tIFlNYPUTCmS2TbEpeItlrEOjmM3UTNCxLcaDOVPUCMibLaJuxhGtXjXaySIovfzZnPlYrc93ihS8eS+TYeDm6VmRAiC8ER9fcVbqakoZHIBRLSGmhERaHBHKWL+cOjavAT/nDtvhU+8f9hSor3aHU8pSnjflVxBSWSlE2prS8fId0qS8CHqSjoJq3hZlnxXfYCkjRyaTBX3JfqgByIhFS/LKofRWBbVd/X3y7qFsbKlL6t1/Gb6lohJhcpPiMZH+kNDrXu9EuitytBbjfjAkgNIi35Ja40nmk6LIVmI5kgqnUD0a+FvI1m8FuQvaasJxL3ik6npoQD5iyrnV4K4Vzzin7SreNJeyLL4CDXTlrSMeKOx/J3kAJAXtCFBZ6ekKnGveItlJOwbNsmkQFoMG2hDxIWDQF719VW+5V7DYeVcv0QS94rnOH7VUmyBIDMxFypQFMWo1p0LtzG3208WwnuTdsYn5ItD5cv+MJvLf780kqlbEeDM4lQqYYqaSSFhRzyayl+Kkgegr28y5oexxEpCT7X5Tk7y7wNLBZKgcfP3sKXCjXjJRFHtjFZOQHMfgIY16NKkkQIHdhY+0+96YcH2ExKrTujRBl1pVAkUrfilhFr6JRQsyzTW1hb7vfNzJZCyfgGypzuoGQB+jcGwzveEgpUVL4psodlcNE3NhBC3il9JtGdDPJAkyWkylcW0qEWsJKzil2Kzjd0HKbSi0hIaT73BUGWhRtJJSsUvBfQ9qkXPQkF6waRDRs2UI+kVvxKbbfQ3DMMtW7I0XCTJ83aTqeoxaqY0KVfxK7FYRg9wHOf36QSSJP/GZCqN66OVEQRRgqRJzeHDR9fSoqqlpXoq2KgiNJTMwMBUwCcAB2PjxjWz8Nm+sZn+/lNrfE5Kbe3asAfKVv4tfO4MGZKmZsT4rfhIcm6Px31LY+OGoM+g7ekZLlKr1ZPUDIkgCCfr6ysWF6EIdcN+MMjTbshzV9rajm5a+SSESAbdVtZJqCfjhGLpF5Mr9VFPZYBOiQidkmVXg7q7R7ZrNPw+akYMRDoZo2f8Vfz4+Ni/aTEoIyNHf3z55W/9d0pW/KFDfbfl5eXd4PMsIdiOQbbRBdlGIzUXWfib3t7hMZ5Xl/qclFC59f79PUVr165bPDMcDseLLS0bd/qr+EiHiFOt4n2jkysr3ev1LntuiD/M5vImf+8hO7h/v71wZaV7PExBqA7N9u0Nx8lnLrxIpdNNGQfb1mY9SsuLNDRUvkiLIRkdPVFAi4tAZLXT4iKNjcWrnh0UC+QAh3opvXiFkrA5OblDtBwVeXmaz9DiInNzjqBLrSFU40l0+KwlhJIaQm/vUCvPa9qo6cPlch7etKlmS7Sf2d09dESj0TRDttQN2VIT8WWsxvvbgYXTtbPz2FnUtUhv78g42bay0iENnCKVTsrBPpPcVtnRMWikblVn5+A9C9tIpROfRqNtJHZX10DUPy6VWVY5EG2vwA8/m5oRESh6LBaLluPWRLxyLxzE45DLF5NyLHk84cSJia+r1fmPrYz4cBkY6Lt148a6r1AzYvzVzbJrro2NVeeQN5GXx+M5SN0hgTRx1XI9C5jNZvfCZ5JZX1ChAa/0TE+fvm7hvQuVngroAVpUDL9RGoiODnu1Xp+/KgsiFUWLCJLaYKRSenvHfUnBSurrSw/R4iKvvHLQVFxc9V2v12MHef4adS9j4fPUavVUXd26VSqRhHk1qQmpYPJiWbmN55n2kZGSzoVK7++f2EpepNzTM/yjwUHr0PDw0d8NDNgX54UufQ/h2DH7meRzJEl4gLqWgRUfBpKkOkheNtvYNPTqv1xaWrerqqrm3/D623//u/8zL7xw4LMnTpxoIu8hKTD8SUglwYqPAKOxbNXwSEVF9c+qqjbcdcYZDX+kLtXgoKTIk8cQBEFiJOXTSZtttJlhuCPU9CFJUq8s8zsSPd9RKVK20u128jj90GuTSZL4R5Op/IPUTAtSrtIhsh+ByH47NcMG8u6ttbWlqy68pCIpU+kWy7iB45ioRx0XiOeaA0qR9Eonc2T6+iYVrST4TMWe2hsPklrp5OIHRGVMa0oGQ5alv0EHJ6aHoMaDpFS6xTJ6C8dxYT0sWwkEga2qry8K+iTlRJLQSu/tPV7J81JMF9BjgSzTEmw6YKJIWKXTwaGkAzn+gMlUVkvNpBD3SrfZxo4xDFtFzZRBkoRvmkwVAR+KEU/iVuk9PcNfVavVUS8TCxnIlFbLtWzYUBRQjqzW0ffCAb0/lsaY41QVGzeWxPSAv0hRvNKHh4dzXC51VA+2gWxjDLKNcmpGxPj4eN7MjGoaDkBUvymR14IV/aJodRuiehTy6pCPmgkXSEWlaCofDvoxOOjV1IwbilzUIOsCR1vh9933c07JCifA57FENqgZNiBVG8jvIDcfU1dciDnSo61syCKmIItYvLsjXsSSNcVLcpJy+Q4yhycTUeEEUnEgXymRri6Q8EqHCn8CUrW3UDMhELlJpYpPaKWDpJyCCo/LcuOhIBVPi0knoTsCkrKOFpMCGfalxaSSsEpXq11JXeGCAFmkJIrCc9RMGgmpdEmSndXV1U5qRgXJvUkmcvToZEzppdlccTEtJo2EVLrJVBp1lENX/xVS2QudHUGQh8kB8G2MEq/X+05aTApxr3RIGqKqIKt1/E2kslmWW3VDAzkAZJvNNhbVs54aGiqTupRt3CtdFN0RdatffnlQP1/ZzFPUFRDoQZaT9/b0HHsddYUNBMNJWkw4ce+RRtKri/XyndM5oW1ubvZQMyhQ6SGvzWZUj9QfUOFzsVQ4Qa8vCXu5Q/iupHWW4lrpkJ49SYvIEuJa6Wo1F9ViyYlCllUxpbHREtdKJ89DosWUBJLQ39FiQkkZTU8SSVnyNq0qHTKOgPe1phNpVelOp9eQyGuZ8SKulU4eLkiLijJf8ZLf2xMjARrSVSt/JIK4VrokMR+hRcUxGMoOk8qXJOnv1BUx0JAqfpt6OMRZXuSbaCFumExl7yaVH+0YTzKIc6WH/+BYQRA+R4tRYTSWcgcOpMfjgFKmIW1oqPwdjdh+6oqYK64If91Fm20iaQ8pj3ulw4+LaMoaRGxdIjIU0POv0mLCiXulw4+LKoMhFS+KRXG5mwLOpqReK02IvFitoz+mxYgwm1nfQj6SJNxDXYqQ7Ef+xHwahxpPXyARkhEO/f39ayQp9xQ1gxKvfU5YQ2q3j0e85lc88Hrz/T6FJpEkMHthtFDx76ZGVpPASicwf33ooYdS9lkYiSLBla5SnXHGRUK2V3zCK51AKp48IpOaWUfMlR79/EBhClLJ+6mRcsQz24q50hmGkcgOer1CxA+lYlnuSpJyAoqecXb76A6rdXxxGdpIyMkR8+Kd3ir+4VbrWDfLsg3UjIhYF1Ow2SZM0ANe9nSwlRVosRyv4jjpGDUXEUXPR8zmKkU7YYGI2xENt9PkH/kRg6E0rPmGg4NT6zwe9zgcrIAjjJIkO0ymUt867CsrHc4yh9E4vy1RxPU0gh9YAD/Q9yTGVAAq/1eyzH13odLjLSOBSMiXdncPf06jUd9JzRRgZo3BYEhaMCT0SNts406QgaStwwJS8juQkqieu6ckCT+9SKYSjyc/BmOppqcCSdE0QlfXQLlWmxPV/PJISJXlRpaStEpfAFLMuyHF/DA1FUOtlk3V1dE/iSCeJL3SF4DOjINlmZinREiS9JrJVLbquR+pRMpUOiE2vZcFyO3jth6YkiRlwCsQC0MKguD9AHWFhU7nzU2XCiekVKSvxGYba4FdPAQHY9V+wlnh1Wi42urq1FkQDUEQBEGQBJCU7AUyD+bIkcHFB29v3lwTdPLPyod0R8LCw8BXfkZOjkcoLS2dpWZQSP9hYGBq2UNJInnI+EoCVvqBA73fXrNm7f+j5jJEUfRCblwYycoWHR0dGq22yAVd/oDfOTV16ttnnFG/ak57LBdEFsbMV36Gw+GYamnZGNaSVs89t/eympq6J6jpI5ax+FWdoyNH+q4mOxiowgkcx6m9Xp0j3MqwWscc5G7mYBVOgO/8FvlMssYidWUkyyodKseZk5P3B2qGBakk8rh7aq6CbIfKjmhMZXaWmenoGIh4kYV0YTHyYr3A4O+icrhnQiAmJ6cKzz7bPL3ycyRJmpucnAjrGdrnnrv5TeTflZ+RTHnx/WF7u/0t+fn5j/s8K5idnf3Zli1115Hyyy93GIuLizohcv3e1rJ0R3p7Rzp4nt9EzUWgPThlNpcvW8uro6PvbXp93qPUXAb5zJUVBg3bUaOxdCM1wyKVKt0nL/4qfG5u9s/kgxcqnHDuuc02k6lMSy4MUNcyurqOvUaLKn8V7vV6i1dWOKG5ue4x8l0Qwcsq5tQpb8o+ST0W2H37ut5Py4vMzEz/ePPmulX+BUBGZH9HWqvVnkn+PXJkYNVthqdPT21qaKg8Tk2/wAH1HUxS2eTzt2+vdPg2ZBjsunVFiw++W6C11fhFWgyKw+FatcoFyWlzcnJWzVnZts3cRYtByeTKXmCVTDgcc7fQYkhaWqp/T4uLdHQcXfVcTkEQfkCLigBnWg3R6FAv+vaUY1Wlt7TUfosWo0Kv161aYbS+vsLvk2uzFb8NYixAD3+V1pOZXrSIAKsq/bXXumO6RWV6emo/LS4yN3fqT7SIAKsqff369X+lxZC0t7evSuny8vI/TYuLFBQUXkqLIbHbx0ppMSAkTycNbqgXfXvKwbrdrsO0vEhn5zETLQYlP79i1Sgd6Hf37OzMqqlr3d3HnqfFELBjpBHs7u7Op46Mg21qql61bopOp7VANAVd3MBmG191Ayz8jW95pi1bDKvWxtJotBcGq3iSai7NODSa9b7u//79w0lfGFlpfPICHcFV93j29U16rdbxVZF88OBAE6kMSNtW3fYCXfPFsZvZ2blzaHERUvHkb3t6Rn5CXWSSkZEsghlovksm5uyLurc0yqJhbm72CujFLj5fn2C1js6wLBf1MO3CPMRY943oeyyfcfRo31tWjr2EC2Rzrzcai5+lpo/FhjSWhsfhcFy+ssIJJlN5PhkRpGZEDA4Wq0mFUzOjWJa9RFrxoihNkL9padn4N+pahclUlud0usJeVooMepHP3LWLSeqiCfFkVcpIfvDsrHsDNYPCcWxJOKdtc3P1PeRzp6ZOfYq6ViEI4vTgYKd6YdArkwkZ2f39sk4QxuZAmwNWRqRnSLYTMqpqaxkXaDNHKlYQhHHqXmRm5vT7aBGJJ21t1l8QWYk1q0CiYM+e/pR9eDaCLAMbQEpv77jfZWTr60sP0eIiNtvEQ+Rfo7HkCp9jBVbriQ2SJPiuBfv7e6x0SqD2yV9mtvDeQFlbW5utq6CgoJGU/b0n43PicCGVs7SCFmyylkB//8RWMvB27NjxKhn69UNDRy8hL/pWMlinIe+hpmrrVmMTLfoFKz0Es7MnHpUk1cG1a9VzHo9vTQGmqqrm3+RFtpOo7+ubdJP3kHJv78g08QcDKz0C/M1iGxo6dt3IyNCXBMHrG5HleT7kdQCs9LBhDqyscEJV1Ya7KiqqbuN5ddijqVjpYXLs2MB9tOiXSJaoxUpXCI47nhKLfSIIgiAIgigPDnhFCVnlVJKYh1iWraGuiJFl6W6DofTj/jpdiPJgsIcJuXOT5/kRCMy4recjCN7P1ddX/pSaiMJgsAfBYhn7HMexSVk/VZIki0ajO7umZk1Yj05BQoPBvoT51SPWt7EsF/QSUDIQBPH6+vryu6iJREHWB3tf38QFsqx6gZppgSiKtpycnLOrqgpPUBcSBlkX7BaLpFWpJg5AerJqKYN0xesVbmhoqLiDmkgAsiLYbbbR1zEM+xT83LCfDZyuyLJkd7mONzU3N3uoC6FkZLDLsqy22cafYFn2jdSVtUBdnG80lr5EzawmY4Ldbh97A/ycJ7JBvaMFcv0DKtXMeWaz2XfzdbaRtsFO7ni32cb+j2W5i6krqUAn17dYqSQJD7Asv+omdIaRPyrLjBr+5cBKgSURZDfDiJfU1VWkVec8FtIq2Pv7RzdKEtubaPWGE0uWJPEFhuE+bjLF53kzZE3WuTnmC/BVX4Lfl/Ali0RR+jf8tssYOAOoK+NI6WAnz03euvX874FS3khdCQEO/B6OU73fYChbdWNtIiGtV1/fxLug1XgQgjCBJ7js9nikhsbG8gHqyAhSLth7e8fqeJ7pTqR6Q1C5vF6pMdUPLgl+SN32QOp2AXUlBGjVnjUay96Y7nN4UiLYrdaRH4B6f4WaCQECR2ZZsRZy1qPUlVaQ3bdax/7Dcdx51JUQ4Hs9UG/mdKy3pN8oY7dPvJTIQBdF8Z/33fdzzmgsZdM10AlEZc3m8vPJXbGi6DSSk5duiisknZJlfoCcbNSVNiRd2Umwwz/nzlvxQxSFJ83mirdQMyPp6Ogv0+lyyMzMuB9XfzfgpjpZcAukfIyoX6YHOqG5uXaMtFiQZZdRF7KEjA120qyr1a71BkNpNXVlDWQUiZzgZLiUuhAgI4MdUpZnicJVV1efpK6sxGQqv0gUZSM1s56MC3ZJkr4BKcvrqZkUoFFhenuH/9zTM3w+dSUNs7nUft99xRxp6agra8moDqogeN5QX1/1DDUTSl/fSI0kcW3QafP7WDc4CZ8zmcqSOrXBZhv3wv4FfZBBuKRjBzVjgl2S5OtNptKE3clD1NtmG7uDZbnPU1cEyG6WVZ1dW1vaTh0JQ6mAx2CPAiWCnYydm83ll1EzbvT0jNZyHHOQZdmon5rtD1D9F0D1L6JmXCEnaV/fZMxBisEeBbEGO2SiDqOxJG4PP7VaR+5kGO56OLAJqSsIRo8se40mUxVZvTMuWK1Db2NZjd8n94YLBnsUxK7s3hqDoXKQGopgtY4PsCwT9XowSiLL0majsewINRUD0hnFn02e6qT7aMxxpQOdABpeTItJRxC819KiokCL2EKLWUO6B/uP6b9IhMRrXn4qk9bBzrLy3bSIRAGou5MWs4K0Dvba2tIxWkSiANK1n9NiVpBxV1ARJBAY7HHE4fBUy7J4I16qTw3SOtghhlJ+/43G8h+RSWnzN1mwhbDPKXPrnySJl9JiVpDWwd7TM2yixbTAbC6ahsCvJYE/PwVX+HIyVZ9lOQMtZgVpHexqteZ5WkxLTKaK2xZU3+M5USDLUsI63BbLsSr4RztvZQdpHewMoyoj661QM61pbGycMRrLyhdUHwI/rpPaGIZ/mhazhrQOdsLMDGOlRcUAtc0ll8Mhp32AuhIOBP71JOgbGjZ8mroUw24/WQgpTAM1s4a0D3ai7nb7+OXUVAwy78NkKr9qQWkFQTJAdr1qWbv0xJvUxZ+SRdoH+zzMw/FOZ+rry/qMxpJ8EvhkKQ5IM4I++DdVsVpH74f6yqpcfYEMCXaVanaWmSHL5VEzruzevVuCNONDC6oviuJHkzmqEi5W69i9kL5cSc2sI2OCnXDGGRcJiQr4pZjN5XcvjKpArs9LktRNN6UM84HOfoiaWUnG3Ja3gnoIPAstZz0Wy/EqjpMUvRkE57OnDr2gZHtpGUF8ZGqwq6DJPgtaDdlqHdpAXUiWk7HBvgDLagZttnF3MnJ5JLXI+GAnQG6pIZ1XDPrsJunBLgjCr2kx7iwEPUlv+vrGt1A3EiGyLDvSrXNKSPpozFKGh6eLnE7nIFSknrriDhw4jyRxBrO5aIi6Mg4lRmMkSbrXaCz9CBybtJ2bn1LBvpSbbrqJvfLKT93PstwHqCshQEvzqfr6ioS1NuEwODi1zu12tUGne3FFYlmW2mZn5Z2treVz1BWQaIJdkmQnx3m31tVV9VJX2pOywb4Sm22sRZaZ11g2+rVOokGWxUfVav0Xa2rW9FFXXIGWhrNax6/nOOaHcHjCXqZOkrzvNJkqH6HmMsINdgjwI0ZjyZZ0Vu9gpE2wLwUCgoW8+z44KB+kriQh/wl25XZR9DqgNQjrqung4OA6p5Mv5Xn+y5AavA7UWvHFmCRJbDcay7YtBG2wYBdF4XKzueJv1Mxo0jLYV0JUH37KPji4WTnBKRQQ0J/hON63kgCcCKDeZRmr3sHIiGBfClF9m238ZXJRibqyHkkSrjaZKu6nZtaSccG+kt7ekQ9BynAvNbMCUO/DeXmqc8vLQ3des4mMD/alUNXvANVvpK6MAfoNV5rNlQ9SE/FDVgX7SiyW0Y9yHPsbqIa0u5Isy9LM7KxcHs7QIzJPVgf7UiyW4wUqlfASBH8zdaUU0CpBh1L+OXQur6MuJEIw2APQ2zt6Dc9z91AzKUiSPMXzmtra2rVT1IXEAAZ7GExOTuafPi0NMQwD6h8/iHpDenKnyVT+RepCFASDPQoslpErWZa7B4I/5gdxQXSfUKvlHTU1ZQm5QpvNYLArBLlJRJb5CyD12U5sCOKP+TaoZCfDsL5REjg3fqLROCYqKysdvk0IgiAIgiAIgiAIgmQfMY3GvPhid35BgebtgiC+Mycn9yxBEAr0en0+2ebxuB0sy07Btn5Jkv8qy6o/bN5cc8r3hwlClmWmo+PYdlkWb9FqdRfxPBd0CjDsq8vtdj9/6tTMJy68sCWiO3v27TtiWLcu8Y9bPHZs4GcXXbRj8apqZ+fRTTqdvoOafnE4HKdbWjYq+kh6wtNPv/qWurrax6npF6jjtvr68m3UTChhBzsEDnf4cN8DeXn576OumHA6nf8pKGDeVF1drdjjCeeDe/CnOTn6z1JXzMBnynNzs9/cssXwPeryS7KCfWho8K4LL9x+PTVVbW1HNxUUhAz2KQj2tdRUjOee23tZTU3dE9T0SzKDPegEKBLg3d1DHfN3408KSgU6AVqAC7xenWN+IaOxIfiuqCdjHTkycB7dR0nJQCcwAPzu75LPt9nGpY6Oo+fTTUia4TfA9uzZw0MAekiAazSaTdQdNyDdqYTvEiGYxJ6e4SLqDklPz8i1JAhzcnJepK64QgIfTtL/ku/s6hq8kLqRNGFVGgNKfggCfDM1k4IkScdNprJiaq6io6NDo9MVOyH2ImoNoPWAlzQ+PX36X6DWJ4hvZma6ZM2adW+Gz1rve1MEiKLkNJlKc+Fv5XDSGPj+o0Zj6UZqxgVMYwKzLNiJYtFiSKDT6ZqddZyzdWttO3UFpa3NugsC7GlQ8bBW5CKBefDgC/wVV1whUpeP3t7xLTzPhPWd8BmywzH33s2b6x6mrrBoa7NcWVCwJqzb2GZmZh5pbTW8E4M9jXL2cAPd6Zy7gaxDDoqmDzfQCVu3mvaAWvPkb6GyQ67LAmq5ar31gwctxeEEOgSVpNVqi8ia6ZEGOmHrVvMDZD+PHz++KqWCjvUrMzMjeWQ7eZFAp5uQFMcX7JC6hJwvDfHjJge3ubn2DuqKGlCVTw0OFqtJUFJXQLZuvWCGFlUFBYUhH53ocrn2QpBzVVWFvjQlFs46q+kE+c1qtStnIbibm2vObW1txbuD0hAGAv1cyNHJAwECAjm0AKqspqaCyIzdPhky4MfGRi/keV5VVFT8AnX5RRTF42ZzecBcP56Ek8ZAPZ6YnZ39IzWjhmUZFbRYnyN9BepaBNOYwDCdnYMHdDpd0C8XRaHEbK6YpKaiWCzjl3McEzTVgBbgJATKBMcFf5wh5M/1kFYk5YkbiR5nn5kR8/zdf4rBHhgWmv2QHaZ4BTohP196ihYDAsGug/+HXPYuWYGOpAcspAfHaTkge/bIMd+RE4i+vvFcWgwINNvC+PjYHmoGZO/eQ2fTIoKsgj15cupmWg5IWdnIAC0qzvr1RSFHV0RR+o0gSDdSMyDr15cm5OJS9Mhe6FeMKPHasqXMRT8UCRPfOHs4w45ut2dPU1PV66ipCFbr6CGW5YJewIIURiZDiKTc2zs8wvPqct+GAJDONLxfC503RRbLh68ni6gKsiwdh+I5ZnOpnW5aBo6zp8k4+9DQ0QqfFQStVrPLah2Dgx57SjM6OppLpgaECnTCyZMzi++pr6+spMWAsCzLk6kHBw9av05dUQOd9yfIZ8GJw8C+FkNH2kaEgbw6Oo4e7O7u9s3wRNIDX7BfeOGZo6dOnXiTzxMEcvUTDr6XHGwy+Yq6w6az074TThjJ4eBmSfxQd0Dm5mbfu2OHcalKyadODWpAvUO2RIWFhQuTtzzt7Zat1B2Srq5j77LZxny/UafTXUbdq9Dr9Vs1mvXTFsuYEwQgpqnSSGJYdpDIJCy1Wh3xyAsJPlEUxjhO/ejJk5OPzs7OOWpqat8HwXpRTk5OA5wkEQfD3JxzXbD57xbL6AGO45LSHC4wNzf3h82ba68h5XRKYwTB6xkdHVa0M9/R8Zq1qWn7haHSGOh/dY6MDF5FTUUoKsrpbG5u9lAzIH6D0GIZeY7j+F3UTChw4txjMpV9hJpBsVgsWpYtnIZWQkNdCQEOmMtkKs2B711sYRI9zr6SEycmvr5jR/P3wwn2eDAw0Hcrw6j+GyrY4wE0rK83GoufpWZA/KYSZnPF68ilcTioIcfAlcDr9YxPT8+tJd8ZbqATzGazm3RGyd95vd4j1B03JEk8ZDAUs2ZzmX5poCPpQdC8GQ7qpSSQDhx4nne5nAeoW1FAyR0QN2/furU2pvUMGxoqN5N9rasr5iF9ivmS/AJO59wDJMDnT8TyVmgMMcjTlKg6Vh0dsoZhhj/C88xXeV6tyDOBRFE8ZTaXr6OmokCuzHV3H2ucnj59zfr1xW9zu93k/kvfXB9oej1qteY0dNAfzc3NfXBycqBj165dAtkWCQcOdFfk5RUkbZz/1KnTN599dtN9pLPc1zf2YepOGNAP+DfDuGY4Lv9y6koYPK//R03NmpD3Nys+imCzTVwqit4/w0kQ9rAcHCAPSUeoiSBxQfFgX0l/f7/O5VLv0Wg0fnv/siyJRmNZ3KYjIEjSIA/zfe21rvdZrWNem20cRB3HqBEEQRAEiQZMIZBlkGkStBgWZPrG9u3bvdQMyPPP77t0w4aaJ6lJJqMNtLRsrKVmWLS12boKCgqWPelQllUvGo0lO6kZlJDzU5DsQpbZdy9/kQeXLUV+z9LtZ5xxRsTDtNGSn1949czMTMib9QOByo4EhUzcWzq3idwov2sXsyzADx7sPVBYuHZxntKJEyd+tm7duk8zDONbGaKurph74YX9bwqk7F1dxy7TaDSP+ZscKAjClEZTXl5by/jm7z/zzMsfq601/ta3EUBlR5LK+vXrP7sQ6G63++TNNwe+P6i3d3hGq9U+sRDoLpfzFZfL82nfRoDn+TWSNEnWA41ZmDHYkbhA1JxMsWhq2rB+9+7dAW+kqa+vzHe7PW+FbMn3Hp1Of45Op/mlb6PCYLAjinP06MAtoNRh3SlGFovVajWPLyg7uYeBnCS+jQqDwY4oDqT4IW/iX8KywM7Jyf2zvxEh8MV8myUGO5JUjMZSRpbFFsjth4kNCs94PO5RWWa2Q2azGdKbvQ7HbD95+f4AQRAEQRAEQRAEQRAESRNwbkyMDA4OrnM4+Gs4jr2eZdmg9+PKsuqvKpW422gsT/hSFwgGe1TIsszZ7eP3MAwb9WI/oihaWJa53Ggsi/sSIMg8GOwRQJbu3rBh7GGG4d5BXTEDJ45bFD1n1ddvOERdSJzAYA8Ti2XoWxyn2U1NxYGgd8Hnl9fWro1p/RwkMBjsIbBax85hGOYFeMXhmVKrkSTpVaOx9Dz4vmWPxERiB4M9APv3y+rCwgmSV8d1IdJAeL2ez9bXV/4Cgh5XIFMIDPYVQDrB2O0Tj0CQvY26kgZJbXieOW/jxpKD1IXEAAb7Enp7h3fyvPo/1EwZRFG06XT6s6qr15ykLiQKMNiB/v7xMlFUDSYqL48WWZYePnjwP+9f+Yh7JDyyOtjJ+u4qVcEBjmM3UVdaIIrS583msp9QEwmTrLx5gyzB19s7+m2OW+NKt0AnwD7fabONu+z24zuoCwmDrFN2q3X0IpblQj5TNV2QJNGek5N7dmVlQSS3wmUlWRPsvb2DlTyv7YOfnNBH0iQKWRYfMRjK3oVDlYHJ+GAnS2aLov4fDMOGfBpgJiCKwqfN5opfURNZQkYHu8Uy8i2O4+N2iT9VIfNtXC7Hxubm2jHqQoCMDHabbexi+OcpUPOUHkqMN6IoHjCZys6F1CbkYxOzgYwKdovlWBXLal6Gg7uBuhAAgv6rDz5Y9qPdu5V5xH26khHBDs222m6feBKC/A3UhfjnAoOh5L+0nHWkfbD39g5/m+fV/4+aSAhIPu/1uuoaG2tGqCtrSNtg7+kZblCr+UPwE1JgKFF2yzLjlGXJBf2Ee6lzEUHwroMT8op5Sy6EFijp9S5J0lOyXPJOs5l1U1fGk3bBvn//cM6aNXwvxEsVdSUY2Q2BslcQxDt0OvVrtbWlEY94gLqyQ0MnKtxukSzNfC38FvJc1qQgScI3TaaK71Izo0mbYH/ooYe41tbzvs9x6i9TVwKRT8P/fqDTCT+trKx0zPuUpbd3pJFl2Xsg8HckWvmhRfLACfgmk6k8Y64s+yMtgt1mG3kzw/D/pGZCgINPrkTeqdcL34xXgAfCah19D6RDv4SYX09dCUGS5EGed9TX1tb6nnKRaaR0sPf0jNaq1WxPIvNyCHGXJInvefDBX/0z2CL6iYBMPRYE6R8sy/l9YHK8gN//tNFY9iY42TJqqDIlg729fTQ3J4d5NZEzEomSi6Lwwfr6yj9RV8owPj6eNzOj6ofgK6KuhAD1cbPZXJExV6BTaorvQw/JnMUy8sP8fG42kYEOnbQn7r//F3wqBjqhtLR01mgsLZZltxnOyYRdDeU4/mabbdzd3z+alPtwlSZllN1mm7gMumVPUDMhQOC4WFZsqKurOEpdaYHFMvoCx3EXUDMhQF0NaTRuc3V1NXmYV1qSdGUnqmG1jo0kOtBFUXwK1Dw33QKdYDaXXwidSRNJvagr7kAKVeX16hwWy/B34GvT8qafpCp7R0eHRq8vSfhFDa/Xc0VDQ9XD1ExbSNBBizjDskwOdSUI+XmDoXQXNdKGpJ6hGk1TQk+2eSX01mRCoBPIaInRWJIvSeKL1IUEIWvuQSWB7vF4iw2GykHqyghIwJtM5TshLcOAD0FWBPtCoDc1VZ2growD8vidoPBZO6MxHDI+2LMh0BcAhb8AFB4DPgBZEOzemmwI9AVA4S8Ahd9PTWQJGR3sgiC822SqOkbNrMFoLDsLGrQ5aiKUjA12CPTH6+sr/k7NrGJ+TotUR1I46kKAjAx2OMQOaM7fTs2sxGgsnxBF6SPURICMDHaXy7UB1C3rVa2+vvxeEPdT1Mx6Mi7YoXP29+bmalzamTI7K23AdGaeDAt2WYLO2eXUSBp2+/j5vb0jD5LpENSVNFpby6GjKt1Ozawm04L9kmSmL/39ss5mGxuGLuJ/eZ7/AJn3Y7WOJn0+OOTvXwZxF6iZtWRMsJNOqcFQ9gw1EwoEEgNBfYckTToZhq2gbh8sy32LLC/d3z/eSl1JAWL9PbSYtWRMsIuiJymjL1br+CV2+4QAQf0F6loFtDZaSWLaiOqThVapO6GYTJWPZLu6Z0Sww0GU6uurEqrqZB4+KPZJlmX+BcEcVj0S1ZekXKfFMpKUu/izXd0zJNilb9Ji3Hn55UG91Tq2V5I4ck/oWuqOCI7jL4ITRYJWIaH5PFX3rB2ZyYhg53nXj2kxbpC8HBT5J6WlOgfLsmdRd9TAicJAq/Atu33cZbEMbaXuBCD/khayjrQPdgjCwXivc0LWrSF5OSjy9dSlIIyW4zQHQen7EzFUyXHMLbSYdWSAsksfpgXF6egYz4MgnCQLNIWbl0cLfP5GMlQJSh9X5SXL9YFAZGVHNe2DneNcL9OiYpCUBfLy1/R6ZgaCMKFrtUDYfwoCXiAPOqOOOCD/mhayinQP9uNKpzDkQWOQsoiQl59JXUmA4cgT/SDo4zI9Gc7lO2kxq0jzYJcVf1CWKLK5pPNIzSQTn5WKjcYSOy1mFWke7MJvaQGJADiXyQBkRi5eGoy0DnaW9UzQIhIhsizuo8WsIa2DPVOXVk4ELMu8SotZQzoH+yT9F4kCSVL/lBazhjTP2REkfNI22GVZyjplUhKjcd0QLWYNaRvsDMPirWYxQEZkaDFrwDQGyRow2JGsAYM9Tsjksg2SUmCwxwnoQM+J4pQOYn6AupAkg8EeR8xms9toLK2VJLFZkmS8AJZk0jbYvV6hlBZTHpOpvNNkKtULgnhjqqQ3FsvxAlrMGtI22NVq/n20mDbU15f/6NixLg2o/D+oK2kwDFNIi1lD2gY7CCRPi2nFrl27BFD5d0E+XyhJUtLyeYbxrqHFrCFtgx2UKao7+1MFyOenTaayWq/XvSUZ+TzDqK6mxawhrTuodvtY2uTtgWho2HCY5POSJHyJuhKCLDOfpsWsIa2DXRSlnbSY9phMFbfX1RXzsiw+Ql1xBVrGpKxMlkzSOtgZhk2oGsYbCEDRaCx/p9Mp58cztbHbT5LOKTdvZQ9pHewsyyi+uFBjY6VdlqVuaiaF5ubSWZLa6HTeXOpSFFl2v4sWs4q0DnbQQo3Sefu8upY1iaLTKCd5fZXKykoHLSqKJKm+QotZRZoHOwlO7kO0qChmc43daCxVS5L349SVMXAcV0+LWUXaBzukHHFdzs1kqvwddBw5URT/QF1pTW/vsS20mHWkfbDHI5VZCaQ2ktlcfg3Lzukhtemn7rSEYfiHaTHryIBg9+Wgj9FiXCGrGUBqUycITkOy8/logH2GDIYzUTPryIhgZ1l2x0MPPZSwobT6+pq++XxeTPrzkiLBZhv/PS1mJRkR7IRt2y78ES0mDJOp/ObBwU4I+uQOVYYDUXUQhbh05tOFjAl2yKu/kEh1X2B+YldZE8MIGyGg5qg75ch2VSdkTLATtm7deRstJpy6uoqjkNrkiaLnoxD0KXVLHqr6PBkV7CzLfX58fDyPmknBbK6622Ao4YaGelJmViaoehctZjUZFeyEmRlV0u/5hJRKJukNNZMOw7BxWfo63ci4YIdAW2+xjCT9ke5I6pFxwU7gOP7hZKczSOqRkcFOmJ1VHadFBPGRscEOCY3Wah1towaCZHKww49judaenuHPUxPJcjI62AlqtfrHFsvw56iJZDEZH+wEjlPfiQGPZEWwEzDgkawJdgIJ+J6ewRupiWQZSQ12k4nxyLLspGZCUKt1t5JRmmRMGssUvF7vL2kxrUiJJzlDevFBUN0HqJkQ4CSDE81rNJmq4vLI9FTCZpuYYxhVDjWjRpLkjrw86ezy8vKUnd0ZjBR5bPk8oLgPsiz3AWomBFkWHzAay6+iZkYSa7CDMDhYlt1WV1fcS11pSUoFOwEqlrXZxjuhchuoK+4QlRdF1Y76+tJD1JVywD5ydvtYDxyy/zMYSj9LJpvRTSGJJdgFQbimvr4iI242T7lgX8BmG2uRZeY1lk3cMm2SJFlYVrPDYFh3mrpSAotl5Ascx99BTR/QIr0fWqQ/UzMo0QQ71MW9RmPpRyI5qVKdlA32BWy2kU8wDP9raiYEURStWi3zppqasj7qSjhEyaEv83me1wS8IQVyaMfsrKNy69baKerySyTBTlKW3FypJF3z8mCkfLATSGpjt0/cByrzQepKCPPpjXi92Vz+W/huibrjCgSmCb75x/B9l1FXSCRJbDcay7YFUuFwg10UhcvN5oq/UTPjSItgX4A8GoVhhFcTmc//D9kNqcP1DOP8i8FgUDTN6e+fbBBF6bZIAtwfsiz9EoL+WmouEirY4e/uhr/7KDUzlrQK9gWSkc+vBHLaXqi+F0BV72QYzbDZXDRNNwWlt3ekEU7WNbDv18Hfv5+6FUWSvO80mSoXl74OFOyw70cgyLcEahEyjbQM9gUgcD7J8/yvqIksgeTzLDtbQVqhlcFO8nJJ4srDPUEzhbQOdgLJ50Hp70/0+Hy6AC1QO8Ow5oVgz/S8PBhpH+wLkHyeZcVxaJKz7okS4QB5+e8hZfkYNbOSjAn2BUg+D0p2mJpZD8nL8/JU52TiUGKkZFywL2C1jj4AqU1ChypTCZKXQyu31WAosVBX1pOxwU6g+XwXBH1WLb7v9QpXNzRU3E9NhJLRwb5AKgxVJgJJkn9jNJZ8KluGEiMlK4J9Aat15GqG4e6FYMio3y2KwuH8fOZczMuDk1XBvoDVOnZvJiz0CWkaKDhTD2pupS4kCFkZ7IT5qQfeVyCfb6KutEIQPNfU11dlxNTbRJG1wb6AzTbarFKxr0Fmo6eulEaSxKeNxrJLMC+PnKwP9gUg6D8M+fzd1ExB5NMsq9lYW7s26HReJDAY7EsgQ5V2+8SvQTVT5koj7JMoy8K7TabKR6kLiRIMdj+QfF6l8r7IcVwLdSUc0vmE7udPTaZSXL5PITDYgzAwcLzJ6xX3s2xi83kQ870GQ9m5mJcrCwZ7GPT0DH2G59V3QfDFtb4kSTrldLoNmzfXnKIuREEw2MMEcgoy9QBUnttKXYpBEhZJEq40myv/SF1IHMBgj5DJycn8U6fE5zmO3UZdUePLylXy7QZD6Y2YssQfDPYoIUE/PS1+Q5aZ6yFQI8rpIcaPw/8/AUH+CAZ54sBgVwAIXnZgYKpalgXfKsGCIFzAcZzZt1ElP8gwrFOSPP/huJy22tq1SX+aH4IgCIIgCIIgCIIgCIIgCIIgCIIgCJLtZNV0gb17LQU5OdpVj4TU6XLFWFe0JTd8qNVcwh+1ufI2vf7+fp1KtSbo+jjxurUPvnsNfDe1/JPM2wpjCvZXXjlcqtGor83PX3u1IHhz1Wp1Ecuyvs90uVwnwJ49derkH7Va7rdbttQfZRL09IoF9u+3F3KcfJ1er/8U7EsldQfE6xWGnM7Z23NzVb80m81u6g4Li2V0iuO4QmomDIOhZNkxtFrHnaEWg7LZRvIuuaRV8TVmrNYxaeH4B6KurphLdBwsEHGwHz7c38Dz3F+0Wt1m6gobOCEGJEn8VGNj9b+pKy4cOTJ4pkbDPc7z6lLqihiv13N0evrUzh07WsJ6TioGe+oHe9jNbmfn0U29vSMzubm53dEEOgGCb6NGo/sXBIa7s7P/UupWjPZ2WwkJupwc3WuxBDpBrdbUrF9fOtjdfQxe3fnUjaQxIYN9zx6Z7+kZtul0+g6e5/OoOyZAATWQJz/Z2zs8Dp9dRN1RI8sy09Ex8Iv8/IJxpdVVo9Fu0GjWT3d0HP0qdSFpStBgt1hGmqqrJ72Q7xqoS1FAfUvgsyeh1biCuiKGBDq0OIN6fc6nqSsuQN7/fWimu8j3UReSZgQM9o6O/hs4ju+kZlyBVuMvFsvYX6gZNoODkr6vb8IFJ0wVdcUVyEcb4cQaw4BPT/wGO6QEX9HrcwM+bDYecBx7RU/PyN+pGRIScF7v5BT0sTXUlRDgxCqBgB/BgE8/Vh2w7u6hT2k0ml9SM+HMzEx/rrXV+FNq+oUEGnRE+6APsZG6Eo7T6fhHc/PGd1EzrNGYycnxZyVJFqipADJ77rlb3kgNHzgaE5hlO3bgwNGKNWv0w9RMGg7HbGtLS90haq6is3PwxzqdLuKVsgRBdExPT72Sk5PTBR1Pp8vlzoGAOR8+qwkOUsQtxMzM3JtbW2v/RcrhBPvcnHNdvNeEwWAPzLI0pqBAG/HNwB6Pu+fUqePnsKx6LRnzXXiJolBy+vTMG8mFGvrWsNHpcg6AevtNsfbv7ymKJNDhc1SzszN/zsuT8+vry3PPPLPx9Zs21VxvMpV9paWl5rqWlo1boax1u1UVLpfrefpnYZGbq/+nxSJpqYmkOIsBdfhw33fgrFRTMyQOx8xDcJbyjY0bGrdvb9q78jKw2VwxuW2b4emGhooNojilczgcL9BNIYH94I4cGfC7YFB+fkHYT8Jzu13dLpcqf8sWw/tLS0tnqdsvTU0lo5s2Ve+amRHzRFE8Qd1BgfPI/eqrD2KwpwmLwZ6bm/cNWgyKJElel0vY2NJieC80RyJ1B4VcegcFvcjhcO2Avw9rnZTc3Nz32u32ZWnBvn1d5ZCnl1MzKILg/WtTU3VTc3PwIF9Ja2v5nNlcXuR0Ov9JXauQZck9N+d4i9lcpr/qqquy6inR6Ywv2Nvb+77rs0IAgeoeGurO2bSp4ih1RURLS/W+06fFPPicsHI2p5Nb9sS3vLyC/9JiUCA3f7i+vvI91IyK5uaay6BleJWaPmC3PTMzM28zGst0mzdvfJK6kTTBF+z5+Xlf91lBgNxXhkDP27VrV0yjCdu3VzrGxibCumqq0+nfQouqjo4ODRDy4pYgCBOQm0d9kWopkKKdAwHuXVByktu3thoep5uRNIM9dMgS1gWZ6enZN8Ya6Avs3Ln5lNvt/iE1AwJpErN/v+XseSv/mvl/gyNJaiMtxgx8vazVegpRyTMDVqfL+x0tBwTUzQmdzWeoqQiNjVVfDSed4TjmB+RftVr9BZ8jCC6Xc19jY/EMNRWhurraSYtImsNYrWMiC1DbLw7H3K6WltqIhuXCoaPj6Bf0ev0d1PSLJIluk6lcZ7GMeDiODzpadOLEKcOOHfV91Ewo4Y2zz/5CFKWwOvXBcDhmHznvvNbnqLkMHGcPDGO3TwQdHSG5utFYGvRkiJb9+4dz1q5Vh6x0Mm6fzP0Mh3CCXSnIBWSjsdjvI+ox2AMTMji8Xq+iacFSSGcVMpmQQ5G9vUOttBgQiHUcAkSCEjLYIRiP0GJcgM+302JAZmbmQt48cfz4ZDstIohfQga7TqeNq2LyPBfyXk+32xVy3go0jV5aRBC/hAx2QZB4WowLkMWE3AeNRhOyU1dQUFhLiwjil5CB5nQ66mgxLni9npAXmHQ63TgtBoTn+QpaRBC/hAz2vLy8uCkmdCoZrVZXTM2A/PWvG3tpMSAcx+nh80L+HiR7CRkckAuz/f3jZdRUlLY2a0hVhwBW7d7NSG63O6S6Hz48cDUtpiTQGR8RRTHml9M543eMHQkO0919bEKj0QZVV4/H+2xjY+XrqakYFstoGyhy0GFFCPYZo7G04NVXO+8oKioOehVVliWP0Vim6JRb0lrcfLPKd8JRl1/w5o00GGcHxfwZLQdEo1FfDAdd0Y7q4cNH14YKdILX6/VNZ5Ak8VafIwjQCGkOH+77JDUVoatr8M6rrpoQLJbh2266CdOkdIa1WAxhTe/t7h6y0KIiaLXqMFcumLmJ/P+cczaPQxoQUhFycnJ/1dHRr0jadfiwvVSn018HSsRwnPoGCHrvwYOWD9DNSJrBXnEFI3q9npBXSbVabS3kxN+hZkyAWv46nJswID893djYuLhvMzPT36fFgEBckqnBQ3b7yZgu3ZPFm3Jy8kap6YP0XwoL1zxos4152ttt76NuJE3wNcszM453+6wQ5ObmfOPw4f5bqBkV0Ef4uVar+wQ1g+J2uz5Ciz4kaXo3LQYFYpKTZe+pcKcvrwTUuwlOxgmi6NS1DPh8dX5+wZ8gRxWgFfkRdSMpji/YzzzT/DRkCGHNVc/Nzf1mT8+QNdIcHt7PdHUdew06w9dSV1Dg/Z6Wltpl68hs377d63K5QubuBBKoeXlrjkErsod0Mqk7KOPj43mwj6+CencGCvSlQGeMEwTxKWoiKc5iEEAqE/Zoi1qtMfb1TXp7e4f/HCroyXrhnZ2DP7DbJ0RIhc6k7pAcPz6xgxaXsWlT9VchvXFQMyTQilwE+ypC0FtefbXrHLKOOt3kgwQ4WX6PbJ+dZWZgH/1+rz8EwTvW2mrEYcA0YZl6wQE/CMGxlZphI0myY2bm9P8VFKwZOnrU+qcNGwxvcLkcDdBZfCsIZC59W9hA+tLe1FQdcD/ISE5urv4kNZMCnOTy1JSQR2ZuEjudhh7JfbRTUyciXuIkGBddtKMtnKHHoaGjZ5C6o2bMyLJa3rVra1iTAJftGOwDSzpf0DqvejpFogDVdppMZblwkgStkEOH+s/Oy8t9hZoJZ3Z27pwtW2r3UjOh89n9sbBOezjBHg/q6oohdsbJjUAh0z+lWfjtoViWy0KASaIoxeVqaTjAySZxnKM8VKATSKBBC3AzNROK1+u+eGmgI77YUUyt48WqjltDQ+Vxt9uR8ElVoOgnXa5JvcFgOE1dIYFUZzfkzWGtd6MU0EG+sKFhA+bpaYjfUYqmpo2jLCuXS6Dz1BVX5uZmbzKby9c3Nzd7qCts6usrv0fWhlQyD/SHBB0Tj0fYDh3k/1AXkmYEHJKrrS0dMxrLNG63u5u6FGdqauqnkOtpNm+u+zZ1RQVZBFWSTuvJupPUpSher7d3aKhU09hYcYC6kDQkYLATSA7f1LShaXp6+l3hXKqPlDVr1lzf2zv8J/IoG+qKGrLEHll30uVyNkNwKnJ3lSCIpz0e12ZI7Rp27WIUXGoaSQZBg32BrVuN/zAaS9UzMzM3QMwrmtqo1Zp3k0fZHDpkj/jJG/7YtKmmE4KzcGRkbJ3XK7RRd0RA/6F9fHxifX19+ZrGxuq43oOLJI6ohomOHBnawPOqB3ieO0+pYUqPx9PQ2FgV8iaNaGhvb89Vq9depdVqPwEnQLEoCrmQ4mtYlnHD/s/xvPokdHR/4XafeLC1Nbqprz09QwegJVxLzYRCRkLM5grf0oAWy7GzOY5v8m1IIAZD+d022+iHGSa6mIoW0quE/t7d1AxKzDtGpr1+8INDFZLEPAoqvY26IwICzwEtR8QXnxAkEhQ9C/fs6ddVVGieAqW8iLrCwu2ee1dTU+0/qIkgcSEuTQ5R+8svP3pbTk5OyPUZQdW9oOoJfQgYkp3EPb9qa7O+Jy8v/0E2wFM9pqamPnLGGeZ7qIkgcSNhnYm2tv6NOTnafTzPL95kTS4EGQwl5J7ElL/UjKQ/YQ09KsHWrbUD9fUVxadODea63Z59xDc3N3cPBjqS8ezfv18Nwp6wlgVBEARBEARB0hTMmZFFBgYmyt1uuYSaIdHp5JmamrKwHutjt0+S+5UXB0QMhmLyHN2IBid6e8e30OIi9fWlAR/7vxIMdmQRq3X8TyzLhL0ejtPpONbcvLGamkGx2cYlCO7FeItmGTx/jxoK95Y8QsKGHhEk2WCwI4tAVvE9yDTevfCam5tb+azanqXb9fqcD1J/QiDfSYtRgWkMEpCnn9779rq6ukeoSWiHtGHVEif9/RPLfLW1Jb77CF5++fCFJSWlbzAaS7/5/PP73rB0+u+FF575f7S4iMUysVVNJ5V4PNLp+vrV/YGVqUwkaQwGOxKQcIN9ZQAKgvcFnldfOG/J+w2G0jMD5ezQadV0dw/v02o1m+mmRWAb/J/5vtFY8vV5T2zBjmkMojj/C/TQWCwjJ/wFOoGcG/Df1/r7JxuoKyYw2JG44na7+2lxFX19J2vgxMijpg+Xy3kF/DMxb80jSbJvjf5YwWBH4oLX67mCpBhNTdUkeP2i1a6dHBo6dt3Ca2xs5LtqteYa2LRyrF+RdBuDHVEcURT/0dBQ9TA1A1JZyTjKy/N/W1ZWdnVV1Ya7ysoqvsFx3KV0s+JgsCOKYzKVvYcWQ8JxhQ5IZZat7izLoR/xHw0Y7IjiQMcyrOVW2tqskOIwizEILYJERmkgLP9NXYqCwY4kjfz8Ncse5cmy3GtkONLjcddQlw9JknJoMSYw2JGkMTNz+nFa9MEwqrPJeLxWq22kLh8sy7babBMvUTNqMNiRpLF1q/HX8vyVo0VA2eN2oRODHUkqRmMp6/F4/0xNHx6P5xEybHn69Omvw6mw1+GY7YfUJi6rxSEIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiBIJoBLaSBJYXBwap3H425UqeRPSpJ8Acdxy+awK40kSb0Mo3qJYaRfFRZqeouKihR5MDSCpCIo7Ejc2bNnD19R0XAGy7JfAXF9C8Mwfp8ll2hkWXbLsvQ3lmVurasr7SA3SdFNCJLWoLAjigOCyfX3j22XZfYrspw6Qh4K2G8XCP3fOY79YW1tyREUeiRdQWFHFAFEkbfZhs+Ef34LwriJutMaMnwDQv8TtVr/p9ratVPUjSApDwo7EhUg5Mzo6EzR9PT0tTyv/ka6ZOXRMp/Ny4/wPPOFjRtLxuH3xmXFMgRRAhR2JGxA2NR2+8gOlYq/Ecw3Z7qYBwOyeYssC7cOD1vv27Vrl0DdCJISoLAjQYGsvGRmZvojDMN9imXZuM5cSVdINi8I4jdA7P/Q2Fh5ErN5JNmgsCPLAJHiLZaRc1iWuxEE6pJszsqjRRTFfSzLX2swFLVD/WE2jyQcFHZE1d8/XiYI0ochHEhWHtZj2ZHwgIbSLYreb8oyc299fcUJzOaRRIDCnoXs379fvW5d9TmSJJOx8jdiVp44SDbPcarPnjo13LZ9+3YvdSOIoqCwZwkDAxPlXq/wEZWK/QRm5akBzeb/H8Ow95pM5ccxm0eUAoU9QyFZ+fr1NecJgngjyzIXw6HW0E1IiiJJ0j5ZVl1vMpUeAJHHbB6JGhT2DKK/v18nCNrPqlTcdSDmmJWnMbIs2eH1SxD4+w2GsknM5pFIQGFPY6Arz/b1TRrJ3ZFw4r8Os/LMhAzZQDb/b4ZhbzUaS16FYx3WE/KR7AWFPc3o75d1ojh+HhRBzDPj1n0kMkDk+yGB/yUU/2A0lk/MexHkf6CwpzgkK7fZhivhn09zHHcDZuXIUkg2D///P1kWPvPAA78d3r17Ny5chqCwpyKDg4N6l4s7X6XifpwpC2ohiQGEvl8QhN+o1dw9BkPZOHUjWQYKewowP1Y+UiWKzKcwK0eUgmTz8HqGZdlb6+qKX8ax+ewBhT1JDA5KekGY3CkI4h0cx2NWjsQdEPkBWZZul+XS35rNrJu6kQwEhT1BkKy8v390gyAwH4MM6hrInqropiyEZJIqJ9SJC0LwIaiLOeKVJPEVvV7d5nsLAI2eEMkSuaSOe3qOl+XlMSx1qZxOTwHU93tUKlYL29eyLPNu+JfcaZsLn5vFd9ySmTbycywrfqqurmII6gLH5jMIFPY40tHRodFq170OROXLDKPayTBsVggJCKcMv3daFOU2nmdeEgTpVZVK3Zab6z5ZWVnpoG9LCcbHx/NOn+bWMIz3XI5jN8M+vx7EvxEannwQu6w5P6BRhWPFf1Glmt1bW1sLDS6SzqCwK4zdPlwNieMnQMxJVl5J3RkLaDhkfuIrHMf9W5JUf83JEUZSTbyjhYi+w8FWiaL4HhD6y0Dwt8IpkwXXP2S3IAg/gCT+dyZT1Qhm8+kHCnuMkKxcpyu5GE4GkpWfl8knPogbZHLSScjH7+Z56ff33vurwWybXgcNGdvXN2yUZfUn4Vh/kGHktZl9zGWPLEsvQGz/gONcL2M2nx6gsEdBX99IjSCoPskw7IdYlq2g7oyDCLkkCa9Apnq7Xi/tyZRMXGnmh3PEN0FmewPExDb4N4OFXjomSdLvIYm/22isHMZsPjVBYQ8DmpW/HoKaLKh1TqZmaGRsHP4/Bv/8Dhquu//85+zLyGOFZPR2+6RBksRPQqP/IXCtB/HL2PMMfmc7nBNfVqs9L1VXVzupG0kyKOwB6Os7WSOKrk8xDHc1nJcZnJUTMVeNiqLwpbw81aOYlStLR8d4nk6neqMoil/nOI5k8xl7zkHiMwThdDfLSr/HmTbJBYWdAgHJWSyjZsiyfgUZyNmZmpUT5sVcBjGXb5iZkR7bvh3FPBEQkddqhfczDP9dMIsyW+TJ2Lz8oiwzt5pMJc/CT8WboxJI1gt7d/dQPc9zf2dZrom6MhZJkqZA0u/MydH/rKqq8AR1I0mgq2ugXKvVfU6SGLLEcg51ZyyQzQ97veIPGxoq7gKRxyWI40xWC7vFImk57vhzUDx33pN50Ox8BET98w8++Ou/45h5agGHh7Vax65hGPb7kL8XZ3IWD7/2+bq6kovhJ2IMxhkU9gwVdiLoIOZP5eSIV1dVVWF2ngaQh4p7vdLDLMuel5kCj8KeKBZvvUYyAyLooig86fF4i83m8stQ1NOH2trSMThmO10uRwUcwxfJsaSbECQiUNgzhOWCXvGWpiYU9HSlubkWBL5iJ8PI5aIo/hcFHokUFPY0BwU9cyHrqUMGfwEReElCgUfCB4U9jZEk6RRkdJebTOVvRUHPXIjAwzG+AHT9nfDyrYSJIMFAYU9DSOYGov4No7F0fX19xd8ZnD6WFZhMZY8aDCUF0Ee7ncQAdSPIKlDY0ww4n49JElcNJ/n3UNCzDzKjxGgs/5IkqUwQC6eoG0GWgcKeJkCOTsbS/6HRuOvN5qIh6kayFLO51J6bK22AmNiD2TuyEhT2NECSZKckiZeYzRXvwoWWkAXKy8vnTKby14ui+GHQdoG6EQSFPdUhQy+yzJnN5sqnqQtBFiFDM/X1FX9Qq+V6HJpBFkBhT2EgS39arXZtyeahFxArprNzpMZiGb3dZhs7abdPyORls427wPdMb+94K31rVlNTU9YH8VIvSeQxhEi2g0sKpOiSAtC9fkqtLntXbS2TdU+sIWJusYycz7Lc91mWORPCNOhKm/B+MsY8AML2YY/n5CvNzc2e+S3ZR3v7aG5urvwMy/JnU1cKgUsKJAoU9hQU9mwUdbKkrUYj7eY49kqQ6ZgWw5IkeQL+/2tJ8v66vr56mLqzhuFhOWdubuwZjuPOoa4UAYU9UaCwp5iwZ4uoL2TlDMPeCgJ0Brjisv49fI8IQv9faDC+5XROvJot2TwR99nZ0Wd5PpUydxT2RIHCnkLCLsvSMY2GP6e6uigjs8z5B01I3wYxvxLMJD1oQp4QRem3KpXwK7N5Q0ZfuxgeHobMnXmO4/izqCvJoLAnChT21BH24y6XsH3Tpoqj1E57SFbe1zd5PiTNP1Sp2DPghFbTTSkByebh/y+KIvstr3dibyZm8z09o7UcxxxkWXYNdSURFPZEgcKeAsIOAiOxrOrzdXWld1FX2kKz8ltoVp5WD3KG4zApSSSbV/8yk2YiWa3Db2cY/q9wKHjqShIo7IkChT0lhF38rsFQ9v8g4NPuDkKSlVssg7Usq/kOiPnl8BtSKiuPFvhd5Jmde6HN/Va6z7Qhx8huH/8ZHJ9rqStJoLAnCpzHnnwmOI6Fky59RP3llwf1NtvIpVbr2Gt2+4TA83o7y3LvzxRRJ8Bv0bAsewHH8c/rdMUum21i1GodvYUkA/QtaQOJLY5jboFG6iR1IRkOCnsSgUxKgnPuO+TJOdSVkpCMr7d3rM5mG/upzTZ+qrRU54Be/ZMgfGeCaGR8DMFvBFRl0Hh9E3p4IPLjbhD5/1osQ1vpW1IeGmN3wrHEdWWyABT25DLo8Qh/ouWUpbt72AQZ3xHQ8OtA4VLgIlxygTqAbJ47n+M0B3t6htLmuggcw9/CP5i1ZwEo7EmCZOssq7qjoaHyOHUhaYmc5AuS4TOftcs/waw980FhTx4noHv/MC0jSEKQZfW90OfIumUqsg0U9iQB3fk7U31sHck8TKb1xxhG+jk1kQwFhT0JQE/YIUniK9REkIQiCPLzEIO4fnsGg8KeBCBbn+N5tpuaCJJQWFZzGKLQS00kA0FhTwJer/c1r7cYH4qAJAWeF0DUJQc1kQwEhT0JqNXqV8xm1k1NBEko5NoOw7D3UBPJQFDYEQRBMgwUdgRBkAwDhR1BECTDQGFH0g5ZlmYFQXyLJEmPgyVSN4IgFBR2JO0gd8R7POJhk6nsbQZDKa9S8WtkWbwRhB5v+EIQAIUdSXsMhnWnjcbyH4HQlw8Odqq9XmEHZPU2XBMFyVZQ2JMAiM5n7faxUmoiCrJr1y6hoaFin9FYZjIaS1lRZAuhvu+SJBnXR6FYrSc2QJP3GWoiGQgKexJgGJZj2fR5ZFw6YzYXTYPIX28ylepJNi/LzJkqFWbzSGaDwp4U5GJRVH2IGkiCINm80Vi832CYz+Y9HqYgG7N5hhGvhbRCT00kA0FhTwqMSpLECkgasf6TSGNj8cxCNl9XV8zLspDx2fxDD8kcNGbl1EQyFBSWJEGeETowMFFCTSTJMJDGGo0Vi9m8KAqboPH9e6Zl81u3nqxgGPYKaiIZCgp7kgAhKZYk5iPURFIMs7miy2QqfzfJ5p3OCa0kCTdAIt+f7tk8w3ivx2GYzAeFPbl8rr9/vIyWUxaO4wUQg6xdv7u5udljMlXcAZl83cGDJWpZFlsgm/8bmTfP8+r/0relPGQ2DJzyOBsmC0BhTy4lgiB9FZLAlD4O9fVlfQZDaaFa7coRReFmyFln6aas44oryJBNeQdk85eTefNGY9kf6aaUh2XF6zBbzw5Q2JMMw7BX9/cPm6iZ0lRXVzvN5ordRmNJ/uBgsdrr9X5clqVulUqW6FuQFKW399gWOE7XUxPJcFDYkwzDMGtFkb1vfHw8j7rSgl27GKGhofJ3kLE2QTbPeTxirSiKf8jmbD5VsdtPFrIs/xeINi11IRkOCnsKACfdjtlZ1XdSfUgmGI2N5QNmc/k1JJuvqysGofc0SJJ8GDJ6vBEoyciy8FWW5eqpiWQBKOypw6dttrF303JaA70QqbGxqtdkKt0CGT3LMPxGSZLuBaGfo29BEoTdPvoRkPYbqYlkCSjsKQOjYVn2Aat19D3UkTHU1a07ajKVfRiEPo/c1i+K3o+B0Hen+9TBVIeMq8sy9zNoaPE8zzLwgKcUjAbOwV/a7RNm6sg4yG39ZnPl70Hom+6//xe81yvWiaJ4H2h81k6njAdE1DlO+wrOgslOUNhTDMiu1oPIvdzdPZTxY6K7d++WGhrK+83m8g8ZjaWQyU/pQOQ/Cr9/gL4FiQIUdQSFPQUh4q5Wq1/KBnFfitlsdoPI3w0iX1tXV8ySbF6SpD+oVJjNhwuKOkJAYU9RiLhrNOpDFsvI5dSVVcDvl0k2bzKVXWMwlKqdzmItCPxuSRLHYevBnBz3NH0rQrFYRj/K85r9KOpIVq8JbrFIWo47/hwUz533pCKyRxSFG9vbX/rZFVdcgc/3RPxisRyvYlmpF0Q9h7pSEPn5urqSi6HRxhva4gxm7CkPo+E49Z1btpx/+0MPPcRRJ4IgSEBQ2NMEnuc/19q686DVOrSBuhAEQfyCwp5GcBy3mWXVNotl+HOYvSMIEggU9rRjfmhm69adB+aXYUUQBFkOCnuawrLcFpYVB63Wsb3ptoAYgiDxBYU9zWFZ9qyZGdUJHJ5BEGQBFPYMgGHmh2e2bbvQgQKPIAgKewaBAo8gCAGFPQNZKvA9PcOfR4FHkOwChT2DIQKvVqt/DALvtVpH23AOPIJkB1kt7GYz677vvp/vlGVpsySJf5Rl2Uk3ZRQg8AzLcq0sqxm028ddZJgGfis26khCkCS5QxSFy+vqSl4HoYjLCSSArF4rxh8Wy/EClvW8D3TvCyzLNlB3RiJJkkWWhVtNpsp78YRLb1JprRhIGhyQLD28Zg1/XXFx8Qx1IwkEhT0IJKuFDHcT/PtV6Ny8i2UZHd2UcaDIK8/g4NQ6QXDk19aWD0KdxvVpUckWdoifDhDzm02m8r/H+7cioUFhjwCSzcuy+0Mcx98KwZvBS6PKbllWPSxJnq+ZzRuGqBMJA6t13Aj1dyskAW+D04unbpIkzMH//8Bxzm/U1tZOUbdiJFrY57Ny+SFZnv6c2WzGJZRTDBT2KFnI5iFT+RUIfQov+xs7kiRaJEm+g+d1fzYY1p2mbgQgWbnb7bgGenSfY1m2mrpDIorCcwzDfdJoLLErkeEmQtgxK08fUNgVwmYbLYGT+w7IdN+dyUM288xn9KLouc1srjoCJ3lWDN1AY8719Y2dAafNV2SZeRv87sWMPBag4TwEgvnD3NyKRyorGQd1R0Q8hJ1m5X+BBusHdXXFVhTz9AGFPQ6QbL63d/SDHMd+PdMvwP4Pn9g/Bf8+pVbrnqmuLhxIV8EnAm63T9bJsqdYpeK+xDDsW5US8VBAVuwEcb4XGo47IsnmlRJ26Jkdgf7EbXl5zN/Ky8vnqBtJM1DYE0B2ZfOrAbHqhUbugNcrvKDRqP+Tn8+MFBUVJXVclgyhiKK3xOv1vpnn+e2iKJ0HjXAN3ZwyQDbfDvX3w7y8ikeDZfPRCjvJyuH/f4bG61bMyjMHFPYEQ7J5i2XoSo5Tfw1OpizJ5sMDBKyHZbk2avoAYXsOhPclagZFFIU3Mgx3FjV9wN+fA4K9kZppDWTTRNjvg9ftK7P5SIQd6uQIfNZtTifzt9ZWzMozERT2JGO3j5VCt/t2KL4bTtSsy+aR6IGGsB2E/Id6vfjo3Jx2XSBhBxF3QkrxJ2jgMCvPElDYUwiSzdtso1eqVL6x+XrqRpCQQOyQu6a1INq+O4pB9Dvg/z+am8OsPBtBYU9RiMjTm6O+AucqZvNISATB+zzPqz+JWTmCwp4mWHw3R3neD5k8WeoAs3nEd+FTkryfzc/nHsIZLMhSUNjTEJLN9/YONXMcfyNk85dDdqalm5AMRxTFIxABu/EmISQYKOwZwPHjxwtOnPBeQy6OZeN0ykyGzIRhGNWDMzOOG7duVX4pAiQzQWHPMBbG5qH4ZTi878Gx+fQCjh9k4fIhUZRuMZvL/4FZORINKOwZDhmbZxj3e1Uq9ossy+G8+RRElqVZEPAHWNbxtXgsEIZkHyjsWcRCNg///oZh2LNATPD4JwVZAsj6MLc5HOyjOB0RURo8sbOY+Zk2ZBli9fdB4nOpG4kDIOIzsqy6n2G8dxoMVTYcYkHiCQo74oNk81br6AdUKvYrLMs0gfDgo/NiBLLy/ZIk3O50co9jVo4kEhR2xC9dXQPlGo3uFhD690I2n0fdSBCgcZyB/5OVGX+q1DrrCBINKOxISOaz+ZH3QxJ/I8uymyBsOLopq4F6IeyD0u1zc6onMStHUgUUdiRi5rN57W4In/eB2OdTd1YwP1Yu363RsHdVV5f0YVaOpCIo7EhMgMiRbJ4I/Jfh1QJCl1HZvC8nl8V9sqz6UW5u+T+jfcIRgiQSFHZEMeZFfrQBxP16EPmr4F/FHtOWSOB3CKIoPgtt1GdMJszKkfQDhR2JG5OTk/knTnjfwXEMWbisBcItIY+XixSSk8M/J+F1r1ot/6K6urQfxRxJZ1DYkYRBhP7UKe/bIexA6LlGkFQdCGgSYlD2gpSfhn/vFUXVL81mFHIks0BhR5IKEfvjx8WNajX7AVmWSkFg3wFhqQHRJQ+NiCrDhwTcC5/hIWXyzFCOY/fLsvCCKGpfM5vXj6CII5kOCjuSNpBGYHZWWE9NHx6P12s2b0CxRhAEQRAEQRAEQRAEQRAEQRAEQRAEQRAEQRAEQRAEQRAEQRAEQRAEQRAEQRAEWUXKLCmwZ88eXqstLnC7XawoermZmdOa+vqm82EXS1mWrP/BkjX4xNHR4aedzrnTZWXlgk4nSC5g+/btWb9GdkdHh2Zy0lVQUFBo0mjU58/NzW1Yt27t6xiG00PthXGcyS35kmtq6vTTen3OMUHwvup2u7vXruVnzWazm74p7hw40F2Rn7/mMZZl1lBXRjM+Pn7Heedt+QU1V7F3796C/Pzyv2i1WhN1RYXb7RmdmLC/YdeuXS7qSmleeungmSUlFQ8yjCqmZ+/Ozs7e39pq/DYUs2rJiYQK+969lgJZdm3kef69eXn5l4KrgufVRSww/47oIaoPYnQKPuoUiNoTDMM+zfPOlzdt2jTFMIxE35b2EAGfmuKKcnL49+fk5FwDAljDcXxcn2JElrWFxvaE2+09KEnik9D4PrRjx6bxeKzPsm/fEUNhYdEBjuMKqSujGRoavOvCC7dfT81VtLUd3ZSXp9sPx1lHXVHhcDimRkamqi65pDUtHt/33HN7L9uwYePjcD7HpFGCILaZzWXbM0kDwiFuwg5awB06ZG+E4tcgA7wUxDxpGZgkSQ7IWF6Bf3/s8aj3bN9emTYZPhFyWdZvgcz7SxqN5s3xFvFwmRd78QQ0po84HHPf2r69cUwJoUdhXw4KOwp7NMScKS+lvX2gtqOj/3cWy8h0X9+kkJ9fcAReH0imqBMgOHL0et3Fubk5T6xdq56zWMac3d3HHm9r698I+qRoHSgBEfO2Nuuunp7hXp2u2JWTk/8aNI5XpIqoE+BEYeC4Ful0+o+tW1c0YrdPCF1dQ88ePtx/DtRpQnuCCIIsJ2ZR6+7u39jRMfAHq3XMk5+f06fX5340lQTIHxzH6jQa7VsKCnL7QZC8XV3Hnu7sHKlJpsgTMezosO/o7R05otUWuQoKCp9Tq9VmIqD0LSkN7Car1Wpel5ub+zKpU4iJv9jtY6Uo8giSeKISMnKhs6dn6NMg5ic1mtx+yCavhqxYTTenFfOCpH29TscPwO85DVnydyDzXLbmdzzZv384p7d3+DqLZXRSr89/FbLg5li7n8kG6pQjPQwIrzGrdfQY9I4uQoFHkMQRkbDv2SPzR44M3LhhQ+OcWq35BQjQWropI+A4Lg+y5G9oNOoJEPi/wauIblIcIug9PSPfXbuWP8Xz6p+CoCesMUkk0HurhN7RHuiJjLW3D7wOBR5B4k9Ywk4y9I6O/i9WVY3P5eTk3ApJroZuykhIFg8C/y4Q2/He3tGHLJbjBXRTzBBhg8bxvLw81YBazX8dvi2j63IBqM+S/PycZy2WMWtbW28ldSMIEgdCZk8HD9pMOTn6vXBirqOurEMURYfL5fhES0vdn0D0o766ToZ4eJ57FnoGW6grK4HGTXK73b9Xq6uuM5vZZXPkFZwVY1ep+DMMhnWnqZ2W4KwYnBUTDQEzdpKlt7f331lYWGBJlKiDgLrgdcrj8diOH5/869TUyT/Mzs78Gl6/mpmZ/u3JkyfuB//jcLCOwfumJEn0zv9lfAGRgY5K3gNdXYPP2u0nIxYckqV3dh7dCZ8zGG9RlySZ3LPVDq8fjI1NbhMEV1VdXTFnMJQwgV46nTfX5Zrd6HA43wav30L9DkmS5HsYdDwgPSKdTvdxlWqsi9yQRN2KAnXOz83NJO1iOIIkE7+tYVfXRDnDeJ7TaDQN1KU4IMrTTqfrKUGQbud53rZ5c80puilCZObVVztL1WpNCzRAX9FqdeeBeMaU3QSDNDxzc9Ov27q1vp26gkJE/fDh/i/l5ub+gAgadSsGSX6hIXwWhPzLW7eaepTMTNrbR3M1GvdFsqz6qkajPZtlOZ5uUgyv1ztls/W0vuUtFx8ltlIZO9T7UYfDtTX6uEoNMGPHjD0aVgnNoUOWKhD1zniIusfj7oIu+Icgg+RNpvLCzZtr37dtm2FfbCcfI591VvPYtm3mp1taal9vNpfrT53y5s7NzX1NELxj9E2KAYKzNje34OUjRwbeTV0BAXFRd3UduzcvL++HSoo6fC4Zyvj38eMT5UZjma6pqfoy+P1dSgdva2v5XFPTxic3bdq4E75H43I53wANyAH4/phuRIJG3e10Op53ueYunZ1VVS6IOoIgyrBMbMhFLa1W3w6irthsFzI0MDs7+9XBwU51Y+OGTU1NG+4DARLp5rhA7iyFRuMHZnNFhdvtqACR/z1okWLfCeKu1+t1f+zoGHw/da0Cvo85cMDyZa1WexV1xQwRdEEQHoJXKdTjm0iDRjfFHThm8qZNNc9s2lS9/cSJE8VOp/Of4Qo8GdaB9788NXX67TMzI3nQqOuamzfu2rSp9ql0ugsYQdKFRWEfGJgo1+ly96vVWkWm3UFWJhBBNxpL8rZsqbt1165dAt2UMIgYQcY5CiL/sakpoQC6o/eEK0ahIDODtFr1r6AxbKWuZRw50v/xwsLCW2AfYp7eR/YZMtxniKDX11e8t6Gh8jjdlBTOOqvpRHNzzWVwjHdBV3eSuhchQg6Z/SszMzNvJb0nk6lMC+8/74wzTI+1tqbHUACCpDOLwu5weB6ATL2MmjHhdrs73W7XBiLo8c7Ow4VkhiAuH3W7584BgVRkpgTLcgXQw3mwra1/2ZIJHR39ZRqNdjcLUFfUQJLuBYH8KGTLlyRb0FcCPaIXZmakjS6X+x9wzP8L/16qVrtyiJBDZn9ua6vhCczIESTx+IRn377uD5DbwX2eGPF4PE82NlZtaW6uTdgwQbjMDyfUvcrzuhpB8B6h7pgAAW/S69W3UNM3BAPZ9VfUanXMjSTJfKGX8cGtW433wL6n5MUfItybNm14V1PThgvg36eqq6uddBOCIEmCLHLO6/U5/4/aMQFi+RhklW9PlSw9EGRuM8+7dioh7mSkheP4Kzs7bb71sp9//sD63NyCgGPv4QKiLjidcx/ZvLnuYepCIoIRc3Pzs2omBIIswLz88uF3lpaW/Z3aUQNZ6uFNm2q2pbqoL6Wra7AZRPm/fMyrT8ogxKofm0ylX2xrs32loKDgB3RD1Jw+ferxrVvN70jVTD1eZPKyvZIkd2i1xTuqq9mwezU43RGnO0YDW1RU/EVajhrI+iUQ9i+nk6gTmpo2dELAxyzC0D6qpqenziQ3dTkcs2QN+pgQRdHpcjm+k23BmOmQC+4nT47HfN0FQULBulzOmGfBzM7OdJ95ZtP/UTONYGRRFH4PdbBqZkekrFmzZnNFRcMZxcUlF1BX1Hg8nqGCgoouaiIIgkQEKwhCzMKel5c3RItph04nuDQabcyzTSRJxUHWrodizNMboaE82txcOktNBEGQiCAXT2NeRz2dhwzWr18vs2zs+09mw4iiqEg3W4ljgiBI9sKCKMc8Pc3pdKbtuux2+xTr9QpaakYNy6qknBytE/Q95nnbRUXFre3tdjM1EQRBIoI8PWiClqNGp9Of0dMzciY104rS0vXkQdsGakaNLKvc+flFoydPHn+UuqIGGtvCnByy+iGCIEjksIIgPkvLUQNCpGZZ5uvUTBuGh4dzZFm6EfY/5nFxj8f9r9ratQMMwz0mikJMS97O7w77kX37LDE3OAiCZB8sCNG/aTkmWJZ92/79ve+kZspDxsRPnfJ+GBqkrdQVNaIouaampn8xb/FdYNvny9HDcdw6yNofimb9d8TXgxoUBMngdnuKUuV18OB4C1kxk+4igsQNX6ba0zP8ilqtPtvniQEQS48geC9taKiKuRcQT4iod3QMXKTV6v4FAhrzo+lcLue+oiLd60pL52eyHDpk/1hubu6vGSb2tWLcbvc+t1t449attVPUlXL09h6tYxjNPyVJ/BeI6c8efnhD3+7d0V2QxvXYl4M3KOENStHgEx7ykAYJzkqfJwag8jQ8r36qvd3+VupKOYio9/YOf0qv1z+jhKhLkuxwu52fWRB1gtd76g9wIsV8Ny9Bq9WemZentx46ZGuhrpTiyJGBtzCM9jDUZb1arfmcXq+zXnXVhGCxjI5BwnDb/v09cXsgOIIg/vEJe2ur4cW5udnFhaxiAcRdnZ+f/1h39/Az+/fvT6lpex0d43mdnUf/AQL0CyWyaWgkZK/X/dtt2xr2UZeP7du3e51O16e8Xq+VumICspai3Nz8Qz09I0/Y7faUGJo5eNBSDHX5LDSQj3Ecm0vdPiAGGBD6UugF3rB27bpJq3XMC+9ta2+3vre7uzufvg1BkDixKG6trcbdkLkrdveoRqO+eM2aDXNHjvTfDPqn+CPVIoE84q2nZ+gunU41pdfnvJ26Y8bpdD76l7/83u+SDGTNcsjnLyeP0qOumCBiqVbzl8ly3gnocfwTGilFlliOFItlhAj6UwUFheM6nf51ZL/opoBAw8TDe1vz8wv/rNGsnyZC39ExcPjAAcuVTz+9H68hIIjCLMtaOzs3XOpyOV+gZswQLcrJyb3Jbp9wdnYOPtbZecy3AmKimM/QB+/Jy2NPQ5b+Wdgfjm6KGbfb9SrPO6/evXt3wLG7hoYNhyVJuAjE/SR1xQz5DTyvfjM0UqNdXcf6Dx3q+1C8s/ju7sn8w4f7P2yxjB5nWW4CRPpN4Qh6IIjQQwPbsmbNmvvr6qqnentHujs6BhPywHQEyQaWCfsVVzBiU1P1xS6X+2nqUgTQAMjYdG/V6bQWi2XM2dU19NcjRwbPVDqTJ+PnnZ19NUeODNwGYnFar2dm4HuvUVLQ4VtIpv4Uw8y9obGxcYY6A0LE3eM5YfJ6vR3UpQhEV7Va7ca8vLx7Var8KajXWRDfx7u6ht8fq9ATIe/sHHoPNBwv2Wzjbo1Gns7Nzb2b47j1Mei5X5zOuccZZra1ublascYPQbIdv2cpCCR7+HDfzXl5+Yqs0x4M+C6H0+nYx3Hqx1wux78gw58I50lB/f39utlZVS2I2+Uej/diEPDt4M4B4VFWeZYgSZLsdrt/uWlTNcn+I3rEHrneoNUWfR/284uxXukPF1mW3LCf5HmjY9CwHNFotDNqtdoNXy/Cb+HJHbfQ8yiYf1iIrhx+np5k0/TP4wrsm+h0ur7W3Fxz29K6xFkxy8FZMTgrJhqCVlpX1+CFarX2n1C3OdSVcCRJFGVZRQ4KQ0QnjrodFEEQpkAI3w+Z5b+oKyp6eo5tho7F4xqNppq6sg6oS4vb7bxg82bDOHUtopywSzMzM7PPkwaEulIeOM9kaIxuP/fclpeoSzFhJ0BdeCTJdy6lLJBo/B0a+yv37Hn1UiWEHRp4ko/FdMNgIuB59pK6upL/UDNmQlYayd67u4/dotXq0u7OUiUggQH//cRoLLsh0iw9ECR7Lyys/BLLcjeBGfM6NemCKAon3G7P2+HEfTlQXWbygzbC4cSJia/v2NH8fWoqKuzpwMBA360XX3z2V5XK2NMFSPZebzQWK3b/T8gpf6QL09RU/Q2Wlcs9Hvcr1J3xQE8Bshv5Nwwzu85kKv+iUqJOINMh4TO/L4pThR6Pdzc0HimfUcQCpEwOqMtvezzlFS0tG19Ssi4RBFlN2HO5a2tLxxobN5zrdjsq3G73y9SdUYDAytAVfNHr9Z4PGbrOZCr9pMFgOE03K47ZbHY3NlbebDCU5Lhcs2fD947QTRkB/J4hiJVzoB7z4HVTczOT0Q0YgqQKYQv7Ak1NG0ebmjacx7Jz+tnZuS9ANuaim9ISUZTmQMwfnpubKQOB5aB3srOhoTKhWSV8l7hpU92r8L2VJIt3OOZ+BvUq0M1phSCITtj/n6tUM2saGiqqIVb2wi/EDB1BEkjEwr5AbW2ta8uW2jtNpjI9yeJnZmZ/B2KUNhmZx+OZcru994KwXzQ+vuED5EJeKgwRQBY/3dJSex3Uq/rUqcE1Dsfs7YIgxK3XoASQmU+cOnX8ayoVv6a+vjwX9v+z8z0dFHQESQZRC/tSSBbf2lr3cRAj7fi4LWd6+vR1IEZjdHNKotFo1mi16ms0Gn5fdfWk12Ybd3R0HP1nW5t1V0/PcEqsb7J9+/bTLS11X6qvr1hTV1fMz8xMt4DQ3yMI3hFyqZ++LaGQ7yXf73A47oV9aR0c7FRDT6N0+/amHxgM60gDhGKOIEkm7lecyXzz6Wn5EhDSG1iWa+B5rphuSknIOLsoCj+ur6+8gbpSFlK3U1OCQRTlN2g06ou0Wk0rHNIynudjnmkjCKIbZHzM7fYckSTxaY5jX8jLY3qhpwb++Il3ts+KmZwc/8bZZ7d8j5qqw4eP1kEC0gbHtIC6Mhro/T0Dicwlzz239001NXWPQy9akeQz1VF6VkxSphJ1dMgaSOjVubnsztnZWSMI6ba1a9eeDQJSCOJfQd+WcEDTVS6X+1ebNm24NhNmblgsklanG2JPnjzJDgzMskVF61XQm2LU6hnG682XCwoE2etdI3s8gtzYuE5yuaoks5klw2lJ++1wDJhXXnlFp9HUZMU0t+WMqs444wwXxF5W3UyDKE9KnjwkE3U4uDexLPtVyFS2wb8JWSXS6/U8n59feVllZezPLUUQBEkWaZEVdXR0aBhmXbnX6/y6Xq+/HMRe8QWjXC7XXq9X/Xp8wg2CIOlOWnZ3b7pJZj/4waGKuTnne7Ra3YfUak0zZPVRL/QFot4ty9M7mpubFx+WgSAIkq5kzDgmGU92u4+9URA879brc9+hVvNhXXwTBHFybm7uvG3bjIo8FANBECTZZOwFqptuuol9z3uurpIk9lqNRv1ejuNrVq47IQjCqbm52fO3bTN3UReCIEjak7HC7g+LxaJ1udSXqtXqL4Kob5iaOvn2nTu3HaKbEQRBEARBEARBEARBEARBEARBEATJYrLq4imCIOFjs03cr1LJ76Om4rhcjmMvvXSi/pOf3O6lrph5/vl9l1ZVVT/BANS1DIfDMdDcXGOI97IN7e22Q3l5+U3UDMaLRmPpLlpWjKxYYAdBkMiRZZk8YzhuL8gr+TPOoF+WYciySu3vN698kTqgf6IoKOwIgiAZBg7FIAgSFU8/vfftGzdu/EeQB063Dw4Wn7lrF5Owp4Hddddd6zdt2n4DSJvffZqbm7O+9a0X3wPFhKxg+swzL3+sttb4W2quAjL7F43Gkp3UVAwUdgRBokJJYT940PpqQUFBwIGZ4eGhz69fr/0NwxS+nuPYa0G2L+Q4Pofxrdcu76+rKzkLytLzz7/25qqq6scDCbvTOTfQ3FxrIu+lrkVkWda0t9suLSgovGp2drY1Nze3hm5ahihKHq/X+7JarT6s0zE/q6kp66ObVpEsYcehGARBUgCJjDlzgV6lpWXf0+tL3Dqd9kkQ1Mt4Xp0Hfj/6RQSdYck2fy+QvFV/Y7NNfNNunxD6+ibdIOr/ANe78vLy6uD9fveF5zm9Xq+7GP79giCwdpttXILP+NH8p6UGKOwIgqQ8IOb5tKgoFsvoU9AU3ALFqFeHBbEHVF86eLA3ZZ66hsKOIEhaIUmi2+v1kimN73A6XesXhmHo5rCx24/vYFn2EmquQhRF+Exmh8FQwgiC3CpJ0jDd5JfCwrXvgn9SYngbhR1BkLQAhNXjdM590Ggs0zc0VL61rq740ebm6pPRiDrBYCh6zWgsZYlwk5coTuncbsdbZVl+zOl02EH0VbIsvWq3T8g8z7SDXUn/NOVBYUcQJOUhog7J8K7m5to/gpArNqOFrPja1zf+XZttXOS4NS6tNoc8QPtten0OuYmJjMun5QQTFHYEQVIeSZJfMBpL9lJTEfr7RzfKct6ALDNfJyJO3csgwzGCIBx2Op03qFTyHupOeVDYEQRJecbHR8mYuqLLAIgi+zOe58uouQoQ9QMmUxlfX1+xpbm55g5oANx0U8qDwo4gSMojSSItKUko+ZPrOzuPfaCzc/jtPT3DrzKM6k10QyDOtVhGXrHZxr9L7aSBwo4gSFbCMDJ5ktppaq6C4/g8vV73gE6nfkStVu+g7qDA35wFn3wRNZMGCjuCIFmJwVBi0evLyl0uz7Ug8NPUHRQy1XJ2dua2cN+fLNLyii+CIMmnv79fJ8s5F4ii/wSRZdkTdXVF+5kwZrH09h5vZFnR7y38BFnmXjabi0KK6eDgoF4QtGSf/Gobw7CTRmPxAWquhBkelvVu98mdoigs+/s1a9iXioqKZlf+FlmWA3zP/PuGh4dzHA7+Ap/TDzyvGqutLW2nJoIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCJI1qFT/H6IeRd28R6cMAAAAAElFTkSuQmCC')";
			heViewPortInner.style.backgroundPosition = "right bottom";
			heViewPortInner.style.backgroundRepeat = "no-repeat";		
			heViewPortInner.style.backgroundSize = "6%";
		}
		if(this.attr('useall') !== true)
			heViewPortInner.setAttribute('tabindex', '0');
		
		htElementPool.put('viewportinner', heViewPortInner);
		htElementPool.put('$viewportinner', QBOX.$(heViewPortInner));
		
		if(this._createViewPortCells(heDiv)){
			heViewPort.appendChild(heViewPortInner);
			return true;
		}
		
		return false;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createViewPortInner', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createFooterRowHeaderInner = function(heDiv){
	try{
		var objLayoutSize = this.attr('layoutsize'), htElementPool = this.attr('elementpool'), strID = this.attr('id'), css = QBOX.QCELL.def.css,
		heFooterRowHeader = htElementPool.get('footerrowheader'), heFooterRowHeaderInner = heDiv.cloneNode();
		
		heFooterRowHeaderInner.className += css.FOOTERROWHEADER_INNER;
		heFooterRowHeaderInner.style.width = objLayoutSize.footerrowheader.clientWidth + 'px';
		heFooterRowHeaderInner.style.height = objLayoutSize.footerrowheader.clientHeight + 'px';
		
		htElementPool.put('footerrowheaderinner', heFooterRowHeaderInner);
		htElementPool.put('$footerrowheaderinner', QBOX.$(heFooterRowHeaderInner));
		
		if(this._createFooterRowHeaderCells(heDiv)){
			heFooterRowHeader.appendChild(heFooterRowHeaderInner);
			return true;
		} else{
			return false;
		}
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createFooterRowHeaderInner', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createFooterInner = function(heDiv){
	try{
		var objLayoutSize = this.attr('layoutsize'), htElementPool = this.attr('elementpool'), strID = this.attr('id'), css = QBOX.QCELL.def.css,
		heFooter = htElementPool.get('footer'), heFooterInner = heDiv.cloneNode();
		
		heFooterInner.className += css.FOOTER_INNER;
		heFooterInner.style.width = objLayoutSize.footer.clientWidth + 'px';
		heFooterInner.style.height = objLayoutSize.footer.clientHeight + 'px';
		
		htElementPool.put('footerinner', heFooterInner);
		htElementPool.put('$footerinner', QBOX.$(heFooterInner));
		
		console.log(heFooterInner);
		console.log(heFooter);
		
		if(this._createFooterCells(heDiv)){
			heFooter.appendChild(heFooterInner);
			return true;
		}
		
		return false;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createFooterInner', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createCell = function(heDiv,bTab){
	var heCell, css = QBOX.QCELL.def.css;
	
	heCell = heDiv.cloneNode();
	heCell.className += css.CELL;
	if(this.attr('useall') !== true){
		if(bTab !== false && this.attr('usetreeall') !== true)
			heCell.setAttribute('tabindex', '0');
	}
		
	
	return heCell;
};

QBOX.QCELL.BasicQCELL.prototype._getHeaderCellSpan = function(strHeaderCellText,nRow,nCol){
	var css = QBOX.QCELL.def.css,
	$span = QBOX.$('<span></span>'),
	heColHtml = this._getColHtml(nCol);
	
	$span.addClass(css.COLHEADER_AREA);
	
	if(heColHtml !== null && QBOX._.isFunction(heColHtml.header)){
		strHeaderCellText = heColHtml.header(this, nRow, nCol, QBOX._.isUndefined(strHeaderCellText) === true ? '' : strHeaderCellText);
		$span.html(strHeaderCellText);
	}else{
		$span.html(QBOX.QCELL.st.replaceText2HeaderText(strHeaderCellText));	
	}
	
	return $span[0].outerHTML;
};

QBOX.QCELL.BasicQCELL.prototype._createEdgeHeaderCells = function(heDiv){
	try{
		var css = QBOX.QCELL.def.css,
		htElementPool = this.attr('elementpool'),
		arrRowCellMatrix = this.attr('cellmatrix').get('row'),
		heEdgeHeaderInner = htElementPool.get('edgeheaderinner'),
		nHeaderRows = this.attr('headerrows'), nHeaderCols = this.attr('headercols'), nHeaderRowHeight = this.attr('rowheight').header,
		nHeaderColWidth = this.attr('headercolwidth'),
		arrRowHeaders = this.attr('rowheaders'),arrRowHeadersTitle = this.attr('rowheaderstitle'),arrRowHeadersSortable = this.attr('rowheaderssort'),
		nGap = QBOX.browser.name === 'msie' ? 0 : 2,strId = this.attr('id');
		
		var heSpan,heText;
		
		for(var i = 0; i < nHeaderRows; i++){
			var heCell = null;
		
			arrRowCellMatrix.push([]);//현재 행에 표시될 셀들의 정보를 담을 배열을 추가해야 한다.
			
			for(var j = 0; j < nHeaderCols; j++){
				if(i === 0){
					heCell = this._createCell(heDiv);
					heCell.style.width = nHeaderColWidth + 'px';
					heCell.style.height = (nHeaderRowHeight * nHeaderRows) + 'px';					
					heCell.style.lineHeight = (nHeaderRowHeight * nHeaderRows - nGap) + 'px';
					heCell.className += ' ' + css.CELL_EDGEHEADER + ' ' + css.CELL_HEADERROWS + ' ' + css.CELL_HEADERCOLS;
					heCell.setAttribute('data-row', 0);
					heCell.setAttribute('data-col', j);
					heCell.setAttribute('id', strId + '_cell_' + 0 + '_' + j);
					heCell.style.left = (nHeaderColWidth * j) + 'px';					
				
					if(arrRowHeaders[j] === 'checkbox' ) {
						var heCheckbox = document.createElement('input');
						heCheckbox.setAttribute("type", arrRowHeaders[j]);
						heCheckbox.setAttribute("name", this.attr('id') + '_rowheader_col_' + j + '_checkbox_all');
						heCheckbox.setAttribute("data-row", i);
						heCheckbox.setAttribute("data-col", j);
						//heCheckbox.style.position = 'relative';
						//heCheckbox.style.top = ((nHeaderRowHeight * nHeaderRows) / 4) + 'px';
						if(arrRowHeaders[j] === 'checkbox')
							heCheckbox.className +=   css.CELL_ROWHEADER_CHECKBOX;
						else 
							heCheckbox.className +=   css.CELL_ROWHEADER_RADIO;
						
						heCell.appendChild(heCheckbox);

						if(arrRowHeaders[j] === 'checkbox')
							heCell.className += ' ' +  css.EDGEHEADER_CELL_CHECKBOX;
						else 
							heCell.className += ' ' +  css.EDGEHEADER_CELL_RADIO;						
						

					}else if(arrRowHeaders[j] === 'custom'){
						this._setRowheaderCustom(heCell,0,j);
					}
					else{
						if(arrRowHeadersTitle !== undefined){
							var text = arrRowHeadersTitle[j];
							heSpan = document.createElement('span');
							heText = document.createTextNode(text);
							heSpan.appendChild(heText);
							heCell.appendChild(heSpan);							
						}
						if(arrRowHeadersSortable !== undefined){
							var bSort =arrRowHeadersSortable[j];
							
							if(bSort !== undefined && bSort === true){
								if(this.attr('defaultsortarea') === null){
									this.attr('defaultsortarea', this._createDefaultSortArea(heDiv), 'jquery');
								}
						
								if(this._getQCellCol(j).attr('colsortarea') === null){
									this._getQCellCol(j).attr('colsortarea', this.attr('defaultsortarea').clone(true), 'jquery');
								}
								
								heCell.appendChild(this._getQCellCol(j).attr('colsortarea').get(0));
							}
							
						}						

					}
					
					heEdgeHeaderInner.appendChild(heCell);
				}
				
				arrRowCellMatrix[i].push(heCell);
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createEdgeHeaderCells', e.message);
		return false;
	}
};
QBOX.QCELL.BasicQCELL.prototype._isBottomPanel = function(heCell){
	
	if(QBOX.util.hasClass(heCell, 'rt-qc-cell-frozenbottomrows-panel'))
		return true;
	
	return false;	
	
};
QBOX.QCELL.BasicQCELL.prototype._getRowGroupOfDynamicRows = function(idx){
	//동적 행의 그룹(틀고정 행/일반 데이터 행/하단 틀고정 행/표시되지 않는 행)을 식별
	
	var rowgroup = QBOX.QCELL.def.rowgroup,
	nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'),
	nDynamicRows = this.attr('vsinfo').nDynamicRows,bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false;
	
	if(bPanel === true && nDynamicRows-1 === idx){
		return rowgroup.FROZENBOTTOM;
	}
	
	//데이터 수가 동적행 div의 수보다 많을 때 -> 일반적인 경우
	if(nDynamicRows < nFrozenRows){
		return rowgroup.FROZEN;
	} else if(nDynamicRows < nFrozenRows + nFrozenBottomRows){
		if(idx < nFrozenRows){
			return rowgroup.FROZEN;
		} else{
			return rowgroup.FROZENBOTTOM;
		}
	} else{
		if(idx < nFrozenRows){
			return rowgroup.FROZEN;
		} else if(idx >= nDynamicRows - nFrozenBottomRows){
			return rowgroup.FROZENBOTTOM;
		}
	}
	
	return rowgroup.NORMAL;
};

QBOX.QCELL.BasicQCELL.prototype._createRowHeaderCells = function(heDiv){
	try{
		var THAT = this, rowgroup = QBOX.QCELL.def.rowgroup, css = QBOX.QCELL.def.css,
		heRowHeaderInner = this.attr('elementpool').get('rowheaderinner'),
		arrRowCellMatrix = this.attr('cellmatrix').get('row'),
		arrRowHeaders = this.attr('rowheaders'),
		nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'),
		nHeaderCols = this.attr('headercols'),
		nDataRowHeight = this.attr('rowheight').data, nRowHeaderClientHeight = this.attr('layoutsize').rowheader.clientHeight,
		nHeaderColWidth = this.attr('headercolwidth'),
		nDynamicRows = this.attr('vsinfo').nDynamicRows,
		nFrozenBottomRowCount = 0,
		nCurrentDataCount = this.attr('currentdata').length,
		i,
		nGap = QBOX.browser.name === 'msie' ? 0 : 2,
		bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false,strId= this.attr('id'),
		fnClick = function(event)  {
			var nRow = Number(event.target.getAttribute('data-row'));
			var nCol = Number(event.target.getAttribute('data-col'));
			if(QBOX._.isNumber(nRow) && QBOX._.isNumber(nCol)){
				//var arrDeselectedRows = QBOX._.range(nHeaderRows, THAT._getSelectedRow() + 1);				
				THAT._deselectRow( THAT._getSelectedRow());
				THAT._clearFocus();
				THAT._selectRow(nRow);
			}
		};//iterator
		
		for(i = 0; i < nDynamicRows; i++){//i:iterator
			//1. 틀고정 행/일반 데이터 행/하단 틀고정 행/표시되지 않는 행 식별 
			var nRowGroup = this._getRowGroupOfDynamicRows(i),
			nRow = i + nHeaderRows,
			objPaginationInfo = this.attr('paginationinfo');
			
			arrRowCellMatrix.push([]);
			
			if(nRowGroup === rowgroup.FROZENBOTTOM){
				nRow = nCurrentDataCount + nHeaderRows - (nDynamicRows - i);
				nFrozenBottomRowCount += 1;
			}
			
			for(var j = 0; j < nHeaderCols; j++){
				var heCell = this._createCell(heDiv),
				nCol = j,
				heCheckbox;
				
				heCell.style.width = nHeaderColWidth + 'px';
				heCell.style.height = nDataRowHeight + 'px';
				
				if(this._getColWordwrap(j)){
					heCell.style.whiteSpace = 'pre-wrap';
				}else{
					//heCell.style.lineHeight = (nDataRowHeight - nGap) + 'px';
					heCell.style.display = 'flex';
					heCell.style.justifyContent = 'center';
					heCell.style.alignItems = 'center';
				}
				
				heCell.style.left = (nHeaderColWidth * j) + 'px';
				heCell.className += ' ' + css.CELL_ROWHEADER + ' ' + css.CELL_HEADERCOLS;
				heCell.setAttribute('data-row', nRow);
				heCell.setAttribute('data-col', nCol);
				heCell.setAttribute('id', strId +'_cell_' + nRow + '_' + nCol);
				heCell.onclick =fnClick;
				heRowHeaderInner.appendChild(heCell);
				
				if(this.attr('useall') || this.attr('usetreeall')){
					heCell.setAttribute('aria-hidden' , 'true');
				}				
				
				if(nRowGroup === rowgroup.FROZENBOTTOM){//FrozenBottomRows영역에 표시 할 행에 속한 cell인 경우
					//FrozenBottomRows영역에 표시할 행의 top은 하단영역에서부터 맞춰준다.
					heCell.style.top = (nRowHeaderClientHeight - (nDataRowHeight * (nDynamicRows - i))) + 'px';
					if(bPanel === true){
						heCell.className += ' ' + css.CELL_FROZENBOTTOMROWS_PANEL;
						if(arrRowHeaders[j] === 'sequence' || arrRowHeaders[j] === 'reverse') {
							QBOX.util.textContent(heCell, this._getRowData(nRow).rt_qc_seq !== undefined? this._getRowData(nRow).rt_qc_seq : '');
						}

					}
					else{
						heCell.className += ' ' + css.CELL_FROZENBOTTOMROWS;
						// .attr('paginationinfo') 정보가 설정되지 않았을 경우
						if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
							if(arrRowHeaders[j] === 'sequence' || arrRowHeaders[j] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[j] === 'reverse' ? nCurrentDataCount + nHeaderRows - nRow : nRow - nHeaderRows + 1);
							} else if(arrRowHeaders[j] === 'checkbox' || arrRowHeaders[j] === 'radio') {
								heCheckbox = this._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[j]);
								
								heCell.appendChild(heCheckbox);
								if(arrRowHeaders[j]==='checkbox')
									heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
								else
									heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;
							} else if(arrRowHeaders[j] === 'state') {
								heCell.className += ' ' + css.ROWHEADER_STATE_INIT;
							} else if(arrRowHeaders[j] === 'custom') {
								heCell.className += ' ' + css.ROWHEADER_CUSTOM;
								this._setRowheaderCustom(heCell,nRow,nCol);
							}
						}
						// .attr('paginationinfo') 정보가 설정되었을 경우
						else {
							if(arrRowHeaders[j] === 'sequence' || arrRowHeaders[j] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[j] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit) - nRow + nHeaderRows) : nRow - nHeaderRows + 1 );
							} else if(arrRowHeaders[j] === 'checkbox' || arrRowHeaders[j] === 'radio') {
								heCheckbox = this._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[j]);
								
								heCell.appendChild(heCheckbox);
								if(arrRowHeaders[j]==='checkbox')
									heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
								else
									heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;
								
							}else if(arrRowHeaders[j] === 'state') {
								heCell.className += ' ' + css.ROWHEADER_STATE_INIT;
							} else if(arrRowHeaders[j] === 'custom') {
								heCell.className += ' ' + css.ROWHEADER_CUSTOM;
								this._setRowheaderCustom(heCell,nRow,nCol);
							}
						}						
						
					}
						
					
					
				} else{//FrozenRows, 일반 데이터 표시 영역에 표시 할 행에 속한 cell인 경우
					heCell.style.top = (nDataRowHeight * i) + 'px';
					
					//var objContent;
					// .attr('paginationinfo') 정보가 설정되지 않았을 경우
					if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
						if(arrRowHeaders[j] === 'sequence' || arrRowHeaders[j] === 'reverse') {
							QBOX.util.textContent(heCell, arrRowHeaders[j] === 'reverse' ? nCurrentDataCount - i : nRow - nHeaderRows + 1);
						} else if(arrRowHeaders[j] === 'checkbox'  || arrRowHeaders[j] === 'radio') {
							heCheckbox = this._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[j]);
							
							heCell.appendChild(heCheckbox);
							if(arrRowHeaders[j]==='checkbox')
								heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
							else
								heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;
							
						}else if(arrRowHeaders[j] === 'state') {
							heCell.className += ' ' + css.ROWHEADER_STATE_INIT;
						} else if(arrRowHeaders[j] === 'custom') {
							heCell.className += ' ' + css.ROWHEADER_CUSTOM;
							this._setRowheaderCustom(heCell,nRow,nCol);
						}
					}
					// .attr('paginationinfo') 정보가 설정되었을 경우
					else {
						if(arrRowHeaders[j] === 'sequence' || arrRowHeaders[j] === 'reverse') {
							QBOX.util.textContent(heCell, arrRowHeaders[j] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit +  i)) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (i + 1)) );
						} else if(arrRowHeaders[j] === 'checkbox'|| arrRowHeaders[j] === 'reverse') {
							heCheckbox = this._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[j]);
							
							heCell.appendChild(heCheckbox);
							if(arrRowHeaders[j]==='checkbox')
								heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
							else
								heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;
							
						}else if(arrRowHeaders[j] === 'state') {
							heCell.className += ' ' + css.ROWHEADER_STATE_INIT;
						}else if(arrRowHeaders[j] === 'custom') {
							heCell.className += ' ' + css.ROWHEADER_CUSTOM;
							this._setRowheaderCustom(heCell,nRow,nCol);
						}							
					}
					heCell.className += ' ' + (nRowGroup === rowgroup.FROZEN ? css.CELL_FROZENROWS : css.CELL_NORMALROWS);
				}
				
				arrRowCellMatrix[nHeaderRows + i].push(heCell);
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createRowHeaderCells', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createRowheaderCheckbox = function(heCell, nRow, nCol,strType){
	strType = strType === undefined? "checkbox" : strType;
	var objRowheadercheckboxclick = this.attr('rowheadercheckboxclick'),
	heCheckbox = document.createElement('input'),
	bInvisible = this._getQCellCol(nCol).attr('cellinvisible')[nRow];
	heCheckbox.setAttribute("type", strType);
	heCheckbox.setAttribute("name", this.attr('id') + '_rowheader_col_' + nCol + '_checkbox');
	heCheckbox.setAttribute("data-row", nRow);
	heCheckbox.setAttribute("data-col", nCol);
	
	if(this.attr('rowheaderstitlekey') !== undefined && this.attr('rowheaderstitlekey') !== null){
		var arrTitleKey =this.attr('rowheaderstitlekey');
		
		if(arrTitleKey.length> nCol){
			var objData = this.getRowData(nRow);
			
			if(arrTitleKey[nCol] !== undefined && QBOX._.isFunction(arrTitleKey[nCol]) === true ){
				var strTitle = arrTitleKey[nCol](nRow,nCol,objData);
				
				if(strTitle !== undefined && strTitle !== '' )
					heCheckbox.setAttribute("title", strTitle);
			}
			
			if((arrTitleKey[nCol] !== undefined && arrTitleKey[nCol] !== '' )&&
					(objData[arrTitleKey[nCol]] !==undefined && objData[arrTitleKey[nCol]] !=='')){
				heCheckbox.setAttribute("title", objData[arrTitleKey[nCol]]);
			}
		}
	}
	
	if(strType === "checkbox")
		heCheckbox.className +=  QBOX.QCELL.def.css.CELL_ROWHEADER_CHECKBOX ;
	else
		heCheckbox.className +=  QBOX.QCELL.def.css.CELL_ROWHEADER_RADIO;
	
	
	if(this._getRowheaderData(nRow, nCol) === true) {
		heCheckbox.checked = true;
	} else {
		heCheckbox.checked = false;
	}
	
	if(!QBOX._.isUndefined(objRowheadercheckboxclick[nRow]) && !objRowheadercheckboxclick[nRow][nCol]){
		heCheckbox.setAttribute('disabled', 'disabled');
	} else {
		heCheckbox.removeAttribute('disabled');
	}
	
	//console.log(nRow, nCol, bInvisible);
	if(!QBOX._.isUndefined(bInvisible)){
		if(bInvisible){
			//QBOX.$(heCheckbox).hide();
			QBOX.$(heCheckbox).css({'visibility': 'hidden'});
		}else {
			//QBOX.$(heCheckbox).show();
			QBOX.$(heCheckbox).css({'visibility': 'visible'});
		}
	}
	
	/*
	if(QBOX._.isElement(heCell)){
		heCheckbox.style.position = 'absolute';
		heCheckbox.style.top = parseInt(QBOX.$(heCell).css('height')) / 4 +'px';
		heCheckbox.style.left = parseInt(QBOX.$(heCell).css('width')) / 2 - 10 + 'px';
	}
	*/
	
	if(this._getQCellCol(nCol).attr('celldisabled')[nRow] === true){
		heCheckbox.setAttribute('disabled', 'disabled');
	}
	
	return heCheckbox;
};
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._createColHeaderCells = function(heDiv){
	try{
		var objHSInfo = this.attr('hsinfo'), css = QBOX.QCELL.def.css,
		htElementPool = this.attr('elementpool'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nHeaderRowHeight = this.attr('rowheight').header,
		arrRowCellMatrix = this.attr('cellmatrix').get('row'),
		arrQCellCols = this.attr('qcellcols'), arrHeaderText = this.attr('headertext'),
		heColHeaderInner = htElementPool.get('colheaderinner'),
		nGap = QBOX.browser.name === 'msie' ? 0 : 2;
		
		for(var i = 0; i < nHeaderRows; i++){
			var nBeforeCellWidth = 0, nRow = i;
			
			if(arrRowCellMatrix[i] === undefined){//rowheader를 설정하지 않는 경우에는 현재 행에 표시될 셀들의 정보를 담을 배열을 추가해야 한다.
				arrRowCellMatrix.push([]);
			}
			
			for(var j = 0; j < objHSInfo.nDynamicCols; j++){
				var heCell = this._createCell(heDiv),
				nCol = j + nHeaderCols,
				nColWidth = this._getColWidth(nCol),
				strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow],
				objColStyle = this._getQCellCol(nCol).attr('style');
				
				heCell.setAttribute('data-row', nRow);
				heCell.setAttribute('data-col', nCol);
				heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
				heCell.style.width = nColWidth + 'px';
				heCell.style.height = nHeaderRowHeight + 'px';
				
				if(this._getColWordwrap(nCol)){
					heCell.style.whiteSpace = 'pre-wrap';
				}else{
					//heCell.style.lineHeight = (nHeaderRowHeight - nGap) + 'px';
					heCell.style.display = 'flex';
					heCell.style.justifyContent = 'center';
					heCell.style.alignItems = 'center';
				}								
				
				heCell.style.left = nBeforeCellWidth + 'px';
				heCell.style.top = (nHeaderRowHeight * i) + 'px';
				
				if(!QBOX._.isEmpty(objColStyle)){
					if(QBOX._.isObject(objColStyle.header)){
						var keys = Object.keys(objColStyle.header);
						for(var k = 0; k < keys.length; k++){
							QBOX.$(heCell).css(keys[k], objColStyle.header[keys[k]]);
						}
					}
					this.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
				}
				
				heCell.className += ' ' + css.CELL_COLHEADER + ' ' + css.CELL_HEADERROWS + ' ' + (j < nFrozenCols ? css.CELL_FROZENCOLS : css.CELL_NORMALCOLS) + ' ' + this._getColStyleClassName(nCol, 'header');
				
				heCell.innerHTML = this._getHeaderCellSpan(strHeaderCellText);
				
				if(nRow === nHeaderRows - 1 || this._isLastHeaderRowMasterCell(nRow, nCol)){
					if(this.attr('useGroupUI')){
						QBOX.$(heCell).draggable({
							helper: this._setGroupMakeHelper,
							revert: 'invalid'
						});
					}
					
					if(this._getQCellCol(nCol).attr('move')){						
						heCell.appendChild(this._getColHeaderDragDropArea());
					}
					
					if(this._getQCellCol(nCol).attr('search')){						
						heCell.appendChild(this.attr('colsearcharea').clone(true).get(0));
					}
					
					if(this._getQCellCol(nCol).attr('sort')){
						if(this.attr('defaultsortarea') === null){
							this.attr('defaultsortarea', this._createDefaultSortArea(heDiv), 'jquery');
						}
						
						if(this._getQCellCol(nCol).attr('colsortarea') === null){
							this._getQCellCol(nCol).attr('colsortarea', this.attr('defaultsortarea').clone(true), 'jquery');
						}
						
						heCell.appendChild(this._getQCellCol(nCol).attr('colsortarea').get(0));
					}
					
					if(this._getQCellCol(nCol).attr('resize')){						
						heCell.appendChild(this._getColResizeArea());
					}
					
					if(this._getQCellCol(nCol).attr('filter')){						
						heCell.appendChild(this._getFilterArea(nCol));
					}
					
					if(this._getQCellCol(nCol).attr('editor')){
						if(this.attr('colstyleeditorarea') === null){
							this.attr('colstyleeditorarea', this._createColStyleEditorArea(heDiv), 'jquery');
						}
						
						if(this.attr('colstyleeditorui') === null){
							this.attr('colstyleeditorui', this.attr('colstyleeditorarea').clone(true), 'jquery');
						}
						
						heCell.appendChild(this.attr('colstyleeditorui').get(0));
					}
				}
				
				heColHeaderInner.appendChild(heCell);
				
				arrRowCellMatrix[i].push(heCell);
				
				nBeforeCellWidth += parseFloat(nColWidth);
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createColHeaderCells', e.message);
		return false;
	}
};
*/
QBOX.QCELL.BasicQCELL.prototype._removeEmptymessage = function(){
	var css = QBOX.QCELL.def.css,
	heEmptyMessage = document.getElementsByClassName(css.EMPTYMESSAGE + '_' + this.getID());
	
	if(heEmptyMessage.length > 0){
		for(var i=0; i<heEmptyMessage.length; i++){
			var heParent = heEmptyMessage[i].parentNode;
			heParent.removeChild(heEmptyMessage[i]);
		}
	}
	
	return true;
};

QBOX.QCELL.BasicQCELL.prototype._createEmptymessage = function(heDiv){
	var css = QBOX.QCELL.def.css,
	nColWidth = 0, j = 0,
	nDynamicCols = this.attr('hsinfo').nDynamicCols,
	nViewPortClientHeight = this.attr('layoutsize').viewport.clientHeight,
	nViewPortClientWidth = this.attr('layoutsize').viewport.clientWidth,
	arrRowHeaders = this.attr('rowheaders'),
	nRowHeaderLength = arrRowHeaders.length,
	emptymessage = this.attr('emptymessage');
	
	for(j = nRowHeaderLength; j <= nDynamicCols; j++){
		nColWidth += QBOX._.isUndefined(this._getColWidth(j)) ? 0 : this._getColWidth(j);
	}
	
	if(nColWidth > nViewPortClientWidth){ // 총합이 viewport보다 작을 때
		heDiv.style.width = '100%';
	} else {
		heDiv.style.width = nColWidth + 'px';
	}
	
	heDiv.style.height = nViewPortClientHeight + 'px';				
	heDiv.style.lineHeight = (nViewPortClientHeight - 2) + 'px';
	
	heDiv.className += ' ' + css.CELL_VIEWPORT + ' ' + css.EMPTYMESSAGE + ' ' + css.EMPTYMESSAGE + '_' + this.getID(); // css에 EMPTYMESSAGE 추가
	
	QBOX.util.textContent(heDiv, emptymessage);
	
	return heDiv;
};
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._createViewPortCells = function(heDiv){
	try{
		var rowgroup = QBOX.QCELL.def.rowgroup, css = QBOX.QCELL.def.css,
		heViewPortInner = this.attr('elementpool').get('viewportinner'),
		arrRowCellMatrix = this.attr('cellmatrix').get('row'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nDataRowHeight = this.attr('rowheight').data, nViewPortClientHeight = this.attr('layoutsize').viewport.clientHeight,
		nViewPortClientWidth = this.attr('layoutsize').viewport.clientWidth,
		nHeaderColWidth = this.attr('headercolwidth'),
		nDynamicRows = this.attr('vsinfo').nDynamicRows, nDynamicCols = this.attr('hsinfo').nDynamicCols,
		nFrozenBottomRowCount = 0,
		nHighlightRepeat = this.attr('highlightrepeat'),
		nCurrentDataCount = arrCurrentData.length,
		emptymessage = this.attr('emptymessage'),
		i,//iterator
		heCell, nColWidth, nBeforeCellWidth,
		j,
		arrData = this.attr('data').input,
		nRowHeaderLength = arrRowHeaders.length,arrDataTextAlign=[], arrUseTextAlign=[];
		nGap = QBOX.browser.name === 'msie' ? 0 : 2;
		
		if(nDynamicRows === 0 && arrData.length === 0) { // data가 없을 시, 생성할 rows가 없을 때
			if(QBOX.$.trim(emptymessage).length > 0) { // 설정된 emptymessage가 있을 때
				heCell = this._createEmptymessage(heDiv);
				heViewPortInner.appendChild(heCell);
			}
		} else {
			for(i = 0; i < nDynamicRows; i++){//i:iterator
				var nRow = i + nHeaderRows,
				nRowGroup;
				nBeforeCellWidth = 0;
				
				//1. 틀고정 행/일반 데이터 행/하단 틀고정 행/표시되지 않는 행 식별 
				nRowGroup = this._getRowGroupOfDynamicRows(i);
				
				if(arrRowCellMatrix[nHeaderRows + i] === undefined){
					arrRowCellMatrix.push([]);
				}
				
				if(nRowGroup === rowgroup.FROZENBOTTOM){
					nRow = nCurrentDataCount + nHeaderRows - (nDynamicRows - i);
					nFrozenBottomRowCount += 1;
				}
				
				for(j = 0; j < nDynamicCols; j++){
					var nCol = j + nHeaderCols,
					keyOfCol = this._getKeyOfCol(nCol),
					cellData,
					objColStyle = this._getQCellCol(nCol).attr('style'); 
					
					if(i===0){
						arrUseTextAlign.push(this._useDataTextAlign(nCol));
						arrDataTextAlign.push(this._getDataTextAlign(nCol));
					}
					
					heCell = this._createCell(heDiv);
					nColWidth = this._getColWidth(nCol);
					
					heCell.style.width = nColWidth + 'px';
					heCell.style.height = nDataRowHeight + 'px';
					if(arrUseTextAlign[j])heCell.style.textAlign = arrDataTextAlign[j];
					
					if(this._getColWordwrap(nCol)){
						heCell.style.whiteSpace = 'pre-wrap';
					}else{
						heCell.style.lineHeight = (nDataRowHeight - nGap) + 'px';
						//heCell.style.display = 'flex';
						//heCell.style.justifyContent = 'center';
						//heCell.style.alignItems = 'center';
					}
					
					heCell.style.left = nBeforeCellWidth + 'px';
					
					if(!QBOX._.isEmpty(objColStyle)){
						if(QBOX._.isObject(objColStyle.data)){
							var keys = Object.keys(objColStyle.data);
							for(var k = 0; k < keys.length; k++){
								QBOX.$(heCell).css(keys[k], objColStyle.data[keys[k]]);
							}
						}
						this.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
					}
					
					heCell.className += ' ' + css.CELL_VIEWPORT + ' ' + (j < nFrozenCols ? css.CELL_FROZENCOLS : css.CELL_NORMALCOLS) + ' ' + this._getColStyleClassName(nCol, 'data');
					heCell.setAttribute('data-row', nRow);
					heCell.setAttribute('data-col', nCol);
					heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
					
					arrRowCellMatrix[nHeaderRows + i].push(heCell);
					if(nRowGroup === rowgroup.FROZENBOTTOM){//FrozenBottomRows영역에 표시 할 행에 속한 cell인 경우
						//FrozenBottomRows영역에 표시할 행의 top은 하단영역에서부터 맞춰준다.
						cellData = arrCurrentData[nRow - nHeaderRows][keyOfCol];
						heCell.style.top = (nViewPortClientHeight - (nDataRowHeight * (nDynamicRows - i))) + 'px';
						heCell.className += ' ' + css.CELL_FROZENBOTTOMROWS;
					} else{//FrozenRows, 일반 데이터 표시 영역에 표시 할 행에 속한 cell인 경우
						cellData = arrCurrentData[i][keyOfCol];
						heCell.style.top = (nDataRowHeight * i) + 'px';
						heCell.className += ' ' + (nRowGroup === rowgroup.FROZEN ? css.CELL_FROZENROWS : css.CELL_NORMALROWS);
					}
					
					cellData = cellData === undefined ? '' : cellData;
					var strDataFormat = this._showDataFormat(nCol, cellData);
					
					QBOX.util.textContent(heCell, strDataFormat);
					
					if(nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0)){
						heCell.className += ' ' + css.CELL_HIGHLIGHTREPEAT;
					}
					
					heViewPortInner.appendChild(heCell);
					
					nBeforeCellWidth += parseFloat(nColWidth);
				}
			}			
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createViewPortCells', e.message);
		return false;
	}
};
*/
QBOX.QCELL.BasicQCELL.prototype._createFooterRowHeaderCells = function(heDiv){
	try{
		var htElementPool = this.attr('elementpool'), css = QBOX.QCELL.def.css,
		heFooterRowHeaderInner = htElementPool.get('footerrowheaderinner'),
		arrRowCellMatrix = this.attr('cellmatrix').get('row'),
		nFooterRows = this.attr('footerrows'), nFooterRowHeight = this.attr('rowheight').footer,
		nHeaderRows = this.attr('headerrows'), nHeaderCols = this.attr('headercols'),
		nDynamicRows = this.attr('vsinfo').nDynamicRows,
		nHeaderColWidth = this.attr('headercolwidth'),
		nGap = QBOX.browser.name === 'msie' ? 0 : 2;
		
		for(var i = 0; i < nFooterRows; i++){
			arrRowCellMatrix.push([]);
			
			for(var j = 0; j < nHeaderCols; j++){
				var heCell = this._createCell(heDiv);
				heCell.style.width = nHeaderColWidth + 'px';
				heCell.style.height = nFooterRowHeight + 'px';
				heCell.style.lineHeight = (nFooterRowHeight - nGap) + 'px';
				
				heCell.className +=  ' ' + css.CELL_FOOTERROWHEADER + ' ' + css.CELL_FOOTERROWS + ' ' + css.CELL_HEADERCOLS;
				//QBOX.util.textContent(heCell, arrRowHeaders[j] === 'reverse' ? nCurrentDataCount - i : i + 1);
				//heCell.setAttribute('data-row', i + nHeaderRows);
				heCell.setAttribute('data-col', j);
				heCell.style.left = (nHeaderColWidth * j) + 'px';
				heCell.style.top = (nFooterRowHeight * i) + 'px';
				
				heFooterRowHeaderInner.appendChild(heCell);
				
				arrRowCellMatrix[nHeaderRows + nDynamicRows + i].push(heCell);
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createFooterRowHeaderCells', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createFooterCells = function(heDiv){
	try{
		var objHSInfo = this.attr('hsinfo'), css = QBOX.QCELL.def.css,
		htElementPool = this.attr('elementpool'),
		arrRowCellMatrix = this.attr('cellmatrix').get('row'),
		nFooterRows = this.attr('footerrows'), nFooterRowHeight = this.attr('rowheight').footer,
		nHeaderRows = this.attr('headerrows'), nHeaderCols = this.attr('headercols'),
		nFrozenCols = this.attr('frozencols'),
		nDynamicRows = this.attr('vsinfo').nDynamicRows,
		heFooterInner = htElementPool.get('footerinner'),
		nGap = QBOX.browser.name === 'msie' ? 0 : 2,bTab;
		
		for(var i = 0; i < nFooterRows; i++){
			var nBeforeCellWidth = 0;
			
			if(arrRowCellMatrix[nHeaderRows + nDynamicRows + i] === undefined){
				arrRowCellMatrix.push([]);
			}
			
			for(var j = 0; j < objHSInfo.nDynamicCols; j++){
				bTab = this._getColTabindex(j);
				var heCell = this._createCell(heDiv,bTab),
				nCol = j + nHeaderCols,
				nColWidth = this._getColWidth(nCol);
				heCell.style.width = nColWidth + 'px';
				heCell.style.height = nFooterRowHeight + 'px';
				
				if(this._getColWordwrap(nCol)){
					heCell.style.whiteSpace = 'pre-wrap';
				}else{
					heCell.style.lineHeight = (nFooterRowHeight - nGap) + 'px';
					//heCell.style.display = 'flex';
					//heCell.style.justifyContent = 'center';
					//heCell.style.alignItems = 'center';
				}
				
				heCell.style.left = nBeforeCellWidth + 'px';
				heCell.style.top = (nFooterRowHeight * i) + 'px';
				heCell.className += ' ' + (j < nFrozenCols ? css.CELL_FROZENCOLS : css.CELL_NORMALCOLS) + ' ' + css.CELL_FOOTER + ' ' + css.CELL_FOOTERROWS;
				heCell.setAttribute('data-col', nCol);
				heCell.setAttribute('data-footer', true);
				
				heFooterInner.appendChild(heCell);
				
				arrRowCellMatrix[nHeaderRows + nDynamicRows + i].push(heCell);
				
				nBeforeCellWidth += parseFloat(nColWidth);
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._createFooterCells', e.message);
		return false;
	}
};
QBOX.QCELL.BasicQCELL.prototype._getColHeaderDragDropArea = function(){
	if(this.attr('colheaderdndarea') === null){
		var heDiv = document.createElement('div');
		this.attr('colheaderdndarea', this._createColHeaderDragDropArea(heDiv), 'jquery');
	}
	
	return this.attr('colheaderdndarea').clone(true).get(0);
};
QBOX.QCELL.BasicQCELL.prototype._createColHeaderDragDropArea = function(heDiv){
	//ColHeader에 표시되는 컬럼이동을 위한 아이콘 표시 영역 Element를 생성한다.
	var css = QBOX.QCELL.def.css;
	
	/*
	 * Drag and Drop을 이용한 컬럼 이동 로직 구현 순서
	 * 1. "ColHeaderDragDropArea" 영역에 "mousedown" 이벤트 발생 시 컬럼 이동을 위한 Drag and Drop이 발생했다고 판단하며 "colmove" 속성을 true로 설정하고 "colMoveShadow" UI를 숨김상태로 생성한다.
	 * 2. document에서 "movemove" 이벤트 발생 시 "colMoveShadow" UI를 마우스 커서 위치로 이동시킨다.
	 * 3. QCELL의 "mousemove" 이벤트 발생 시 컬럼 이동 위치를 의미하는 경계선을 표시하고 컬럼 이동 가능 여부를 결정한다.
	 * 4. document에서 "mouseup" 이벤트 발생 시 컬럼을 이동시키고 "colMoveShadow", "colMoveLine" UI를 제거한다.
	 */
	
	return QBOX.$(heDiv.cloneNode()).addClass(css.COLHEADER_DRAG_AND_DROP_AREA).on('mousedown', this.attr('eventparam'), function(event){
		//console.log('컬럼 이동 시작');
		var target = event.target,
		objQCell = event.data.target,
		objLayoutSize = objQCell.attr('layoutsize'),
		arrColCellDOMs = [],
		$colMoveShadow,
		$colMoveLine,
		nHeaderRows = objQCell.attr('headerrows'),
		nFrozenBottomRows = objQCell.attr('frozenbottomrows'),
		nRows = objQCell.attr('rows'),
		nCol = target.parentNode.getAttribute('data-col'),
		nAdjustHeight = 0,
		nAdjustHeight2 = 0;
		
		objQCell.attr('colmove', true, 'boolean');
		objQCell.attr('colmoveexecution', false, 'boolean');
		
		QBOX._.each(objQCell._getColCellDOMs(nCol), function(heOriginCell, idx){
			var heCell = heOriginCell.cloneNode(true);
			nRow = parseInt(heCell.getAttribute('data-row'));
			
			heCell.style.left = '0px';
			//heCell.style.width = '100%';
			//heCell.style.borderLeftWidth = '1px';
			heCell.style.display = 'block';
			
			//"colMoveShadow" div에 표시하기 위해 colheader, viewport, footer 영역에 있던 셀 div들의 top값을 보정
			if(isNaN(nRow)){//footerRows
				heCell.style.top = (parseInt(heCell.style.top) + nAdjustHeight2) + 'px';
			} else{
				if(nRow < nHeaderRows){//HeaderRows
					heCell.style.top = nAdjustHeight + 'px';
					
					nAdjustHeight += parseInt(heCell.style.height);
				} else{
					heCell.style.top = (parseInt(heCell.style.top) + nAdjustHeight) + 'px';
					
					if(nRow >= nRows - nFrozenBottomRows){
						nAdjustHeight2 = parseInt(heCell.style.top) + parseInt(heCell.style.height);
					}
				}
			}
			
			arrColCellDOMs.push(heCell);
		});
		
		//최하단의 셀이 frozenbottomrows나 footerrows인 경우 border-bottom이 없어 채워준다.
		QBOX._.last(arrColCellDOMs).style.borderBottomWidth = '1px';
		
		$colMoveShadow = QBOX.$(heDiv.cloneNode()).addClass(css.COLMOVE_SHADOW).attr('data-col', nCol)
		.css({display: 'none'}).append(arrColCellDOMs).appendTo(document.body);
		
		objQCell.attr('colmoveshadow', $colMoveShadow, 'jquery');
		
		$colMoveLine = QBOX.$(heDiv.cloneNode()).addClass(css.COLMOVELINE).css({
			'display'	: 'none',
			'height'	: objLayoutSize.colheader.offsetHeight + objLayoutSize.viewport.offsetHeight + objLayoutSize.footer.offsetHeight
		}).appendTo(objQCell.attr('elementpool').get('container'));
		
		objQCell.attr('colmoveline', $colMoveLine, 'jquery');
	});
};

QBOX.QCELL.BasicQCELL.prototype._getColResizeArea = function(){
	if(this.attr('colresizearea') === null){
		var heDiv = document.createElement('div');
		this.attr('colresizearea', this._createColResizeArea(heDiv), 'jquery');
	}
	return this.attr('colresizearea').clone(true).get(0);
};
QBOX.QCELL.BasicQCELL.prototype._createColResizeArea = function(heDiv){
	var css = QBOX.QCELL.def.css;
	
	var clicks = 0, delay = 400;
	return QBOX.$(heDiv.cloneNode()).addClass(css.COLRESIZE_AREA).on('mousedown', this.attr('eventparam'), function(event){
		event.preventDefault();
        clicks++;
        
		var target = event.target,
		objQCell = event.data.target,
		$colResizeLine, $colResizeTooltip,
		objLayoutSize = objQCell.attr('layoutsize');
		
		 setTimeout(function() {
             clicks = 0;
         }, delay);
         if (clicks === 2) {
             var nCol = QBOX.$(target).parent().attr('data-col'),
             colHeaderData = objQCell.attr('headertext')[nCol], // header title
             colData = objQCell._getColData(nCol), // col data
             strWidth = 13, colWidth = 0, len = 0, j = 0; //, korean = /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/;
             
             for(j = 0; j < colHeaderData.length; j++){ // header title check
            	 try{
                	 colHeaderData[j] = colHeaderData[j] === undefined ? '' :colHeaderData[j] ;
                	 colHeaderData[j] = '' + colHeaderData[j];
                	 len = colHeaderData[j].length * strWidth;            		 
            	 }catch(e){
            		 len =0;
            	 }
            	 
            	 if(len > colWidth){
        			 colWidth = len;
        		 }
             }
             
             for(j = 0; j < colData.length; j++){ // col data check
            	 try{
                	 colData[j] = colData[j] === undefined ? '' : colData[j];
                	 colData[j] = '' + colData[j];
                	 len = colData[j].length * strWidth;            		 
            	 }catch(e){
            		 len = 0;
            	 }
            	 
            	 if(len > colWidth){
        			 colWidth = len;
        		 }
             }
             
             nCol = parseInt(nCol);
             colWidth = parseInt(colWidth);
             
             setTimeout(function(){
            	 objQCell.setColWidth(nCol, colWidth);
             },0);
             
             return;
         }
		
		objQCell.attr('colresize', true, 'boolean');
		
		$colResizeLine = QBOX.$(heDiv.cloneNode()).addClass(css.COLRESIZELINE).css({
			'display'	: 'none',
			'height'	: objLayoutSize.colheader.offsetHeight + objLayoutSize.viewport.offsetHeight + objLayoutSize.footer.offsetHeight
		}).appendTo(objQCell.attr('elementpool').get('container'));
		
		objQCell.attr('colresizeline', $colResizeLine, 'jquery');
		
		//컬럼 너비 조절시 시각적 표현 위한 tooltip 영역 처리
		$colResizeTooltip = QBOX.$(heDiv.cloneNode()).addClass(css.COLRESIZETOOLTIP).css({
			'display'	: 'none'
		}).appendTo(objQCell.attr('elementpool').get('container'));
		
		objQCell.attr('colresizetooltip', $colResizeTooltip, 'jquery');
	});
};

QBOX.QCELL.BasicQCELL.prototype._createInputForm = function(){
	var heRoot = this.attr('elementpool').get('root'),heDiv ,
		strID = this.attr('id'), def = QBOX.QCELL.def,THAT = this,form,strInputId,heDivRoot;
	
	if(document.getElementById( def.areaname.INPUTFORM + '-root' + strID) !== null){
		heRoot.removeChild(document.getElementById( def.areaname.INPUTFORM + '-root' + strID));
	}
	if(this.attr('jqDialog') !== null){
		this.attr('jqDialog').dialog('destroy');
	}
	heDivRoot = document.createElement('div');
	heDivRoot.setAttribute('id', def.areaname.INPUTFORM + '-root' + strID);
	
	heDiv = document.createElement('div');
	
	heDiv.setAttribute('id', def.areaname.INPUTFORM + '-' + strID);
	heDiv.className += def.css.INPUTFORM_INNER;
	
	var heForm=document.createElement('form'), heFiledset = document.createElement('fieldset'),
	nHeaderCols = this.attr('headercols'),nCols = this.attr('cols'),nHeaderRows = this.attr('headerrows'),i;
	
	
	
	for(i=nHeaderCols; i< nCols;i++){
		var heLabel = document.createElement('label'),heText = document.createTextNode(this._cellValue(nHeaderRows-1,i));
		var heInput, strKey = this._getKeyOfCol(i);
		strInputId = strID+'_'+strKey+'_'+this.getColID(i);
		switch(this._getColType(i)){
			case 'input' :{
				heInput = document.createElement('input');
				break;				
			}
			case 'checkbox' : {
				heInput = document.createElement('input');
				heInput.setAttribute('type','checkbox');
				break;
			}
			case 'textarea' :{
				heInput = document.createElement('textarea');
			
				break;				
			}
			case 'datepicker':{
				heInput = document.createElement('input');
				heInput.setAttribute('type','date');
				break;
			}
			case 'image' :{
				heInput = document.createElement('img');
				break;
			}
			case 'selectmenu' :{
				heInput = document.createElement('select');
				
				var arrData = this._getColElement(i)._getDataArray(),heOption,label,value;
				
				for(var t = 0; t < arrData.length; t++ ){
					heOption = document.createElement('option');
					label =arrData[t].label;
					value =arrData[t].value;					
					heOption.setAttribute('value', value);
					heOption.innerHTML = label;					
					QBOX.$(heInput).append(heOption);
					
					heOption = null;
				}
				
				break;
			}
			default : {
				heInput = document.createElement('output');
			}
		}
		
		heInput.setAttribute('name',strInputId);
		heInput.setAttribute('id',strInputId);
		//heInput.style.display = "block";
		//heInput.style.width = "100%";
		heInput.className += def.css.INPUTFORM_ITEM;
		
		
		heLabel.appendChild(heText);
		heLabel.setAttribute('for',strInputId);
		//heLabel.style.display = "block";
		//heLabel.style.width = "100%";
		heLabel.className += def.css.INPUTFORM_HEADER;
		
		heFiledset.appendChild(heLabel);
		heFiledset.appendChild(heInput);
		
		heFiledset.appendChild(document.createElement('br'));
	}
	heDiv.setAttribute('title','Input Form');
	heForm.appendChild(heFiledset);
	heDiv.appendChild(heForm);	
	
	var heSubmit = document.createElement('input');
	heSubmit.setAttribute('type','submit');
	heSubmit.setAttribute('tabindex','-1');
	
	heDivRoot.appendChild(heDiv);
	
	heRoot.appendChild(heDivRoot);
	
	var jqDialog = QBOX.$(heDiv).dialog({
		autoOpen:false,
		height: 'auto' ,
		width : '80%',
		modal : true,
		buttons: {
	        "적용": function(){
	        	var obj = THAT.attr('inputformdata');
	        	if(obj === null)
	        		return;
	        	if(THAT.attr('inputformdatarow') === -1 || THAT.attr('inputformdatarow') === null)
	        		return;
	        	
	        	for(i=nHeaderCols; i< nCols;i++){
	        		var strKey = THAT._getKeyOfCol(i), heElement;
	        		strInputId = strID+'_'+strKey+'_'+THAT.getColID(i);
	        		
	        		var heChild = document.getElementById(strInputId),strValue = QBOX.$(heChild).val();
	        		
	        		if(THAT._getColType(i) === 'checkbox'){
	        			if(heChild.checked !== obj[strKey]){
	        				THAT.setCellDataEx(THAT.attr('inputformdatarow'),strKey,heChild.checked);
	        			}
	        		}else{	
	        			if(THAT._getColType(i) === 'datepicker')
	        				strValue = QBOX.util.replaceAll(strValue,'-','');
	        			else if(THAT._getColType(i) === 'image')
	        				continue;
	        			if(QBOX._.isNumber(obj[strKey])){
		        			if(obj[strKey] !== parseInt(strValue) )
		        				THAT.setCellDataEx(THAT.attr('inputformdatarow'),strKey,parseInt(strValue));	        				
	        				
	        			}else{
		        			if(obj[strKey] !== strValue )
		        				THAT.setCellDataEx(THAT.attr('inputformdatarow'),strKey,strValue);	        				
	        			}
	        		}		
	        	}
	        	THAT.attr('inputformdatarow',-1,'number');
	        	THAT.attr('inputformdata',null,'object');
	        	THAT.attr('isInputForm',false,'boolean');
	        	THAT.attr('jqDialog').dialog( "close" );
	        	
	        },
	        "취소": function() {
	        	THAT.attr('inputformdatarow',-1,'number');
	        	THAT.attr('inputformdata',null,'object');
	        	THAT.attr('isInputForm',false,'boolean');
	        	THAT.attr('jqDialog').dialog( "close" );
	        }
	      },
		  beforeClose : function(){
	        	THAT.attr('inputformdatarow',-1,'number');
	        	THAT.attr('inputformdata',null,'object');
	        	THAT.attr('isInputForm',false,'boolean');
			  },
			
	      close: function() {
	        form[ 0 ].reset();
	    	setTimeout(function(){
				THAT.onResize();	
			},0);
	      }
	});
	
	form = jqDialog.find( "form" ).on( "submit", function( event ) {
	      event.preventDefault();
	      alert('t2');
	    });
	
	this.attr('jqDialog',jqDialog,'jquery');
};
QBOX.QCELL.BasicQCELL.prototype._initData = function(){
	var bool = true;
	try{
		var onloadurl = this.attr('onloadurl'),
		objQCell = this;
		
		if( QBOX._.isUndefined(onloadurl) === false && QBOX._.isNull(onloadurl) === false && QBOX._.isString(onloadurl) ){
			// ajax 통신 동기화 처리
			if(this.attr('bLoadurlstop') !== true){
				setTimeout(function(){
					QBOX.$.ajaxSetup({async: false});
					var fnQCELLSucess = function(result){
						var jsonData = null;
						if(QBOX._.isArray(result)){
							jsonData = result;
						}else if (QBOX._.isObject(result)){
							var arrData = [];
							arrData.push(result);
							jsonData = arrData;
						}else{
							try{
								jsonData = JSON.parse(result);
							}catch(e){
								QCELL.log('err', 'QCELL.BasicQCELL._initData', e.message);
								jsonData = [];
							}
						}
						
						if(objQCell.attr('onloadurlsucesscallback') !== null && QBOX._.isFunction(objQCell.attr('onloadurlsucesscallback'))){
							jsonData = objQCell.attr('onloadurlsucesscallback')(jsonData);
						}
						
						objQCell._setColsDataType(jsonData);
						objQCell._setCurrentData(jsonData,true);
						
						if(objQCell.attr('original')){
							objQCell.attr('origindata', QBOX.$.extend(true, [], JSON.parse(result)), 'array'); 
						}	
					};
					
					var fnQCELLFail = function(){
						if(objQCell.attr('onloadurlfailcallback') !== null && QBOX._.isFunction(objQCell.attr('onloadurlfailcallback'))){
							objQCell.attr('onloadurlfailcallback')();
						}
					};
					if(objQCell.attr('onloadurlparam') !== null){
						QBOX.$.post(onloadurl, objQCell.attr('onloadurlparam'),fnQCELLSucess).fail(fnQCELLFail);	
					}else{
						QBOX.$.post(onloadurl, fnQCELLSucess).fail(fnQCELLFail);					
					}
				},0);					
			}else{
				var arrBD = this.attr('arrBackupData');
				if(QBOX._.isArray(arrBD)){
					this._setColsDataType(arrBD); // 0번째 데이터로 컬럼의 데이터 타입 설정
					this._updateCurrentData(arrBD);
					this.attr('arrBackupData', null, 'array');
					
					this.attr('idxinfo', this.attr('objBackupIdx'),'object');
					this.attr('deletedrowsdata', this.attr('arrBackupDeletedrowsdata'),'array');
					this.attr('objBackupIdx',null,'object');
					this.attr('arrBackupDeletedrowsdata', null, 'array');
					arrBD = [];
				}
			}

		} else {
			var arrData = this.attr('bLoadurlstop') === true ? this.attr('arrBackupData') : this.attr('data').input;
			this._setColsDataType(arrData); // 0번째 데이터로 컬럼의 데이터 타입 설정
			this._updateCurrentData(arrData);
			
			if(this.attr('bLoadurlstop') === true){
				this.attr('arrBackupData', null, 'array');
				
				this.attr('idxinfo', this.attr('objBackupIdx'),'object');
				this.attr('deletedrowsdata', this.attr('arrBackupDeletedrowsdata'),'array');
				this.attr('objBackupIdx',null,'object');
				this.attr('arrBackupDeletedrowsdata', null, 'array');
				
				this.attr('bLoadurlstop',false,'boolean');
			}
			
			if(this.attr('original')){
				this.attr('origindata', QBOX.$.extend(true, [], this.attr('data').input), 'array'); 
			}
		}
		bool = true;
		this.attr('bLoadurlstop',false,'boolean' );
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._initData', e.message);
		bool = false;
	} finally {
		// 통신완료 후 비동기화 처리
		QBOX.$.ajaxSetup({async: true});
	}
	
	return bool;
};

QBOX.QCELL.BasicQCELL.prototype._updateCurrentData = function(data){
	this.removeAttr('currentdata');
	var THAT = this;	
	if(!QBOX._.isEmpty(data) && QBOX._.isArray(data) && data.length !== 0){
		setTimeout(function(){
			THAT._removeEmptymessage();
		});
		
		if(this.attr('makefrozenbottomdata') === true){
			if(data[data.length-1].rt_qc_fbrd !== true){
				data.push({'rt_qc_fbrd' : true});
				setTimeout(function (){
					THAT._trigger('frozendatacreated');			
				},0);				
			}else{
				setTimeout(function (){
					THAT._trigger('frozendataupdated');			
				},0);
			}
		}
	}else{
		if(QBOX._.isEmpty(data) || QBOX._.isArray(data) || data.length === 0){
			var emptymessage = this.attr('emptymessage');
			
			if(QBOX.$.trim(emptymessage).length > 0 && this.attr('useemptymessage') !== false) {
				setTimeout(function (){
					THAT._removeEmptymessage();
					var heDiv = document.createElement('div'),heCell,heViewPortInner = THAT.attr('elementpool').get('viewportinner');
					heCell = THAT._createEmptymessage(heDiv);
					heViewPortInner.appendChild(heCell);					
				});
			}
		}
			
	
		
	}
	
	this.attr('currentdata', (data !== undefined && QBOX._.isArray(data)) ? data : [], 'array');
	this.attr('rows', this.attr('headerrows') + this.attr('currentdata').length, 'number');
	
	this._setVSRange();//세로스크롤바 이동 범위 설정(nStartRow, nEndRow 설정)
};

QBOX.QCELL.BasicQCELL.prototype._setCurrentData = function(data, bInitScrollbarPos,bKeep){
	if(QBOX._.isArray(data)){
		var objQCell = this,
		objHSInfo = this.attr('hsinfo'),
		objVSInfo = this.attr('vsinfo'),
		bVScroll = objVSInfo.bVScroll,
		nCurrentDataCount,			//데이터 변경 전 카운트
		nUpdatedCurrentDataCount;	//데이터 변경 후 카운트
		
		nCurrentDataCount = this.attr('currentdata').length;
		
		this._updateCurrentData(data);
		this._initRowheaderData();
		
		nUpdatedCurrentDataCount = this.attr('currentdata').length;
		
		this._clearFocus();			//focus 초기화
		this._clearSelection();		//selection 초기화
		this._clearCellStyles();	//cell style 초기화
		
		//DynamicRow 추가/삭제
		if(nCurrentDataCount < nUpdatedCurrentDataCount){//데이터 수 증가 시
			this._makeRowUI(nUpdatedCurrentDataCount - nCurrentDataCount,bKeep);
		} else if(nCurrentDataCount > nUpdatedCurrentDataCount){//데이터 수 감소 시
			this._removeRowUI(nCurrentDataCount - nUpdatedCurrentDataCount,bKeep);
		}
		
		//Dynamic CSS 제거
		this._clearHighlightRepeatCSS();
		this._clearDynamicCSS('row', 'data');
		
		//화면 갱신
		this._refreshDRs();
		
		if(bVScroll !== objVSInfo.bVScroll){
			//세로스크롤바 표시여부가 행 추가삭제 이전과 달리지는 경우 headerCols를 제외한 모든 컬럼의 colWidth가 변경되어 보정이 필요하다.
			//dynamicRows 추가삭제 후 컬럼 기준 refresh전에 행 기준 refresh를 수행해야 cellDOM에 'data-row'값이 정상적으로 세팅된다.
			var objGroupState = this.attr('groupstate').grouped === true ? this.attr('groupstate') : this.attr('treestate');
			if(objGroupState.grouped === true){
				this._refreshDCs();
			}else{
				this.resize();
			}
		}
		
		if(bInitScrollbarPos){
			if(objHSInfo.bHScroll && objHSInfo.nPos !== 0){
				setTimeout(function(){
					objQCell._scrollLeft(objHSInfo.nStartCol);
				}, 200);
			}
			
			if(objVSInfo.bVScroll && objVSInfo.nPos !== 0){
				setTimeout(function(){
					objQCell._scrollTop(objVSInfo.nStartRow);
				}, 200);
			}
		}
		
		return true;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._setData = function(data){
	//_setData() 로직은 _createElement() 로직과 유사하지만, 초기화해야 할 속성들만 초기화해야 하고 layout 영역을 재생성하지 않고 초기화 해 준다.
	var THAT = this;
	if(QBOX._.isArray(data)){
		this.attr('data').input = data;			//reference data 변경
		
		this._rebuild();
		
//		//1. 동적 정보 초기화
//		this._clearDynamicStyles();				//동적 스타일 정보 초기화
//		this._clearFocus();						//포커스 정보 초기화
//		this._clearSelection();				//selection 정보 초기화
//		
//		//2. 스크롤바 정보 초기화
//		this._initHSInfo();						//가로스크롤바 정보 초기화
//		this._initVSInfo();						//세로스크롤바 정보 초기화
//		
//		//3. cell DOM 제거
//		this._initLayout();						//layout 초기화, 스크롤바UI제거
//		
//		//4. 데이터 바인딩
//		this._updateCurrentData(data);		//currentdata 변경
//		
//		//5. 스크롤바 이동 범위 설정
//		this._setHSRange();						//가로스크롤바 이동 범위 설정
//		this._setVSRange();						//세로스크롤바 이동 범위 설정
//		
//		//6. 스크롤바 생성 여부 확인
//		this._initLayoutSize();					//root, panel, container의 사이즈, 위치  설정, 스크롤바 생성 여부 확인(DOM이 박혀있어야만 정확하게 세팅이 가능하다.)
//		
//		//7. 스크롤바 존재 여부에 따른 틀고정 기능 사용 가능 여부 보정
//		this._adjustFrozenCount();
//		
//		//block의 크기가 정해졌으면
//		
//		//8. DynamicCols, DynamicRows 계산
//		this._calculateDynamicCols();			//몇 개의 열 div를 만들 것인지 계산한다. -> 사이즈가 변경되지 않았더라도 세로스크롤바가 표시되지 않는 경우 dynamicCols값이 바뀔 수 있다.
//		this._calculateDynamicRows();			//몇 개의 행 div를 만들 것인지 계산한다. -> 사이즈가 변경되지 않았더라도 데이터의 수에 따라 dynamicRows값이 바뀔 수 있다.
//		
//		//9. cell DOM 생성
//		this._createFlesh();				//각 block에 셀들을 생성한다.
//		
//		//10. 스크롤바 사이즈 조정
//		this._resizeHScrollbar();				//가로스크롤바 길이 갱신
//		this._resizeVScrollbar();				//세로스크롤바 길이 갱신
//		//_resizeVScrollbar()에서 스크롤바를 움직이면 rebuild()수행 시 스크립트 오류가 발생한다.
//		/*.mCustomScrollbar('scrollTo', objVSInfo.nTop, '', {ignorecallback:true})*/
//		
//		//10. 스크롤바 정보 갱신
//		this._updateHSInfo();					//hsinfo 정보 갱신
//		this._updateVSInfo();					//vsinfo 정보 갱신
		
		// pagination 정보가 있으면 setData시 1페이지로 이동
		if(QBOX._.isEmpty(this.attr('paginationinfo')) === false){
			this.attr('bRebuildWithPrevData',true,'boolean');
			this._movePage(1);
			this.attr('bRebuildWithPrevData',false,'boolean');
		}
		
		setTimeout(function (){
			THAT._trigger('datachanged');			
		},0);
		
		
		return true;
	}
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._getRowData = function(nRow){
	var rowdata = this.attr('currentdata')[nRow - this.attr('headerrows')];
	
	if(rowdata !== undefined){
		rowdata = QBOX._.clone(rowdata);
	}
	
	return rowdata;
};

QBOX.QCELL.BasicQCELL.prototype._getRowDataWithFormat = function(nRow){
	var rowdata = this.attr('currentdata')[nRow - this.attr('headerrows')];
	
	if(rowdata !== undefined){
		rowdata = QBOX._.clone(rowdata);
		
		for(var key in rowdata){
			var arr = this.getColsOfKey(key);
			if(arr.length > 0)
				rowdata[key] = this._getCellLabel(nRow,arr[0]);
		}
	}
	
	return rowdata;
};

QBOX.QCELL.BasicQCELL.prototype._setRowData = function(nRow, /*Array or Object*/rowdata){
	var objQCell = this,
	result = false;
	
	//행 데이터 통째로 변경
	this.attr('currentdata')[nRow - this.attr('headerrows')] = rowdata = QBOX._.clone(rowdata);
	var cellData;	
	for(var j = this.attr('headercols'), nCols = this.attr('cols'); j < nCols; j++){
		cellData = rowdata[this._getKeyOfCol(j)] === undefined ? '':rowdata[this._getKeyOfCol(j)];
		result = this._cellValue(nRow, j,  cellData);
		
		if(result === false){
			break;
		}
	}
	
	setTimeout(function (){
		objQCell._trigger('rowdatachanged');			
	},0);
	
	return result;
};
QBOX.QCELL.BasicQCELL.prototype._setRowDataEx = function(nRow, /*Array or Object*/rowdata){
	var objQCell = this,
	result = false;
	
	//행 데이터 통째로 변경
	this.attr('currentdata')[nRow - this.attr('headerrows')] = rowdata = QBOX._.clone(rowdata);
	var cellData;	
	for(var j = this.attr('headercols'), nCols = this.attr('cols'); j < nCols; j++){
		cellData = rowdata[this._getKeyOfCol(j)] === undefined ? '':rowdata[this._getKeyOfCol(j)];
		var objFormat = j !== undefined ? objQCell._getColFormat(j) : undefined;
		result = this._cellValue(nRow, j,  cellData);
		
		if(objFormat !== undefined && (
				this.attr('currentdata')[nRow - this.attr('headerrows')].rt_qc_header === true ||
				this.attr('currentdata')[nRow - this.attr('headerrows')].rt_qc_footer === true
				)){
			cellData = this._showDataFormat(nRow,j, cellData);
			rowdata[this._getKeyOfCol(j)] = cellData;
		}		
		
		if(result === false){
			break;
		}
	}
	
	setTimeout(function (){
		objQCell._trigger('rowdatachanged');			
	},0);
	
	return result;
};
QBOX.QCELL.BasicQCELL.prototype._getColData = function(nCol){
	return QBOX._.pluck(this.attr('currentdata'), this._getKeyOfCol(nCol));
};

QBOX.QCELL.BasicQCELL.prototype._setColData = function(nCol, arrValues){
	var result = true,
	nHeaderRows = this.attr('headerrows'),
	nCurrentDataCount = this.attr('currentdata').length;
	
	for(var i = 0, nLength = arrValues.length; i < nLength; i++){
		if(result === false || i >= nCurrentDataCount){
			break;
		}
		
		result = this._cellValue(i + nHeaderRows, nCol,  arrValues[i]);
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._getCellLabel = function(nRow, nCol, bBeforeformat){
	var heCell = this._getCellDOM(nRow, nCol),
	result = '',strValue;
	
//	if(bBeforeformat === false){		
		return this._showDataFormat(nRow,nCol, this._cellValue(nRow, nCol),bBeforeformat);
//	}
	
//	if(heCell !== null){
//		result = QBOX.util.textContent(heCell); 
	//} else{
//		strValue = this._cellValue(nRow, nCol);
		
	//	result = this._showDataFormat(nRow,nCol, strValue,bBeforeformat);
	//}
	
	//return result;
};

QBOX.QCELL.BasicQCELL.prototype._setCellLabel = function(nRow, nCol, data){
	var bool = false;
	var heCell = this._getCellDOM(nRow, nCol);
	
	try{
		this._cellValue(nRow, nCol, data);
		if(heCell !== null){
			//heCell.innerHTML = data;
			QBOX.util.textContent(heCell, data);
		}
		bool = true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._setCellLabel', e.message);
		bool = false;
	}
	
	return bool;
};

QBOX.QCELL.BasicQCELL.prototype._showProgressUI = function(bool, time) {
	var css = QBOX.QCELL.def.css,
	heParent = this.attr('parent'),
	strTargetId = QBOX.$(heParent).attr("id"),
	heContainer = QBOX.$(heParent).parent(),
	heDiv = QBOX.$(document.createElement('div')) //QBOX.$("<div></div>")
			.attr('id', css.PROGRESS_UI)
			.addClass(css.PROGRESS_UI)
			.css({'width': QBOX.$(heParent).css("width"), 'height': QBOX.$(heParent).css("height")});
	
	if(bool) {
		QBOX.$(heContainer).find("#"+strTargetId).before(heDiv);
	} else {
		// .rt-qc-progress-ui 가진 Element 모두 제거
		QBOX.$(heContainer).find("."+css.PROGRESS_UI).fadeOut(time === undefined ? 500 : time, function(){QBOX.$(this).remove();});
	}
};

QBOX.QCELL.BasicQCELL.prototype._resetData = function(){
	var bool = false;
	try{
		if(this.attr('original')){
			this._setData(QBOX.$.extend(true, [], this.attr('origindata')));
		}
		bool = true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._resetData', e.message);
		bool = false;
	}
	
	return bool;
};

QBOX.QCELL.BasicQCELL.prototype._getFocusRowData = function(){
	var htFocusIdxInfoOfRow = this._getIdxInfo('focus', 'row'),
	nRow = htFocusIdxInfoOfRow.current > -1 ? htFocusIdxInfoOfRow.current : -1;
	
	return nRow === -1 ? {} : this._getRowData(nRow);
};
QBOX.QCELL.BasicQCELL.prototype._checkData = function(data){
	 var arrCurrentData = this.attr('currentdata'),i;
	 
	 if(data.length !== arrCurrentData.length)
		 return false;
	 
	 if(data.length === 0)
		 return false;
	 
	 for(i=0;i<data.length;i++){
		 if(!QBOX._.isEqual(data[i], arrCurrentData[i]))
			 return false;
	 }
	 
	 return true;
};
QBOX.QCELL.BasicQCELL.prototype._findRowSub = function(data,startRow,strKey){
	var currentData = this.attr('currentdata'),i,nRows = this.getRows(),objData;
	
	for(i = startRow ; i< nRows ; i++){
		objData = this.getRowData(i);
		if(objData[strKey] === data){
			return i;
		}
	}
	
	return -1;
};
QBOX.QCELL.BasicQCELL.prototype._getColStyleEditorArea = function(){
	if(this.attr('colstyleeditorarea') === null){
		var heDiv = document.createElement('div');
		this.attr('colstyleeditorarea', this._createColStyleEditorArea(heDiv), 'jquery');
	}
	
	return this.attr('colstyleeditorarea').clone(true).get(0);
};
// colstyler area생성
QBOX.QCELL.BasicQCELL.prototype._createColStyleEditorArea = function(heDiv){
	var css = QBOX.QCELL.def.css;
	
	// 아이콘 click시 colstyler생성 및 처리
	return QBOX.$(heDiv.cloneNode()).addClass(css.EDITOR_AREA).on('mousedown', this.attr('eventparam'), function(event){
		var target = event.target,
		objQCell = event.data.target,
		nTargetCol = parseInt(target.parentNode.getAttribute('data-col')),
		heDiv = document.createElement('div'),
		heTextArea = document.createElement('textarea'),
		editorWidth = 606,
		editorHeight = 306,
		heDivWarp = heDiv.cloneNode(),
		textarea_id = objQCell.attr('id')+'_'+nTargetCol+'_colStyleEditorArea',
		warp_id = objQCell.attr('id')+'_'+nTargetCol+'_colStyleEditorWrap';
		
		if(objQCell._getQCellCol(nTargetCol).attr('colstyleeditorvisivle')){ // 출력 상태라면 제거
			objQCell._removeColStyleEditor(nTargetCol);
		} else {
			// 이전에 출력된 colstyleeditor가 있으면 제거
			objQCell._allRemoveColStyleEditor();
			
			QBOX.$(this).addClass(css.EDITOR_AREA_HOVER);
			objQCell._getQCellCol(nTargetCol).attr('colstyleeditorvisivle', true, 'boolean');
			
			//heDiv.setAttribute('id', ui_id);
			//heDiv.className += QBOX.QCELL.def.css.EDITOR_UI_STYLE;
			
			heTextArea.style.width = '606px';
			heTextArea.style.height = '306px';
			heTextArea.setAttribute('id', textarea_id);
			heTextArea.value = objQCell._getQCellCol(nTargetCol).attr('colstyleeditorbdata');
			
			//heDivWarp.appendChild(heDiv);
			heDivWarp.appendChild(heTextArea);
			heDivWarp.setAttribute('id', warp_id);
			QBOX.util.addClass(heDivWarp, css.COLSTYLEEDITOR_WRAP);
			QBOX.$(heDivWarp).appendTo(objQCell.attr('elementpool').get('container'));
			
			var editor = document.getElementById(textarea_id);
			
			sceditor.create(editor, {
				locale: 'ko',
				plugins: 'undo',
				//format: 'bbcode',
				format: 'xhtml',
				icons: 'monocons',
				style: RightTechPath+'QCELL/js/modules/BasicQCELL/lib/sceditor/themes/content/default.min.css',
				emoticonsRoot: RightTechPath+'QCELL/js/modules/BasicQCELL/lib/sceditor/',
				toolbar: 'bold,italic,underline,strike,subscript,superscript,left,center,right,justify,font,size,color,removeformat,cut,copy,paste,pastetext,source',
				fonts: 'Arial,Arial Black,Comic Sans MS,Courier New,Georgia,Impact,Sans-serif,Serif,Times New Roman,Trebuchet MS,Verdana, NanumGothic, Dotum'
			});
			
			QBOX.$(heDivWarp).css(objQCell._calculateColStyleEditorPosition(event, editorWidth, editorHeight));
			
			var instance = sceditor.instance(editor);
			
			objQCell.attr('colstyleeditorui', QBOX.$(heDivWarp), 'jquery');
			objQCell.attr('colstyleeditor', instance, 'object');
			
			// Wysiwyg
			sceditor.instance(editor).keyPress(function(e){
				objQCell._colStyleEditorOnKeyDown(e, objQCell, nTargetCol);
			}, false, true)
			.keyUp(function(e){
				objQCell._colStyleEditorOnKeyUp(e, objQCell, nTargetCol);
			});
			
			// Source
			sceditor.instance(editor).keyPress(function(e){
				objQCell._colStyleTextAreaOnKeyDown(e, objQCell, nTargetCol);
			}, true, false)
			.keyUp(function(e){
				objQCell._colStyleTextAreaOnKeyUp(e, objQCell, nTargetCol);
			}, true, false);
		}
		
	});
};

//texAarea 상황에서 keyDown event 처리
QBOX.QCELL.BasicQCELL.prototype._colStyleTextAreaOnKeyDown = function(event, THAT, nCol){
	var strKeyCode = event.keyCode,
	instance = THAT.attr('colstyleeditor'),
	targetCol = THAT._getQCellCol(nCol);
	
	if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB ){//enter
		
		targetCol.attr('colstyleeditordata', instance.getSourceEditorValue(), 'string');			
		THAT._hideColStyleEditor(nCol, 'save', instance);
		
		event.stopPropagation();
		event.preventDefault();
	}
};

QBOX.QCELL.BasicQCELL.prototype._colStyleTextAreaOnKeyUp = function(event, THAT, nCol){
	if(event.altKey === false){
		if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB ){//enter
			
			targetCol.attr('colstyleeditordata', instance.getSourceEditorValue(), 'string');			
			THAT._hideColStyleEditor(nCol, 'save', instance);
			
			event.stopPropagation();
			event.preventDefault();
		} else if(strKeyCode === QBOX.def.key.ESC){//esc
			//this._hide(heCell, strKeyCode);
			THAT._hideColStyleEditor(nCol, 'cancel', instance);
		}
	} else{
		if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === 10){//enter
			//objEditor.t.value += '\r';
			instance.sourceEditorInsertText('\r');
		}
	}
};

// colStyler 상황에서 keyDown event 처리
QBOX.QCELL.BasicQCELL.prototype._colStyleEditorOnKeyDown = function(event, THAT, nCol){
	var strKeyCode = event.keyCode,
	instance = THAT.attr('colstyleeditor'),
	targetCol = THAT._getQCellCol(nCol);
	
	if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB ){//enter
		var val = instance.getWysiwygEditorValue();
		instance.setSourceEditorValue(val);
		
		targetCol.attr('colstyleeditordata', instance.getSourceEditorValue(val), 'string');			
		THAT._hideColStyleEditor(nCol, 'save', instance);
		
		event.stopPropagation();
		event.preventDefault();
	}
};

QBOX.QCELL.BasicQCELL.prototype._colStyleEditorOnKeyUp = function(event, THAT, nCol){
	var strKeyCode = event.keyCode,
	instance = THAT.attr('colstyleeditor'),
	targetCol = THAT._getQCellCol(nCol);
	
	if(event.altKey === false){
		if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB ){//enter
			var val = instance.getWysiwygEditorValue();
			instance.setSourceEditorValue(val);
			
			targetCol.attr('colstyleeditordata', instance.getSourceEditorValue(val), 'string');			
			THAT._hideColStyleEditor(nCol, 'save', instance);
			
			event.stopPropagation();
			event.preventDefault();
		} else if(strKeyCode === QBOX.def.key.ESC){//esc
			THAT._hideColStyleEditor(nCol, 'cancel', instance);
		}
	} else{
		if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === 10){//enter
			event.stopPropagation();
			event.preventDefault();
			
			var rangeHelper = instance.getRangeHelper();
			if(QBOX.browser.name === 'msie'){
				var br = document.createElement('br');
				
			    rangeHelper.insertNode(br);
				
				var parent = br.parentNode,
				children = parent.childNodes,
				brlen = 0;
				
				for(var i = 0; i < children.length; i++){
					if(children[i].isEqualNode(br)){
						brlen++;
					}
				}
				
				if(brlen == 1){ // ie에선 최초 한번만 brbr 입력, 이후 br 코드 한번으로 줄바꿈 처리됨
					rangeHelper.insertNode(br.cloneNode());
				}
			} else {
				rangeHelper.insertHTML('<br><br>');
			}
		}
	}
};

// colstyler의 위치 조정
QBOX.QCELL.BasicQCELL.prototype._calculateColStyleEditorPosition = function(event, editorWidth, editorHeight){
	var target = event.target,
	objQCell = event.data.target,
	nViewportOffsetLeft = objQCell.attr('layoutsize').viewport.offsetLeft,
	nTargetLeft = target.parentNode.offsetLeft + nViewportOffsetLeft,//colMoveLine이 viewport가 아닌 container에 들어가 있으므로 container기준으로 left값을 구해야 한다.
	nViewportOffsetTop = objQCell.attr('layoutsize').viewport.offsetTop,
	nTargetCol = parseInt(target.parentNode.getAttribute('data-col')),
	nTargetColWidth = this._getColWidth(nTargetCol),
	nRootOffsetWidth = objQCell.attr('layoutsize').root.offsetWidth,
	left, top;
	
	top = nViewportOffsetTop + 'px';
	if((nTargetLeft + editorWidth) > nRootOffsetWidth){
		left = ((nTargetLeft + nTargetColWidth) - editorWidth) + 'px';
	} else {
		left = nTargetLeft + 'px';
	}
	
	return {left: left, top: top};
};

// 전체col colstyler 제거
QBOX.QCELL.BasicQCELL.prototype._allRemoveColStyleEditor = function(){
	var cols = this.attr('cols'),
	headerCols = this.attr('headercols');
	
	// 이전에 출력된 colstyleeditor가 있으면 제거
	for(var i = headerCols; i < cols; i++){
		if(this._getQCellCol(i).attr('colstyleeditorvisivle')){
			this._removeColStyleEditor(i);
		}
	}
};

// col별 colStyler 제거
QBOX.QCELL.BasicQCELL.prototype._removeColStyleEditor = function(nCol){
	var css = QBOX.QCELL.def.css;
	
	QBOX.$('.'+css.EDITOR_AREA).removeClass(css.EDITOR_AREA_HOVER);
	
	this.attr('colstyleeditorui').remove();
	this.attr('colstyleeditorui', null, 'jquery');
	this._getQCellCol(nCol).attr('colstyleeditorvisivle', false, 'boolean');
};

// colStyler 숨기기
QBOX.QCELL.BasicQCELL.prototype._hideColStyleEditor = function(nCol, type, instance){
	
	if(type == 'save'){
		var targetCol = this._getQCellCol(nCol),
		targetStr = 'QCELL_COL_DATA';
		// 데이터를 저장함에 있어, 현재 데이터에 공통 문장의 홰손 여부와 공통 문장이 하나 이상 존재하는지 확인
		if(targetCol.attr('colstyleeditordata').indexOf(targetStr) > -1 && targetCol.attr('colstyleeditordata').replace(targetStr, '').indexOf(targetStr) == -1){
			targetCol.attr('colstyleeditorbdata', targetCol.attr('colstyleeditordata'), 'string');
			
			if(QBOX.QCELL.module === 'normal'){
				this.attr('qcellcols')[nCol].attr('colelement').attr('editcellcol', false, 'boolean');
			}
			
			this._refresh();
		}
	}
	
	instance.destroy();
	
	this._removeColStyleEditor(nCol);
};
//객체 생성 시 마다 resize이벤트를 등록하는게 아니라 브라우저의 resize 발생 시 모든 QCELL객체가 resize되도록 라이브러리 등록 시에 window객체에 이벤트를 바인딩한다.
QBOX.$(window).on('resize.' + QBOX.QCELL.name, QBOX._.debounce(function(event){
	QBOX._.each(QBOX.QCELL.getInstanceIDs(), function(id){
		QBOX.QCELL.getInstance(id)._defaultAction(event);
	});
}, 300));
QBOX.QCELL.BasicQCELL.prototype.onFocusIn = function(event){	
	if($(event.target).hasClass('rt-qc-container')){
	/*	var nFocus = this.getIdx('row','focus');
		var heElement,nRow,nCol;
		if(this.getRows() - this.attr('headerrows')<= 0)
			return;
		
		if(nFocus === -1){
			nRow = this.attr('headerrows');
			nCol = this.attr('headercols');			
		}else{	
			nRow = nFocus;
			nCol = this.getIdx('col','focus');
		}
		heElement = this._getCellDOM(nRow,nCol);
		if(heElement !== null){
			this._focusCell(nRow,nCol);	
			$(heElement).focus();
		}*/
	}
};
QBOX.QCELL.BasicQCELL.prototype._getEventTarget = function(strEventName){
	try{
		var htElementPool = this.attr('elementpool'),
		$eventTarget;
		switch(strEventName){
			case 'mousewheel': case 'DOMMouseScroll': {
				$eventTarget = htElementPool.get('$edgeheader')
				.add(htElementPool.get('$colheader'))
				.add(htElementPool.get('$rowheader'))
				.add(htElementPool.get('$viewport'));
				
				break;
			}
//			case 'mouseup': {
//				$eventTarget = QBOX.$(document);
//				break;
//			}
			case 'resize': {
				$eventTarget = QBOX.$(window);
				break;
			}
			default: {
				$eventTarget = htElementPool.get('$container');
				//add(htElementPool.get('$sheetpanel'));
				break;
			}
		}
		
		return $eventTarget;

	}
	catch(e){
		return null;
	}
};

QBOX.QCELL.BasicQCELL.prototype._initEvent = function(){
	var htElementPool = this.attr('elementpool');
	var THAT = this;
	//&& htElementPool.containsKey('$sheetpanel')
	if(QBOX._.isFunction(htElementPool.containsKey) && htElementPool.containsKey('$sheetpanel') && htElementPool.containsKey('$edgeheader') && htElementPool.containsKey('$colheader') && htElementPool.containsKey('$rowheader') && htElementPool.containsKey('$viewport')){
		var strID = this.attr('id'),
		objEventParam = this.attr('eventparam');
		
		//이벤트 바인딩 target 변경 시 항상 확인 할 것!
		var eventTarget =this._getEventTarget('mousewheel');
		if(eventTarget !== null)
			eventTarget.on('mousewheel DOMMouseScroll', objEventParam, QBOX.st.eventProcess);
		
		eventTarget =this._getEventTarget('default'); 
		if(eventTarget !== null)		
			eventTarget.on('mousedown mouseup click dblclick mouseenter mouseleave mousemove mouseover keydown change focusin', objEventParam, QBOX.st.eventProcess);
		
		//edge 브라우저에서는 selectstart 이벤트 중지 시키면 input 입력 활성화 창의 한글이 재대로 입력 되지 않는 문제가 있어, edge에서는 이벤트 중지 시키지 않도록 분기 추가.
		if(QBOX.browser.name !== 'msedge' && QBOX.browser.name !== 'msie'){
			//mouse drag를 이용한 select 방지, IE10이하에서는 user-select:none CSS3.0 속성이 동작하지 않는다. 
			htElementPool.get('$root').on('selectstart', function(event){return false;});
		}
				
		// Mobile 일 경우 swipe 이벤트 추가함		
		if(QBOX.util.isMobile()){
			this._createInputForm();
			htElementPool.get('$root').swipe( {
				swipeDown : function ( event,direction,distance, duration,fingerCount,fingerData,currentDirection){
					THAT.onSwipe(event, direction, distance, duration, fingerCount, fingerData);
				},
				swipeUp : function ( event,direction,distance, duration,fingerCount,fingerData,currentDirection){
					THAT.onSwipe(event, direction, distance, duration, fingerCount, fingerData);
				},
				swipeRight : function ( event,direction,distance, duration,fingerCount,fingerData,currentDirection){
					THAT.onSwipe(event, direction, distance, duration, fingerCount, fingerData);
				},
				swipeLeft : function ( event,direction,distance, duration,fingerCount,fingerData,currentDirection){
					THAT.onSwipe(event, direction, distance, duration, fingerCount, fingerData);
				},
				longTab : function(event,target){
					THAT.onLongTab(event,target);
				},
				tab : function(event,target){
					THAT.onTab(event,target);
				}, 

				
				/*
				longTap : function (event,target){
					if(QBOX.$(target).hasClass('rt-qc-cell')){
						var nRow = parseInt(target.getAttribute('data-row')),
						nCol = parseInt(target.getAttribute('data-col'));
						
						if(nRow >= THAT.getRows('header') && nCol >= THAT.getCols('header')){
							THAT.clickCell(nRow,nCol);
						}
						
					}
				},*/
				threshold: 25
			});
			
			
		}
		//this._createInputForm();
		QBOX.$(htElementPool.get('$sheetpanel')).on('selectstart', function(e){
			htElementPool.get('$root').off('selectstart');
			return true;
		}).off('selectstart', function(e){
			htElementPool.get('$root').on('selectstart', function(event){return false;});
			return false;
		});
		
		//"resize" 이벤트의 target은 window이다.
		//객체 생성 시 마다 resize이벤트를 등록하는게 아니라 브라우저의 resize 발생 시 모든 QCELL객체가 resize되도록 라이브러리 등록 시에 window객체에 이벤트를 바인딩한다.
		//this._getEventTarget('resize').on('resize.' + strID, objEventParam, _.debounce(QBOX.st.eventProcess, 300));
		
		//"mouseup" 이벤트의 target은 document이다.
		//IE8이하에서 마우스 이벤트를 window에 걸면 동작하지 않는다. "resize"이벤트 이외의 이벤트는 document객체에 걸어야 한다. 
		QBOX.$(document).on('mouseup.' + strID, objEventParam, function(event){
			var objQCell = event.data.target,
			objVSInfo = objQCell.attr('vsinfo'),
			bVScroll = objVSInfo.bVScroll,
			nTopRow = objVSInfo.nTopRow,
			objHSInfo = objQCell.attr('hsinfo'),
			bHScroll = objHSInfo.bHScroll;
			
			if(objQCell){
				//QCELL의 mouseup 발생 이후에는 'mousedown' 속성이 false라서 동작하지 않는다.
//				if(objQCell.attr('mousedown')){
//					QBOX.QCELL.BasicQCELL.prototype.onMouseUp.call(objQCell, event);
//				}
				
				if(objQCell.attr('dragging')){//dragging 중일 때
					var css = QBOX.QCELL.def.css,
					target = event.target;
					
					if(QBOX.util.hasClass(target, css.CELL_VIEWPORT)){//target이 viewport 셀인 경우에만
						var nRow, nCol;
						
						nRow = parseInt(target.getAttribute('data-row'));
						nCol = parseInt(target.getAttribute('data-col'));
						
						objQCell._updateIdx('drag', nRow, nCol);
					}
					
					objQCell.onDrop(event);
				}
				
				if(objQCell.attr('colmove')){
					var $colMoveShadow = objQCell.attr('colmoveshadow'),
					$colMoveLine = objQCell.attr('colmoveline');
					
					//컬럼 이동 성공 여부 체크 후 컬럼 이동 수행
					if(objQCell.attr('colmoveexecution')){
						var nBeforeCol = parseInt($colMoveLine.attr('data-beforecol')),
						nAfterCol = parseInt($colMoveLine.attr('data-aftercol'));
						
						//console.log('컬럼 이동 성공');
						//console.log('nBeforeCol:', nBeforeCol, ', nAfterCol', nAfterCol);
						
						objQCell._moveCols(nBeforeCol, 1, nAfterCol, false);
					}
					
					//colMoveShadow UI 제거
					if($colMoveShadow !== null){
						$colMoveShadow.remove();
						
						objQCell.attr('colmoveshadow', null, 'jquery');
					}
					
					//colMoveLine UI 제거
					if($colMoveLine !== null){
						$colMoveLine.remove();
						
						objQCell.attr('colmoveline', null, 'jquery');
					}
					
					//console.log('컬럼 이동 종료');
				}
				
				//컬럼 너비 조절 처리
				if(objQCell.attr('colresize')){
					var $colResizeLine = objQCell.attr('colresizeline'),
					$colResizeTooltip = objQCell.attr('colresizetooltip'),
					nTargetCol = parseInt($colResizeLine.attr('data-targetcol')),
					nOriginLeft = parseInt($colResizeLine.attr('originleft')),
					nTargetColWidth = objQCell._getColWidth(nTargetCol);
					
					objQCell._setColWidth(nTargetCol, nTargetColWidth + (parseInt($colResizeLine.css('left')) - nOriginLeft));
					
					//colResizeLine UI 제거
					if($colResizeLine !== null){
						$colResizeLine.remove();
						
						objQCell.attr('colresizeline', null, 'jquery');
					}
					
					//colResizeTooltip UI 제거
					if($colResizeTooltip !== null){
						$colResizeTooltip.remove();
						
						objQCell.attr('colresizetooltip', null, 'jquery');
					}
					
					objQCell._scrollTop(nTopRow);
					//objQCell.refresh();
					/*
					// colresize 후 스크롤 생성 여부 관련 처리
					
					// 1-1. colresize 후 스크롤바의 생성여부 확인
					objQCell._initLayoutSize();
					
					// 1-2. DynamicCols 계산
					objQCell._calculateDynamicCols();
					
					// 2-1. 스크롤바 존재 여부에 따른 틀고정 열 기능 사용 가능 여부 보정
					objQCell._adjustFrozenColsCount();
					
					// 2-2. "col" 단위 셀 그룹 업데이트
					if(objQCell.attr('frozencols') > 0){
						// 2-2-1. "col" 단위 셀 그룹 CSS 클래스 갱신 -> headerCols, frozenCols, normalCols
						objQCell._setCellGroupCSS('col', 'frozen');
					}
					
					objQCell._setCellGroupCSS('col', 'normal');
					
					// 3-1. 가로스크롤바 길이 갱신
					objQCell._resizeHScrollbar();
					
					// 3-2. hsinfo 정보 갱신(nLeftCol, nRightCol, nAdjustedLeft 설정)
					objQCell._updateHSInfo();
					
					// 4. colresize 후 가로스크롤바 표시 여부 확인
					if(bHScroll && objHSInfo.bHScroll && objHSInfo.nPos === objHSInfo.nLastPos){//가로스크롤바가 원래 있었고, 가로스크롤바가 마지막까지 움직인 상태에서 세로스크롤바가 생겼을 때
						var nScrollBarWidth = objQCell.attr('scrollbarwidth');
						QBOX._.each(QBOX._.flatten(objQCell._getCellGroupDOMs('col', 'normal')), function(heCell){
							heCell.style.left = (parseFloat(heCell.style.left) - nScrollBarWidth) + 'px';//세로스크롤바의 width만큼 nomalCols 셀들의 left값을 보정한다.
						});
					}

					objQCell._resizeVScrollbar();	//세로스크롤바 길이 갱신
					objQCell._updateVSInfo();		//vsinfo 정보 갱신(nTopRow, nBottomRow 설정)
					
					//5. 화면 갱신
					objQCell._refreshDRs();
					
					if(objQCell.attr('percentcolwidth') && bVScroll !== objVSInfo.bVScroll){  
						//"%" colWidth 사용 시 세로스크롤바 표시여부가 행 추가삭제 이전과 달리지는 경우 headerCols를 제외한 모든 컬럼의 colWidth가 변경되어 보정이 필요하다.
						//dynamicRows 추가삭제 후 컬럼 기준 refresh전에 행 기준 refresh를 수행해야 cellDOM에 'data-row'값이 정상적으로 세팅된다.
						objQCell._refreshCs();
					}
					*/
				}
				
				objQCell.attr('colmove', false, 'boolean');
				objQCell.attr('colresize', false, 'boolean');
				objQCell.attr('mousedown', false, 'boolean');
				

			}
		}).on('mousemove.' + strID, objEventParam, function(event){
			//document의 "mousemove" 이벤트에서는 colMoveShadow만 이동시키고, 가이드라인 이동은 QCELL의 "mousemove" 이벤트에서 처리한다.
			var objQCell = event.data.target;
			
			if(objQCell){
				if(objQCell.attr('colmove')){
					//colmove여부를 체크해서 colMoveShadow를 이동시킨다.
					var objLayoutSize = objQCell.attr('layoutsize'),
					$colMoveShadow = objQCell.attr('colmoveshadow'),
					nCol = parseInt($colMoveShadow.attr('data-col'));
					
					if($colMoveShadow !== null){
						if($colMoveShadow.css('display') === 'none'){
							$colMoveShadow.css({
								display	: 'block',
								width	: objQCell._getColWidth(nCol) + 'px',
								height	: objLayoutSize.container.offsetHeight + 'px'
							});
						}
						
						$colMoveShadow.css({
							'left'	: (event.clientX + 5) + 'px',
							'top'	: (event.pageY ) + 'px'
						});
					}
				}
			}
		});
		
		//User Events 바인딩
		this._bindUserEvents();
		
		return true;
	} else{
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._defaultAction = function(event){
	//custom event 추가 시 _trigger()에도 추가 해 줄 것
	switch (event.type){
		/* default events */
		case 'mousewheel':	case 'DOMMouseScroll':	this.onMouseWheel(event);	break;
		case 'mousedown':							this.onMouseDown(event);	break;
		case 'mouseup':								this.onMouseUp(event);		break;
		case 'click':								this.onClick(event);		break;
		case 'dblclick':							this.onDblClick(event);		break;
		case 'mouseenter':							this.onMouseEnter(event);	break;
		case 'mouseleave':							this.onMouseLeave(event);	break;
		case 'mousemove':							this.onMouseMove(event);	break;
		case 'keydown':								this.onKeyDown(event);		break;
		case 'resize':								this.onResize(event);		break;
		case 'focusin' :							this.onFocusIn(event);		break;
		
		/* custom events */
		//case 'valuechanged':						this.onValueChanged(event);	break;
		//case 'beforesort':						this.onBeforeSort(event);	break;
		//case 'aftersort':							this.onAfterSort(event);	break;
		
		default:																break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._bindUserEvents = function(){
	var objQCell = this;
	
	QBOX.$.each(this.attr('usereventinfo'), function(strEventName, fnHandler){
		objQCell._bind(strEventName, fnHandler, false);
	});
	
	return true;
};

QBOX.QCELL.BasicQCELL.prototype._getUserEventName = function(strEventName){
	strUserEventName = QBOX.s(strEventName).trim().toLowerCase().value();
	
	switch(strUserEventName){
		/*case 'mouseup': */case 'resize': {
			strUserEventName += '.' + this.attr('id') + '.user';
			break;
		}
		default: {
			strUserEventName += '.user';
			break;
		}
	}
	
	return strUserEventName;
};
QBOX.QCELL.BasicQCELL.prototype.getParameter = function(strEventName){
	return this.attr('eventparam_'+strEventName);
};
QBOX.QCELL.BasicQCELL.prototype._bind = function(strEventName, fnHandler, bUpdateUserEventInfo,data){
	if(strEventName !== '' && QBOX._.isFunction(fnHandler)){
		var objUserEventInfo = this.attr('usereventinfo'),
		objEventParam = this.attr('eventparam'),
		arrEventNames = QBOX.s(strEventName).trim().value().replace(/\s\s+/g, ' ').split(' '),strKey;
		
		if(arrEventNames.length > 0){
			for(var i = 0, nLength = arrEventNames.length; i < nLength; i++){
				var $eventTarget = this._getEventTarget(arrEventNames[i]),
				strUserEventName = this._getUserEventName(arrEventNames[i]);
				
				if(!QBOX._.isUndefined(data) && QBOX._.isObject(data) ){
					for(strKey in data){
						objEventParam[strKey] = data[strKey];
					}

					this.attr('eventparam_'+strEventName,data,'object');
				}
				
				if(QCELL.config.usebuttonclickcallback && strUserEventName === 'buttonclick.user'){
					this.attr('buttonclickcallback', fnHandler, 'function');
				}else{
					if($eventTarget !== null)
						$eventTarget.off(strUserEventName).on(strUserEventName, objEventParam, fnHandler);	
				}
				
				if(bUpdateUserEventInfo){
					objUserEventInfo[arrEventNames[i]] = fnHandler;
				}
			}
			
			return true;
		}
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._unbind = function(strEventName, bUpdateUserEventInfo){
	if(strEventName !== ''){
		var objUserEventInfo = this.attr('usereventinfo'),
		arrEventNames = QBOX.s(strEventName).trim().value().replace(/ +/g, ' ').split(' ');
		
		if(arrEventNames.length > 0){
			for(var i = 0, nLength = arrEventNames.length; i < nLength; i++){
				var $eventTarget = this._getEventTarget(arrEventNames[i]),
				strUserEventName = this._getUserEventName(arrEventNames[i]);
				
				if($eventTarget !== null)
					$eventTarget.off(strUserEventName);
				
				if(bUpdateUserEventInfo){
					delete objUserEventInfo[arrEventNames[i]];
				}
			}
			
			return true;
		}
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._trigger = function(strEventName,extraParam){
	var result = false;
	
	var jqCont = this._getEventTarget('default');
	
	if(jqCont === null)
		return;
	
	//UserEvent만 trigger가 가능하도록 제한한다.
	switch(strEventName){
		default: {
			if(extraParam === undefined)
				jqCont.trigger(this._getUserEventName(strEventName));
			else
				jqCont.trigger(this._getUserEventName(strEventName),extraParam);
			result = true;
			
			break;
		}
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._filedowntrigger = function(strEventName, param){
	var result = false;
	
	//UserEvent만 trigger가 가능하도록 제한한다.
	switch(strEventName){
		default: {
			this._getEventTarget('default').trigger({type: strEventName, filedownresult: param});
			
			result = true;
			
			break;
		}
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._orderbyExportInfo = function(objArr, order) {
	var obj = [],
	rowheaderLength = this.attr('rowheaders').length,
	i;
	
	if(rowheaderLength > 0){
		for(i = 0; i < rowheaderLength; i++){
			obj.push(objArr[i]);
		}
	}
	
	for(i = 0; i < order.length; i++){
		var num = Number(order[i]);
		obj.push(QBOX._.clone(objArr[num]));
	}
	
	return obj;
};

QBOX.QCELL.BasicQCELL.prototype._exportCellInfoURLHuge = function(properties) {
	var objExcelInfo = {},
	arrTemp = [], strTemp = [], titleTemp = [],
	nCols = this.attr('cols'),
	arrColWidths = this.attr('colwidthsperpixel'), 
	arrTitle = this.attr('headertext'),
	arrColumns = this.attr('qcellcols'), 
	arrKeys = this.attr('colkeys'),
	i, j, i_len, j_len,
	//arrData = QBOX.$.extend(true, [], this.attr('currentdata')),
	k, k_len, l, l_len, c_width, totalwidth = this.attr('layoutsize').colheader.clientWidth,
	arrAddNum = [], arrAddNone = [],
	rowheaderLength = this.attr('rowheaders').length;
	
	var obj = null;
	
	try {
		properties.huge = true;
		properties.label = true;
		properties.border = true;
		properties.headershow = true;
		properties.colwidth = true;
		properties.progressui = true;
		
		objExcelInfo.header = {};
		objExcelInfo.header.title = [];
		objExcelInfo.header.mergeType = JSON.parse(JSON.stringify(this.attr('merge'))).header;
		
		objExcelInfo.data = {};
		objExcelInfo.data.colskey = [];
		objExcelInfo.data.mergeType = JSON.parse(JSON.stringify(this.attr('merge'))).data;
		objExcelInfo.data.data = [{}];
		
		objExcelInfo.style = [];
		objExcelInfo.widths = [];
		
		if( QBOX._.isUndefined(properties) === false && QBOX._.isUndefined(properties.orderColumns) === false && QBOX._.uniq(properties.orderColumns).length === nCols - rowheaderLength) {
			arrTitle = this._orderbyExportInfo(arrTitle, properties.orderColumns);
			arrKeys = this._orderbyExportInfo(arrKeys, properties.orderColumns);
			arrColWidths = this._orderbyExportInfo(arrColWidths, properties.orderColumns);
		}
		
		// 삭제하고자 하는 delColumns가 존재할 때
		if( QBOX._.isUndefined(properties) === false && QBOX._.isUndefined(properties.delColumns) === false ) {
			var delColumns = QBOX._.clone(properties.delColumns);
			// 정렬 후 역순으로 재정렬
			delColumns.sort().reverse();
			nCols = nCols - delColumns.length;
			
			for(i = 0; i < delColumns.length; i++){
				var delNum = Number(delColumns[i]);
				arrTitle.splice(delNum, 1);
				arrKeys.splice(delNum, 1);
				arrColWidths.splice(delNum, 1);
			}
		}
		
		// 추가하고자 하는 addColumns가 존재할 때
		if( QBOX._.isUndefined(properties) === false && QBOX._.isUndefined(properties.addColumns) === false ) {
			nCols = nCols + properties.addColumns.length; // cols + 추가할 columns정보
			
			for(k = 0, k_len = properties.addColumns.length; k < k_len; k++) {
				if( !QBOX._.isUndefined(properties.addColumns[k].position) ) {
					//QBOX.$.extend(true, [], this.attr('qcellcols'))
					//QBOX._.clone(properties.addColumns[k])
					arrAddNum.push(QBOX.$.extend(true, [], properties.addColumns[k])); // 속성 position이 있으면 arrAddNum에 추가 컬럼정보 저장
				} else {
					arrAddNone.push(QBOX.$.extend(true, [], properties.addColumns[k])); // 속성 position이 없으면 arrAddNone에 추가 컬럼정보 저장 
				}
			}
			
			if( !QBOX._.isEmpty(arrAddNum) ) {
				arrAddNum = QBOX._.sortBy(arrAddNum, 'position'); // 속성 position의 순서대로 정렬
			}
			
			// arrTitle에 addColumns에 position 지정된 title 정보 추가
			if(arrAddNum.length > 0){
				for(k = 0, k_len = arrAddNum.length; k < k_len; k++) {
					arrTitle.splice(Number(arrAddNum[k].position), 0, arrAddNum[k].title); // 기존 title정보에 position의 순서대로 title정보를 추가
					arrKeys.splice(Number(arrAddNum[k].position), 0, arrAddNum[k].key); // 기존 key정보에 position의 순서대로 key정보를 추가
					
					if( QBOX._.isUndefined(arrAddNum[k].width) ) { // width값이 선언되어 있지 않을 때
						c_width = 100;
					} else { // width값이 선언되어 있을 때
						c_width = arrAddNum[k].width;
						if(c_width.indexOf('%') > -1) { // width값이 %일 때
							c_width = Math.ceil(totalwidth * (Number(c_width.replace('%', '')) / 100));
						} else { // width값이 px일 때
							c_width = Number(c_width); // number형으로 형변환
						}
						
					}
					arrColWidths.splice(Number(arrAddNum[k].position), 0, c_width);
				}
			}
			
			// arrTitle에 addColumns에 position 지정안된 title 정보 추가
			if(arrAddNone.length > 0){
				for(l = 0, l_len = arrAddNone.length; l < l_len; l++) {
					arrTitle.push(arrAddNone[l].title); // 기존 title정보의 마지막에 title정보 추가
					arrKeys.push(arrAddNone[l].key); // 기존 key정보의 마지막에 key정보 추가
					
					if( QBOX._.isUndefined(arrAddNone[l].width) ) { // width값이 선언되어 있지 않을 때
						c_width = 100;
					} else { // width값이 선언되어 있을 때
						c_width = arrAddNone[l].width;
						if(c_width.indexOf('%') > -1) { // width값이 %일 때
							c_width = Math.ceil(totalwidth * (Number(c_width.replace('%', '')) / 100));
						} else { // width값이 px일 때
							c_width = Number(c_width); // number형으로 형변환
						}
						
					}
					arrColWidths.push(c_width);
				}
			}
		}
		
		if(rowheaderLength > 0){	//rowheader가 존재할때
			
			for(i = rowheaderLength ; i < arrTitle.length ; i++){
				arrTemp.push([]);
				for(j = 0 ; j < arrTitle[i].length ; j++){
					arrTemp[i-rowheaderLength].push(arrTitle[i][j]);
				}
			}
			
			//QBOX.$.extend(true, [], this.attr('qcellcols'))
			//col기준의 header title 정보를 row기준으로 변경
			for(i = 0, i_len = arrTemp[0].length; i < i_len; i++){
				for(j = 0, j_len = arrTemp.length; j < j_len; j++){
					strTemp.push(arrTemp[j][i]);
				}
				titleTemp.push(QBOX.$.extend(true, [], strTemp));
				strTemp.RT_clear();
			}
			
			objExcelInfo.header.title = QBOX.$.extend(true, [], titleTemp);
			
			arrTemp.RT_clear();arrTemp = null;
			titleTemp.RT_clear();titleTemp = null;
			strTemp.RT_clear();strTemp = null;
			
			for(i = rowheaderLength ; i < nCols ; i++){
				objExcelInfo.data.colskey.push(arrKeys[i]);
				objExcelInfo.widths.push(arrColWidths[i]);
				
				if(arrColumns.length > i ){
					obj = QBOX._.isNull(arrColumns[i].attr('styleinfo')) ? {} : arrColumns[i].attr('styleinfo');
					if(obj.data !== undefined && obj.data.css !== undefined && this._useDataTextAlign(i))
						obj.data.css['text-align'] = this._getDataTextAlign(i);
					objExcelInfo.style.push(obj); //스타일 추가
				}			
					
				else
					objExcelInfo.style.push({}); //스타일 추가
			}
		} else  {
			for(i = 0, i_len = arrTitle[0].length; i < i_len; i++){
				for(j = 0, j_len = arrTitle.length; j < j_len; j++){
					strTemp.push(arrTitle[j][i]);
				}
				titleTemp.push(QBOX._.clone(strTemp));
				strTemp.RT_clear();
			}
			
			objExcelInfo.header.title = QBOX._.clone(titleTemp);
			titleTemp.RT_clear();titleTemp = null;
			strTemp.RT_clear();strTemp = null;
			
			objExcelInfo.data.colskey = arrKeys;
			objExcelInfo.widths = arrColWidths;
			
			for(i = 0 ; i < nCols ; i++){
				if(arrColumns.length > i ){
					obj = QBOX._.isNull(arrColumns[i].attr('styleinfo')) ? {} : arrColumns[i].attr('styleinfo');
					if(obj.data !== undefined && obj.data.css !== undefined && this._useDataTextAlign(i))
						obj.data.css['text-align'] = this._getDataTextAlign(i);
					objExcelInfo.style.push(obj); //스타일 추가
				}	
				else
					objExcelInfo.style.push({}); //스타일 추가
			}
		}
		
		return objExcelInfo;
		
	} catch (e) {
		QCELL.log('err', 'QCELL.BasicQCELL._exportCellInfoURLHuge', e.message);
		return {};
	}
};

QBOX.QCELL.BasicQCELL.prototype._excelDownloadURLHuge = function(properties) {
	var result = true, objQcell = QBOX._.clone(this);
	
	objQcell._showProgressUI(true);
	
	if( QBOX.$.browser.msie && QBOX.$.browser.version < 10) { //브라우저가 IE이며 9이하일 때
		if(objQcell._excelDownload_checkRequiredProps(properties, "url") && objQcell._excelDownload_checkValidationOfProps(properties)){
			result = objQcell._excelDownloadURLHuge(properties);
		} else {
			result = false;
		}
	} else {
		result = false;
	}
	
	return result;
};

//IE9이하나, url을 통해 엑셀저장
QBOX.QCELL.BasicQCELL.prototype._excelDownloadURLHuge = function(properties) {
	var strAPI = this.attr('id') + '._excelDownloadURLHuge';
	try {
		var fileExt = properties.fileExt !== undefined && properties.fileExt.length !== 0 ? '.'+properties.fileExt : '.xlsx',
		filename = properties.filename+fileExt,
		file = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'filename').val(filename),
		info = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'info'),
		property = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'properties'),
		param = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'param'),
		objQCell = this;
		
		info.val(JSON.stringify(this._exportCellInfoURLHuge(properties)));
		
		property.val(JSON.stringify(properties));
		param.val(JSON.stringify(properties.param));
		
		QBOX.$.fileDownload(properties.url, {
			httpMethod: "POST",
			data: {
				filename: file.val(),
				info: info.val(),
				properties: property.val(),
				param: param.val()
			}
		})
		.done(function(){
			objQCell._showProgressUI(false);
			
			setTimeout(function (){
				objQCell._filedowntrigger('afterurlexceldown', 'success');
			},0);
		})
		.fail(function(){
			objQCell._showProgressUI(false);
			
			setTimeout(function (){
				objQCell._filedowntrigger('afterurlexceldown', 'fail');
			},0);
		});
		
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};

//excel저장을 위한 qcell 정보 출력
QBOX.QCELL.BasicQCELL.prototype._exportCellInfo = function(properties) {
	var objExcelInfo = {},
	arrTemp = [], strTemp = [], titleTemp = [],
	nCols = this.attr('cols'),
	arrColWidths = QBOX.$.extend(true, [], this.attr('colwidthsperpixel')), 
	arrTitle = QBOX.$.extend(true, [], this.attr('headertext')),
	arrColumns = QBOX.$.extend(true, [], this.attr('qcellcols')), 
	arrKeys = QBOX.$.extend(true, [], this.attr('colkeys')),
	i, j, i_len, j_len,
	arrData = QBOX.$.extend(true, [], this.attr('currentdata')),
	huge = typeof properties === 'undefined' ? false : properties.huge, 
	label = typeof properties === 'undefined' ? false : properties.label,
	totaldata = typeof properties === 'undefined' ? false : properties.totaldata,
	k, k_len, l, l_len, c_width, totalwidth = this.attr('layoutsize').colheader.clientWidth,
	arrAddNum = [], arrAddNone = [],
	staticrowsinfo = this.attr('staticrowsinfo'),
	staticrow,bMake,
	rowheaderLength = this.attr('rowheaders').length,nA =0;
	
	if(this.attr('makefrozenbottomdata') === true || this._isPanel() )
		nA = 1;
	var obj =null;
	
	try {
		objExcelInfo.header = {};
		objExcelInfo.header.title = [];
		objExcelInfo.header.mergeType = JSON.parse(JSON.stringify(this.attr('merge'))).header;
		
		objExcelInfo.data = {};
		objExcelInfo.data.colskey = [];
		
		
		objExcelInfo.data.mergeType = JSON.parse(JSON.stringify(this.attr('merge'))).data;
		var bUseOrginData = properties.useorgindata;
		
		if(staticrowsinfo.length > 0){
			bMake = true;
		}
		
		if( label === true && (QBOX.QCELL.module === 'normal' || QBOX.QCELL.module === 'basic')) {
			var fnFind = function (obj){
				return obj.nRow === j;
			};
			for(i = this.attr('headercols'); i < nCols; i++) {
				if(arrColumns[i].attr('type') === 'selectmenu' || arrColumns[i].attr('type') === 'static' || arrColumns[i].attr('type') === 'input' || arrColumns[i].attr('type') === 'inputbutton' || arrColumns[i].attr('type') === 'textarea' || arrColumns[i].attr('type') === 'datepicker' || arrColumns[i].attr('type') === 'number') {
					for(j = this.attr('headerrows'); j < this.attr('rows') -nA; j++) {
						if(bMake === true){
							var retValue = QBOX._.find(staticrowsinfo, fnFind);
							
							if(retValue !== undefined){
								arrData[j - this.attr('headerrows')][arrKeys[i]] = this._cellValue(j, i);
								continue;
							}
						}
						var textLabel = bUseOrginData === true ? this._getCellLabel(j, i,false) : this._getCellLabel(j, i);
						if(textLabel === 0 && !QBOX._.isUndefined(this._cellValue(j, i))){
							textLabel = this._cellValue(j, i);
						}
						arrData[j - this.attr('headerrows')][arrKeys[i]] = textLabel;
					}
				}
			}
		}
		if(properties.usehtmltype === true){
			for(i = this.attr('headercols'); i < nCols; i++) {
				if(arrColumns[i].attr('type') === 'html') {
					var heColHtml=this._getColHtml(i);
					if(  QBOX._.isFunction(heColHtml.data) ) {
						for(j = this.attr('headerrows'); j < this.attr('rows'); j++) {
							if(arrData[j - this.attr('headerrows')].rt_qc_fbrd === true)
								break;
							try{
								var vData = heColHtml.data(this,j,i,this._cellValue(j,i),arrData[j - this.attr('headerrows')],true);
								arrData[j - this.attr('headerrows')][arrKeys[i]] = vData;
							}catch(e){
								arrData[j - this.attr('headerrows')][arrKeys[i]] = '';
							}
						}
					}
				}
			}		
			
		}
		
		if( QBOX._.isUndefined(huge) === false && huge === true) {
			objExcelInfo.data.data = [{}];
		} else {
			objExcelInfo.data.data = arrData;
		}
		
		if( QBOX._.isUndefined(totaldata) === false && totaldata === true) {
			objExcelInfo.data.data = QBOX._.clone(this.attr('data').input);
		}	
		
		objExcelInfo.style = [];
		objExcelInfo.widths = [];
		

		
		if( QBOX._.isUndefined(properties) === false && QBOX._.isUndefined(properties.orderColumns) === false && QBOX._.uniq(properties.orderColumns).length === nCols - rowheaderLength) {
			arrTitle = this._orderbyExportInfo(arrTitle, properties.orderColumns);
			arrKeys = this._orderbyExportInfo(arrKeys, properties.orderColumns);
			arrColWidths = this._orderbyExportInfo(arrColWidths, properties.orderColumns);
		}
		
		// 삭제하고자 하는 delColumns가 존재할 때
		if( QBOX._.isUndefined(properties) === false && QBOX._.isUndefined(properties.delColumns) === false ) {
			var delColumns = QBOX._.clone(properties.delColumns);
			// 정렬 후 역순으로 재정렬
			delColumns.sort().reverse();
			nCols = nCols - delColumns.length;
			
			for(i = 0; i < delColumns.length; i++){
				var delNum = Number(delColumns[i]);
				arrTitle.splice(delNum, 1);
				arrKeys.splice(delNum, 1);
				arrColWidths.splice(delNum, 1);
			}
		}
		
		if(properties.usesequence === true){
			if( QBOX._.isUndefined(properties.addColumns) === true){
				properties.addColumns = [];
			}
			var strTitle = properties.sequencetitle === undefined ? '' :properties.sequencetitle; 
			properties.addColumns.push({"key": "_rt_qc_seq", "width": "50", "title": [strTitle], "position": rowheaderLength +""});
		}		
		
		// 추가하고자 하는 addColumns가 존재할 때
		if( QBOX._.isUndefined(properties) === false && QBOX._.isUndefined(properties.addColumns) === false ) {
			nCols = nCols + properties.addColumns.length; // cols + 추가할 columns정보
			
			for(k = 0, k_len = properties.addColumns.length; k < k_len; k++) {
				if( !QBOX._.isUndefined(properties.addColumns[k].position) ) {
					//QBOX.$.extend(true, [], this.attr('qcellcols'))
					//QBOX._.clone(properties.addColumns[k])
					arrAddNum.push(QBOX.$.extend(true, [], properties.addColumns[k])); // 속성 position이 있으면 arrAddNum에 추가 컬럼정보 저장
				} else {
					arrAddNone.push(QBOX.$.extend(true, [], properties.addColumns[k])); // 속성 position이 없으면 arrAddNone에 추가 컬럼정보 저장 
				}
			}
			
			if( !QBOX._.isEmpty(arrAddNum) ) {
				arrAddNum = QBOX._.sortBy(arrAddNum, 'position'); // 속성 position의 순서대로 정렬
			}
			
			// arrTitle에 addColumns에 position 지정된 title 정보 추가
			if(arrAddNum.length > 0){
				for(k = 0, k_len = arrAddNum.length; k < k_len; k++) {
					arrTitle.splice(Number(arrAddNum[k].position), 0, arrAddNum[k].title); // 기존 title정보에 position의 순서대로 title정보를 추가
					arrKeys.splice(Number(arrAddNum[k].position), 0, arrAddNum[k].key); // 기존 key정보에 position의 순서대로 key정보를 추가
					
					if( QBOX._.isUndefined(arrAddNum[k].width) ) { // width값이 선언되어 있지 않을 때
						c_width = 100;
					} else { // width값이 선언되어 있을 때
						c_width = arrAddNum[k].width;
						if(c_width.indexOf('%') > -1) { // width값이 %일 때
							c_width = Math.ceil(totalwidth * (Number(c_width.replace('%', '')) / 100));
						} else { // width값이 px일 때
							c_width = Number(c_width); // number형으로 형변환
						}
						
					}
					arrColWidths.splice(Number(arrAddNum[k].position), 0, c_width);
				}
			}
			
			// arrTitle에 addColumns에 position 지정안된 title 정보 추가
			if(arrAddNone.length > 0){
				for(l = 0, l_len = arrAddNone.length; l < l_len; l++) {
					arrTitle.push(arrAddNone[l].title); // 기존 title정보의 마지막에 title정보 추가
					arrKeys.push(arrAddNone[l].key); // 기존 key정보의 마지막에 key정보 추가
					
					if( QBOX._.isUndefined(arrAddNone[l].width) ) { // width값이 선언되어 있지 않을 때
						c_width = 100;
					} else { // width값이 선언되어 있을 때
						c_width = arrAddNone[l].width;
						if(c_width.indexOf('%') > -1) { // width값이 %일 때
							c_width = Math.ceil(totalwidth * (Number(c_width.replace('%', '')) / 100));
						} else { // width값이 px일 때
							c_width = Number(c_width); // number형으로 형변환
						}
						
					}
					arrColWidths.push(c_width);
				}
			}
		}
		
		if(rowheaderLength > 0){	//rowheader가 존재할때
			
			for(i = rowheaderLength ; i < arrTitle.length ; i++){
				arrTemp.push([]);
				for(j = 0 ; j < arrTitle[i].length ; j++){
					arrTemp[i-rowheaderLength].push(arrTitle[i][j]);
				}
			}
			
			//QBOX.$.extend(true, [], this.attr('qcellcols'))
			//col기준의 header title 정보를 row기준으로 변경
			for(i = 0, i_len = arrTemp[0].length; i < i_len; i++){
				for(j = 0, j_len = arrTemp.length; j < j_len; j++){
					strTemp.push(arrTemp[j][i]);
				}
				titleTemp.push(QBOX.$.extend(true, [], strTemp));
				strTemp.RT_clear();
			}
			
			objExcelInfo.header.title = QBOX.$.extend(true, [], titleTemp);
			
			arrTemp.RT_clear();arrTemp = null;
			titleTemp.RT_clear();titleTemp = null;
			strTemp.RT_clear();strTemp = null;
			
			for(i = rowheaderLength ; i < nCols ; i++){
				objExcelInfo.data.colskey.push(arrKeys[i]);
				objExcelInfo.widths.push(arrColWidths[i]);
				
				if(arrColumns.length > i ){
					obj = QBOX._.isNull(arrColumns[i].attr('styleinfo')) ? {} : arrColumns[i].attr('styleinfo');
					if(obj.data !== undefined && obj.data.css !== undefined && this._useDataTextAlign(i))
						obj.data.css['text-align'] = this._getDataTextAlign(i);
					objExcelInfo.style.push(obj); //스타일 추가
				}	
					
				else
					objExcelInfo.style.push({}); //스타일 추가
				//objExcelInfo.style.push(arrColumns[i].attr('style')); //스타일 추가
				//objExcelInfo.style.push({}); // 스타일 제거로 인한 빈배열만 추가
			}
		} else  {
			for(i = 0, i_len = arrTitle[0].length; i < i_len; i++){
				for(j = 0, j_len = arrTitle.length; j < j_len; j++){
					strTemp.push(arrTitle[j][i]);
				}
				titleTemp.push(QBOX._.clone(strTemp));
				strTemp.RT_clear();
			}
			
			objExcelInfo.header.title = QBOX._.clone(titleTemp);
			titleTemp.RT_clear();titleTemp = null;
			strTemp.RT_clear();strTemp = null;
			
			objExcelInfo.data.colskey = arrKeys;
			objExcelInfo.widths = arrColWidths;
			
			for(i = 0 ; i < nCols ; i++){
				if(arrColumns.length > i )	{
					obj = QBOX._.isNull(arrColumns[i].attr('styleinfo')) ? {} : arrColumns[i].attr('styleinfo');
					
					if(obj.data !== undefined && obj.data.css !== undefined && this._useDataTextAlign(i))
						obj.data.css['text-align'] = this._getDataTextAlign(i);
					objExcelInfo.style.push(obj); //스타일 추가
				}		
					
				else
					objExcelInfo.style.push({}); //스타일 추가
				//objExcelInfo.style.push(arrColumns[i].attr('sytleinfo').data.css); //스타일 추가
				//objExcelInfo.style.push(arrColumns[i].attr('style')); //스타일 추가
				//objExcelInfo.style.push({}); // 스타일 제거로 인한 빈배열만 추가
			}
		}
		
		if(properties.exceltitle !== undefined && QBOX._.isString(properties.exceltitle)){
			if(objExcelInfo.header !==undefined && objExcelInfo.header.title !==undefined && QBOX._.isArray(objExcelInfo.header.title)){
				var arr = [];
				for(var xx = 0; xx < objExcelInfo.data.colskey.length ; xx++){
					arr.push(properties.exceltitle);
				}
				objExcelInfo.header.title.RT_insert(0,arr);
				
			}
		}
		
		return objExcelInfo;
	} catch (e) {
		QCELL.log('err', 'QCELL.BasicQCELL._exportCellInfo', e.message);
		return {};
	}
};

QBOX.QCELL.BasicQCELL.prototype._excelDownload = function(properties) {
	var result = true,
	objQcell = QBOX._.clone(this);
	
	if( properties.progressui !== undefined && properties.progressui === true ) {
		objQcell._showProgressUI(properties.progressui);
	}
	
	if( QBOX.$.browser.msie && QBOX.$.browser.version < 10) { //브라우저가 IE이며 9이하일 때
		if(objQcell._excelDownload_checkRequiredProps(properties, "url") && objQcell._excelDownload_checkValidationOfProps(properties)){
			result = objQcell._excelDownloadURL(properties);
		} else {
			result = false;
		}
	} else {
		if(QBOX._.isUndefined(properties.url)){
			if(objQcell._excelDownload_checkRequiredProps(properties, "loc") && objQcell._excelDownload_checkValidationOfProps(properties)){
				result = objQcell._excelDownloadLOC(properties);
			} else {
				result = false;
			}
		} else {
			if(objQcell._excelDownload_checkRequiredProps(properties, "url") && objQcell._excelDownload_checkValidationOfProps(properties)){
				result = objQcell._excelDownloadURL(properties);
			} else {
				result = false;
			}
		}
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._excelDownload_checkRequiredProps = function(properties, type) {
	var result = true;
	if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
		var arrRequiredProps;
		if(type === "loc") {
			arrRequiredProps = ["filename"];
		} else {
			arrRequiredProps = ["filename", "url"];
		}
		for(var i = 0, length = arrRequiredProps.length; i < length; i++ ){
			var key = arrRequiredProps[i];
			if(properties[key] === undefined){
				QBOX.QCELL.log('err', 'QCELL.BasicQCELL._excelDownload_checkRequiredProps', 'Please check "' + key + '" property.');
				result = false;
				break;
			}
		}
		arrRequiredProps.RT_clear();
		arrRequiredProps = null;
	} else{
		QBOX.QCELL.log('err', 'QCELL.BasicQCELL._excelDownload_checkRequiredProps', 'Please check first parameter\'s type is "object".');
		result = false;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._excelDownload_checkValidationOfProps = function(properties){
	var result = true,
	objQcell = this;
	QBOX.$.each(properties, function(key, val){
		result = objQcell._excelDownload_checkValidationOfProp(key, val);
		return result;
	});
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._excelDownload_checkValidationOfProp = function(key, val){
	var result = true, defaultmsg = true, datatype = '';
	
	switch(key){
		/* string type */
		case 'filename':
		case 'fileExt':
		case 'url': {
			datatype = 'string';
			if(QBOX._.isString(val) === false) {
				result = false;
			}
			
			break;
		}
		
		/* boolean type */
		case 'border': 
		case 'headershow': 
		case 'colwidth': 
		case 'progressui': 
		case 'huge': 
		case 'label': {
			datetype = 'boolean';
			if(QBOX._.isBoolean(val) === false) {
				result = false;
			}
			
			break;
		}
		
		/* object type */
		case 'addColumns': {
			datetype = 'object';
			if(QBOX._.isObject(val) === false) {
				result = false;
			} else {
				QBOX.$.each(val, function(key_of_data, val_of_data){
					QBOX.$.each(val_of_data, function(key_data, val_data){
						switch(key_data){
							/* string type */
							case 'width' :
							case 'key' :
							case 'num' : {
								datatype = 'string';
								if(QBOX._.isString(val_data) === false) {
									QBOX.QCELL.log('err', 'QCELL.BasicQCELL._excelDownload_checkValidationOfProp', 'Please check "' + key + '.' + key_data + '" property. This property\'s type is "'+datatype+'".');
									result = false;
									defaultmsg = false;
									
									return false;
								}
								
								break;
							}
							/* object type */
							case 'title' : {
								datatype = 'object';
								if(QBOX._.isObject(val_data) === false) {
									QBOX.QCELL.log('err', 'QCELL.BasicQCELL._excelDownload_checkValidationOfProp', 'Please check "' + key + '.' + key_data + '" property. This property\'s type is "'+datatype+'".');
									result = false;
									defaultmsg = false;
									
									return false;
								}
								
								break;
							}
							default: break;
						}
					});
				});
			}
			
			break;
		}
		
		/* array type */
		case 'delColumns': 
		case 'orderColumns': {
			datatype = 'array';
			
			if(QBOX._.isUndefined(val) === true || QBOX._.isArray(val) === false) {
				result = false;
			}
			
			break;
		}
		
		default: break;
	}
	
	if(result === false && defaultmsg){
		QBOX.QCELL.log('err', 'QCELL.BasicQCELL._excelDownload_checkValidationOfProp', 'Please check "' + key + '" property\'s type is "' + datatype + '".');
	}
	
	return result;
};


//IE9이하나, url을 통해 엑셀저장
QBOX.QCELL.BasicQCELL.prototype._excelDownloadURL = function(properties) {
	var strAPI = this.attr('id') + '._excelDownloadURL';
	try {
		var fileExt = properties.fileExt !== undefined && properties.fileExt.length !== 0 ? '.'+properties.fileExt : '.xlsx',
		filename = properties.filename+fileExt,
		file = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'filename').val(filename),
		info = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'info'),
		property = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'properties'),
		param = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'param'),
		objQCell = this;
		
		/*
		if( properties.huge !== undefined && QBOX._.isBoolean(properties.huge) && properties.huge ) {
			info.val(JSON.stringify(this._exportCellInfo(properties)));
		} else {
			info.val(JSON.stringify(this._exportCellInfo(properties)));
		}
		*/
		
		info.val(JSON.stringify(this._exportCellInfo(properties)));
		
		property.val(JSON.stringify(properties));
		param.val(JSON.stringify(properties.param));
		
		QBOX.$.fileDownload(properties.url, {
			httpMethod: "POST",
			data: {
				filename: file.val(),
				info: info.val(),
				properties: property.val(),
				param: param.val()
			}
			/*
			, prepareCallback: function (url) { // error시 debug용
			console.log('prepareCallback:'+url);
			console.log('filename:'+file.val());
			console.log('info');
			console.log(info.val());
			console.log('properties');
			console.log(property.val());
			 */
			/*
			, successCallback: function(url){
				console.log('success callback');
				console.log(url);
				console.log('progressui:'+properties.progressui);
				
				if( properties.progressui !== undefined && properties.progressui === true ) {
					objQCell._showProgressUI(false);
				}
				setTimeout(function (){
					objQCell._trigger('afterurlexceldown');			
				},0);
			}, failCallback: function(res, url){
				console.log('fail callback');
				console.log(url);
				console.log(res);
				console.log('progressui:'+properties.progressui);
				
				if( properties.progressui !== undefined && properties.progressui === true ) {
					objQCell._showProgressUI(false);
				}
				setTimeout(function (){
					objQCell._trigger('afterurlexceldown');			
				},0);
			}
			*/
		})
		.done(function(){
			if( properties.progressui !== undefined && properties.progressui === true ) {
				objQCell._showProgressUI(false);
			}
			setTimeout(function (){
				objQCell._filedowntrigger('afterurlexceldown', 'success');
			},0);
		})
		.fail(function(){
			if( properties.progressui !== undefined && properties.progressui === true ) {
				objQCell._showProgressUI(false);
			}
			setTimeout(function (){
				objQCell._filedowntrigger('afterurlexceldown', 'fail');		
			},0);
		});
		
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};

//IE10이상, html5지원하는 브라우저에서 로컬 엑셀저장
QBOX.QCELL.BasicQCELL.prototype._excelDownloadLOC = function(properties) {
	var strAPI = this.attr('id') + '._excelDownloadLOC';
	try {
		var fileExt = properties.fileExt !== undefined && properties.fileExt.length !== 0 ? '.'+properties.fileExt : '.xlsx',
		filename = properties.filename+fileExt,
		mergeInfo = [], h_mergeInfo = [], d_mergeInfo = [],
		excelInfo = this._exportCellInfo(properties),i,j,strKey;
		
		var bColMerge = (QBOX._.isUndefined(properties.delColumns) === false || QBOX._.isUndefined(properties.addColumns) === false )? false : true;
		
		if(properties.totaldata !== undefined && QBOX._.isBoolean(properties.totaldata) && properties.totaldata){
			excelInfo.data.data = QBOX._.clone(this.attr('data').input);
		}
		if(this.attr('excelexportwithformat') === true){
			var objFormat;
			for( j=0 ; j< this.attr('cols'); j++){
				strKey = this._getKeyOfCol(j);
				if(strKey === undefined || strKey === null || strKey === '')
					continue;
				
				objFormat = this._getColFormat(j);
				if( !(QBOX._.isUndefined(objFormat)) && !(QBOX._.isNull(objFormat)) ) {
					for(i=0; i< excelInfo.data.data.length ; i++){
						excelInfo.data.data[i][strKey] =  this._showDataFormat(i,j,excelInfo.data.data[i][strKey]);
					}				
				}					
			}			
		}
		
		
		
		
		if( properties.headershow !== undefined && QBOX._.isBoolean(properties.headershow) && properties.headershow ) {
			h_mergeInfo = this._excelMerge(excelInfo.header, "header",false);
			d_mergeInfo = this._excelMerge(excelInfo.data, "data",bColMerge);
			mergeInfo = this._unionMergeInfo(excelInfo.header.title.length, h_mergeInfo, d_mergeInfo);
			this._exportToExcel(excelInfo, filename, mergeInfo, properties);
		} else {
			mergeInfo = this._excelMerge(excelInfo.data, "data",bColMerge);
			this._exportToExcel(excelInfo, filename, mergeInfo, properties);
		}
		
		if( properties.progressui !== undefined && properties.progressui === true ) {
			this._showProgressUI(false);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};

//Excel파일 저장실행
QBOX.QCELL.BasicQCELL.prototype._exportToExcel = function(info, filename, mergeInfo, properties) {
	var wb = this._SetWorkbook(info, mergeInfo, properties),
	wbout = XLSX.write(wb, {bookType:"xlsx", bookSST:true, type: 'binary', compression:true}),
	fname = filename;
	
	try {
		saveAs(new Blob([this._s2ab(wbout)],{type: "application/octet-stream"}), fname);
	}
	catch(e) { 
		if(typeof console !== 'undefined') {
			console.log(e, wbout); 
		}
	}
	return wbout;
};

//파일을 저장하기 위한 코드변환
QBOX.QCELL.BasicQCELL.prototype._s2ab = function(s){
	var buf, i = 0;
	if(typeof ArrayBuffer !== 'undefined') {
		buf = new ArrayBuffer(s.length);

		var view = new Uint8Array(buf);
		for (i = 0; i < s.length; ++i) {
			view[i] = s.charCodeAt(i) & 0xFF;
		} 
		
		return buf;
	}
	else {
		buf = new Array(s.length);
		for (i = 0; i < s.length; ++i) {
			buf[i] = s.charCodeAt(i) & 0xFF;
		}
		return buf;
	}
};

//workbook 생성 및 데이터 입력, 스타일 적용, merge정보 저장
QBOX.QCELL.BasicQCELL.prototype._SetWorkbook = function(info, mergeInfo, properties) {
	var wb = {};
	wb.SheetNames = [];
	wb.Sheets = {};
	
	var ws_name = "Sheet";
	wb.SheetNames.push(ws_name);
	
	var ws = {};
	var datarows = info.data.data.length,
		totalcols = info.data.colskey.length,
		headerrows = 0, totalrows,
		nHeaderCols = this.attr('headercols'),
		nHeaderRows = this.attr('headerrows'),
		nIndex = 0;
	
	if( properties.headershow !== undefined && QBOX._.isBoolean(properties.headershow) && properties.headershow ) {
		headerrows = info.header.title.length;
	}
	
	totalrows = headerrows + datarows;
	
	var range = {s: {c: 0, r: 0}, e: {c: totalcols - 1, r: totalrows - 1}};
	ws['!ref'] = XLSX.utils.encode_range(range);
	ws['!merges'] = mergeInfo;
	
	var wsCols = [];
	if( properties.headershow !== undefined && QBOX._.isBoolean(properties.headershow) && properties.headershow ) {
		for(var i = 0, len = info.widths.length; i < len; i++) {
			var nWidth = parseInt(info.widths[i]);
			if(properties.defaultColumnSize !== undefined && nWidth === 0){
				properties.defaultColumnSize = QBOX.util.replaceAll(properties.defaultColumnSize , 'px','');
				properties.defaultColumnSize = QBOX.util.replaceAll(properties.defaultColumnSize , '%','');
				nWidth = parseInt(properties.defaultColumnSize);
			}
			
			if(isNaN(nWidth))
				nWidth = 0;
			wsCols.push({ "wpx": (nWidth * 0.75) });
		}
	}
	ws['!cols'] = wsCols;
	
	var r_idx = 0, c_idx = 0;
		cell_ref = "";
	var	excelCell = {};
	var bET = properties.exceltitle !== undefined ? true : false;
	
	//header의 title정보 입력
	var headerCellStyle = 
	{
			fill: {
				patternType: "none",
				fgColor: {rgb: "000000"},
				bgColor: {rgb: "FFFFFFFF"}
			},
			font: {
				name: '맑은 고딕',
				sz: 10,
				color: {rgb: "#000000"},
				bold: true,
				italic: false,
				underline: false
			},
			alignment: {
				vertical: "center",
				horizontal: "left"
			}
		};
	var excelTitleCellStyle = 
	{
			fill: {
				patternType: "none",
				fgColor: {rgb: "000000"},
				bgColor: {rgb: "#FFFFFF"}
			},
			font: {
				name: '맑은 고딕',
				sz: 12,
				color: {rgb: "#000000"},
				bold: true,
				italic: false,
				underline: false
			},
			alignment: {
				vertical: "center",
				horizontal: "center"
			}
		};
	for(r_idx = 0; r_idx < headerrows; r_idx++) {
		
		var titles = info.header.title[r_idx];
		
		for(c_idx = 0; c_idx < totalcols; c_idx++) {
			
			styles = info.style[c_idx].header === undefined ? {
				classname	: '',
				rule		: '',
				css			: {}
			} : info.style[c_idx].header.css;
			
			headerCellStyle =
			{
				fill: {
					patternType: "none",
					fgColor: {rgb: "FF000000"},
					bgColor: {rgb: "FFFFFFFF"}
				},
				font: {
					name: '맑은 고딕',
					sz: 10,
					color: {rgb: "#000000"},
					bold: true,
					italic: false,
					underline: false
				},
				alignment: {
					vertical: "center",
					horizontal: "left"
				}
			};
			
			headerCellStyle = this._cellStyleSetting(headerCellStyle, "header", properties);
			
			cell_ref = XLSX.utils.encode_cell({c: c_idx, r: r_idx});
			
			excelCell = {};
			excelCell.v = titles[c_idx];
			excelCell.t = "s";
			excelCell.s = bET === true  &&  r_idx === 0? excelTitleCellStyle : headerCellStyle;
			
			ws[cell_ref] = excelCell;
			
			excelCell = {};
		}
	}
	
	//data 입력
	for(; r_idx < totalrows; r_idx++) {
		
		var rr_idx = r_idx - headerrows,
			datas = info.data.data[rr_idx],
			colkey = info.data.colskey;
		
		for(c_idx = 0; c_idx < totalcols; c_idx++) {
			styles = info.style[c_idx].data === undefined ? {
				classname	: '',
				rule		: '',
				css			: {}
			} : info.style[c_idx].data.css;
			//styles = info.style[c_idx].data;
			
			var dataCellStyle =
			{
				fill: {
					patternType: "none",
					fgColor: {rgb: "FF000000"},
					bgColor: {rgb: "FFFFFFFF"}
				},
				font: {
					name: '맑은 고딕',
					sz: 10,
					color: {rgb: "#000000"},
					bold: false,
					italic: false,
					underline: false
				},
				alignment: {
					vertical: "center",
					horizontal: "left"
				}
			};
			if(properties.forcebasicstyle !== true )
				dataCellStyle = this._cellStyleSetting(dataCellStyle, "data", properties);
			
			cell_ref = XLSX.utils.encode_cell({c: c_idx, r: r_idx});
			
			excelCell = {};
			if(colkey[c_idx] === '_rt_qc_seq'){
				if(datas.rt_qc_fbrd === true){
					excelCell.v = datas.rt_qc_seq === undefined ? ' ' : datas.rt_qc_seq;
				}else{
					excelCell.v = r_idx;	
				}
				
				excelCell.s = headerCellStyle;
				excelCell.t = "s";
			}else{
				
				excelCell.v = (QBOX._.isUndefined(datas[colkey[c_idx]]) || QBOX._.isNull(datas[colkey[c_idx]])) ? '' : ''+datas[colkey[c_idx]];
				if(properties.datatype === 'string'){
					excelCell.t = "s";	
				}else{
					if(this._getColExportDataType(this._getColsOfKey(colkey[c_idx])[0]) === 'string'){
						excelCell.t = "s";					
					}else{
						if(QBOX._.isString(excelCell.v) && excelCell.v.trim() === '' ){
							excelCell.t = "s";	
						}else{
							if(QBOX._.isNumber(excelCell.v) || !isNaN(Number(excelCell.v))){
								excelCell.t = "n";	
								excelCell.v = Number(excelCell.v);
							}else{
								excelCell.t = "s";	
							}					
						}				
						
					}
				}
					
				
			
				excelCell.s = dataCellStyle;				
			}
			
			
			
			
			ws[cell_ref] = excelCell;
			excelCell = {};
			
		}
		nIndex++;
	}
	
	wb.Sheets[ws_name] = ws;
	return wb;
};

//스타일 정보 적용
QBOX.QCELL.BasicQCELL.prototype._cellStyleSetting = function(cellStyle, type, properties) {
	if(type === "header") {
		
		cellStyle.fill.bgColor.rgb = "FF7b7d87";
		cellStyle.fill.fgColor.rgb = "FF7b7d87";
		cellStyle.fill.patternType = "solid";
		
		cellStyle.font.color.rgb = "FFFFFFFF";
		cellStyle.font.bold = true;
		cellStyle.alignment.horizontal = "center";
	}
	if( properties.border !== undefined && QBOX._.isBoolean(properties.border) && properties.border ) {
		cellStyle.border = {
			top: {style: "thin", color: {auto: 1}},
			right: {style: "thin", color: {auto: 1}},
			bottom: {style: "thin", color: {auto: 1}},
			left: {style: "thin", color: {auto: 1}}
		};
	}
	
	var $that = this;
	QBOX.$.each(styles, function(key, val){
		var code = "",
		nVal = "",
		i =0, ch = '';
		
		switch(key) {
			case 'background-color': {
				if(val.indexOf("#") < 0) {
					code = $that._convertHtmlColorCode(val);
				}
				else {
					if(val.length == 4){
						val = val.replace("#", "");
						nVal = '';
						for(i = 0; i < val.length; i++){
							ch = val.substr(i, 1);
							nVal += ch+ch;
						}
						val = nVal;
					}
					code = val;
				}
				
				code = code.replace("#", "");
				code = "FF"+code.toUpperCase();
				
				cellStyle.fill.bgColor.rgb = code;
				cellStyle.fill.fgColor.rgb = code;
				cellStyle.fill.patternType = "solid";
				
				break;
			}
			case 'font-weight': {
				if(val === "bold" || val === "bolder") {
					cellStyle.font.bold = true;
				}
				else {
					cellStyle.font.bold = false;
				}
				break;
			}
			case 'text-align': {
				cellStyle.alignment.horizontal = val;
				break;
			}
			case 'color': {
				var colorCode = "";
				if(styles.color.indexOf("#") < 0) {
					colorCode = $that._convertHtmlColorCode(val);
				}
				else {
					if(val.length == 4){
						val = val.replace("#", "");
						nVal = '';
						for(i = 0; i < val.length; i++){
							ch = val.substr(i, 1);
							nVal += ch+ch;
						}
						val = nVal;
					}
					colorCode = val;
				}
				
				colorCode = colorCode.replace("#", "");
				colorCode = "FF"+colorCode.toUpperCase();
				
				cellStyle.font.color.rgb = colorCode;
				break;
			}
			case 'text-decoration': {
				if(val.indexOf('underline') > -1 ) {
					cellStyle.font.underline = true;
				}
				else {
					cellStyle.font.underline = false;
				}
				
				if(val.indexOf('line-through') > -1 ) {
					cellStyle.font.strike = true;
				}
				else {
					cellStyle.font.strike = false;
				}
				
				break;
			}
			default: break;
		}
	});
	
	return cellStyle;
};

//header영역과 data영역의 merge정보 통합 
QBOX.QCELL.BasicQCELL.prototype._unionMergeInfo = function(h_idx, h_mergeInfo, d_mergeInfo) {
	
	if(d_mergeInfo.length > 0) {
		for(var i = 0, end = d_mergeInfo.length; i < end; i++) {
			d_mergeInfo[i].s.r = d_mergeInfo[i].s.r + h_idx;
			d_mergeInfo[i].e.r = d_mergeInfo[i].e.r + h_idx;
		}
	}
	
	return QBOX._.union(h_mergeInfo, d_mergeInfo);
};

//merge정보 설정
QBOX.QCELL.BasicQCELL.prototype._excelMerge = function(info, type, bColMerge) {
	var mergeType = info.mergeType,
		data = [];
	
	if( type === "header" ) { //현재 데이터가 header 데이터 일 때
		data = info.title;
	} else {
		var key = info.colskey,
		tempData = info.data;
		
		for(var i = 0, i_end = tempData.length; i < i_end; i++) {
			var  temp = [];
			for(var j = 0, j_end = key.length; j < j_end; j++) {
				temp.push(tempData[i][key[j]]);
			}
			data.push(temp);
		}
	}
	
	return this._mergeInfoSetting(mergeType, data, type,bColMerge);
};

//merge실행
QBOX.QCELL.BasicQCELL.prototype._mergeInfoSetting = function(mergeType, data, type,bColMerge) {
	var st_row = 0, st_col = 0,
		ed_row = 0, ed_col = 0,
		mergeTemp = {},
		c_idx = 0, r_idx = 0,
		c_next = 0, r_next = 0,
		rows = data.length,
		//cols = this.attr('cols') - this.attr("rowheaders").length,
		cols = QBOX._.isEmpty(data) === true ? this.attr('cols') - this.attr("rowheaders").length : data[0].length,
		mergeInfo = [],i,m,l,arrMerge,objMerge,r_st,
		rowheaderLength = this.attr('rowheaders').length;
	
	if(mergeType === "row") { //mergeType이 row일 때 병합 정보 저장
		for(r_idx = 0; r_idx < rows; r_idx++) {
			for(c_idx = 0; c_idx  < cols; c_idx++) {
				if(this._getColDataMergeCol(c_idx+rowheaderLength ) === false && bColMerge){
					continue;
				}
				if(c_idx === 0) {
					st_col = 0;
					ed_col = 0;
				}
				
				c_next = c_idx+1;
				
				if(c_next >= cols) {
					c_next = c_idx;
				}
				
				if(data[r_idx][c_idx] === data[r_idx][c_next]) {
					ed_col = c_next;
				}
				else {
					mergeTemp.s = {r: r_idx, c: st_col};
					mergeTemp.e = {r: r_idx, c: ed_col};
					
					if(mergeTemp.s.c !== mergeTemp.e.c) {
						mergeInfo.push(mergeTemp);
					}
					
					st_col = c_next;
					ed_col = c_next;
					
					mergeTemp = {};
				}
				
				if(c_idx+1 === cols) {
					mergeTemp.s = {r: r_idx, c: st_col};
					mergeTemp.e = {r: r_idx, c: ed_col};
					
					if(mergeTemp.s.c !== mergeTemp.e.c) {
						mergeInfo.push(mergeTemp);
					}
					
					mergeTemp = {};
				}
			}
		}
	}
	else if(mergeType === "col") { //mergeType이 col일 때 병합 정보 저장
		for(c_idx = 0; c_idx  < cols; c_idx++) {
			if(this._getColDataMergeCol(c_idx+rowheaderLength ) === false && bColMerge){
				continue;
			}
			for(r_idx = 0; r_idx < rows; r_idx++) {
				
				if(r_idx === 0) {
					st_row = 0;
					ed_row = 0;
				}
				
				r_next = r_idx+1;
				
				if(r_next >= rows) {
					r_next = r_idx;
				}
				
				
				if(data[r_idx][c_idx] === data[r_next][c_idx]) {
					ed_row = r_next;
				}
				else {
					mergeTemp.s = {r: st_row, c: c_idx};
					mergeTemp.e = {r: ed_row, c: c_idx};
					
					if(mergeTemp.s.r !== mergeTemp.e.r) {
						mergeInfo.push(mergeTemp);
					}
					
					st_row = r_next;
					ed_row = r_next;
					
					mergeTemp = {};
				}
				
				if(r_idx+1 === rows) {
					mergeTemp.s = {r: st_row, c: c_idx};
					mergeTemp.e = {r: ed_row, c: c_idx};
					
					if(mergeTemp.s.r !== mergeTemp.e.r) {
						mergeInfo.push(mergeTemp);
					}
					
					mergeTemp = {};
				}
			}
		}
	}
	
	else if(mergeType === "rowandcol" && type == "header") { //mergeType이 rowandcol일 때 병합 정보 저장
		for(r_idx = 0; r_idx < rows; r_idx++) {
			st_row = r_idx;
			ed_row = r_idx;
			
			for(c_idx = 0; c_idx  < cols; c_idx++) {
				if(c_idx === 0) {
					st_col = 0;
					ed_col = 0;
				}
				
				c_next = c_idx+1;
				
				if(c_next >= cols) {
					c_next = c_idx;
				}
				
				if(data[r_idx][c_idx] === data[r_idx][c_next]) {
					ed_col = c_next;
				}
				else {
					ed_row = this._excelFindEndRow(st_row, st_col, ed_col, data);
					
					if( (st_row !== ed_row || st_col !== ed_col) && !this._checkMerge(st_row, st_col, mergeInfo)) {
						mergeTemp.s = {r: st_row, c: st_col};
						mergeTemp.e = {r: ed_row, c: ed_col};
						
						mergeInfo.push(mergeTemp);
						
						mergeTemp = {};
					}
					
					st_col = c_next;
					ed_col = c_next;
					ed_row = st_row;
				}
				
				if(c_idx+1 === cols) {
					ed_row = this._excelFindEndRow(st_row, st_col, ed_col, data);
					
					if( (st_row !== ed_row || st_col !== ed_col) && !this._checkMerge(st_row, st_col, mergeInfo)) {
						mergeTemp.s = {r: st_row, c: st_col};
						mergeTemp.e = {r: ed_row, c: ed_col};
						
						mergeInfo.push(mergeTemp);
						
						mergeTemp = {};
					}
				}
			}
		}
	}
	else if(mergeType === "colandrow" && type == "header") { //mergeType이 colandrow일 때 병합 정보 저장
		for(c_idx = 0; c_idx  < cols; c_idx++) {
			st_col = c_idx;
			ed_col = c_idx;
			
			for(r_idx = 0; r_idx < rows; r_idx++) {
				if(r_idx === 0) {
					st_row = 0;
					ed_row = 0;
				}
				
				r_next = r_idx+1;
				
				if(r_next >= rows) {
					r_next = r_idx;
				}
				
				if(data[r_idx][c_idx] === data[r_next][c_idx]) {
					ed_row = r_next;
				}
				else {
					ed_col = this._excelFindEndCol(st_col, st_row, ed_row, data, cols);
					
					if( (st_row !== ed_row || st_col !== ed_col) && !this._checkMerge(st_row, st_col, mergeInfo)) {
						mergeTemp.s = {r: st_row, c: st_col};
						mergeTemp.e = {r: ed_row, c: ed_col};
						
						mergeInfo.push(mergeTemp);
						mergeTemp = {};
					}
					
					st_row = r_next;
					ed_row = r_next;
					ed_col = st_col;
				}
				if(r_idx+1 === rows) {
					ed_col = this._excelFindEndCol(st_col, st_row, ed_row, data, cols);
					
					if( (st_row !== ed_row || st_col !== ed_col) && !this._checkMerge(st_row, st_col, mergeInfo)) {
						mergeTemp.s = {r: st_row, c: st_col};
						mergeTemp.e = {r: ed_row, c: ed_col};
						
						mergeInfo.push(mergeTemp);
						mergeTemp = {};
					}
				}
			}
		}
		
	} else if(mergeType === "group") { //mergeType이 colandrow일 때 병합 정보 저장
		arrMerge = [];
		for(c_idx = 0; c_idx  < cols; c_idx++) {
			if(this._getColDataMergeCol(c_idx+rowheaderLength ) === false && bColMerge){
				continue;
			}
			arrMerge[c_idx] = [];
			if( c_idx === 0 ) { // col이 0일 때, group의 첫번째 열의 병합
				for(r_idx = 0; r_idx < rows; r_idx++) {
					if(r_idx === 0) {
						st_row = 0;
						ed_row = 0;
					}
					
					r_next = r_idx+1;
					
					if(r_next >= rows) {
						r_next = r_idx;
					}
					
					if(data[r_idx][c_idx] === data[r_next][c_idx]) {
						ed_row = r_next;
					}
					else {
						mergeTemp.s = {r: st_row, c: c_idx};
						mergeTemp.e = {r: ed_row, c: c_idx};
						
						if(mergeTemp.s.r !== mergeTemp.e.r) {
							arrMerge[c_idx].push(mergeTemp);
						}
						
						st_row = r_next;
						ed_row = r_next;
						
						mergeTemp = {};
					}
					
					if(r_idx+1 === rows) {
						mergeTemp.s = {r: st_row, c: c_idx};
						mergeTemp.e = {r: ed_row, c: c_idx};
						
						if(mergeTemp.s.r !== mergeTemp.e.r) {
							arrMerge[c_idx].push(mergeTemp);
						}
						
						mergeTemp = {};
					}
				}
			} else { // col이 0이 아닐 때
				if(arrMerge[c_idx-1].length > 0){
					for( i = 0, len = arrMerge[c_idx-1].length; i < len; i++) {
						objMerge = arrMerge[c_idx-1][i];
						
						for(r_st = objMerge.s.r , r_ed = objMerge.e.r; r_st < r_ed; r_st++) {
							if(r_st === objMerge.s.r) {
								st_row = objMerge.s.r;
								ed_row = objMerge.s.r;
							}
							
							r_next = r_st+1;
							
							if(data[r_st][c_idx] === data[r_next][c_idx]) {
								ed_row = r_next;
							}
							else {
								mergeTemp.s = {r: st_row, c: c_idx};
								mergeTemp.e = {r: ed_row, c: c_idx};
								
								if(mergeTemp.s.r !== mergeTemp.e.r) {
									//mergeInfo.push(mergeTemp);
									arrMerge[c_idx].push(mergeTemp);
								}
								
								st_row = r_next;
								ed_row = r_next;
								
								mergeTemp = {};
							}
							
							if(r_st+1 === r_ed) {
								mergeTemp.s = {r: st_row, c: c_idx};
								mergeTemp.e = {r: ed_row, c: c_idx};
								
								if(mergeTemp.s.r !== mergeTemp.e.r) {
									arrMerge[c_idx].push(mergeTemp);
								}
								
								mergeTemp = {};
							}
						}
					}
				}
			}
		}
		
		if(arrMerge.length > 0) {
			for( m = 0; m  < arrMerge.length; m++) {
				if(arrMerge[m].length > 0) {
					for( l = 0; l < arrMerge[m].length; l++) {
						mergeInfo.push(arrMerge[m][l]);
					}
				}
			}
		}
	}else if(mergeType === "groupandrow") { //mergeType이 colandrow일 때 병합 정보 저장
		arrMerge = [];
		var arrTempMerge  = [],nNextCol;
		for(c_idx = 0; c_idx  < cols; c_idx++) {
			if(this._getColDataMergeCol(c_idx+rowheaderLength ) === false && bColMerge){
				continue;
			}
			arrMerge[c_idx] = [];
			if( c_idx === 0 ) { // col이 0일 때, group의 첫번째 열의 병합
				for(r_idx = 0; r_idx < rows; r_idx++) {
					if(r_idx === 0) {
						st_row = 0;
						ed_row = 0;
					}
					
					r_next = r_idx+1;
					
					if(r_next >= rows) {
						r_next = r_idx;
					}
					
					if(data[r_idx][c_idx] === data[r_next][c_idx]) {
						ed_row = r_next;
					}
					else {
						mergeTemp.s = {r: st_row, c: c_idx};
						mergeTemp.e = {r: ed_row, c: c_idx};
						
						if(mergeTemp.s.r !== mergeTemp.e.r) {
							arrMerge[c_idx].push(mergeTemp);
						}else {
							for(nNextCol = c_idx +1;  nNextCol < cols ; nNextCol++){
								if(data[r_idx][c_idx] !== data[r_idx][nNextCol]) {
									break;
								}
							}
							
							if(c_idx + 1 !== nNextCol){
								mergeTemp.s = {r: st_row, c: c_idx};
								mergeTemp.e = {r: ed_row, c: nNextCol-1};
								
								arrTempMerge.push(mergeTemp);
							}
						}
						
						st_row = r_next;
						ed_row = r_next;
						
						mergeTemp = {};
					}
					
					if(r_idx+1 === rows) {
						mergeTemp.s = {r: st_row, c: c_idx};
						mergeTemp.e = {r: ed_row, c: c_idx};
						
						if(mergeTemp.s.r !== mergeTemp.e.r) {
							arrMerge[c_idx].push(mergeTemp);
						}else {
							
							for(nNextCol = c_idx +1;  nNextCol < cols ; nNextCol++){
								if(data[r_idx][c_idx] !== data[r_idx][nNextCol]) {
									break;
								}
							}
							
							if(c_idx + 1 !== nNextCol){
								mergeTemp.s = {r: st_row, c: c_idx};
								mergeTemp.e = {r: ed_row, c: nNextCol-1};
								
								arrTempMerge.push(mergeTemp);
							}
						}
						
						mergeTemp = {};
					}
				}
			} else { // col이 0이 아닐 때
				if(arrMerge[c_idx-1].length > 0){
					for(i = 0, len = arrMerge[c_idx-1].length; i < len; i++) {
						objMerge = arrMerge[c_idx-1][i];
						
						for(r_st = objMerge.s.r , r_ed = objMerge.e.r; r_st < r_ed; r_st++) {
							if(r_st === objMerge.s.r) {
								st_row = objMerge.s.r;
								ed_row = objMerge.s.r;
							}
							
							r_next = r_st+1;
							
							if(data[r_st][c_idx] === data[r_next][c_idx]) {
								ed_row = r_next;
							}
							else {
								mergeTemp.s = {r: st_row, c: c_idx};
								mergeTemp.e = {r: ed_row, c: c_idx};
								
								if(mergeTemp.s.r !== mergeTemp.e.r) {
									//mergeInfo.push(mergeTemp);
									arrMerge[c_idx].push(mergeTemp);
								}else {
									for(nNextCol = c_idx +1;  nNextCol < cols ; nNextCol++){
										if(data[r_st][c_idx] !== data[r_st][nNextCol]) {
											break;
										}
									}
									
									if(c_idx + 1 !== nNextCol){
										mergeTemp.s = {r: st_row, c: c_idx};
										mergeTemp.e = {r: ed_row, c: nNextCol-1};
										
										arrTempMerge.push(mergeTemp);
									}
								}
								
								st_row = r_next;
								ed_row = r_next;
								
								mergeTemp = {};
							}
							
							if(r_st+1 === r_ed) {
								mergeTemp.s = {r: st_row, c: c_idx};
								mergeTemp.e = {r: ed_row, c: c_idx};
								
								if(mergeTemp.s.r !== mergeTemp.e.r) {
									arrMerge[c_idx].push(mergeTemp);
								}else {
									for(nNextCol = c_idx +1;  nNextCol < cols ; nNextCol++){
										if(data[r_st][c_idx] !== data[r_st][nNextCol]) {
											break;
										}
									}
									
									if(c_idx + 1 !== nNextCol){
										mergeTemp.s = {r: st_row, c: c_idx};
										mergeTemp.e = {r: ed_row, c: nNextCol-1};
										
										arrTempMerge.push(mergeTemp);
									}
								}
								
								mergeTemp = {};
							}
						}
					}
				}
			}
		}
		
		if(arrMerge.length > 0) {
			for( m = 0; m  < arrMerge.length; m++) {
				if(arrMerge[m].length > 0) {
					for( l = 0; l < arrMerge[m].length; l++) {
						mergeInfo.push(arrMerge[m][l]);
					}
				}
			}
		}
		if(arrTempMerge.length > 0){
			for ( l = 0 ; l <arrTempMerge.length ; l++){
				mergeInfo.push(arrTempMerge[l]);
			}
		}
	}
	
	return mergeInfo;
};

//mergeType이 colandrow일 때 동일데이터를 가진 마지막 col 확인
QBOX.QCELL.BasicQCELL.prototype._excelFindEndCol = function(st_col, st_row, ed_row, data, cols) {
	var ed_col = st_col,
	tempStr = data[st_row][st_col],
	bool = true;
	
	var i_len = 0, i = 0;
	for(i = st_col, i_ed = cols; i < i_ed; i++) {
		if(data[st_row][i] != tempStr) {
			i_len = i;
			break;
		}else {
			i_len = i;
		}
	}
	
	for(i = st_col, i_ed = i_len; i <= i_ed; i++) {
		for(var j = st_row, j_ed = ed_row; j <= j_ed; j++) {
			if(data[j][i] == tempStr) {
				ed_col = i;
			}
			else {
				ed_col = --i;
				bool = false;
				break;
			}
		}
		
		if(!bool){
			break;
		}
	}
	
	return ed_col;
};

//mergeType이 rowandcol일 때 동일데이터를 가진 마지막 row 확인
QBOX.QCELL.BasicQCELL.prototype._excelFindEndRow = function(st_row, st_col, ed_col, data) {
	var ed_row = st_row, 
	tempStr = data[st_row][st_col],
	bool = true;
	
	for(var i = st_row, i_ed = data.length; i < i_ed; i++) {
		for(var j = st_col, j_ed = ed_col; j <= j_ed; j++) {
			if(data[i][j] === tempStr) {
				ed_row = i;
			}
			else {
				ed_row = --i;
				bool = false;
				break;
			}
		}
		
		if(!bool){
			break;
		}
	}
	return ed_row;
};

//merge정보 중 특정 row와 col 정보가 겹치는 지 확인
QBOX.QCELL.BasicQCELL.prototype._checkMerge = function(st_row, st_col, mergeInfo) {
	var bool = false;
	if(mergeInfo.length > 0) {
		for(var i = 0, len = mergeInfo.length; i < len; i++) {
			if( (st_row >= mergeInfo[i].s.r) && (st_row <= mergeInfo[i].e.r) && (st_col >= mergeInfo[i].s.c) && (st_col <= mergeInfo[i].e.c) ) {
				bool = true;
			}
		}
	}
	return bool;
};

QBOX.QCELL.BasicQCELL.prototype._getMergeInfo = function(st_row, st_col, mergeInfo) {
	var targetMergeInfo = {};
	if(mergeInfo.length > 0) {
		for(var i = 0, len = mergeInfo.length; i < len; i++) {
			if( (st_row >= mergeInfo[i].s.r) && (st_row <= mergeInfo[i].e.r) && (st_col >= mergeInfo[i].s.c) && (st_col <= mergeInfo[i].e.c) ) {
				targetMergeInfo = mergeInfo[i];
				break;
			}
		}
	}
	return targetMergeInfo;
};

//css의 html색상코드를 hex코드로 변경
QBOX.QCELL.BasicQCELL.prototype._convertHtmlColorCode = function(str) {
	var code = "";
	switch( str.toLowerCase() ) {
		// red html color names
		case "indianred" : code = "#cd5c5c"; break;
		case "lightcoral" : code = "#f08080"; break;
		case "salmon" : code = "#fa8072"; break;
		case "darksalmon" : code = "#e9967a"; break;
		case "lightsalmon" : code = "#ffa07a"; break;
		case "crimson" : code = "#dc143c"; break;
		case "red" : code = "#ff0000"; break;
		case "firebrick" : code = "#b22222"; break;
		case "darkred" : code = "#8b0000"; break;
		
		// pink html color names
		case "pink" : code = "#ffc0cb"; break;
		case "lightpink" : code = "#ffb6c1"; break;
		case "hotpink" : code = "#ff69b4"; break;
		case "deeppink" : code = "#ff1493"; break;
		case "mediumvioletred" : code = "#c71585"; break;
		case "palevioletred" : code = "#db7093"; break;
		
		case "coral" : code = "#ff7f50"; break;
		case "tomato" : code = "#db7093"; break;
		case "orangered" : code = "#ff4500"; break;
		case "darkorange" : code = "#ff8c00"; break;
		case "orange" : code = "#ffa500"; break;
		
		// yellow html color names
		case "gold" : code = "#ffd700"; break;
		case "yellow" : code = "#ffff00"; break;
		case "lightyellow" : code = "#ffffe0"; break;
		case "lemonchiffon" : code = "#fffacd"; break;
		case "lightgoldenrodyellow" : code = "#fafad2"; break;
		case "papayawhip" : code = "#ffefd5"; break;
		case "moccasin" : code = "#ffe4b5"; break;
		case "peachpuff" : code = "#ffdab9"; break;
		case "palegoldenrod" : code = "#eee8aa"; break;
		case "khaki" : code = "#f0e68c"; break;
		case "darkkhaki" : code = "#bdb76b"; break;
		
		// purple html color names
		case "lavender" : code = "#e6e6fa"; break;
		case "thistle" : code = "#d8bfd8"; break;
		case "plum" : code = "#dda0dd"; break;
		case "violet" : code = "#ee82ee"; break;
		case "orchid" : code = "#da70d6"; break;
		case "fuchsia" : code = "#ff00ff"; break;
		case "magenta" : code = "#ff00ff"; break;
		case "mediumorchid" : code = "#ba55d3"; break;
		case "mediumpurple" : code = "#9370db"; break;
		case "rebeccapurple" : code = "#663399"; break;
		case "blueviolet" : code = "#8a2be2"; break;
		case "darkviolet" : code = "#9400d3"; break;
		case "darkorchid" : code = "#9932cc"; break;
		case "darkmagenta" : code = "#8b008b"; break;
		case "purple" : code = "#800080"; break;
		case "indigo" : code = "#4b0082"; break;
		case "slateblue" : code = "#6a5acd"; break;
		case "darkslateblue" : code = "#483d8b"; break;
		
		// green html color names
		case "greenyellow" : code = "#adff2f"; break;
		case "chartreuse" : code = "#7fff00"; break;
		case "lawngreen" : code = "#7cfc00"; break;
		case "lime" : code = "#00ff00"; break;
		case "limegreen" : code = "#32cd32"; break;
		case "palegreen" : code = "#98fb98"; break;
		case "lightgreen" : code = "#90ee90"; break;
		case "mediumspringgreen" : code = "#00fa9a"; break;
		case "springgreen" : code = "#00ff7f"; break;
		case "mediumseagreen" : code = "#3cb371"; break;
		case "seagreen" : code = "#2e8b57"; break;
		case "forestgreen" : code = "#228b22"; break;
		case "green" : code = "#008000"; break;
		case "darkgreen" : code = "#006400"; break;
		case "yellowgreen" : code = "#9acd32"; break;
		case "olivedrab" : code = "#6b8e23"; break;
		case "olive" : code = "#808000"; break;
		case "darkolivegreen" : code = "#556b2f"; break;
		case "mediumaquamarine" : code = "#66cdaa"; break;
		case "darkseagreen" : code = "#8fbc8b"; break;
		case "lightseagreen" : code = "#20b2aa"; break;
		case "darkcyan" : code = "#008b8b"; break;
		case "teal" : code = "#008080"; break;
		
		// blue html color names
		case "aqua" : code = "#00ffff"; break;
		case "cyan" : code = "#00ffff"; break;
		case "lightcyan" : code = "#e0ffff"; break;
		case "paleturquoise" : code = "#afeeee"; break;
		case "aquamarine" : code = "#7fffd4"; break;
		case "turquoise" : code = "#40e0d0"; break;
		case "mediumturquoise" : code = "#48d1cc"; break;
		case "darkturquoise" : code = "#00ced1"; break;
		case "cadetblue" : code = "#5f9ea0"; break;
		case "steelblue" : code = "#4682b4"; break;
		case "lightsteelblue" : code = "#b0c4de"; break;
		case "powderblue" : code = "#b0e0e6"; break;
		case "lightblue" : code = "#add8e6"; break;
		case "skyblue" : code = "#87ceeb"; break;
		case "lightskyblue" : code = "#87cefa"; break;
		case "deepskyblue" : code = "#00bfff"; break;
		case "dodgerblue" : code = "#1e90ff"; break;
		case "cornflowerblue" : code = "#6495ed"; break;
		case "mediumslateblue" : code = "#7b68ee"; break;
		case "royalblue" : code = "#4169e1"; break;
		case "blue" : code = "#0000ff"; break;
		case "mediumblue" : code = "#0000cd"; break;
		case "darkblue" : code = "#00008b"; break;
		case "navy" : code = "#000080"; break;
		case "midnightblue" : code = "#191970"; break;
		
		// brown html color names
		case "cornsilk" : code = "#fff8dc"; break;
		case "blanchedalmond" : code = "#ffebcd"; break;
		case "bisque" : code = "#ffe4c4"; break;
		case "navajowhite" : code = "#ffdead"; break;
		case "wheat" : code = "#f5deb3"; break;
		case "burlywood" : code = "#deb887"; break;
		case "tan" : code = "#d2b48c"; break;
		case "rosybrown" : code = "#bc8f8f"; break;
		case "sandybrown" : code = "#f4a460"; break;
		case "goldenrod" : code = "#daa520"; break;
		case "darkgoldenrod" : code = "#b8860b"; break;
		case "peru" : code = "#cd853f"; break;
		case "chocolate" : code = "#d2691e"; break;
		case "saddlebrown" : code = "#8b4513"; break;
		case "sienna" : code = "#a0522d"; break;
		case "brown" : code = "#a52a2a"; break;
		case "maroon" : code = "#800000"; break;
		
		// white html color names
		case "white" : code = "#ffffff"; break;
		case "snow" : code = "#fffafa"; break;
		case "honeydew" : code = "#f0fff0"; break;
		case "mintcream" : code = "#f5fffa"; break;
		case "azure" : code = "#f0ffff"; break;
		case "aliceblue" : code = "#f0f8ff"; break;
		case "ghostwhite" : code = "#f8f8ff"; break;
		case "whitesmoke" : code = "#f5f5f5"; break;
		case "seashell" : code = "#fff5ee"; break;
		case "beige" : code = "#f5f5dc"; break;
		case "oldlace" : code = "#fdf5e6"; break;
		case "floralwhite" : code = "#fffaf0"; break;
		case "ivory" : code = "#fffff0"; break;
		case "antiquewhite" : code = "#faebd7"; break;
		case "linen" : code = "#faf0e6"; break;
		case "lavenderblush" : code = "#fff0f5"; break;
		case "mistyrose" : code = "#ffe4e1"; break;
		
		// gray html color names
		case "gainsboro" : code = "#dcdcdc"; break;
		case "lightgray" : code = "#d3d3d3"; break;
		case "silver" : code = "#c0c0c0"; break;
		case "darkgray" : code = "#a9a9a9"; break;
		case "gray" : code = "#808080"; break;
		case "dimgray" : code = "#696969"; break;
		case "lightslategray" : code = "#778899"; break;
		case "slategray" : code = "#708090"; break;
		case "darkslategray" : code = "#2f4f4f"; break;
		case "black" : code = "#000000"; break;
		
		default: code = "#000000"; break;
	}
	
	return code;
};

QBOX.QCELL.BasicQCELL.prototype._htmlDownload = function(properties) {
	var result = true,
	objQcell = QBOX._.clone(this);
	
	if( properties.progressui !== undefined && properties.progressui === true ) {
		objQcell._showProgressUI(properties.progressui);
	}
	
	if( QBOX.$.browser.msie && QBOX.$.browser.version < 10) { //브라우저가 IE이며 9이하일 때
		result = false;
	} else {
		if(objQcell._htmlDownload_checkRequiredProps(properties) && objQcell._excelDownload_checkValidationOfProps(properties)){
			result = objQcell._htmlDownloadLOC(properties);
		}
		else {
			result = false;
		}
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._htmlDownload_checkRequiredProps = function(properties) {
	var result = true;
	if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
		var arrRequiredProps;
		arrRequiredProps = ["filename"];
		
		for(var i = 0, length = arrRequiredProps.length; i < length; i++ ){
			var key = arrRequiredProps[i];
			if(properties[key] === undefined){
				QBOX.QCELL.log('err', 'QCELL.BasicQCELL._htmlDownload_checkRequiredProps', 'Please check "' + key + '" property.');
				result = false;
				break;
			}
		}
		arrRequiredProps.RT_clear();
		arrRequiredProps = null;
	} else{
		QBOX.QCELL.log('err', 'QCELL.BasicQCELL._htmlDownload_checkRequiredProps', 'Please check first parameter\'s type is "object".');
		result = false;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._htmlDownloadLOC = function(properties) {
	var strAPI = this.attr('id') + '._htmlDownloadLOC';
	try {
		var fileExt = properties.fileExt !== undefined && properties.fileExt.length !== 0 ? '.'+properties.fileExt : '.html',
		filename = properties.filename+fileExt,
		mergeInfo = [], h_mergeInfo = [], d_mergeInfo = [],
		excelInfo = this._exportCellInfo(properties);
		
		var bColMerge = (QBOX._.isUndefined(properties.delColumns) === false || QBOX._.isUndefined(properties.addColumns) === false )? false : true;
		
		if(properties.totaldata !== undefined && QBOX._.isBoolean(properties.totaldata) && properties.totaldata){
			excelInfo.data.data = QBOX._.clone(this.attr('data').input);
		}
		if( properties.headershow !== undefined && QBOX._.isBoolean(properties.headershow) && properties.headershow ) {
			h_mergeInfo = this._excelMerge(excelInfo.header, "header",false);
			d_mergeInfo = this._excelMerge(excelInfo.data, "data",bColMerge);
			mergeInfo = this._unionMergeInfo(excelInfo.header.title.length, h_mergeInfo, d_mergeInfo);
			if(properties.export === true)
				return this._exportToHtml(excelInfo, filename, mergeInfo, properties);
			else
				this._exportToHtml(excelInfo, filename, mergeInfo, properties);
		} else {	
			mergeInfo = this._excelMerge(excelInfo.data, "data",bColMerge,bColMerge);
			
			if(properties.export === true)
				return this._exportToHtml(excelInfo, filename, mergeInfo, properties);
			else
				this._exportToHtml(excelInfo, filename, mergeInfo, properties);
		}
		
		if( properties.progressui !== undefined && properties.progressui === true ) {
			this._showProgressUI(false);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._exportToHtml = function(info, filename, mergeInfo, properties) {
	var strAPI = this.attr('id') + '._exportToHtml';
	try {
		properties.headershow = true; // header data 포함하여 출력
		var wb = this._SetWorkbook(info, mergeInfo, properties),
		wbout = XLSX.write(wb, {charset:'utf-8', bookType:"html", type:'string', filename: filename, cellDates:true, cellStyles:true}),
		objQCell = this;
		//console.log(info);
		//console.log(mergeInfo);
		//console.log(properties);
		
		var html = QBOX.$.parseHTML(wbout, true),
		$html = QBOX.$(html),
		title = '', table = '', i, trzi,nHeaderRows = this.attr('headerrows');
		
		$html.each(function() {
			if(QBOX.$(this).is('title')){
				QBOX.$(this).text(filename.replace('.html', '')); // title 입력
				title = QBOX.$(this);
			}
			else if(QBOX.$(this).is('table')){
				var headerLength = info.header.title.length,
				trz = QBOX.$(this).find('tr'),
				height = objQCell.attr('rowheight'),
				style = info.style,
				tdeach = function (z, tag){
					var row = parseInt(tag.getAttribute('data-row')),jqDTag = QBOX.$(tag);
					if(!QBOX._.isEmpty(style[z]) && !QBOX._.isUndefined(style[z].data)){
						jqDTag.css(style[z].data.css);
					}

					jqDTag.css(objQCell.getCellStyle(row, z));
					
					jqDTag.css('width', info.widths[z]);
					jqDTag.css('height', height.data);
				},
				theach = function (z, tag){
					/*
					var tag = tag.outerHTML;	
					tag = tag.replace('<td', '<th');
					tag = tag.replace('/td>', '/th>');
					*/
					var row = parseInt(tag.getAttribute('data-row')),jqTag = QBOX.$(tag);
					jqTag.removeAttr("style");
					jqTag.addClass('rt-qc-header rt-qc-th');
					if(!QBOX._.isEmpty(style[z]) && !QBOX._.isUndefined(style[z].header)){
						jqTag.css(style[z].header.css);
					}

					jqTag.css(objQCell.getCellStyle(row, z));
					jqTag.css('height', height.header);
					jqTag.css('width', info.widths[z]);
				};
				
				for(i = 0; i < trz.length; i++){
					trzi = QBOX.$(trz[i]);
					QBOX.$(trzi).children('td').each(tdeach);
				}
				for(i = 0; i < headerLength; i++){
					trzi = QBOX.$(trz[i]);
					trzi.removeClass('rt-qc-cell');
					//trzi.addClass('rt-qc-header');
					QBOX.$(trzi).children('td').each(theach);
				}
				table = QBOX.$(this);
			}
		});
		
		var title_text = title.html(),
		title_stidx = wbout.indexOf('<title>'),
		title_edidx = wbout.indexOf('</title>'),
		title_st = wbout.substring(0, title_stidx + 7),
		title_ed = wbout.substring(title_edidx);
		wbout = title_st.concat(title_text, title_ed); //header 문자 교체
		
		var table_text = table.html(),
		table_stidx = wbout.indexOf('<table'),
		table_edidx = wbout.indexOf('</table>'),
		table_st = wbout.substring(0, table_stidx + 53),
		table_ed = wbout.substring(table_edidx);
		wbout = table_st.concat(table_text, table_ed); //table 문자 교체
		
		var style = '<style>';
		style += 'body{font-family: NanumGothic, Dotum, sans-serif !important; background-color: #fff;} ';
		style += '.rt-qc-table, .rt-qc-cell {border-width: 1px; border-style: solid; border-color: #d3d5df; border-collapse: collapse; background-color: #fff;} ';
		style += '.rt-qc-table {border-spacing: 0px; } ';
		style += '.rt-qc-cell {padding: 0px; border-spacing: 0px; font-family: NanumGothic, Dotum, sans-serif !important; } ';
		style += '.rt-qc-header {text-align: center; font-weight: bold; background-color: #7b7d87; border-color: #93959f; color: #fff;} ';
		style += '.rt-qc-cell {font-size: 13px; } ';
		style += '</style>';
		
		var hIdx = wbout.indexOf('</head>'),
		st = wbout.substring(0, hIdx),
		ed = wbout.substring(hIdx);
		
		wbout = st.concat(style, ed); //style 추가
		
		if(properties.export === true){
			return wbout;
			
		}
		
		saveAs(new Blob([wbout],{type: "text/html"}), filename); //html 파일 출력
		
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._pdfDownload = function(properties) {
	var result = true,
	objQcell = QBOX._.clone(this);
	
	/*
	if( properties.progressui !== undefined && properties.progressui === true ) {
		objQcell._showProgressUI(properties.progressui);
	}
	*/
	
	setTimeout(function(){
		objQcell._showProgressUI(true);
	}, 0);
	
	setTimeout(function(){
		//objQcell._showProgressUI(true);
		if( QBOX.$.browser.msie && QBOX.$.browser.version < 10) { //브라우저가 IE이며 9이하일 때
			result = false;
		} else {
			if(objQcell._pdfDownload_checkRequiredProps(properties) && objQcell._excelDownload_checkValidationOfProps(properties)){
				result = objQcell._pdfDownloadLOC(properties);
			}
			else {
				result = false;
			}
		}
		
		return result;
	}, 300);
};

QBOX.QCELL.BasicQCELL.prototype._pdfDownload_checkRequiredProps = function(properties) {
	var result = true;
	if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
		var arrRequiredProps;
		arrRequiredProps = ["filename"];
		
		for(var i = 0, length = arrRequiredProps.length; i < length; i++ ){
			var key = arrRequiredProps[i];
			if(properties[key] === undefined){
				QBOX.QCELL.log('err', 'QCELL.BasicQCELL._pdfDownload_checkRequiredProps', 'Please check "' + key + '" property.');
				result = false;
				break;
			}
		}
		arrRequiredProps.RT_clear();
		arrRequiredProps = null;
	} else{
		QBOX.QCELL.log('err', 'QCELL.BasicQCELL._pdfDownload_checkRequiredProps', 'Please check first parameter\'s type is "object".');
		result = false;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._pdfDownloadLOC = function(properties) {
	var strAPI = this.attr('id') + '._pdfDownloadLOC';
	var result = true;
	try {
		var fileExt = properties.fileExt !== undefined && properties.fileExt.length !== 0 ? '.'+properties.fileExt : '.pdf',
		filename = properties.filename+fileExt,
		mergeInfo = [], h_mergeInfo = [], d_mergeInfo = [],
		excelInfo = this._exportCellInfo(properties);
		
		var bColMerge = (QBOX._.isUndefined(properties.delColumns) === false || QBOX._.isUndefined(properties.addColumns) === false )? false : true;
		
		if(properties.totaldata !== undefined && QBOX._.isBoolean(properties.totaldata) && properties.totaldata){
			excelInfo.data.data = QBOX._.clone(this.attr('data').input);
		}
		if( properties.headershow !== undefined && QBOX._.isBoolean(properties.headershow) && properties.headershow ) {
			h_mergeInfo = this._excelMerge(excelInfo.header, "header",false);
			d_mergeInfo = this._excelMerge(excelInfo.data, "data",bColMerge);
			mergeInfo = this._unionMergeInfo(excelInfo.header.title.length, h_mergeInfo, d_mergeInfo);
			this._exportToPDF(excelInfo, filename, mergeInfo, properties);
		} else {	
			mergeInfo = this._excelMerge(excelInfo.data, "data",bColMerge);
			this._exportToPDF(excelInfo, filename, mergeInfo, properties);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._exportToPDF = function(info, filename, mergeInfo, properties) {
	var strAPI = this.attr('id') + '._exportToPDF';
	try {
		//console.log($.fn.html2canvas);
		//console.log(QBOX.$.fn.html2canvas);
		//var html2canvas = QBOX.$.fn.html2canvas;
		//console.log(html2canvas);
		
		//html2canvas = require('html2canvas');
		//console.log(html2canvas);
		
		properties.headershow = true; // header data 포함하여 출력
		var wb = this._SetWorkbook(info, mergeInfo, properties),
		wbout = XLSX.write(wb, {charset:'utf-8', bookType:"html", type:'string', filename: filename, cellDates:true, cellStyles:true}),
		objQCell = this;
		//console.log(info);
		//console.log(mergeInfo);
		//console.log(properties);
		
		//console.log(wb);
		//console.log(wbout);
		
		var html = QBOX.$.parseHTML(wbout, true),
		$html = QBOX.$(html),
		title = '', table = '', i, trzi;
		
		$html.each(function() {
			if(QBOX.$(this).is('title')){
				QBOX.$(this).text(filename.replace('.html', '')); // title 입력
				title = QBOX.$(this);
			}
			else if(QBOX.$(this).is('table')){
				var headerLength = info.header.title.length,
				trz = QBOX.$(this).find('tr'),
				height = objQCell.attr('rowheight'),
				style = info.style,
				tdeach = function (z, tag){
					//console.log(z);
					//console.log(tag);
					var row = parseInt(tag.getAttribute('data-row'));
					//console.log(tag);
					//console.log(QBOX.$(tag).text());
					if(!QBOX._.isEmpty(style[z]) && !QBOX._.isUndefined(style[z].data)){
						QBOX.$(tag).css(style[z].data.css);
					}
					QBOX.$(tag).css(objQCell.getCellStyle(row, z));
					
					QBOX.$(tag).css('width', info.widths[z]);
					QBOX.$(tag).css('height', height.data);
				},
				theach = function (z, tag){
					/*
					var tag = tag.outerHTML;	
					tag = tag.replace('<td', '<th');
					tag = tag.replace('/td>', '/th>');
					*/
					var row = parseInt(tag.getAttribute('data-row'));
					QBOX.$(tag).removeAttr("style");
					QBOX.$(tag).addClass('rt-qc-th');
					if(!QBOX._.isEmpty(style[z]) && !QBOX._.isUndefined(style[z].header)){
						QBOX.$(tag).css(style[z].header.css);
					}
					QBOX.$(tag).css(objQCell.getCellStyle(row, z));
					QBOX.$(tag).css('height', height.header);
					QBOX.$(tag).css('width', info.widths[z]);
				};
				
				for(i = 0; i < trz.length; i++){
					trzi = QBOX.$(trz[i]);
					QBOX.$(trzi).children('td').each(tdeach);
				}
				for(i = 0; i < headerLength; i++){
					trzi = QBOX.$(trz[i]);
					trzi.addClass('rt-qc-header');
					
					QBOX.$(trzi).children('td').each(theach);
				}
				table = QBOX.$(this);
			}
		});
		
		var title_text = title.html(),
		title_stidx = wbout.indexOf('<title>'),
		title_edidx = wbout.indexOf('</title>'),
		title_st = wbout.substring(0, title_stidx + 7),
		title_ed = wbout.substring(title_edidx);
		wbout = title_st.concat(title_text, title_ed); //header 문자 교체
		
		var table_text = table.html(),
		table_stidx = wbout.indexOf('<table'),
		table_edidx = wbout.indexOf('</table>'),
		table_st = wbout.substring(0, table_stidx + 53),
		table_ed = wbout.substring(table_edidx);
		wbout = table_st.concat(table_text, table_ed); //table 문자 교체
		
		var style = '<style>';
		style += 'html, body{ background: #fff; background-color: #fff; margin: 0; padding: 0;}';
		style += 'body{font-family: NanumGothic, Dotum, sans-serif !important;} ';
		style += '.rt-qc-table {margin: auto; } ';
		style += '.rt-qc-table, .rt-qc-cell {border-width: 1px; border-style: solid; border-color: #d3d5df; border-collapse: collapse;} ';
		style += '.rt-qc-table {border-spacing: 0px; } ';
		style += '.rt-qc-cell {padding: 0px; border-spacing: 0px; font-family: NanumGothic, Dotum, sans-serif !important; } ';
		style += '.rt-qc-header {text-align: center; font-weight: bold; background-color: #7b7d87; border-color: #93959f; color: #ffffff;} ';
		style += '.rt-qc-cell {font-size: 13px;} ';
		style += '.rt-qc-td {background-color: #fff; color: #000; } ';
		style += '.rt-qc-th {background-color: #7b7d87 !important; color: #fff !important;} ';
		style += '</style>';
		
		var hIdx = wbout.indexOf('</head>'),
		st = wbout.substring(0, hIdx),
		ed = wbout.substring(hIdx);
		
		wbout = st.concat(style, ed); //style 추가
		
		var qc_table = QBOX.$(wbout).filter('#rt-qc-tbl');
		var $div = QBOX.$('<div id="editor"></div>');
		$div.css({display: 'none'});
		$div.append(qc_table);
		QBOX.$(document.body).append($div);
		
		var iframeId = "rt-qc-ifrm";
		var iframe = document.createElement('iframe');
		iframe.setAttribute("frameborder", "0");
		iframe.style.width = "100%";
		iframe.style.height = "100%";
		iframe.style.visibility = 'hidden';
		iframe.id = iframeId;
		document.body.appendChild(iframe);
		
		var ifrm = document.getElementById(iframeId);
		ifrm = ifrm.contentWindow || ifrm.contentDocument.document || ifrm.contentDocument;
		ifrm.document.open();
		ifrm.document.write(wbout);
		ifrm.document.close();
		
		QBOX.$('#'+iframeId).load(function(){
			html2canvas(QBOX.$('#'+iframeId).contents().find('body'),{
			    scale: 3, // Adjusts your resolution
				//backgroundColor: '#fff',
			    //background :'#fff',
			    allowTaint: false,
	            logging: false,
	            background:'#fff',
				onrendered: function(canvas){
					//console.log(canvas);
					//canvas.style.backgroundColor = '#fff';
					canvas.style.background = '#FFFFFF';
					
					// 캔버스를 이미지로 변환
					var imgData = canvas.toDataURL('image/jpeg', 1.0);
					//var imgData = canvas.toDataURL('image/jpeg');
					
					var imgWidth = 210; // 이미지 가로 길이(mm) A4 기준
					//var imgWidth = 145; // 이미지 가로 길이(mm) A4 기준
					var pageHeight = imgWidth * 1.414;  // 출력 페이지 세로 길이 계산 A4 기준
					var imgHeight = canvas.height * imgWidth / canvas.width;
					//var imgHeight = 700;
					var heightLeft = imgHeight;
					
					//var doc = new jsPDF('p', 'mm');
					var doc = new jsPDF({
						orientation: 'p',
						unit: 'mm',
						format: 'a4',
						compress: true
					});
					var position = 0;
					
					//console.log('imgData');
					//console.log(imgData);
					
					doc.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight, '', 'FAST');
					heightLeft -= pageHeight;
					
					// 한 페이지 이상일 경우 루프 돌면서 출력
					while (heightLeft >= 20) {
						position = heightLeft - imgHeight;
						doc.addPage();
						doc.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight, '', 'FAST');
						heightLeft -= pageHeight;
					}
					doc.save(filename);
		            
					setTimeout(function(){
				    	QBOX.$($div).remove();
				    	QBOX.$('#'+iframeId).remove();
				    }, 1000);
				}
			});
		});
		
		result = true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		result = false;
	} finally {
		this._showProgressUI(false);
	}
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._txtDownload = function(properties) {
	var result = true,
	objQcell = QBOX._.clone(this);
	
	/*
	if( properties.progressui !== undefined && properties.progressui === true ) {
		objQcell._showProgressUI(properties.progressui);
	}
	*/
	
	setTimeout(function(){
		objQcell._showProgressUI(true);
	}, 0);
	
	setTimeout(function(){
		//objQcell._showProgressUI(true);
		if( QBOX.$.browser.msie && QBOX.$.browser.version < 10) { //브라우저가 IE이며 9이하일 때
			result = false;
		} else {
			if(objQcell._txtDownload_checkRequiredProps(properties) ){
				result = objQcell._txtDownloadLOC(properties);
			}
			else {
				result = false;
			}
		}
		
		return result;
	}, 300);
};

QBOX.QCELL.BasicQCELL.prototype._txtDownload_checkRequiredProps = function(properties) {
	var result = true;
	if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
		var arrRequiredProps;
		arrRequiredProps = ["filename"];
		
		for(var i = 0, length = arrRequiredProps.length; i < length; i++ ){
			var key = arrRequiredProps[i];
			if(properties[key] === undefined){
				QBOX.QCELL.log('err', 'QCELL.BasicQCELL._txtDownload_checkRequiredProps', 'Please check "' + key + '" property.');
				result = false;
				break;
			}
		}
		arrRequiredProps.RT_clear();
		arrRequiredProps = null;
	} else{
		QBOX.QCELL.log('err', 'QCELL.BasicQCELL._txtDownload_checkRequiredProps', 'Please check first parameter\'s type is "object".');
		result = false;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._txtDownloadLOC = function(properties) {
	var strAPI = this.attr('id') + '._txtDownloadLOC';
	var result = true;
	try {
		var fileExt = properties.fileExt !== undefined && properties.fileExt.length !== 0 ? '.'+properties.fileExt : '.txt',
		filename = properties.filename+fileExt,strColSep = properties.colsep === undefined? ',' : properties.colsep,
				strRowSep = properties.rowsep === undefined ? '\n' : properties.rowsep,
			bHeaderShow = properties.headershow === undefined ? false : properties.headershow,
				bLabel = properties.label === undefined ? false : properties.label,
						arrAddCols = properties.addColumns;
		
		var strTxt = '',i,j,objAddCol,strAdd,x,strRow = '';
		
		if(bHeaderShow){
			for( i= 0; i<this.getRows('header') ; i++){
				strRow = '';
				if(properties.usesequence === true){
					var strTitle = properties.sequencetitle === undefined ? ' ' :properties.sequencetitle; 
					strRow += strTitle ;
				}				
				for ( j=this.getCols('header') ; j <this.getCols();j++){

					if(arrAddCols !== undefined && QBOX._.isArray(arrAddCols)){
						strAdd = '';
						for( x=0;x<arrAddCols.length;x++){
							objAddCol = arrAddCols[x];							
							
							if(j === Number(objAddCol.position)){
								if(strRow !== '')
									strRow += strColSep;
								
								strAdd += objAddCol.title[i];
								break;
							}
						}
						
						strRow += strAdd;
					}
					if(strRow !== ''){
						strRow += strColSep;
					}
					strRow += this._cellValue(i,j);
				}

				if(arrAddCols !== undefined && QBOX._.isArray(arrAddCols)){
					strAdd = '';
					for( x=0;x<arrAddCols.length;x++){
						objAddCol = arrAddCols[x];							
						
						if(this.getCols() === Number(objAddCol.position)){
							if(strRow !== '')
								strRow += strColSep;
							
							strAdd += objAddCol.title[i];
						}
					}
					
					strRow += strAdd;
				}				
				
				
				strTxt += strRow;
				
				if(strTxt !== ''){
					strTxt += strRowSep;
				} 				
			}
		}
		for( i=this.getRows('header') ; i<this.getRows() ; i++){
			strRow = '';
			var objRowData = this.getRowData(i);
			if(properties.usesequence === true){
				if(objRowData.rt_qc_fbrd === true)
					strRow += objRowData.rt_qc_seq === undefined ? ' ': objRowData.rt_qc_seq;
				else
					strRow += i ;
			}			
			for ( j=this.getCols('header') ; j <this.getCols();j++){
				
				if(arrAddCols !== undefined && QBOX._.isArray(arrAddCols)){
					strAdd = '';
					for( x=0;x<arrAddCols.length;x++){
						objAddCol = arrAddCols[x];							
						
						if(j === Number(objAddCol.position)){
							if(strRow !== '')
								strRow += strColSep;
							
							strAdd += this.getCellDataEx(i,objAddCol.key) === undefined? '' : this.getCellDataEx(i,objAddCol.key) ;
							break;
						}
					}
					
					strRow += strAdd;
				}				
				
				if(strRow !== ''){
					strRow += strColSep;
				}
				if(objRowData.rt_qc_fbrd === true){
					var strData = this.getCellData(i,j) === undefined ? '' : this.getCellData(i,j) ;
					strRow +=strData;
					
				}else{
					if(properties.usehtmltype === true && this._getColType(j) === 'html'){
						var objCol = this._getQCellCol(j),heColHtml = this._getColHtml(j),strValue;
						
						strValue = this._cellValue(i,j);
						strValue = this._showDataFormat(i,j, strValue);
						
						if(  QBOX._.isFunction(heColHtml.data) ) {
							var vData = heColHtml.data(this, i , j, QBOX._.isUndefined(strValue) === true ? '' : strValue, this.getRowData(i,j),true);
							if( QBOX._.isString(vData) ) {
								strRow += vData;							
							}else{
								strRow += ' ';
							}
						} else {
							strRow += strValue;
						}
					}else{
						if(bLabel === true){
							strRow += this._getCellLabel(i,j) === undefined? '' : this._getCellLabel(i,j);
						}else{
							strRow += this.getCellData(i,j) === undefined ? '' :this.getCellData(i,j);
						}
						
					}				
					
				}
				
			}
			
			if(arrAddCols !== undefined && QBOX._.isArray(arrAddCols)){
				strAdd = '';
				for( x=0;x<arrAddCols.length;x++){
					objAddCol = arrAddCols[x];							
					
					if(this.getCols() === Number(objAddCol.position)){
						if(strRow !== '')
							strRow += strColSep;
						
						strAdd += this.getCellDataEx(i,objAddCol.key) === undefined ? '' :this.getCellDataEx(i,objAddCol.key);
					}
				}
				
				strRow += strAdd;
			}				
			
			strTxt += strRow;
			
			if(strTxt !== ''){
				strTxt += strRowSep;
			} 
		}
		
		
		saveAs(new Blob([strTxt],{type: "text/txt"}), filename); //html 파일 출력
		
		this._showProgressUI(false);
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};
QBOX.QCELL.BasicQCELL.prototype._createDataIndexPool = function(){
	var objQCell = this,
	arrFilterColumns = QBOX._.filter(QBOX._.range(0, this.attr('cols')), function(nCol){
		return objQCell._getQCellCol(nCol).attr('filter');
	});
	
	if(arrFilterColumns.length > 0){
		this._createDataIndex(arrFilterColumns);
	}
	
	if(this.attr('additionaldataindex') !== null){
		this._createDataIndexEx(this.attr('additionaldataindex'));
	}	
};

QBOX.QCELL.BasicQCELL.prototype._createDataIndex = function(arrTargetCols){
	var arrOriginData = this.attr('data').input,
	arrColIDs = this.attr('colids'),
	arrColKeys = this.attr('colkeys'),
	htDataIndexPool = this.attr('dataindexpool'),THAT = this;
	/*
	 * 색인 구조
		Hashtable<string, Hashtable<mixed, HashSet<number>>>
		
		{
			'col_1' : {
						'전체' : [1,5,7,8....],
						'관광업': [2,3,10....]
			}
		}
	*/
	
	QBOX._.each(arrTargetCols, function(nCol){
		var strColID = arrColIDs[nCol],
		strColKey = arrColKeys[nCol],
		htTemp;
		if(THAT._getQCellCol(Number(nCol)).attr('datatype') !== 'string')
			return;
		
		if(htDataIndexPool.containsKey(strColID)){
			htTemp = htDataIndexPool.get(strColID);
			htTemp.clear();
		} else{
			htTemp = new _QHashtable();
			htDataIndexPool.put(strColID, htTemp);
		}
		
		QBOX._.each(arrOriginData, function(objRowData, idx){
			var cellData = objRowData[strColKey];
			
			if(cellData === undefined || cellData === null){
				cellData = '';
			}
			
			if(htTemp.containsKey(cellData) === false){
				htTemp.put(cellData, new _QHashSet());
			}
			
			htTemp.get(cellData).add(idx);
		});
	});
};

QBOX.QCELL.BasicQCELL.prototype._createDataIndexEx = function(arrTargetCols){
	var arrOriginData = this.attr('data').input,
	htDataIndexPool = this.attr('dataindexpool'),THAT = this;
	/*
	 * 색인 구조
		Hashtable<string, Hashtable<mixed, HashSet<number>>>
		
		{
			'col_1' : {
						'전체' : [1,5,7,8....],
						'관광업': [2,3,10....]
			}
		}
	*/
	var nIndex = 0;
	QBOX._.each(arrTargetCols, function(nCol){
		var strColID = arrTargetCols[nIndex],
		strColKey = arrTargetCols[nIndex],
		htTemp;
		
		nIndex++;
		
		if(htDataIndexPool.containsKey(strColID)){
			htTemp = htDataIndexPool.get(strColID);
			htTemp.clear();
		} else{
			htTemp = new _QHashtable();
			htDataIndexPool.put(strColID, htTemp);
		}
		
		QBOX._.each(arrOriginData, function(objRowData, idx){
			var cellData = objRowData[strColKey];
			
			if(cellData === undefined || cellData === null){
				cellData = '';
			}
			
			if(htTemp.containsKey(cellData) === false){
				htTemp.put(cellData, new _QHashSet());
			}
			
			htTemp.get(cellData).add(idx);
		});
	});
};
QBOX.QCELL.BasicQCELL.prototype._getColFillteredEx = function(nCol){
	if(QBOX._.isNumber(nCol))
		return this._getColFilltered(nCol);
	
	var htPrev = this.attr('_filterprev');
	
	if(htPrev === null){
		htPrev = new _QHashtable();
		this.attr('_filterprev' , htPrev , 'object');
	}
	
	if(htPrev.get(nCol) === null){
		var arr = this.attr('additionaldataindex');
		
		if(arr === undefined || arr === null)
			return;
		
		for(var i=0 ; i< arr.length ; i++){
			if( arr[i] === nCol){
				htPrev.put(nCol,{});
				break;
			}
		}
	}
	
	return htPrev.get(nCol);
	
};
QBOX.QCELL.BasicQCELL.prototype._setColFillteredEx = function(nCol,objFilter){
	if(QBOX._.isNumber(nCol)){
		this._setColFilltered(nCol,objFilter);
	}else{
		var htPrev = this.attr('_filterprev');
		
		if(htPrev === null){
			htPrev = new _QHashtable();
			this.attr('_filterprev' , htPrev , 'object');
		}		
		
		htPrev.put(nCol, objFilter);
	}
	
};
QBOX.QCELL.BasicQCELL.prototype._resetFilter = function(col){
	if(col === undefined){
		var nHeaderCols = this.attr('headercols'),nCols = this.attr('cols'),i,
			htPrev = this.attr('_filterprev'),arrKeys = htPrev !== null ? htPrev.keys() : [];
		
		
		
		for(i=nHeaderCols; i< nCols ; i++){
			if(this._getColFillteredEx(i)){
				this._setColFillteredEx(i,null);
			}
		}
		
		for(i=0; i < arrKeys.length; i++){
			this._setColFillteredEx(arrKeys[i],null);
		}
		this._doFiltering();	
		
		return true;
		
	}else if(this._getColFillteredEx(col)){
		this._setColFillteredEx(col,null);	
		this._doFiltering();			
		return true;
	}
	return false;
};
QBOX.QCELL.BasicQCELL.prototype._isUserFilter = function(col,values){
	var bRet = false, bCheck = false;
	if(QBOX._.isString(col)){
		if(QBOX._.isArray(values)){
			if(values.length === 0)
				return 0;
			for(var i=0; i<values.length;i++){
				if(!QBOX._.isString(values[i]))
					return 0;
			}
			return 1;
			
		}else if(QBOX._.isObject(values)){
			if(values.key1 !==undefined && values.op1 !==undefined)
				return -1;
			if(values.value1 === undefined && values.comparison1 === undefined){
				for(var strKey in values){
					bCheck = true;
				}
				if(bCheck === true)
					return 1;
				
				return 0;
			}
			
			if(values.value1 === undefined)
				return 0;
			if(values.comparison1 === undefined)
				return 0;
			
			return -1;
		}

	}
	return 0;
};
QBOX.QCELL.BasicQCELL.prototype._filter = function(col,values){	
	var obj = {},i;
	if(this._getColFillteredEx(col)){
		if((QBOX._.isNumber(col) && this._getQCellCol(col).attr('datatype') === 'string') || this._isUserFilter(col,values) === 1){
			var strColId = QBOX._.isString(col) ? col : this._getColID(col);
			var objFilter = this.attr('dataindexpool').get(strColId);
			
			for(i=0; i< values.length;i++){
				if(!QBOX._.isString(values[i]))
						return false;
				
				//if(objFilter.containsKey(values[i]) === false)
				//	return false;
				
				obj[values[i]] = true;
			}
			
			this._setColFillteredEx(col,obj);
			this._doFiltering();			
			return true;			
		}else{
			if(QBOX._.isObject(values)){
				if(values.value1 === undefined)
					return false;
				if(values.comparison1 === undefined)
					return false;
				
				switch(values.comparison1){
				case '>' : 	case '<' :	case '>=' :	case '<=' :	case '==' :	case '!=' :
					break;
				default : return false;
				}				
				
				if(values.logical !== undefined){
					if(values.logical === 'and' || values.logical ==='or'){
						if(values.value2 === undefined)
							return false;
						if(values.comparison2 === undefined)
							return false;	
						
						switch(values.comparison2){
						case '>' : 	case '<' :	case '>=' :	case '<=' :	case '==' :	case '!=' :
							break;
						default : return false;
						}							
						obj.key1 = values.value1;
						obj.op1 = values.comparison1;
						obj.logical = values.logical;
						obj.key2 = values.value2;
						obj.op2 = values.comparison2;
					}else{
						return false;						
					}

					
				}else{
					obj.key1 = values.value1;
					obj.op1 = values.comparison1;
				}
				
				this._setColFillteredEx(col,obj);
				this._doFiltering();			
				return true;							
				
			}			
		}
		

	}
	
	return false;
};
QBOX.QCELL.BasicQCELL.prototype._doFiltering = function(){
	var htDataIndexPool = this.attr('dataindexpool');
	var nCols = this.attr('cols'), nHeaderCols = this.attr('headercols'),nHeaderRows = this.attr('headerrows'),strKey;
	
	var objResult = {},objFilter,nIndex = 0;
	var arrNewData = [];
	var arrIcon = [],i;
	var objPaginationInfo;
	this.attr('_filtering',false,'boolean');
//	if(htDataIndexPool.size() > 0){
		for(i=nHeaderCols ; i< nCols;i++){
			if(this._getQCellCol(i).attr('datatype') === 'string'){
				objFilter = this._getColFilltered(i);
				if(objFilter !== null){
					this._setColStringFilter(i,objFilter,objResult);
					arrIcon.push({'col': i, 'state' : true});
					nIndex++;
				}else{
					arrIcon.push({'col': i, 'state' : false});
				}
			}else{
				objFilter = this._getColFilltered(i);
				if(objFilter !== null){
					this._setColNumberFilter(i,objFilter,objResult);
					nIndex++;
					arrIcon.push({'col': i, 'state' : true});
				}else{
					arrIcon.push({'col': i, 'state' : false});
				}				
			}
		}
		var htPrev = this.attr('_filterprev'),arrKeys = htPrev !== null ? htPrev.keys() : [];
		
		for(i=0; i < arrKeys.length; i++){
			var ob = this._getColFillteredEx(arrKeys[i]);
			if(this._isUserFilter(arrKeys[i],ob) === 1){
				this._setColStringFilter(arrKeys[i],ob,objResult);
				nIndex++;
			}else if(this._isUserFilter(arrKeys[i],ob) === -1){
				this._setColNumberFilter(arrKeys[i],ob,objResult);
				nIndex++;				
			}
		}
		 
		
		if(nIndex){
			var arrOrignData = this.attr('data').input;
			for(strKey in objResult){
				if(objResult[strKey] === nIndex){
					var objRowData = arrOrignData[Number(strKey)];
					if(objRowData === undefined){
						continue;
					}
					objRowData = QBOX._.clone(objRowData);
					arrNewData.push(objRowData);
				}
			}
			
			this._setCurrentData(arrNewData,true);
			
			this.attr('_filtering',true,'boolean');
			
			if(QBOX._.isEmpty(this.attr('paginationinfo')) === false){
				objPaginationInfo = this.attr('paginationinfo');
				if(objPaginationInfo !== undefined && QBOX._.isObject(objPaginationInfo)){
					objPaginationInfo.currentData = arrNewData;
					this._movePage(1);					
				}
			}
		}else{
			if(QBOX._.isEmpty(this.attr('paginationinfo')) === false){
				objPaginationInfo = this.attr('paginationinfo');
				if(objPaginationInfo !== undefined && QBOX._.isObject(objPaginationInfo)){
					objPaginationInfo.currentData = [];
				}

			}
			this._setData(this.attr('data').input);
		}	
		
		for(i=0;i<arrIcon.length;i++){
			this._changeFilterIcon(arrIcon[i].col, arrIcon[i].state );
		}
		
		if(this.attr('hierachystate').grouped === true){
			this._setHierachy(this.attr('_heirachyinfo'));
		}

//	}	
	
};
QBOX.QCELL.BasicQCELL.prototype._changeFilterIcon = function(nTargetCol,bAdjust){
	if(this._getQCellCol(nTargetCol).attr('filter')){
		var css = QBOX.QCELL.def.css;
		var htCell = this._getCellDOM(this.attr('headerrows') - 1, nTargetCol );
		
		if(htCell === null || htCell === undefined)
			return;
		var jqFilterarea = this._getQCellCol(nTargetCol).attr('colfilterarea');	
		
		if(jqFilterarea === null){
			this._getQCellCol(nTargetCol).attr('colfilterarea', this.attr('filterarea').clone(true), 'jquery');
			jqFilterarea = this._getQCellCol(nTargetCol).attr('colfilterarea');	
		}
		
		if(jqFilterarea.hasClass(css.FILTER_AREA_ADJUST) && bAdjust)
			return;
		
		if(jqFilterarea.hasClass(css.FILTER_AREA) && bAdjust === false)
			return;

		
		if(bAdjust){
			jqFilterarea.removeClass(css.FILTER_AREA).removeClass(css.FILTER_AREA_ADJUST);
			jqFilterarea.addClass(css.FILTER_AREA_ADJUST);
		}else{		
			jqFilterarea.removeClass(css.FILTER_AREA).removeClass(css.FILTER_AREA_ADJUST);
			jqFilterarea.addClass(css.FILTER_AREA);
		}
		
	}
};
QBOX.QCELL.BasicQCELL.prototype._setColStringFilter = function(nTargetCol,objFilter,objResult){
	var strKey,THAT = this, arrResult = [],objTemp ={};
	QBOX._.each(objFilter,function(bValue,strKey){
		if(bValue === false)
			return;
		var strColId = QBOX._.isString(nTargetCol) === true ?  nTargetCol :THAT._getColID(nTargetCol); 
		var ht = THAT.attr('dataindexpool').get(strColId).get(strKey);
		
		if(ht !== null){
			arrResult = ht.values(true);
		
			arrResult.forEach(function(x){
				objTemp[x.toString()] = 1;
			});					
		}
	});
	
	for(strKey in objTemp){
		objResult[strKey] =objResult[strKey] === undefined ? 1 : objResult[strKey] +1;  
	}
	
};

QBOX.QCELL.BasicQCELL.prototype._setColNumberFilter = function(nTargetCol,objFilter,objResult){
	var strKey,THAT = this, arrResult = [],objTemp ={};
	var objTempResult = {};
	
	this._processNumberFilter(nTargetCol,objFilter.key1, objFilter.op1,objTempResult);
	
	if(objFilter.logical === undefined){
		objTemp = objTempResult;
	}else{
		this._processNumberFilter(nTargetCol,objFilter.key2, objFilter.op2,objTempResult);
		
		if(objFilter.logical === 'and'){
			for( strKey in objTempResult ){
				if(objTempResult[strKey] >1)
					objTemp[strKey] = 1;
			}
		}else{
			for( strKey in objTempResult ){
				objTemp[strKey] = 1;
			}			
			
		}
	}
	
	
	for(strKey in objTemp){
		objResult[strKey] =objResult[strKey] === undefined ? 1 : objResult[strKey] +1;  
	}
};
QBOX.QCELL.BasicQCELL.prototype._processNumberFilter = function(nTargetCol,nValue, strOp, objResult){
	var strKey = QBOX._.isString(nTargetCol) === true ? nTargetCol : this._getKeyOfCol(nTargetCol),
	i, arrData = this.attr('data').input,rowData;
	
	for(i=0; i< arrData.length; i++){
		rowData = arrData[i];
		if(rowData[strKey] === undefined || rowData[strKey] === null || isNaN(rowData[strKey]))
			continue;
		
		switch(strOp){
			case '>' : {
				if(rowData[strKey] > nValue ){
					this._makeNumberFilterSub(i,objResult);
				}
				break;
			}
			case '<' : {
				if(rowData[strKey] < nValue ){
					this._makeNumberFilterSub(i,objResult);
				}
				break;
			}
			case '>=' : {
				if(rowData[strKey] >= nValue ){
					this._makeNumberFilterSub(i,objResult);
				}
				break;
			}
			case '<=' : {
				if(rowData[strKey] <= nValue ){
					this._makeNumberFilterSub(i,objResult);
				}
				break;
			}
			case '==' : {
				if(rowData[strKey] === nValue ){
					this._makeNumberFilterSub(i,objResult);
				}
				break;
			}	
			case '!=' : {
				if(rowData[strKey] !== nValue ){
					this._makeNumberFilterSub(i,objResult);
				}
				break;
			}				
		}
	}
};
QBOX.QCELL.BasicQCELL.prototype._makeNumberFilterSub = function(nIndex,objResult){
	var strIndex = nIndex.toString();
	objResult[strIndex] = objResult[strIndex] === undefined ? 1 : objResult[strIndex] + 1;  
};
QBOX.QCELL.BasicQCELL._createFilterAreaSub = function(event){
	var target = event.target,
	objQCell = event.data.target;

	var css = QBOX.QCELL.def.css,
	heFilterArea = objQCell.attr('heFilterDiv').cloneNode(),
	nTargetCol = parseInt(target.parentNode.getAttribute('data-col')),
	$filterUIArea = QBOX.$(objQCell.attr('heFilterDiv').cloneNode()).addClass(css.FILTER_UI_AREA);
	
	if(objQCell.attr('filteruivisible')){
		objQCell._removeFilterUIArea();
	}
	
	if(objQCell._getQCellCol(nTargetCol).attr('datatype') === 'string'){
		objQCell._createStringFilterUI(nTargetCol, $filterUIArea);
	} else{
		objQCell._createNumberFilterUI(nTargetCol, $filterUIArea);
	}
	
	objQCell._showFilterUIArea(target, nTargetCol);	
};
QBOX.QCELL.BasicQCELL.prototype._getFilterArea = function(nCol){
	if(this.attr('filterarea') === null){
		var heDiv = document.createElement('div');
		this.attr('filterarea', this._createFilterArea(heDiv), 'jquery');
		
		//this._createDataIndexPool();//필터 색인 생성
	}
	
	if(this._getQCellCol(nCol).attr('colfilterarea') === null){
		this._getQCellCol(nCol).attr('colfilterarea', this.attr('filterarea').clone(true), 'jquery');
	}
	
	return this._getQCellCol(nCol).attr('colfilterarea').get(0);
};
QBOX.QCELL.BasicQCELL.prototype._createFilterArea = function(heDiv){
	var css = QBOX.QCELL.def.css;
	this.attr('heFilterDiv',heDiv,'element');
	
	return QBOX.$(heDiv.cloneNode()).addClass(css.FILTER_AREA).on('mousedown', this.attr('eventparam'), QBOX.QCELL.BasicQCELL._createFilterAreaSub);
};

QBOX.QCELL.BasicQCELL.prototype._createStringFilterUI = function(nTargetCol, jqFilterUIArea){
	var css = QBOX.QCELL.def.css,
	$div = QBOX.$(document.createElement('div')),
	$button = QBOX.$(document.createElement('button')).addClass(css.FILTER_UI_BTN),
	$span = QBOX.$(document.createElement('span')),
	$titleArea, $gridArea, $buttonArea, 
	strTitle = this.attr('headertext')[nTargetCol][this.attr('headertext')[nTargetCol].length - 1];
	
	jqFilterUIArea.css({
		'display'	: 'none',
		'height'	: '290px'
	});
	
	/* 상단 제목 영역 start */
	$titleArea = $div.clone();
	$titleArea.addClass(css.FILTER_TITLE_AREA);
	
	$span.clone().text(strTitle).addClass(css.FILTER_TITLE_SPAN).appendTo($titleArea);
	
	$div.clone().addClass(css.FILTER_UI_CLOSE).on('click', this.attr('eventparam'), function(event){
		var objQCell = event.data.target;
		
		if(objQCell.attr('filteruivisible')){
			objQCell._removeFilterUIArea();
		}
	}).appendTo($titleArea);
	
	$titleArea.appendTo(jqFilterUIArea);
	/* 상단 제목 영역 end */
	
	/* 그리드 영역 start */
	$gridArea = $div.clone().attr({
		'id'	: 'filter-dataindex-' + this.attr('id')
	}).css({
		'width'	: '228px',
		'height': '210px'
	});
	
	$gridArea.appendTo(jqFilterUIArea);
	/* 그리드 영역 end */
	
	/* 하단 버튼 영역 start */
	$buttonArea = $div.clone().css({
		'text-align': 'center',
		'margin'	: '10px 0px 0px 0px'
	});
	
	$span.clone().text(QBOX.QCELL.def.resource.adjust).appendTo($button.clone().css({'background-color': '#949598', 'border': '1px solid #949598'}).on('click', this.attr('eventparam'), function(event){
		var objQCell = event.data.target,
		dataindexQCell = QCELL.getInstance('filter-dataindex'),
		arrTemp = [], i, j;
		
		var objFilter = {};
		
		for(i = 1; i < dataindexQCell.attr('rows'); i++){
			if(dataindexQCell._cellValue(i,0)){
				arrTemp.push(dataindexQCell._cellValue(i,1));
				objFilter[dataindexQCell._cellValue(i,1)] = true;
			}else{
				objFilter[dataindexQCell._cellValue(i,1)] = false;
			}
		}
		
		objQCell._setColFilltered(nTargetCol,objFilter);
		
		objQCell._removeFilterUIArea();
		//objQCell._changeFilterIcon(nTargetCol,true);
		objQCell._doFiltering();
		
	}).appendTo($buttonArea));
	$span.clone().text(QBOX.QCELL.def.resource.reset).appendTo($button.clone().css({'background-color': '#3b99fc', 'border': '1px solid #3b99fc'}).on('click', this.attr('eventparam'), function(event){
		var objQCell = event.data.target;
		
		objQCell._setColFilltered(nTargetCol,null);		
		objQCell._removeFilterUIArea();
		//objQCell._changeFilterIcon(nTargetCol,false);
		objQCell._doFiltering();
		
	}).appendTo($buttonArea));
	
	$buttonArea.appendTo(jqFilterUIArea);
	/* 하단 버튼 영역 end */
	
	this.attr('filteruiarea', jqFilterUIArea, 'jquery');
};



QBOX.QCELL.BasicQCELL.prototype._createNumberFilterUI = function(nTargetCol, jqFilterUIArea){
	var css = QBOX.QCELL.def.css,
	$div = QBOX.$(document.createElement('div')),
	$button = QBOX.$(document.createElement('button')).addClass(css.FILTER_UI_BTN),
	$span = QBOX.$(document.createElement('span')),
	$select = QBOX.$(document.createElement('select')),
	$option = QBOX.$(document.createElement('option')),
	$input = QBOX.$(document.createElement('input')),
	$titleArea, $inputArea, $inputForm, $radioForm, $buttonArea, 
	strTitle = this.attr('headertext')[nTargetCol][this.attr('headertext')[nTargetCol].length - 1];
	
	var objPrevFilter = this._getColFilltered(nTargetCol);
	
	$input.addClass(css.EXCLUDE_DRAGABLE);
	$select.addClass(css.EXCLUDE_DRAGABLE);
	
	jqFilterUIArea.css({
		'display'	: 'none',
		'width'		: '290px',
		'height'	: '100px'
	});
	
	/* 상단 제목 영역 start */
	$titleArea = $div.clone();
	$titleArea.addClass(css.FILTER_TITLE_AREA);
	
	$span.clone().text(strTitle).addClass(css.FILTER_TITLE_SPAN).appendTo($titleArea);
	
	$div.clone().addClass(css.FILTER_UI_CLOSE + ' ' + css.EXCLUDE_DRAGABLE).on('click', this.attr('eventparam'), function(event){
		var objQCell = event.data.target;
		
		if(objQCell.attr('filteruivisible')){
			objQCell._removeFilterUIArea();
		}
	}).appendTo($titleArea);
	
	$titleArea.appendTo(jqFilterUIArea);
	/* 상단 제목 영역 end */
	
	/* 입력 영역 start */
	$inputArea = $div.clone().attr({
		'id'	: 'filter-input-area-' + this.attr('id')
	});
	
	
	$inputForm = $div.clone().attr({
		'id'	: 'filter-input-form1-' + this.attr('id')
	});
	
	var inputC = 	$input.clone();
	inputC.attr({'id' : 'filter-input1-' + this.attr('id')
		}).css({
		'width'	: '120px',
		'margin': '0px 5px 0px 0px'
	}).appendTo($inputForm);
	
	
	$option.clone().val('>').text('크다(>)').appendTo($select);
	$option.clone().val('<').text('작다(<)').appendTo($select);
	$option.clone().val('>=').text('크거나 같다(>=)').appendTo($select);
	$option.clone().val('<=').text('작거나 같다(<=)').appendTo($select);
	$option.clone().val('==').text('같다(==)').appendTo($select);
	$option.clone().val('!=').text('같지 않다(!=)').appendTo($select);
	
	var selectC = $select.clone();
	selectC.attr({
		'id' : 'filter-select1-' + this.attr('id')
	}).css({
		'height'	: '20px',
		'margin'	: '0px 10px 0px 0px'
	}).appendTo($inputForm);
	
		
	$inputForm.appendTo($inputArea);
		
	var $inputForm3  = $div.clone().attr({
		'id'	: 'filter-input-form2-' + this.attr('id')
	});
	
	
	var $inputC2 = $input.clone();
	
	$inputC2.attr({'id' : 'filter-input2-' + this.attr('id')
	}).css({
	'width'	: '120px',
	'margin': '0px 5px 0px 0px'
	}).appendTo($inputForm3);
	
	var $selectC2 = $select.clone();
	$selectC2.attr({
		'id' : 'filter-select2-' + this.attr('id')
	}).css({
		'height'	: '20px',
		'margin'	: '0px 10px 0px 0px'
	}).appendTo($inputForm3);
	
	jqFilterUIArea.css({
		'height'	: '150px'
	});
	
	$radioForm = $div.clone().attr({
		'id'	: 'filter-radio-form-' + this.attr('id')
	}).css({
		'margin': '5px 0px 5px 0px'
	});
	
	var $radioAnd =	$input.clone();
	$radioAnd.attr({'type': 'radio','name': 'filter-operator-' + this.attr('id'), 'checked': 'checked'}).val('and').appendTo($radioForm);
	$span.clone().text('and').css({'font-size': '12px'}).appendTo($radioForm);
	
	var $radioOr = $input.clone(); 
	$radioOr.attr({'type': 'radio','name': 'filter-operator-' + this.attr('id')}).val('or').appendTo($radioForm);
	$span.clone().text('or').css({'font-size': '12px'}).appendTo($radioForm);	
	
	$radioForm.appendTo($inputArea);
	$inputForm3.appendTo($inputArea);
	
	$inputForm.find('div').remove();
	$inputForm3.find('div').remove();	
	
	var $addOper =$div.clone();
	$addOper.addClass(css.FILTER_UI_ADDOPERATOR).on('click', this.attr('eventparam'), function(event){
		var objQCell = event.data.target;
		
		if(objQCell.attr('isNumberFilterExtened') === true){
			$radioForm.hide();
			$inputForm3.hide();
			
			jqFilterUIArea.css({
				'height'	: '100px'
			});	
			
			objQCell.attr('isNumberFilterExtened',false,'boolean');
			
			$addOper.removeClass(css.FILTER_UI_ADDOPERATOR);
			$addOper.removeClass(css.FILTER_UI_ADDOPERATOR_CLOSE);
			$addOper.addClass(css.FILTER_UI_ADDOPERATOR);
			
		}else{
			$radioForm.show();
			$inputForm3.show();
			
			jqFilterUIArea.css({
				'height'	: '150px'
			});	
			
			objQCell.attr('isNumberFilterExtened',true,'boolean');
			
			$addOper.removeClass(css.FILTER_UI_ADDOPERATOR);
			$addOper.removeClass(css.FILTER_UI_ADDOPERATOR_CLOSE);
			$addOper.addClass(css.FILTER_UI_ADDOPERATOR_CLOSE);			
			
		}
		
	}).appendTo($inputForm);
	
	if(objPrevFilter === null){
		$radioForm.hide();
		$inputForm3.hide();
		
		jqFilterUIArea.css({
			'height'	: '100px'
		});
		
	}else if(objPrevFilter !== null){
		inputC.val(objPrevFilter.key1);
		selectC.val(objPrevFilter.op1);
		
		if(objPrevFilter.logical !== undefined){
			$inputC2.val(objPrevFilter.key2);
			$selectC2.val(objPrevFilter.op2);
			
			if(objPrevFilter.logical === 'and')
				$radioAnd.prop("checked", true);
			else
				$radioOr.prop("checked", true);
			
			$addOper.removeClass(css.FILTER_UI_ADDOPERATOR).addClass(css.FILTER_UI_ADDOPERATOR_CLOSE);
			this.attr('isNumberFilterExtened',true,'boolean');
		}else{
			$radioForm.hide();
			$inputForm3.hide();
			
			jqFilterUIArea.css({
				'height'	: '100px'
			});	
			this.attr('isNumberFilterExtened',false,'boolean');
		}
	}

	$inputArea.appendTo(jqFilterUIArea);
	/* 입력 영역 end */
	
	/* 하단 버튼 영역 start */
	$buttonArea = $div.clone().css({
		'text-align': 'center',
		'margin'	: '10px 0px 0px 0px'
	});
	
	$span.clone().text(QBOX.QCELL.def.resource.adjust).appendTo($button.clone().css({'background-color': '#949598', 'border': '1px solid #949598'}).on('click', this.attr('eventparam'), function(event){
		var objQCell = event.data.target;
		var $value1 = QBOX.$('#filter-input1-' + objQCell.attr('id'));
		var $op1 = QBOX.$('#filter-select1-' + objQCell.attr('id'));
		var $log,$value2,$op2;
		
		if(isNaN(Number($value1.val())) || $value1.val()===''){
			$value1.focus();
			return;
		}
		
		var objFilter = {
			'key1' : Number($value1.val()),
			'op1' : $op1.val()				
		};		
		
		if(objQCell.attr('isNumberFilterExtened') === true){
			$value2 = QBOX.$('#filter-input2-' + objQCell.attr('id'));
			$op2 = QBOX.$('#filter-select2-' + objQCell.attr('id'));
			$log = QBOX.$(':radio[name="filter-operator-' + objQCell.attr('id') + '"]:checked');
			
			if(isNaN(Number($value2.val()))){
				$value2.focus();
				return;
			}
			objFilter.key2 = Number($value2.val());
			objFilter.op2 = $op2.val();
			objFilter.logical = $log.val();
		}
		
		
		objQCell._setColFilltered(nTargetCol,objFilter);		
		objQCell._removeFilterUIArea();
		//objQCell._changeFilterIcon(nTargetCol,true);
		objQCell._doFiltering();	
		
		
	}).appendTo($buttonArea));
	$span.clone().text(QBOX.QCELL.def.resource.reset).appendTo($button.clone().css({'background-color': '#3b99fc', 'border': '1px solid #3b99fc'}).on('click', this.attr('eventparam'), function(event){
		var objQCell = event.data.target;
		
		objQCell._setColFilltered(nTargetCol,null);		
		objQCell._removeFilterUIArea();
		//objQCell._changeFilterIcon(nTargetCol,false);		
		objQCell._doFiltering();		
		
	}).appendTo($buttonArea));
	
	$buttonArea.appendTo(jqFilterUIArea);
	/* 하단 버튼 영역 end */
	
	this.attr('filterinput', inputC, 'jquery');
	this.attr('filteruiarea', jqFilterUIArea, 'jquery');
};

QBOX.QCELL.BasicQCELL.prototype._showFilterUIArea = function(heTarget, nTargetCol){
	var $filterUIArea = this.attr('filteruiarea'),
	nViewportOffsetLeft = this.attr('layoutsize').viewport.offsetLeft,
	nTargetLeft = heTarget.parentNode.offsetLeft + nViewportOffsetLeft,//colMoveLine이 viewport가 아닌 container에 들어가 있으므로 container기준으로 left값을 구해야 한다.
	nTargetColWidth = this._getColWidth(nTargetCol),
	nTargetTop = heTarget.parentNode.offsetTop + 8;
	
	$filterUIArea.appendTo(this.attr('elementpool').get('container'));
	$filterUIArea.prop("id",this.attr('id')+'_filterPopup');
	QBOX.util._dragElement(this.attr('id')+'_filterPopup');
	
	if($filterUIArea.css('display') === 'none'){
		$filterUIArea.css('display', 'block');
	}
	
	$filterUIArea.css({
		'left'	: (nTargetLeft + nTargetColWidth - 1) + 'px',
		'top'	: nTargetTop + 'px'
	});
	
	if(this._getQCellCol(nTargetCol).attr('datatype') === 'string'){
		var objTemp, arrIndexData = [];
		
		var objPrev = this._getColFilltered(nTargetCol);
		
		this.attr('dataindexpool').get(this._getColID(nTargetCol)).each(function (key){
			var bCheck = objPrev === null ? true : objPrev[key];
			
			objTemp = {'check' : bCheck , 'indexpool' : key};
			
			arrIndexData.push(objTemp);
		});
		
		var objIndexPoolQCell = QBOX.QCELL.NormalQCELL.create({
			id			: 'filter-dataindex',
			parentid	: 'filter-dataindex-' + this.attr('id'),
			rowheight	: {header : 30, data : 30},
			selectmode	: 'row',
			columns		: [
			       		   {title : [''], key : 'check', width : '15%', type : 'checkbox', options : {wholeselect : true, disabled: false}},
			       		   {title : ['색인목록'], key : 'indexpool', width : '85%'}
			       		   ],
			data		: {'input' : arrIndexData}
		});
		
		objIndexPoolQCell._createCols();
		objIndexPoolQCell._create();
		QBOX.QCELL.storage.put('filter-dataindex', objIndexPoolQCell);
		
		//필터UI창의 그리드 이벤트가 부모 그리드에 전파되지 않도록 처리
		objIndexPoolQCell.bind('mousedown mousewheel DOMMouseScroll mouseenter mouseleave mousemove click dblclick keydown resize onDrag onDrop', function(e){
			e.stopPropagation();
		});
	
	}else{
		var THAT = this;
		
		setTimeout(function(){
			THAT.attr('filterinput').focus();
		},0);
		
		//this.attr('filterinput').focus();
	}
	
	this.attr('filteruivisible', true, 'boolean');
};

QBOX.QCELL.BasicQCELL.prototype._removeFilterUIArea = function(){
	var $filterUIArea = this.attr('filteruiarea');
	
	$filterUIArea.remove();
	
	this.attr('filteruiarea', null, 'jquery');
	
	this.attr('filteruivisible', false, 'boolean');
	
	QBOX.QCELL._deleteInstance('filter-dataindex');
};

QBOX.QCELL.BasicQCELL.prototype._clearFocus = function(){
	this._idx('row', 'focus', 'previous', -1);
	this._idx('col', 'focus', 'previous', -1);
	this._idx('row', 'focus', 'current', -1);
	this._idx('col', 'focus', 'current', -1);
	
	this._clearFocusCSS();
};

QBOX.QCELL.BasicQCELL.prototype._clearFocusCSS = function(){
	var heBeforeFocusCell = this.attr('focuscell');
	if(heBeforeFocusCell === null){
		var nR = this.getIdx('row','focus','previous'),
		nC = this.getIdx('col','focus','previous');
		
		if(nR !== -1 && nC !== -1){
			heBeforeFocusCell = this._getCellDOM(nR,nC);
		}
	}
		
	if(QBOX._.isElement(heBeforeFocusCell)){
		this._removeFocusStyleClass(heBeforeFocusCell);
	}
};

QBOX.QCELL.BasicQCELL.prototype._addFocusStyleClass = function(heCell){
	QBOX.util.addClass(heCell, QBOX.QCELL.def.css.CELL_FOCUS);
	this.attr('focuscell', heCell, 'element');
};

QBOX.QCELL.BasicQCELL.prototype._removeFocusStyleClass = function(heCell){
	QBOX.util.removeClass(heCell, QBOX.QCELL.def.css.CELL_FOCUS);
	this.attr('focuscell', null, 'element');
};

QBOX.QCELL.BasicQCELL.prototype._isFocusRow = function(nRow){
	return nRow === this._idx('row', 'focus', 'current');
};

QBOX.QCELL.BasicQCELL.prototype._isFocusCol = function(nCol){
	return nCol === this._idx('col', 'focus', 'current');
};

QBOX.QCELL.BasicQCELL.prototype._clearGroup = function(){
	//QCELL에 적용된 그룹화 상태를 제거하고 원상태로 복원
	var objGroupState = this.attr('groupstate');

	if(objGroupState.grouped){
		objGroupState.grouped = false;
		objGroupState.showpanel = false;
		objGroupState.type = 'normal';
		objGroupState.data = [];
		objGroupState.columnsinfo.clear();
		objGroupState.nodes.clear();
		objGroupState.treeuirows = [];
		objGroupState.treeuirownodes = [];
		objGroupState.headerrows = [];
		objGroupState.headerrownodes = [];
		objGroupState.footerrows = [];
		objGroupState.footerrownodes = [];
		
		objGroupState.groupuirows = {};
		objGroupState.groupuinodes = {};
		
		objGroupState.expand = null;
		objGroupState.collapse = null;
		
		return this._setCurrentData(this.attr('data').input, false);
	}

	return false;
};

QBOX.QCELL.BasicQCELL.prototype._checkValidationOfGroupProps = function(objGroupProps){
	return QBOX._.has(objGroupProps, 'columns') && QBOX._.isArray(objGroupProps.columns);
};

QBOX.QCELL.BasicQCELL.prototype._setGroup = function(objGroupProps){
	/*
	qcell1._setGroup({
		type: 'tree',	//'normal' or 'tree' or 'step'
		columns: [		//그룹핑 할 컬럼 정보 설정
			{
				key		: 'si',	//그룹핑 할 컬럼의 key값
				expand	: true,	//tree, step 펼침 여부 설정('tree' || 'step' 타입 사용시에만 사용가능한 옵션)
				header	: {	//현재 그룹 레벨의 헤더 행 설정
					//통계함수:
					//childcount(),					//직계 자식노드의 수,ex> 서울특별시에 몇개의 구가 있는지 계산 시 사용
					//count(),						//전체 자식노드의 수,ex> 서울특별시에 몇개의 동이 있는지 계산 시 사용
					//countif(colkey, stdvalue),	//전체 자식노드들 중에서 특정 기준값을 가지는 자식노드의 수, ex> 성별이 남자인 사람의 수만 알고 싶은 경우
					//groupvalue(nLevel)			//그룹 헤더가 그려진 기준이 되는 그룹의 값
					//sum(colkey),					//데이터의 총합
					//average(colkey)				//데이터의 평균값

					"si" 	: ["groupvalue(0)",	"의 Header 행", " 수: ", "countif('cpNm', '강원도')", "건"],
					"gu" 	: ["groupvalue(0)", "에 있는 시군구 수: ", "childcount()", "개"],
					"dong"	: ["groupvalue(0)", "에 있는 읍면동 수: ", "count()", "개"],
					"people": ["groupvalue(0)", "의 총 인구 수: ", "sum()", "명", ", 읍면동 당 평균 인구 수: ", "average()", "명"]
				},
				footer	: {}
			},
			{key	: 'gu'},
			{key	: 'dong'}
		]
	});
	*/
	if(this._checkValidationOfGroupProps(objGroupProps)){

		/*
		this.attr('groupstate', {
			grouped		: false,
			showpanel	: false,
			type		: 'normal',
			data		: [],
			columnsinfo	: new Hashtable(),
			nodes		: new Hashtable(),
			treeuirows		: [],
			treeuirownodes	: [],
			headerrows		: [],
			headerrownodes	: [],
			footerrows		: [],
			footerrownodes	: []
		}, 'object');
		*/
		var objQCell = this,
		objGroupState = this.attr('groupstate'),
		htGroupColumnsInfo = objGroupState.columnsinfo,
		nHeaderCols = this.attr('headercols');
		
		this.attr('_groupProps', QBOX._.clone(objGroupProps),'object');

		objGroupState.grouped = true;
		objGroupState.showpanel = QBOX._.has(objGroupProps, 'showpanel') && QBOX._.isBoolean(objGroupProps.showpanel) ? objGroupProps.showpanel : false;
		objGroupState.hidekeydata = QBOX._.has(objGroupProps, 'hidekeydata') && QBOX._.isBoolean(objGroupProps.hidekeydata) ? objGroupProps.hidekeydata : false;
		objGroupState.type = QBOX._.has(objGroupProps, 'type') && QBOX._.isString(objGroupProps.type) && (objGroupProps.type === 'normal' || objGroupProps.type === 'tree' || objGroupProps.type === 'step' || objGroupProps.type === 'group') ? objGroupProps.type : 'normal';
		
		objGroupState.expand = QBOX._.has(objGroupProps, 'expand') && QBOX._.isFunction(objGroupProps.expand) ? objGroupProps.expand : null ;
		objGroupState.collapse = QBOX._.has(objGroupProps, 'collapse') && QBOX._.isFunction(objGroupProps.collapse) ? objGroupProps.collapse : null ;
		
		objGroupState.presentkey = QBOX._.has(objGroupProps, 'presentkey') && QBOX._.isBoolean(objGroupProps.presentkey) ? true : false;
		objGroupState.leafnodekey = QBOX._.has(objGroupProps, 'leafnodekey') && QBOX._.isString(objGroupProps.leafnodekey) ? objGroupProps.leafnodekey : undefined;
		objGroupState.exclude = objGroupProps.exclude === undefined? [] : objGroupProps.exclude;
		
		if(QBOX._.has(objGroupProps, 'sort') &&  QBOX._.isString(objGroupProps.sort)){
			if(objGroupProps.sort === 'none'){
				objGroupState.sort ='none';				
			}
			else if(objGroupProps.sort === 'asc'){
				objGroupState.sort ='asc';				
			}
			else if(objGroupProps.sort === 'desc'){
				objGroupState.sort ='desc';
			}				
			else{
				objGroupState.sort ='asc';
			}			
		}else{
			objGroupState.sort ='asc';
		}

		QBOX._.each(objGroupProps.columns, function(objGroupColumnProps, nIdx){
			var arrColsOfKey = objQCell._getColsOfKey(objGroupColumnProps.key);

			//if(arrColsOfKey.length > 0){
				//동일한 key값을 가진 컬럼이 한 개 있을 경우 하나의 컬럼만 그룹화하도록 한다.
			var nCol = arrColsOfKey[0],
			strColID = arrColsOfKey.length > 0 ? objQCell._getColID(nCol) : objGroupColumnProps.key;
			

			
			if(arrColsOfKey.length > 0){
				var objQCol = objQCell._getQCellCol(nCol);
				objQCol.attr('disabled',true,'boolean');
				objQCell._moveCols(nCol, 1, nHeaderCols + nIdx, true);
			}
			
			if(htGroupColumnsInfo.containsKey(strColID) === false){
				htGroupColumnsInfo.put(strColID, {
					header	: QBOX._.has(objGroupColumnProps, 'header') && QBOX._.isObject(objGroupColumnProps.header) ? QBOX._.clone(objGroupColumnProps.header) : {},
					footer	: QBOX._.has(objGroupColumnProps, 'footer') && QBOX._.isObject(objGroupColumnProps.footer) ? QBOX._.clone(objGroupColumnProps.footer) : {},
					headerFooterCallback : QBOX._.has(objGroupColumnProps, 'headerFooterCallback') && QBOX._.isFunction(objGroupColumnProps.headerFooterCallback) ? objGroupColumnProps.headerFooterCallback : undefined,
				});

				if(objGroupState.type === 'tree' || objGroupState.type === 'step'){
					htGroupColumnsInfo.get(strColID).expand = QBOX._.has(objGroupColumnProps, 'expand') && QBOX._.isBoolean(objGroupColumnProps.expand) ? objGroupColumnProps.expand : true;
				}
			}
			//}
		});
		objQCell._initColStyles();
		QBOX._.each(objGroupProps.outer, function(objGroupOuterProps, nIdx){
			objGroupState.outer = {};
			objGroupState.outer.header = QBOX._.clone(objGroupOuterProps.header);
			objGroupState.outer.footer = QBOX._.clone(objGroupOuterProps.footer);	
			
			objGroupState.outer.headers = QBOX._.clone(objGroupOuterProps.headers);
			objGroupState.outer.footers = QBOX._.clone(objGroupOuterProps.footers);	
			
			
			objGroupState.outer.outerCallback = QBOX._.has(objGroupOuterProps, 'outerCallback') && QBOX._.isFunction(objGroupOuterProps.outerCallback) ? objGroupOuterProps.outerCallback : undefined;
		});

		return this._initGroup();
	}

	return false;
};
QBOX.QCELL.BasicQCELL.prototype._initGroupData = function(){
	var arrUI=[],arrHeader = [], arrHeaderNodes = [], arrFooter = [], arrFooterNodes = [],i,arrData = this.attr('groupstate').data,nHeaderRows = this.attr('headerrows');
	var arrColumsInfo = this.attr('groupstate').columnsinfo.keys(true),j,objRows={}, objNodes={};
	
	for(j=0;j<arrColumsInfo.length;j++){
		objRows[arrColumsInfo[j]] = [];
		objNodes[arrColumsInfo[j]] = [];
	}
	
	for(i=0 ; i<arrData.length ; i++){
		if(arrData[i].qc_header === true){
			arrHeader.push(i+nHeaderRows);
			arrHeaderNodes.push(arrData[i].qc_header_nodes);
		}
		if(arrData[i].qc_footer === true){
			arrFooter.push(i+nHeaderRows);
			arrFooterNodes.push(arrData[i].qc_footer_nodes);
		}
		for(j=0;j<arrColumsInfo.length;j++){
			if(arrData[i]['qc_row_ui_'+arrColumsInfo[j]] === true){

				objRows[arrColumsInfo[j]].push(i+nHeaderRows);
				objNodes[arrColumsInfo[j]].push(arrData[i]['qc_row_ui_'+arrColumsInfo[j]+'_nodes']);
			}
		}
	}
	
	this.attr('groupstate').headerrows = arrHeader;
	this.attr('groupstate').headerrownodes = arrHeaderNodes;
	this.attr('groupstate').footerrows = arrFooter;
	this.attr('groupstate').footerrownodes = arrFooterNodes;

	this.attr('groupstate').groupuirows = objRows;
	this.attr('groupstate').groupuinodes = objNodes;
};
QBOX.QCELL.BasicQCELL.prototype._initGroup = function(){
	/* STEP 1: 그룹 기능을 구성하기 위한 노드 정보 생성 */
	this._makeGroupNodes();

	/* STEP 2: 'nodes' 정보를 이용해 그리드 행 데이터 생성 */
	if(this._makeGroupData()){
		if(this.attr('groupstate').type === 'group'){
			this._initGroupData();
			this.merge('data','group');
			
		}
		/* STEP 3: 그룹데이터로 화면 갱신 */
		return this._setCurrentData(this.attr('groupstate').data.RT_clone(), false);
	}

	return false;
};

QBOX.QCELL.BasicQCELL.prototype._makeGroupNodes = function(){
	var objGroupState = this.attr('groupstate'),
	htGroupNodes = objGroupState.nodes,
	nGroupCols = objGroupState.columnsinfo.size();

	htGroupNodes.clear();

	for(var i = 0, nOriginDataCount = this.attr('data').input.length; i < nOriginDataCount; i++){
		/*
		 * 트리 구조 형태의 노드를 만들기 위해 최상위 그룹 level부터 자신의 level까지 탐색하여 노드를 생성해야 한다.
		 * ex> 현재 그룹 설정이 '시도', '시군구', '읍면동'으로 3개의 level로 설정되어 있는 경우 서울특별시의 강남구에 속한 '대치동'이란 노드를 생성하기 위해서는
		 * 0 level인 그룹에서 '서울특별시' 노드를 찾은 후 1 level에서 '강남구' 노드를 찾아 그 하위에 '대치동' 자식노드를 생성한다.
		 */
		for(var j = 0; j < nGroupCols; j++){
			this._makeGroupNode(null, htGroupNodes, i, 0, j);
		}
	}

	return true;
};

QBOX.QCELL.BasicQCELL.prototype._makeGroupNode = function(objParentNode, htNodes, nIdx, nParentLevel, nLevel){
	var objGroupState = this.attr('groupstate'),
	objGroupColumnInfo,
	arrOriginData = this.attr('data').input,
	htGroupNodes = objGroupState.nodes,
	htGroupColumnsInfo = objGroupState.columnsinfo,
	//nGroupCols = objGroupState.columnsinfo.size(),
	strColID = htGroupColumnsInfo.keys(true)[nParentLevel],
	nGroupCols = htGroupColumnsInfo.size(),
	rowData = arrOriginData[nIdx],
	colKey = this._getKeyOfColID(strColID) === -1 ? strColID :  this._getKeyOfColID(strColID),
	key = rowData[colKey],
	type = objGroupState.type;
	
	objGroupColumnInfo = htGroupColumnsInfo.get(strColID);

	if(nParentLevel === nLevel){
		var bIsParent = false, objNode = null;
		if(type == 'step'){
			bIsParent = nGroupCols === nLevel + 1 ? false : true;
		} else {
			bIsParent = nLevel === nGroupCols - 1 ? false : true;
		}
		if(!(htNodes.containsKey(key))){
			objNode = {
				colid	: strColID,
				isparent: bIsParent,
				colkey	: colKey,
				level	: nLevel,
				key		: key,
				count	: 0, //전체 자식노드들의 총 수을 의미
				header	: QBOX._.size(objGroupColumnInfo.header) > 0 ? true : false,
				footer	: QBOX._.size(objGroupColumnInfo.footer) > 0 ? true : false,
				headerFooterCallback : objGroupColumnInfo.headerFooterCallback,
				parent	: objParentNode,
				_rowData : rowData
			};
			
			if(objGroupState.type === 'tree' || objGroupState.type === 'step' || objGroupState.type === 'group'){
				objNode.expand =  QBOX._.has(objGroupColumnInfo, 'expand') && (typeof objGroupColumnInfo.expand === 'boolean') ? objGroupColumnInfo.expand : true;
			}
			
			htNodes.put(key, objNode);
			
			if(bIsParent){
				objNode.childnodes = new _QHashtable();
			} else{
				objNode.data = new _QHashSet();
				objNode.data.add(nIdx);
				
				while(objNode !== null){
					objNode.count += 1;
					
					objNode = objNode.parent;
				}
			}
			
		} else{
			//console.log('중복된 데이터가 있는 경우를 의미한다.', key);
			objNode = htNodes.get(key);

			if(!(bIsParent)){
				objNode.data.add(nIdx);

				while(objNode !== null){
					objNode.count += 1;

					objNode = objNode.parent;
				}
			}
		}
	} else{
		this._makeGroupNode(htNodes.get(key), htNodes.get(key).childnodes, nIdx, nParentLevel + 1, nLevel);
	}
};

QBOX.QCELL.BasicQCELL.prototype._makeGroupData = function(){
	var objGroupState = this.attr('groupstate');

	if(objGroupState.grouped){
		objGroupState.data = [];
		objGroupState.treeuirows = [];
		objGroupState.treeuirownodes = [];
		objGroupState.headerrows = [];
		objGroupState.headerrownodes = [];
		objGroupState.footerrows = [];
		objGroupState.footerrownodes = [];
		
		objGroupState.groupuirows = {};
		objGroupState.groupuinodes = {};
		
		if(!QBOX._.isUndefined(objGroupState.outer) && (!QBOX._.isUndefined(objGroupState.outer.header ) || !QBOX._.isUndefined(objGroupState.outer.headers ) )){ //outer에 header가 선언되어 있는 경우
			this._makeGroupDatumOuterHeader(objGroupState.nodes);
		}
		
		this._makeGroupDatum(objGroupState.nodes);
		
		if(objGroupState.nodes.size() === 0 && (!QBOX._.isUndefined(objGroupState.outer) && 
			(!QBOX._.isUndefined(objGroupState.outer.header) || !QBOX._.isUndefined(objGroupState.outer.footer) ||
			!QBOX._.isUndefined(objGroupState.outer.headers) || !QBOX._.isUndefined(objGroupState.outer.footers)))){// columns에 key설정없이 outer header나 footer가 설정되어 있는 경우
			this._makeGroupZeroData();
		}
		
		if(!QBOX._.isUndefined(objGroupState.outer) && (!QBOX._.isUndefined(objGroupState.outer.footer) ||!QBOX._.isUndefined(objGroupState.outer.footers) )){ //outer에 header가 선언되어 있는 경우
			this._makeGroupDatumOuterFooter(objGroupState.nodes);
		}

		return true;
	}

	return false;
};

QBOX.QCELL.BasicQCELL.prototype._makeGroupZeroData = function(){
	var objGroupState = this.attr('groupstate'),
	arrOriginData = this.attr('data').input;
	
	for(var i = 0; i < arrOriginData.length; i++){
		objGroupState.data.push(arrOriginData[i]);
	}
	
	return true;
};

QBOX.QCELL.BasicQCELL.prototype._makeGroupDatumOuterHeader = function(htNodes,objHeaderFooter){
	var objGroupState = this.attr('groupstate');
	
	if(!QBOX._.isUndefined(objGroupState.outer.header ) ){
		this._makeGroupDatumOuterHeaderSub(htNodes,objHeaderFooter,objGroupState.outer.header);		
	}
	
	if(!QBOX._.isUndefined(objGroupState.outer.headers ) ){
		for(var i=0; i<objGroupState.outer.headers.length;i++){
			this._makeGroupDatumOuterHeaderSub(htNodes,objHeaderFooter,objGroupState.outer.headers[i]);	
		}
				
	}

};
QBOX.QCELL.BasicQCELL.prototype._makeGroupDatumOuterHeaderSub = function(htNodes,objHeaderFooter,objOuter){
	var objQCell = this,
	objGroupState = this.attr('groupstate'),
	strDataType = this.attr('data').type,
	nHeaderRows = this.attr('headerrows'),
	fnSetTotalHeaderFooterTextCallback = function(arrTexts, colkey){
		objQCell._setGroupTotalHeaderFooterText(rowData, arrTexts, colkey,true);
	},
	objectsAreSame = function(x, y) {//Object객체 비교 method
	   var objectsAreSame = true;
	   for(var propertyName in x) {
	      if(x[propertyName] !== y[propertyName]) {
	         objectsAreSame = false;
	         break;
	      }
	   }
	   return objectsAreSame;
	},
	chks = true,
	i = -1, j = -1,
	rowDataTemp = strDataType === 'array' ? [] : {},
	rowData;
	
	var objNode = {level : '-outer'};
		
	if(objGroupState.type === 'tree' || objGroupState.type === 'step'){//"tree"/"step" 타입인 경우
	
		rowData = QBOX._.clone(rowDataTemp);

		// 그룹 헤더 행에 표시할 정보 세팅
		QBOX._.each(objOuter, fnSetTotalHeaderFooterTextCallback);

		chks = true;
		for(j = 0; j < objGroupState.data.length; j++){
			if(objectsAreSame(objGroupState.data[j], rowData)){
				chks = false;
				break;
			}
		}
		
		if(chks){
			// 데이터에 그룹 헤더 행 추가
			objGroupState.data.push(rowData);

			// 그룹 헤더를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함)
			objGroupState.headerrows.push(nHeaderRows + objGroupState.data.length - 1);
			objGroupState.headerrownodes.push(objNode);
		}
	} else if ( objGroupState.type === 'group'){//"group" 타입인 경우
		rowData = QBOX._.clone(rowDataTemp);

		/* 그룹 헤더 행에 표시할 정보 세팅 */
		QBOX._.each(objOuter, fnSetTotalHeaderFooterTextCallback);

		// header 에 데이터 추가함.
		if(objHeaderFooter !== undefined){
			for(var pKey in objHeaderFooter){
				if(!QBOX._.has(rowData, pKey))
					rowData[pKey] = objHeaderFooter[pKey];
			}
		}
		rowData.qc_header = true;
		
		chks = true;
		for(j = 0; j < objGroupState.data.length; j++){
			if(objectsAreSame(objGroupState.data[j], rowData)){
				chks = false;
				break;
			}
		}
		
		if(chks){
			// 데이터에 그룹 헤더 행 추가
			objGroupState.data.push(rowData);

			// 그룹 헤더를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함)
			objGroupState.headerrows.push(nHeaderRows + objGroupState.data.length - 1);
			objGroupState.headerrownodes.push(objNode);
		}
	} else{//"normal" 타입인 경우
		rowData = QBOX._.clone(rowDataTemp);

		// 그룹 헤더 행에 표시할 정보 세팅
		QBOX._.each(objOuter, fnSetTotalHeaderFooterTextCallback);
		
		chks = true;
		for(j = 0; j < objGroupState.data.length; j++){
			if(objectsAreSame(objGroupState.data[j], rowData)){
				chks = false;
				break;
			}
		}
		
		if(chks){
			// 데이터에 그룹 헤더 행 추가
			objGroupState.data.push(rowData);

			// 그룹 헤더를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함)
			objGroupState.headerrows.push(nHeaderRows + objGroupState.data.length - 1);
			objGroupState.headerrownodes.push(objNode);
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._makeGroupDatumOuterFooter = function(htNodes,objHeaderFooter){
	var objGroupState = this.attr('groupstate');

	if(!QBOX._.isUndefined(objGroupState.outer.footer ) ){
		this._makeGroupDatumOuterFooterSub(htNodes,objHeaderFooter,objGroupState.outer.footer);		
	}
	
	if(!QBOX._.isUndefined(objGroupState.outer.footers ) ){
		for(var i=0; i<objGroupState.outer.footers.length;i++){
			this._makeGroupDatumOuterFooterSub(htNodes,objHeaderFooter,objGroupState.outer.footers[i]);	
		}
				
	}	
	

};
QBOX.QCELL.BasicQCELL.prototype._makeGroupDatumOuterFooterSub = function(htNodes,objHeaderFooter,objFooter){
	var objQCell = this,
	objGroupState = this.attr('groupstate'),
	strDataType = this.attr('data').type,
	nHeaderRows = this.attr('headerrows'),
	fnSetTotalHeaderFooterTextCallback = function(arrTexts, colkey){
		objQCell._setGroupTotalHeaderFooterText(rowData, arrTexts, colkey,false);
	},
	objectsAreSame = function(x, y) {//Object객체 비교 method
	   var objectsAreSame = true;
	   for(var propertyName in x) {
	      if(x[propertyName] !== y[propertyName]) {
	         objectsAreSame = false;
	         break;
	      }
	   }
	   return objectsAreSame;
	},
	chks = true, rowidx = -1,
	i = -1, j = -1, k = -1,
	rowDataTemp = strDataType === 'array' ? [] : {},
	rowData;
	
	var objNode = {level : '-outer'};
	
	if(objGroupState.type === 'tree' || objGroupState.type === 'step'){//"tree"/"step" 타입인 경우
		rowData = QBOX._.clone(rowDataTemp);
		
		/* 그룹 헤더 행에 표시할 정보 세팅 */
		QBOX._.each(objFooter, fnSetTotalHeaderFooterTextCallback);
		
		// 데이터에 그룹 헤더 행 추가
		objGroupState.data.push(rowData);

		// 그룹 헤더를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함)
		objGroupState.footerrows.push(nHeaderRows + objGroupState.data.length - 1);
		objGroupState.footerrownodes.push(objNode);
	} else if ( objGroupState.type === 'group'){//"group" 타입인 경우
		rowData = QBOX._.clone(rowDataTemp);

		/* 그룹 헤더 행에 표시할 정보 세팅 */
		QBOX._.each(objFooter, fnSetTotalHeaderFooterTextCallback);

		if(objHeaderFooter !== undefined){
			for(var pKey in objHeaderFooter){
				if(!QBOX._.has(rowData, pKey))
					rowData[pKey] = objHeaderFooter[pKey];
			}
		}
		rowData.qc_footer = true;
		
		// 데이터에 그룹 헤더 행 추가
		objGroupState.data.push(rowData);

		// 그룹 헤더를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함)
		objGroupState.footerrows.push(nHeaderRows + objGroupState.data.length - 1);
		objGroupState.footerrownodes.push(objNode);
	} else{//"normal" 타입인 경우
		rowData = QBOX._.clone(rowDataTemp);

		/* 그룹 헤더 행에 표시할 정보 세팅 */
		QBOX._.each(objFooter, fnSetTotalHeaderFooterTextCallback);
		
		// 데이터에 그룹 헤더 행 추가
		objGroupState.data.push(rowData);

		// 그룹 헤더를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함)
		objGroupState.footerrows.push(nHeaderRows + objGroupState.data.length - 1);
		objGroupState.footerrownodes.push(objNode);
	}
};

QBOX.QCELL.BasicQCELL.prototype._makeGroupDatum = function(htNodes,objHeaderFooter){
	var objQCell = this,
	objGroupState = this.attr('groupstate'),
	htGroupColumnsInfo = objGroupState.columnsinfo,
	arrNodeList = objGroupState.sort === 'asc' ? htNodes.keys().sort() : objGroupState.sort === 'desc' ? htNodes.keys().sort().reverse() :htNodes.keys(true) ,  
	arrOriginData = this.attr('data').input,
	strDataType = this.attr('data').type,
	nHeaderRows = this.attr('headerrows'),nFirst,
	nLastIndex = -1,

	fnSetHeaderTextCallback = function(arrTexts, colkey){
		objQCell._setGroupHeaderFooterText(objNode, rowData, arrTexts, colkey,true);
	},
	fnSetFooterTextCallback = function(arrTexts, colkey){
		objQCell._setGroupHeaderFooterText(objNode, rowData, arrTexts, colkey,false);
	},	
	
	fnPushTargetRowDataCallback = function(idx){
		//idx: 그리드의 행 인덱스가 아니라 JSON 데이터의 인덱스를 의미
		objGroupState.data.push(arrOriginData[idx]);
		nLastIndex = idx;
	},
	i = -1;
	
	for(i = 0; i < arrNodeList.length; i++){//현재 노드집합의 리스트 수 만큼
		var rowDataTemp = strDataType === 'array' ? [] : {},
		rowData,
		key = arrNodeList[i];
		if(QBOX._.isUndefined(key)){break;}
		var objNode = htNodes.get(key),
		strColID = objNode.colid,
		bIsParent = objNode.isparent,
		qc_level = 1,
		objGroupColumnInfo = htGroupColumnsInfo.get(strColID), pKey;
		
		if(objGroupState.type === 'tree' || objGroupState.type === 'step'){//"tree"/"step" 타입인 경우
			var htParentNode = objNode.parent;

			/* STEP 1: 현재 노드의 트리 UI를 표시하기 위한 행 데이터를 추가한다. */
			rowData = QBOX._.clone(rowDataTemp);
			objGroupState.data.push(rowData);

			//트리 UI를 표시하기 위한 행에 그룹 레벨 값을 표시하기 위한 행 데이터 세팅
			while(htParentNode !== null){
				rowData[htParentNode.colkey] = htParentNode.key;
				htParentNode = htParentNode.parent;
				qc_level++;
			}

			rowData[objNode.colkey] = objNode.key;
			
			rowData._qc_origindata = QBOX._.clone(objNode._rowData);
			rowData._qc_level = qc_level;
			/*
			for(var strTempKey in objNode._rowData ){
				if(rowData[strTempKey] === undefined ){
					rowData[strTempKey] = objNode._rowData[strTempKey];
				}
			}
			*/
			//트리 UI를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함)
			objGroupState.treeuirows.push(nHeaderRows + objGroupState.data.length - 1);
			objGroupState.treeuirownodes.push(objNode);

			/* STEP 2: 현재 노드의 접기/펼침 상태를 확인하여 펼침 상태인 경우 자식 노드가 있으면 하위 노드들의 트리 UI를 표시하기 위한 행들을 추가하고, 최하위 자식노드라면 실제 데이터 표시 행을 추가 */
			if(objNode.expand){
				/* STEP 2-1: 현재 노드의 그룹 헤더 행 추가 */
				if(objNode.header){
					rowData = QBOX._.clone(rowDataTemp);

					/* 그룹 헤더 행에 표시할 정보 세팅 */
					QBOX._.each(objGroupColumnInfo.header, fnSetHeaderTextCallback);

					/* 데이터에 그룹 헤더 행 추가 */
					objGroupState.data.push(rowData);

					/* 그룹 헤더를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함) */
					objGroupState.headerrows.push(nHeaderRows + objGroupState.data.length - 1);
					objGroupState.headerrownodes.push(objNode);
				}

				/* STEP 2-2: 자식 노드가 있으면 하위 노드들의 트리 UI를 표시하기 위한 행들을 추가하고, 최하위 자식노드라면 실제 데이터 표시 행을 추가 */
				if(bIsParent){
					this._makeGroupDatum(objNode.childnodes);
				} else{
					QBOX._.each(objNode.data.values(true), fnPushTargetRowDataCallback);
				}

				/* STEP 2-3: 현재 노드의 그룹 푸터 행 추가 */
				if(objNode.footer){
					rowData = QBOX._.clone(rowDataTemp);

					/* 그룹 푸터 행에 표시할 정보 세팅 */
					QBOX._.each(objGroupColumnInfo.footer, fnSetFooterTextCallback);
					/* 데이터에 그룹 푸터 행 추가 */
					objGroupState.data.push(rowData);

					/* 그룹 푸터를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함) */
					objGroupState.footerrows.push(nHeaderRows + objGroupState.data.length - 1);
					objGroupState.footerrownodes.push(objNode);
				}
			}
		} else if ( objGroupState.type === 'group'){//"group" 타입인 경우
			// 현재 키 저장
			if(objHeaderFooter === undefined) objHeaderFooter = {};
				objHeaderFooter[objNode.colkey] = key;
			
			/* STEP 1: 현재 노드의 그룹 헤더 행 추가 */
			if(objNode.header){
				rowData = QBOX._.clone(rowDataTemp);

				/* 그룹 헤더 행에 표시할 정보 세팅 */
				QBOX._.each(objGroupColumnInfo.header, fnSetHeaderTextCallback);
				
				// header 에 데이터 추가함.
				if(objHeaderFooter !== undefined){
					for(pKey in objHeaderFooter){
						if(!QBOX._.has(rowData, pKey))
							rowData[pKey] = objHeaderFooter[pKey];
					}
				}
				rowData.qc_header = true;
				rowData.qc_header_nodes = objNode;

				/* 데이터에 그룹 헤더 행 추가 */
				objGroupState.data.push(rowData);

				/* 그룹 헤더를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함) */
				objGroupState.headerrows.push(nHeaderRows + objGroupState.data.length - 1);
				objGroupState.headerrownodes.push(objNode);
			}	
			
			if(QBOX._.indexOf(objGroupState.groupuirows, nHeaderRows + objGroupState.data.length - 1, true) < 0){
				if(objGroupState.groupuirows[objNode.colkey] === undefined){
					objGroupState.groupuirows[objNode.colkey] = [];
				}
				if(objGroupState.groupuinodes[objNode.colkey] === undefined){
					objGroupState.groupuinodes[objNode.colkey] = [];
				}				
				objGroupState.groupuirows[objNode.colkey].push(nHeaderRows + objGroupState.data.length - 1);
				objGroupState.groupuinodes[objNode.colkey].push(objNode);				
			}

			/* STEP 2: 자식 노드가 있으면 하위 노드들의 트리 UI를 표시하기 위한 행들을 추가하고, 최하위 자식노드라면 실제 데이터 표시 행을 추가 */
			if(bIsParent){
				nFirst = objGroupState.data.length;				
				this._makeGroupDatum(objNode.childnodes,objHeaderFooter);
				objGroupState.data[nFirst]['qc_row_ui_' + objNode.colid] = true;
				objGroupState.data[nFirst]['qc_row_ui_' + objNode.colid + '_nodes'] = objNode;				

			} else{
				nFirst = objGroupState.data.length;
				if(objNode.expand){
					QBOX._.each(objNode.data.values(true), fnPushTargetRowDataCallback);
				}else{
					var arrTemp = [];
					arrTemp.push(objNode.data.values(true)[0]);
					QBOX._.each(arrTemp, fnPushTargetRowDataCallback);
				}
				
				objGroupState.data[nFirst]['qc_row_ui_' + objNode.colid] = true;
				objGroupState.data[nFirst]['qc_row_ui_' + objNode.colid + '_nodes'] = objNode;
				
			}

			/* STEP 3: 현재 노드의 그룹 푸터 행 추가 */
			if(objNode.footer){
				rowData = QBOX._.clone(rowDataTemp);

				/* 그룹 푸터 행에 표시할 정보 세팅 */
				QBOX._.each(objGroupColumnInfo.footer, fnSetFooterTextCallback);
				
				if(objHeaderFooter !== undefined){
					for(pKey in objHeaderFooter){
						if(!QBOX._.has(rowData, pKey))
							rowData[pKey] = objHeaderFooter[pKey];
					}
				}
				rowData.qc_footer = true;
				rowData.qc_footer_nodes = objNode;

				/* 데이터에 그룹 푸터 행 추가 */
				objGroupState.data.push(rowData);

				/* 그룹 푸터를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함) */
				objGroupState.footerrows.push(nHeaderRows + objGroupState.data.length - 1);
				objGroupState.footerrownodes.push(objNode);
			}
		}else{//"normal" 타입인 경우
			/* STEP 1: 현재 노드의 그룹 헤더 행 추가 */
			if(objNode.header){
				rowData = QBOX._.clone(rowDataTemp);

				/* 그룹 헤더 행에 표시할 정보 세팅 */
				QBOX._.each(objGroupColumnInfo.header, fnSetHeaderTextCallback);

				/* 데이터에 그룹 헤더 행 추가 */
				objGroupState.data.push(rowData);

				/* 그룹 헤더를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함) */
				objGroupState.headerrows.push(nHeaderRows + objGroupState.data.length - 1);
				objGroupState.headerrownodes.push(objNode);
			}

			/* STEP 2: 자식 노드가 있으면 하위 노드들의 트리 UI를 표시하기 위한 행들을 추가하고, 최하위 자식노드라면 실제 데이터 표시 행을 추가 */
			if(bIsParent){
				this._makeGroupDatum(objNode.childnodes);
			} else{
				QBOX._.each(objNode.data.values(true), fnPushTargetRowDataCallback);
			}

			/* STEP 3: 현재 노드의 그룹 푸터 행 추가 */
			if(objNode.footer){
				rowData = QBOX._.clone(rowDataTemp);

				/* 그룹 푸터 행에 표시할 정보 세팅 */
				QBOX._.each(objGroupColumnInfo.footer, fnSetFooterTextCallback);

				/* 데이터에 그룹 푸터 행 추가 */
				objGroupState.data.push(rowData);

				/* 그룹 푸터를 표시하기 위한 행의 그리드 기준 인덱스와 현재 노드 객체를 저장(접고 펼치기 시 참조하기 위함) */
				objGroupState.footerrows.push(nHeaderRows + objGroupState.data.length - 1);
				objGroupState.footerrownodes.push(objNode);
			}
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._getGroupSum = function(targetnode, colkey){
	var objQCell = this,
	arrOriginData = this.attr('data').input,
	nSum = 0;
	
	if(targetnode.isparent){//최하위 노드가 아닌 경우
		targetnode.childnodes.each(function(key, node){
			nSum += objQCell._getGroupSum(node, colkey);
		});
	} else{//최하위 노드인 경우
		QBOX._.each(targetnode.data.values(), function(idx){
			nSum += arrOriginData[idx][colkey];
		});
	}

	return nSum;
};

QBOX.QCELL.BasicQCELL.prototype._getGroupCountif = function(targetnode, colkey, stdvalue){
	var objQCell = this,
	arrOriginData = this.attr('data').input,
	nCount = 0;

	if(targetnode.isparent){//최하위 노드가 아닌 경우
		targetnode.childnodes.each(function(key, node){
			nCount += objQCell._getGroupCountif(node, colkey, stdvalue);
		});
	} else{//최하위 노드인 경우
		QBOX._.each(targetnode.data.values(), function(idx){
			if(arrOriginData[idx][colkey] === stdvalue){
				nCount += 1;
			}
		});
	}

	return nCount;
};

QBOX.QCELL.BasicQCELL.prototype._setGroupTotalHeaderFooterText = function(rowData, arrTexts, colkey,bHeader,bOuter){
	var objQCell = this,
	arrRegExp = [//정규식 객체 저장 변수
		/^childcount\(.*\)$/,	//childcount() 함수 유효성 검사
		/^count\(.*\)$/,		//count() 함수 유효성 검사
		/^countif\(.*\)$/,		//countif() 함수 유효성 검사
		/^groupvalue\(.*\)$/,	//groupvalue() 함수 유효성 검사
		/^sum\(.*\)$/,			//sum() 함수 유효성 검사
		/^average\(.*\)$/,		//average() 함수 유효성 검사
		/.*\(|\)/gi,			//() 괄호 안 파라미터 추출
		/[\"\']/gi,				//홀따옴표, 쌍따옴표 제거
		/^[0-9]*$/				//숫자로만 되어 있는지 유효성 검사
	],
	strDataType = this.attr('data').type,
	arrOriginData = this.attr('data').input,
	strCellData = '', fnOuterCallback = null;
	
	if(bOuter !== false)
		fnOuterCallback = this.attr('groupstate').outer.outerCallback;
	
	QBOX._.each(arrTexts, function(strText){
		/* 통계함수:
		 * childcount(),				//직계 자식노드의 수
		 * count(),						//전체 자식노드의 수
		 * countif(colkey, stdvalue),	//전체 자식노드들 중에서 특정 기준값을 가지는 자식도의 수
		 * groupvalue(nLevel)			//그룹 헤더가 그려진 기준이 되는 그룹의 값
		 * sum([colkey]),				//데이터의 총합
		 * average([colkey])			//데이터의 평균값
		 */
		var userColKey,tempValue;//통계함수의 parameter로 입력받은 colkey값

		if(arrRegExp[0].test(strText)){//childcount()
			tempValue = 0;
			if(QBOX._.isFunction(fnOuterCallback)){
				tempValue = fnOuterCallback(colkey,tempValue,rowData);
			}
			strCellData += tempValue;
		} else if(arrRegExp[1].test(strText)){//count()
			tempValue = arrOriginData.length;
			if(QBOX._.isFunction(fnOuterCallback)){
				tempValue = fnOuterCallback(colkey,tempValue,rowData);
			}
			strCellData += tempValue;
		} else if(arrRegExp[2].test(strText)){//countif()
			var strUserColKeys = strText.replace(arrRegExp[6], ''),//() 괄호 안 파라미터 추출
			arrUserColKeys = QBOX._.map(strUserColKeys.split(','), function(strUserColKey){//parameter가 두개이므로 ','문자로 split
				return QBOX.$.trim(strUserColKey).replace(arrRegExp[7], '');//trim처리 후 홀따옴표,쌍따옴표 제거
			});

			if(arrUserColKeys.length === 2){//반드시 2개의 parameter가 있을 때만 동작
				userColKey = strDataType === 'array' && arrRegExp[8].test(arrUserColKeys[0]) ? parseInt(arrUserColKeys[0]) : arrUserColKeys[0];
				tempValue = objQCell._getGroupCountif(objNode, userColKey, arrUserColKeys[1]);
				if(QBOX._.isFunction(fnOuterCallback)){
					tempValue = fnOuterCallback(colkey,tempValue,rowData);
				}
				strCellData += tempValue;
			}
		} else if(arrRegExp[3].test(strText)){//groupvalue()
			if(bOuter === false)
				return;
			//groupvalue(nLevel) -> 입력한 그룹 레벨에 해당하는 값 출력
			//현재 헤더나 푸터를 표시하는 그룹 레벨보다 하위 레벨을 설정하지는 못한다.
			var nLevel = Number(strText.replace(arrRegExp[6], ''));

			if(isNaN(nLevel) === false){
				if(nLevel <= objNode.level){//상위 레벨값만 유효값이라 볼 수 있다.
					var objNodeTemp = objNode;

					while(nLevel < objNodeTemp.level){
						objNodeTemp = objNodeTemp.parent;
					}

					strCellData += objNodeTemp.key;
				}
			}
		} else if(arrRegExp[4].test(strText) || arrRegExp[5].test(strText)){//sum() or average()
			//"sum()"
			//"sum('people')"
			//"average()"
			//"average('people')"
			
			var strUserColKey = strText.replace(arrRegExp[6], '').replace(arrRegExp[7], '');

			if(strUserColKey === ''){
				userColKey = colkey;
			} else{
				userColKey = strDataType === 'array' && arrRegExp[8].test(strUserColKey) ? parseInt(strUserColKey) : strUserColKey;
			}

			//사용자가 입력한 userColKey의 유효성검사, 데이터 타입이 number인 경우에만 사용 가능
			//if(objQCell._getColsOfKey(userColKey).length > 0 && //userColKey값을 가지는 컬럼의 존재여부 확인
			//   objQCell._getColDataType(objQCell._getColsOfKey(userColKey)[0]) === 'number'){//컬럼의 데이터 타입이 숫자인지 체크
				var cnt = 0;
				for(var i = 0; i < arrOriginData.length; i++){
					cnt += Number(arrOriginData[i][userColKey] !== undefined? arrOriginData[i][userColKey] : 0);
				}
				var nSum = cnt;
				var nCol = objQCell._getColsOfKey(userColKey)[0];
				var objFormat = nCol !== undefined ? objQCell._getColFormat(nCol) : undefined;
				var nCount = arrOriginData.length;
				
				tempValue = arrRegExp[5].test(strText) ? nSum / nCount : nSum;
				if(QBOX._.isFunction(fnOuterCallback)){
					tempValue = fnOuterCallback(colkey,tempValue,rowData);
				}
				
				if(objFormat === undefined){
					strCellData += tempValue;					
				}else{					
					strCellData += objQCell._showDataFormat(0,nCol, tempValue);	
				}
			//}
			
		} else{
			strCellData += strText;
		}
	});

	rowData[colkey] = strCellData;
		
	if(bHeader === true){
		rowData.rt_qc_header = true;
	}else if(bHeader === false){
		rowData.rt_qc_footer = true;
	}else{
		console.log ('error');
	}		
};

QBOX.QCELL.BasicQCELL.prototype._setGroupHeaderFooterText = function(objNode, rowData, arrTexts, colkey,bIsHeader){
	var objQCell = this,
	arrRegExp = [//정규식 객체 저장 변수
		/^childcount\(.*\)$/,	//childcount() 함수 유효성 검사
		/^count\(.*\)$/,		//count() 함수 유효성 검사
		/^countif\(.*\)$/,		//countif() 함수 유효성 검사
		/^groupvalue\(.*\)$/,	//groupvalue() 함수 유효성 검사
		/^sum\(.*\)$/,			//sum() 함수 유효성 검사
		/^average\(.*\)$/,		//average() 함수 유효성 검사
		/.*\(|\)/gi,			//() 괄호 안 파라미터 추출
		/[\"\']/gi,				//홀따옴표, 쌍따옴표 제거
		/^[0-9]*$/				//숫자로만 되어 있는지 유효성 검사
	],
	strDataType = this.attr('data').type,
	strCellData = '';

	QBOX._.each(arrTexts, function(strText){
		/* 통계함수:
		 * childcount(),				//직계 자식노드의 수
		 * count(),						//전체 자식노드의 수
		 * countif(colkey, stdvalue),	//전체 자식노드들 중에서 특정 기준값을 가지는 자식도의 수
		 * groupvalue(nLevel)			//그룹 헤더가 그려진 기준이 되는 그룹의 값
		 * sum([colkey]),				//데이터의 총합
		 * average([colkey])			//데이터의 평균값
		 */
		var userColKey,tempValue;//통계함수의 parameter로 입력받은 colkey값

		if(arrRegExp[0].test(strText)){//childcount()
			tempValue = objNode.isparent ? objNode.childnodes.size() : objNode.data.size();
			if(objNode.headerFooterCallback !== undefined){
				tempValue = objNode.headerFooterCallback(colkey,tempValue,rowData);
			}	
			strCellData += tempValue;
		} else if(arrRegExp[1].test(strText)){//count()
			tempValue = objNode.count;
			
			if(objNode.headerFooterCallback !== undefined){
				tempValue = objNode.headerFooterCallback(colkey,tempValue,rowData);
			}	
			
			strCellData += tempValue;
		} else if(arrRegExp[2].test(strText)){//countif()
			var strUserColKeys = strText.replace(arrRegExp[6], ''),//() 괄호 안 파라미터 추출
			arrUserColKeys = QBOX._.map(strUserColKeys.split(','), function(strUserColKey){//parameter가 두개이므로 ','문자로 split
				return QBOX.$.trim(strUserColKey).replace(arrRegExp[7], '');//trim처리 후 홀따옴표,쌍따옴표 제거
			});

			if(arrUserColKeys.length === 2){//반드시 2개의 parameter가 있을 때만 동작
				userColKey = strDataType === 'array' && arrRegExp[8].test(arrUserColKeys[0]) ? parseInt(arrUserColKeys[0]) : arrUserColKeys[0];

				tempValue = objQCell._getGroupCountif(objNode, userColKey, arrUserColKeys[1]);
				
				if(objNode.headerFooterCallback !== undefined){
					tempValue = objNode.headerFooterCallback(colkey,tempValue,rowData);
				}	
				
				strCellData += tempValue;
			}
		} else if(arrRegExp[3].test(strText)){//groupvalue()
			//groupvalue(nLevel) -> 입력한 그룹 레벨에 해당하는 값 출력
			//현재 헤더나 푸터를 표시하는 그룹 레벨보다 하위 레벨을 설정하지는 못한다.
			var nLevel = Number(strText.replace(arrRegExp[6], ''));

			if(isNaN(nLevel) === false){
				if(nLevel <= objNode.level){//상위 레벨값만 유효값이라 볼 수 있다.
					var objNodeTemp = objNode;

					while(nLevel < objNodeTemp.level){
						objNodeTemp = objNodeTemp.parent;
					}
					
					tempValue = objNodeTemp.key;
					
					if(objNode.headerFooterCallback !== undefined){
						tempValue = objNode.headerFooterCallback(colkey,tempValue,rowData);
					}	

					strCellData += tempValue;
				}
			}
		} else if(arrRegExp[4].test(strText) || arrRegExp[5].test(strText)){//sum() or average()
			//"sum()"
			//"sum('people')"
			//"average()"
			//"average('people')"
			var strUserColKey = strText.replace(arrRegExp[6], '').replace(arrRegExp[7], '');

			if(strUserColKey === ''){
				userColKey = colkey;
			} else{
				userColKey = strDataType === 'array' && arrRegExp[8].test(strUserColKey) ? parseInt(strUserColKey) : strUserColKey;
			}

			//사용자가 입력한 userColKey의 유효성검사, 데이터 타입이 number인 경우에만 사용 가능
			if(objQCell._getColsOfKey(userColKey).length > 0 && //userColKey값을 가지는 컬럼의 존재여부 확인
			   objQCell._getColDataType(objQCell._getColsOfKey(userColKey)[0]) === 'number'){//컬럼의 데이터 타입이 숫자인지 체크
				var nSum = objQCell._getGroupSum(objNode, userColKey);
				var nCol = objQCell._getColsOfKey(userColKey)[0];
				var objFormat = objQCell._getColFormat(nCol);
				tempValue= arrRegExp[5].test(strText) ? nSum / objNode.count : nSum;				
				if(objNode.headerFooterCallback !== undefined){
					tempValue = objNode.headerFooterCallback(colkey,tempValue,rowData);
				}				
				if(objFormat !== undefined){					
					tempValue = objQCell._showDataFormat(0,nCol, tempValue);	
				}
				strCellData += tempValue;
			}
		} else{
			if(objNode.headerFooterCallback !== undefined){
				strText = objNode.headerFooterCallback(colkey,strText,rowData);
			}	
			strCellData += strText;
		}
	});

	rowData[colkey] = strCellData;
	if(bIsHeader === true){
		rowData.rt_qc_header = true;
	}else if(bIsHeader === false){
		rowData.rt_qc_footer = true;
	}else{
		console.log ('error');
	}
};

QBOX.QCELL.BasicQCELL.prototype._seekNextExpandedGroupTreeUIRow = function(nLevel){
	var objGroupState = this.attr('groupstate').grouped === true ? this.attr('groupstate') : this.attr('treestate'),
	arrGroupTreeUIRows = objGroupState.treeuirows,
	arrGroupTreeUIRowNodes = objGroupState.treeuirownodes,
	nNextExpandedGroupTreeUIRow = -1;

	/* nNextExpandedGroupTreeUIRow 계산방법
	 * 현재 행과 level값이 같은 행이 존재하면 그 행 이전까지 접는다.
	 * 현재 행과 level값이 같은 행이 없다면 부모 노드와 level값이 같은 행의 존재 여부를 확인하여 그 행 이전까지 접는다.
	 * 부모 노드와 level값이 같은 행도 없다면 또 상위 부모 노드로 탐색하면서 같은 작업을 반복한다.
	 * level이 0이면서 level값이 같은 행이 존재하지 않으면 현재 행 이후의 모든 행을 제거한다.
	 */

	if(nLevel > 0){
		//현재 level값을 가진 행을 찾되 부모 level과 같은 행이 나타나기 이전까지만 찾아야 한다.
		QBOX.$.each(arrGroupTreeUIRows, function(idx, row){
			var objNodeTemp = arrGroupTreeUIRowNodes[idx];

			if(objNodeTemp.level === (nLevel - 1)){
				return false;
			} else if(objNodeTemp.level === nLevel){
				nNextExpandedGroupTreeUIRow = row;

				return false;
			}
		});
	} else{
		QBOX.$.each(arrGroupTreeUIRows, function(idx, row){
			if(arrGroupTreeUIRowNodes[idx].level === nLevel){
				nNextExpandedGroupTreeUIRow = row;

				return false;
			}
		});
	}

	if(nNextExpandedGroupTreeUIRow === -1 && nLevel > 0){
		return this._seekNextExpandedGroupTreeUIRow(nLevel - 1);
	} else{
		return nNextExpandedGroupTreeUIRow;
	}
};

QBOX.QCELL.BasicQCELL.prototype._setExpandOfGroupTreeUIRow = function(nRow, bExpand){
	var objGroupState = this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
	arrOriginData = this.attr('data').input,
	arrGroupTreeUIRows = objGroupState.treeuirows,
	arrGroupTreeUIRowNodes = objGroupState.treeuirownodes,
	arrGroupHeaderRows = objGroupState.headerrows,
	arrGroupHeaderRowNodes = objGroupState.headerrownodes,
	arrGroupFooterRows = objGroupState.footerrows,
	arrGroupFooterRowNodes = objGroupState.footerrownodes,
	arrGroupDataBackup,
	arrGroupTreeUIRowsBackup,
	arrGroupTreeUIRowNodesBackup,
	arrGroupHeaderRowsBackup,
	arrGroupHeaderRowNodesBackup,
	arrGroupFooterRowsBackup,
	arrGroupFooterRowNodesBackup,
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	nIdxOfGroupTreeUIRow = (objGroupState.type === 'tree' || objGroupState.type === 'step') ? QBOX._.indexOf(arrGroupTreeUIRows, nRow, true) : -1,
	nIdxOfGroupHeaderRow,
	nIdxOfGroupFooterRow,
	nLength, i, j,bLast =false;

	if(nIdxOfGroupTreeUIRow > -1){
		var objQCell = this,
		objNode = arrGroupTreeUIRowNodes[nIdxOfGroupTreeUIRow];

		if(bExpand){//펼칠 때
			if(objNode.expand === false){//접혀 있어 펼칠 수 있을 때만
				/* Tip
				 * 배열 중간에 반복적으로 표시해야 할 데이터를 삽입하는 방식으로 구현 시 삽입 시마다 행 인덱스 동기화를 수행해야 하므로 성능을 보장할 수 없다.
				 * 성능 개선을 위해 삽입할 위치 이후의 행 데이터 정보들을 잘라내서 백업 해 둔 후 삽입이 아닌 추가하는 방식으로 처리 후 백업 해 둔 정보를 붙여넣는 방법을 사용한다.
				 * 'treeuirows'와 'treeuirownodes'를 hashtable을 구현하려고 했으나 행 동기화 처리 시 hashtable의 remove() 성능이 매우 느려 각각의 배열로 처리한다.
				 * 'treeuirows'과 대응하는 'treeuirownodes' 정보는 반드시 동일한 인덱스로 무결성이 보장되어야 한다. ex> 'treeuirows'의 3번째 인덱스의 값이 행번호 5일 때 'treeuirownodes'의 3번째 인덱스의 값은 반드시 5번째 행에 대응하는 node객체이여야 한다.
				*/
				var nBeforeCount = 0,	//펼치기 전 그리드 행 데이터 수
				nAddedRowCount = 0,		//펼쳐졌을 때 펼치기 전과의 행 데이터 수 차이
				strDataType = this.attr('data').type,
				strColID = objNode.colid,
				fnSetHeaderTextCallback = function(arrTexts, colkey){
					objQCell._setGroupHeaderFooterText(objNode, rowData, arrTexts, colkey,true);
				},
				fnSetFooterTextCallback = function(arrTexts, colkey){
					objQCell._setGroupHeaderFooterText(objNode, rowData, arrTexts, colkey,false);
				},
				fnPushTargetRowDataCallback = function(idx){
					//idx: 그리드의 행 인덱스가 아니라 JSON 데이터의 인덱스를 의미
					objGroupState.data.push(arrOriginData[idx]);
				},
				htGroupColumnsInfo = objGroupState.columnsinfo,
				objGroupColumnInfo = htGroupColumnsInfo.get(strColID),
				rowDataTemp = strDataType === 'array' ? [] : {},
				rowData;

				nIdxOfGroupHeaderRow = QBOX._.findIndex(arrGroupHeaderRows, function(row){return row > nRow;});//nRow보다 큰 값 중에서 가장 작은 값의 인덱스
				nIdxOfGroupFooterRow = QBOX._.findIndex(arrGroupFooterRows, function(row){return row > nRow;});

//				console.log("1 nRow:", nRow);
//				console.log("2 arrGroupHeaderRows:", JSON.stringify(arrGroupHeaderRows));
//				console.log("3 nIdxOfGroupHeaderRow:", nIdxOfGroupHeaderRow, ', nGroupHeaderRow:', arrGroupHeaderRows[nIdxOfGroupHeaderRow]);
				//console.log("arrGroupFooterRows:", JSON.stringify(arrGroupFooterRows));
				//console.log("nIdxOfGroupFooterRow:", nIdxOfGroupFooterRow, ', nGroupFooterRow:', arrGroupFooterRows[nIdxOfGroupFooterRow]);

				/* STEP 1: 현재 행 이후의 정보들을 임시로 백업한다. */
				arrGroupDataBackup = objGroupState.data.splice(nRow - nHeaderRows + 1, objGroupState.data.length - (nRow - nHeaderRows + 1));						//그리드 데이터 백업
				arrGroupTreeUIRowsBackup = arrGroupTreeUIRows.splice(nIdxOfGroupTreeUIRow + 1, arrGroupTreeUIRows.length - (nIdxOfGroupTreeUIRow + 1));				//접고/펼치기 UI를 표시하는 그리드 행 인덱스들의 집합 중에서 현재 행 이후의 행들을 추출하여 백업
				arrGroupTreeUIRowNodesBackup = arrGroupTreeUIRowNodes.splice(nIdxOfGroupTreeUIRow + 1, arrGroupTreeUIRowNodes.length - (nIdxOfGroupTreeUIRow + 1));	//arrGroupTreeUIRowsBackup에 대응하는 Node객체들을 백업
				arrGroupHeaderRowsBackup = nIdxOfGroupHeaderRow > -1 ? arrGroupHeaderRows.splice(nIdxOfGroupHeaderRow, arrGroupHeaderRows.length - nIdxOfGroupHeaderRow) : [];			//그룹 헤더 행 인덱스들의 집합 중에서 펼쳐진 트리 UI 행 인덱스보다 큰 값들을 백업
				arrGroupHeaderRowNodesBackup = nIdxOfGroupHeaderRow > -1 ? arrGroupHeaderRowNodes.splice(nIdxOfGroupHeaderRow, arrGroupHeaderRowNodes.length - nIdxOfGroupHeaderRow) : [];//arrGroupHeaderRowsBackup에 대응하는 Node객체들을 백업
				arrGroupFooterRowsBackup = nIdxOfGroupFooterRow > -1 ? arrGroupFooterRows.splice(nIdxOfGroupFooterRow, arrGroupFooterRows.length - nIdxOfGroupFooterRow) : [];			//그룹 푸터 행 인덱스들의 집합 중에서 펼쳐진 트리 UI 행 인덱스보다 큰 값들을 백업
				arrGroupFooterRowNodesBackup = nIdxOfGroupFooterRow > -1 ? arrGroupFooterRowNodes.splice(nIdxOfGroupFooterRow, arrGroupFooterRowNodes.length - nIdxOfGroupFooterRow) : [];//arrGroupFooterRowsBackup에 대응하는 Node객체들을 백업

//				console.log("4 arrGroupHeaderRowsBackup:", JSON.stringify(arrGroupHeaderRowsBackup));
				//console.log("arrGroupFooterRowsBackup:", JSON.stringify(arrGroupFooterRowsBackup));

				/* STEP 2: 백업된 그룹 트리 UI 노드들에 적용된 스타일을 제거한다. */
//				for(var i = 0, nGroupUIRowCount = arrGroupUIRowsBackup.length ; i < nGroupUIRowCount ; i++){
//					this._removeGroupNodeStyle(arrGroupUIRowsBackup[i], arrGroupUIRowNodesBackup[i], true);
//				}

				nBeforeCount = objGroupState.data.length;	//펼치기 전의 그리드 행 데이터 수를 저장한다.
				objNode.expand = true;						//expand 플래그를 true로 설정해야 this._makeGroupDatum()에서 자동으로 데이터를 생성한다.

				/* 현재 노드의 헤더 행 추가 */
				if(objNode.header){
					rowData = QBOX._.clone(rowDataTemp);

					/* 헤더 행에 표시할 정보 세팅 */
					QBOX._.each(objGroupColumnInfo.header, fnSetHeaderTextCallback);

					/* 데이터에 헤더 행 추가 */
					objGroupState.data.push(rowData);

					objGroupState.headerrows.push(nHeaderRows + objGroupState.data.length - 1);
					objGroupState.headerrownodes.push(objNode);
				}

				/* STEP 3: 펼쳐져서 표시될 데이터를 생성하여 그리드 행 데이터로 추가한다. */
				if(objNode.isparent){//현재 노드가 자식 노드를 가지고 있으면
					if(this.attr('treestate').grouped === true){
						this._makeTreeDatum(objNode.childnodes);
					}else{
						this._makeGroupDatum(objNode.childnodes);
					}
				} else{
					var nFirst = objGroupState.data.length;
					//현재 노드가 최 하위 노드이면 'childnodes'정보를 탐색하여 자식 노드들을 만들 필요가 없으니 행 데이터를 바로 추가한다.
					QBOX._.each(objNode.data.values().sort(QBOX.st.asc), fnPushTargetRowDataCallback);
					objGroupState.data[nFirst]['qc_row_ui' + objNode.colkey] = true;
					
				}

				/* 현재 노드의 푸터 행 추가 */
				if(objNode.footer){
					rowData = QBOX._.clone(rowDataTemp);

					/* 푸터 행에 표시할 정보 세팅 */
					QBOX._.each(objGroupColumnInfo.footer, fnSetFooterTextCallback);

					/* 데이터에 푸터 행 추가 */
					objGroupState.data.push(rowData);

					objGroupState.footerrows.push(nHeaderRows + objGroupState.data.length - 1);
					objGroupState.footerrownodes.push(objNode);
				}

				nAddedRowCount = objGroupState.data.length - nBeforeCount;		//펼쳐져서 추가된 행의 수를 계산한다.

				/* STEP 4: 행 정보 동기화를 수행한다. */
				for(i = 0, nLength = arrGroupTreeUIRowsBackup.length; i < nLength ;i++){
					arrGroupTreeUIRowsBackup[i] = arrGroupTreeUIRowsBackup[i] + nAddedRowCount;//기존의 현재 행 이후의 행들의 인덱스 번호를 추가된 행 수 만큼 증가시켜야 한다.
				}
				for(i = 0, nLength = arrGroupHeaderRowsBackup.length; i < nLength ;i++){
					arrGroupHeaderRowsBackup[i] = arrGroupHeaderRowsBackup[i] + nAddedRowCount;//그룹 헤더 행 인덱스들의 집합 중에서 펼쳐진 트리 UI 행 인덱스보다 큰 값들을 추가된 행 수 만큼 증가시켜야 한다.
				}
				for(i = 0, nLength = arrGroupFooterRowsBackup.length; i < nLength ;i++){
					arrGroupFooterRowsBackup[i] = arrGroupFooterRowsBackup[i] + nAddedRowCount;//그룹 푸터 행 인덱스들의 집합 중에서 펼쳐진 트리 UI 행 인덱스보다 큰 값들을 추가된 행 수 만큼 증가시켜야 한다.
				}

				/* STEP 5: 백업 해 두었던 정보들을 추가한다. */
				objGroupState.treeuirows = arrGroupTreeUIRows.concat(arrGroupTreeUIRowsBackup);
				objGroupState.treeuirownodes = arrGroupTreeUIRowNodes.concat(arrGroupTreeUIRowNodesBackup);
				objGroupState.headerrows = arrGroupHeaderRows.concat(arrGroupHeaderRowsBackup);
				objGroupState.headerrownodes = arrGroupHeaderRowNodes.concat(arrGroupHeaderRowNodesBackup);
				objGroupState.footerrows = arrGroupFooterRows.concat(arrGroupFooterRowsBackup);
				objGroupState.footerrownodes = arrGroupFooterRowNodes.concat(arrGroupFooterRowNodesBackup);
				objGroupState.data = objGroupState.data.concat(arrGroupDataBackup);
				
//				console.log("5 headerrows: ", JSON.stringify(objGroupState.headerrows));
				//console.log("footerrows: ", JSON.stringify(objGroupState.footerrows));
			} else{
				return false;
			}
		} else{//접을 때
			if(objNode.expand){//펼쳐져 있어 접을 수 있을 때만 접기를 수행
				var nRemovedRowCount = 0,	//삭제 할 행 데이터 수
				nRemovedGroupHeaderRowCount = 0,//objGroupState.headerrows, objGroupState.headerrownodes 배열에서 삭제되어야 할 개수
				nRemovedGroupFooterRowCount = 0;//objGroupState.footerrows, objGroupState.footerrownodes 배열에서 삭제되어야 할 개수

				nIdxOfGroupHeaderRow = QBOX._.findLastIndex(arrGroupHeaderRows, function(row){return row < nRow;});//nRow보다 작은 값중에서 가장 큰 값의 인덱스
				nIdxOfGroupFooterRow = QBOX._.findLastIndex(arrGroupFooterRows, function(row){return row < nRow;});

//				console.log("6 nRow:", nRow);
//				console.log("7 arrGroupHeaderRows:", JSON.stringify(arrGroupHeaderRows));
//				console.log("8 nIdxOfGroupHeaderRow:", nIdxOfGroupHeaderRow, ', nGroupHeaderRow:', arrGroupHeaderRows[nIdxOfGroupHeaderRow]);
				//console.log("arrGroupFooterRows:", JSON.stringify(arrGroupFooterRows));
				//console.log("nIdxOfGroupFooterRow:", nIdxOfGroupFooterRow, ', nGroupFooterRow:', arrGroupFooterRows[nIdxOfGroupFooterRow]);

				/* STEP 1: 현재 행 이전의 정보들을 임시로 백업한다. */
				arrGroupDataBackup = objGroupState.data.splice(0, nRow - nHeaderRows + 1);		//그리드 데이터 백업
				arrGroupTreeUIRowsBackup = arrGroupTreeUIRows.splice(0, nIdxOfGroupTreeUIRow + 1);		//접고/펼치기 UI를 표시하는 그리드 행 인덱스들의 집합 중에서 첫번 째 행부터 현재 행까지의 행들을 추출하여 백업
				arrGroupTreeUIRowNodesBackup = arrGroupTreeUIRowNodes.splice(0, nIdxOfGroupTreeUIRow + 1);//arrGroupTreeUIRowsBackup에 대응하는 Node객체들을 백업

				arrGroupHeaderRowsBackup = nIdxOfGroupHeaderRow > -1 ? arrGroupHeaderRows.splice(0, nIdxOfGroupHeaderRow + 1) : [];	//그룹 헤더 행 인덱스들의 집합 중에서 펼쳐진 트리 UI 행 인덱스보다 작은 값들을 백업
				arrGroupHeaderRowNodesBackup = nIdxOfGroupHeaderRow > -1 ? arrGroupHeaderRowNodes.splice(0, nIdxOfGroupHeaderRow + 1) : [];	//arrGroupHeaderRowsBackup에 대응하는 Node객체들을 백업
				arrGroupFooterRowsBackup = nIdxOfGroupFooterRow > -1 ? arrGroupFooterRows.splice(0, nIdxOfGroupFooterRow + 1) : [];			//그룹 푸터 행 인덱스들의 집합 중에서 펼쳐진 트리 UI 행 인덱스보다 작은 값들을 백업
				arrGroupFooterRowNodesBackup = nIdxOfGroupFooterRow > -1 ? arrGroupFooterRowNodes.splice(0, nIdxOfGroupFooterRow + 1) : [];	//arrGroupFooterRowsBackup에 대응하는 Node객체들을 백업
				
//				console.log("9 arrGroupHeaderRowsBackup:", JSON.stringify(arrGroupHeaderRowsBackup));
				//console.log("arrGroupFooterRowsBackup:", JSON.stringify(arrGroupFooterRowsBackup));

				/* STEP 2: 현재 행부터 이후의 그룹 UI 노드들에 적용된 스타일을 제거한다. */
//				for(var i = 0, nGroupUIRowCount = arrGroupUIRows.length ; i < nGroupUIRowCount ; i++){
//					this._removeGroupNodeStyle(arrGroupUIRows[i], arrGroupUIRowNodes[i], true);
//				}

				/* STEP 3: 접어서 삭제 될 행 수를 계산한다. */
				//if(objNode.isparent || objNode.count > 0){//자식 노드가 있는 경우
				if(objNode.isparent){//자식 노드가 있는 경우
					var nRemovedGroupTreeUIRowCount = 0,		//objGroupState.treeuirows, objGroupState.treeuirownodes 배열에서 삭제되어야 할 개수
					nNextExpandedGroupTreeUIRow = 0;

					/* STEP 3-1: 접고 난 후 현재 행 이후에  표시되는  행 인덱스 계산 */
					/* nNextExpandedGroupTreeUIRow 계산방법
					 * 현재 행과 level값이 같은 행이 존재하면 그 행 이전까지 접는다.
					 * 현재 행과 level값이 같은 행이 없다면 부모 노드와 level값이 같은 행의 존재 여부를 확인하여 그 행 이전까지 접는다.
					 * 부모 노드와 level값이 같은 행도 없다면 또 상위 부모 노드로 탐색하면서 같은 작업을 반복한다.
					 * level이 0이면서 level값이 같은 행이 존재하지 않으면 현재 행 이후의 모든 행을 제거한다.
					 */
					if(this.attr('treestate').grouped === true)
					{
						nNextExpandedGroupTreeUIRow = this._seekNextExpandedTreeUIRow(objNode,nRow) ;
					}else{
						nNextExpandedGroupTreeUIRow = this._seekNextExpandedGroupTreeUIRow(objNode.level);	
					}
					

					/* STEP 3-2: 삭제 될 행 수와 삭제될 행 중에 접고/펼치기 UI를 표시하는 행의 수를 계산 */
					if(nNextExpandedGroupTreeUIRow > -1){
						nRemovedRowCount = nNextExpandedGroupTreeUIRow - nRow - 1;

						QBOX.$.each(arrGroupTreeUIRows, function(idx, row){
							if(row < nNextExpandedGroupTreeUIRow){
								nRemovedGroupTreeUIRowCount += 1;
							} else{
								return false;
							}
						});

//						QBOX.$.each(arrGroupHeaderRows, function(idx, row){
//							if(row < nNextExpandedGroupTreeUIRow){
//								nRemovedGroupHeaderRowCount += 1;
//							} else{
//								return false;
//							}
//						});

//						QBOX.$.each(arrGroupFooterRows, function(idx, row){
//							if(row < nNextExpandedGroupTreeUIRow){
//								nRemovedGroupFooterRowCount += 1;
//							} else{
//								return false;
//							}
//						});
					} else{
						nRemovedRowCount = this.attr('rows') - nRow - 1;

						//"calculation" 속성 사용 시 position이 bottom인 경우 현재 행 이후의 모든 행을 삭제하되 마지막 행은 삭제하면 안된다.
//						if(htGroupInfo.get('grandcalculation') != null && htGroupInfo.get('grandcalculation').position == 'bottom'){
//							nRemovedRowCount -= 1;
//						}

						nRemovedGroupTreeUIRowCount = arrGroupTreeUIRows.length;
//						nRemovedGroupHeaderRowCount = arrGroupHeaderRows.length;
//						nRemovedGroupFooterRowCount = arrGroupFooterRows.length;
					}

					/* STEP 3-3: 삭제될 행 중에 접고/펼치기 UI를 표시하는 행이 있는 경우 'treeuirows', 'treeuirownodes' 정보에서 제거한다. */
					arrGroupTreeUIRows.splice(0, nRemovedGroupTreeUIRowCount);
					arrGroupTreeUIRowNodes.splice(0, nRemovedGroupTreeUIRowCount);
//					arrGroupHeaderRows.splice(0, nRemovedGroupHeaderRowCount);
//					arrGroupHeaderRowNodes.splice(0, nRemovedGroupHeaderRowCount);
//					arrGroupFooterRows.splice(0, nRemovedGroupFooterRowCount);
//					arrGroupFooterRowNodes.splice(0, nRemovedGroupFooterRowCount);
				} else{
					/* STEP 3-1: 현재 행이 최하위 노드인 경우  삭제 될 행 수는 'data'속성값과 같다. */
					nRemovedRowCount = objNode.data.size() + (objNode.header ? 1 : 0) + (objNode.footer ? 1 : 0);
					bLast = true;
				}

//				console.log("nRemovedRowCount:", nRemovedRowCount);
//				console.log("arrGroupTreeUIRowsBackup: ", JSON.stringify(arrGroupTreeUIRowsBackup));
//				console.log("삭제된 행 제거 전 arrGroupHeaderRows: ", JSON.stringify(arrGroupHeaderRows));
//				console.log("삭제된 행 제거 전 arrGroupFooterRows: ", JSON.stringify(arrGroupFooterRows));

				/* STEP 4: 삭제될 행 중에 그룹헤더/푸터를 표시하는 행이 있는 경우 'headerrows', 'headerrownodes', 'footerrows', 'footerrownodes' 정보에서 제거한다. */
				if(arrGroupTreeUIRows.length > 0){
					QBOX.$.each(arrGroupHeaderRows, function(idx, row){
						if(row < arrGroupTreeUIRows[0]){
							nRemovedGroupHeaderRowCount += 1;
						} else{
							return false;
						}
					});
					arrGroupHeaderRows.splice(0, nRemovedGroupHeaderRowCount);
					arrGroupHeaderRowNodes.splice(0, nRemovedGroupHeaderRowCount);
//					console.log("삭제된 행 제거 후 arrGroupHeaderRows: ", JSON.stringify(arrGroupHeaderRows));

					//nNextExpandedGroupTreeUIRow = this._seekNextExpandedGroupTreeUIRow(objNode.level);
					QBOX.$.each(arrGroupFooterRows, function(idx, row){
						if(row < nNextExpandedGroupTreeUIRow){
							nRemovedGroupFooterRowCount += 1;
						} else{
							return false;
						}
					});
					
					arrGroupFooterRows.splice(0, nRemovedGroupFooterRowCount);
					arrGroupFooterRowNodes.splice(0, nRemovedGroupFooterRowCount);
//					console.log("삭제된 행 제거 후 arrGroupFooterRows: ", JSON.stringify(arrGroupFooterRows));
					
				}
				
				if(bLast === true){/*
					var nFind = -1,nHeaderFoooterIndex =0;
					
					for(nHeaderFoooterIndex = 0 ; nHeaderFoooterIndex < arrGroupHeaderRows.length;nHeaderFoooterIndex++ ){
						if(arrGroupHeaderRows[nHeaderFoooterIndex] > nRow ){
							nFind = nHeaderFoooterIndex;
							break;
						}
					}
					
					if(nFind >= 0 ){
						arrGroupHeaderRows.splice(nFind, arrGroupHeaderRows.length);
						arrGroupHeaderRowNodes.splice(nFind, arrGroupHeaderRowNodes.length);
					}
					nFind = -1;
					for(nHeaderFoooterIndex = 0 ; nHeaderFoooterIndex < arrGroupFooterRows.length;nHeaderFoooterIndex++ ){
						if(arrGroupFooterRows[nHeaderFoooterIndex] > nRow ){
							nFind = nHeaderFoooterIndex;
							break;
						}
					}
					if(nFind >= 0 ){
						arrGroupFooterRows.splice(nFind, arrGroupHeaderRows.length);
						arrGroupFooterRowNodes.splice(nFind, arrGroupFooterRowNodes.length);
					}*/
				}

				/* STEP 5: 접히고 나면 삭제 될 행 수 만큼의 행 인덱스 번호가 감소하므로 'treeuirows', 'treeuirownodes', 'headerrows', 'headerrownodes', 'footerrows', 'footerrownodes' 정보의 행 번호 동기화 */
//				console.log("보정전 arrGroupTreeUIRows: ", JSON.stringify(arrGroupTreeUIRows));
				for(i = 0, nLength = arrGroupTreeUIRows.length; i < nLength; i++){
					arrGroupTreeUIRows[i] -= nRemovedRowCount;
				}
//				console.log("보정후 arrGroupTreeUIRows: ", JSON.stringify(arrGroupTreeUIRows));
//				console.log("보정전 arrGroupHeaderRows: ", JSON.stringify(arrGroupHeaderRows));
				for(i = 0, nLength = arrGroupHeaderRows.length; i < nLength; i++){
					arrGroupHeaderRows[i] -= nRemovedRowCount;
				}
//				console.log("보정후 arrGroupHeaderRows: ", JSON.stringify(arrGroupHeaderRows));
//				console.log("보정전 arrGroupFooterRows: ", JSON.stringify(arrGroupFooterRows));
				for(i = 0, nLength = arrGroupFooterRows.length; i < nLength; i++){
					arrGroupFooterRows[i] -= nRemovedRowCount;
				}
				
				var temp = arrGroupTreeUIRowsBackup.concat(arrGroupTreeUIRows);
				var tempNode = arrGroupTreeUIRowNodesBackup.concat(arrGroupTreeUIRowNodes);
				if(nRow === temp[temp.length -1] && (tempNode[tempNode.length -1].level === 0) && nRow === temp[tempNode.length -1]){
					if(!QBOX._.isUndefined(objGroupState.outer) && !QBOX._.isUndefined(objGroupState.outer.footer)){ //outer에 header가 선언되어 있는 경우
						nRemovedRowCount = objGroupState.data.length -1;
					}
				}
				
//				console.log("보정후 arrGroupFooterRows: ", JSON.stringify(arrGroupFooterRows));
				
				/* STEP 6: 계산된 수 만큼 행 데이터를 삭제한다. */
				objGroupState.data.splice(0, nRemovedRowCount);
				
				/* STEP 7: 백업 해 두었던 정보들과 합친다. */
//				console.log("10 arrGroupHeaderRows:", JSON.stringify(arrGroupHeaderRows));
//				console.log("11 arrGroupHeaderRowsBackup:", JSON.stringify(arrGroupHeaderRowsBackup));
				//console.log("arrGroupFooterRowsBackup:", JSON.stringify(arrGroupFooterRowsBackup));
				//console.log("arrGroupFooterRows:", JSON.stringify(arrGroupFooterRows));
				objGroupState.treeuirows = arrGroupTreeUIRowsBackup.concat(arrGroupTreeUIRows);
				objGroupState.treeuirownodes = arrGroupTreeUIRowNodesBackup.concat(arrGroupTreeUIRowNodes);
				objGroupState.headerrows = arrGroupHeaderRowsBackup.concat(arrGroupHeaderRows);
				objGroupState.headerrownodes = arrGroupHeaderRowNodesBackup.concat(arrGroupHeaderRowNodes);
				objGroupState.footerrows = arrGroupFooterRowsBackup.concat(arrGroupFooterRows);
				objGroupState.footerrownodes = arrGroupFooterRowNodesBackup.concat(arrGroupFooterRowNodes);
				
				objGroupState.data = arrGroupDataBackup.concat(objGroupState.data);
				
				if(nRow === objGroupState.treeuirows[objGroupState.treeuirows.length -1] && (objGroupState.treeuirownodes[objGroupState.treeuirownodes.length-1].level === 0) && nRow === objGroupState.treeuirows[objGroupState.treeuirownodes.length -1]){
					if(!QBOX._.isUndefined(objGroupState.outer) && !QBOX._.isUndefined(objGroupState.outer.footer)){ //outer에 header가 선언되어 있는 경우
						for(i = 0; i < objGroupState.footerrows.length; i++){
							for(j = 0; j < objGroupState.treeuirows.length; j++){
								if(objGroupState.footerrows[i] === objGroupState.treeuirows[j]){
									objGroupState.footerrows[i] = objGroupState.footerrows[i] + 1;
								}
							}
						}
					}
				}
				
//				console.log("12 headerrows: ", JSON.stringify(objGroupState.headerrows));
//				console.log("footerrows: ", JSON.stringify(objGroupState.footerrows));

				objNode.expand = false;
			} else{
				return false;
			}
		}
		objGroupState.footerrows = [];
		objGroupState.headerrows = [];
		
		for(var xx = 0; xx <objGroupState.data.length; xx++ ){
			if(objGroupState.data[xx].rt_qc_footer !== undefined && objGroupState.data[xx].rt_qc_footer === true){
				objGroupState.footerrows.push ( xx + nHeaderRows);
			} 
			if(objGroupState.data[xx].rt_qc_header !== undefined && objGroupState.data[xx].rt_qc_header === true){
				objGroupState.headerrows.push ( xx + nHeaderRows);
			} 
		}

		var bRet = this._setCurrentData(objGroupState.data.RT_clone(), false,true);
			
			if(objNode.expand && QBOX._.isFunction(objGroupState.expand)){
				objGroupState.expand(objNode.colid,objNode.colkey,objNode.key,nRow,this._getColOfID(objNode.colid));
			}else if(!objNode.expand && QBOX._.isFunction(objGroupState.collapse)){
				objGroupState.collapse(objNode.colid,objNode.colkey,objNode.key,nRow,this._getColOfID(objNode.colid));
			}

		this._trigger('treeuiclicked' ,{'nRow' : nRow, 'bExpand':bExpand});
		return bRet;
	}

	return false;
};


QBOX.QCELL.BasicQCELL.prototype._setExpandOfGroupNodes = function(htNodes, nLevel, bExpand, bDependentChild){
	var objQCell = this;

	QBOX._.each(htNodes.keys(), function(key){
		var objNode = htNodes.get(key);

		if(bDependentChild){
			if(objNode.isparent){
				objQCell._setExpandOfGroupNodes(objNode.childnodes, nLevel, bExpand, bDependentChild);
			}

			if(nLevel <= objNode.level){//nLevel과 같은 레벨이거나 하위 레벨인 경우 모두 변경
				objNode.expand = bExpand;
			}
		} else{
			if(nLevel === objNode.level){//nLevel과 같은 레벨이거나 하위 레벨인 경우 모두 변경
				objNode.expand = bExpand;
			} else{
				if(objNode.isparent && nLevel > objNode.level){
					objQCell._setExpandOfGroupNodes(objNode.childnodes, nLevel, bExpand, bDependentChild);
				}
			}
		}
	});
};

QBOX.QCELL.BasicQCELL.prototype._setExpandOfGroupLevel = function(nLevel, bExpand, bDependentChild){
	var objGroupState = this.attr('groupstate');

	if(objGroupState.grouped){
		this._setExpandOfGroupNodes(objGroupState.nodes, nLevel, bExpand, bDependentChild);

		/* STEP 1: 'nodes' 정보를 이용해 그리드 행 데이터 생성 */
		if(this._makeGroupData()){
			/* STEP 2: 그룹데이터로 currentdata 변경 */
			return this._setCurrentData(objGroupState.data, false);
		}

		return false;
	}
};
QBOX.QCELL.BasicQCELL.prototype._setGroupTreeUICell = function(heCell, objNode, cellData){
	var objQCell = this,
	css = QBOX.QCELL.def.css,
	objGroupState = this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
	heArrow = document.createElement('span'),
	heFolder = document.createElement('span'),
	nRow = parseInt(heCell.getAttribute('data-row')),
	nCol = parseInt(heCell.getAttribute('data-col')),
	type = objGroupState.type,
	strData = objGroupState.presentkey === true ? objNode.key : cellData,
	treeuirow = false,
	strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata');

	QBOX.util.bind([heArrow, heFolder], 'click', function(event){
		objQCell._setExpandOfGroupTreeUIRow(nRow, !(objNode.expand));
		if(objQCell.attr('usetreeall')){
/*			objQCell._calculateDynamicRows();
			objQCell._adjustScrollPos();
			objQCell._adjustNormalRowsTop();
			objQCell._resizeVScrollbar(true);
			objQCell._updateNRs();*/
		}
	});
	
	if(this.attr('treestate').grouped === true){
		strData = objNode.showLabel === true ? objNode._rowData[objNode.label] : objNode.key;
		if(strData === undefined)
			strData = '';
		
		if(objNode.level > 1 && this.attr('treestate').exclude.length > 0){
			for(var t=0; t< this.attr('treestate').exclude.length ; t++ ){
				if(this.attr('treestate').exclude[t] === this._getKeyOfCol(nCol)){
					strData = '';
					break;
				}
			}
		}
	}
	
	if(objNode !== null){
		if(type === 'step'){
			heArrow.style.marginLeft = (objNode.level > 0 ? 0 * (objNode.level) : 0) + 'px';
		} else {
			heArrow.style.marginLeft = (objNode.level > 0 ? 20 * (objNode.level) : 0) + 'px';
		}
		
		//레벨 별 paddingleft 처리
		QBOX.util.addClass(heArrow, [css.GROUPTREEUI, css.GROUPTREEUI_ARROW, objNode.expand ? css.GROUPTREEUI_ARROW_EXPAND : css.GROUPTREEUI_ARROW_COLLAPSE]);
		QBOX.util.addClass(heFolder, [css.GROUPTREEUI, css.GROUPTREEUI_FOLDER, objNode.expand ? css.GROUPTREEUI_FOLDER_EXPAND : css.GROUPTREEUI_FOLDER_COLLAPSE]);
	}
	else {
		heArrow.style.marginLeft = '0px';
		
		//레벨 별 paddingleft 처리
		//QBOX.util.addClass(heArrow, [css.GROUPTREEUI, css.GROUPTREEUI_ARROW, css.GROUPTREEUI_ARROW_COLLAPSE]);
		//QBOX.util.addClass(heFolder, [css.GROUPTREEUI, css.GROUPTREEUI_FOLDER, css.GROUPTREEUI_FOLDER_COLLAPSE]);
	}

	heCell.innerHTML = ''; // heCell child 초기화

	if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
		heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strData);
	}
	else {
		QBOX.util.textContent(heCell, strData);
	}
	
	for(var i = 0; i < objGroupState.treeuirows.length; i++){
		if(objGroupState.treeuirows[i] === nRow){
			treeuirow = true;
			break;
		}
	}
	
	if(treeuirow){
		heCell.insertBefore(heFolder, heCell.firstChild);
		heCell.insertBefore(heArrow, heCell.firstChild);
	}
	
	if(!isNaN(nRow) && nRow>0 && !isNaN(nRow) && nCol>0)
		this._setAriaLabel(heCell, nRow,nCol,strData);

	return true;
};

QBOX.QCELL.BasicQCELL.prototype._setGroupTreeDataCell = function(heCell, cellData,rowData){
	var css = QBOX.QCELL.def.css,
	heDot = document.createElement('span'),
	objGroupState = this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
	hidekeydata = objGroupState.hidekeydata,
	type = objGroupState.type,
	strLeafNodeKey = objGroupState.leafnodekey,
	nCol = parseInt(heCell.getAttribute('data-col')),
	strColStyleEditorData = this._getQCellCol(nCol).attr('colstyleeditordata'),
	nSize = 1,
	htGroupColumnsInfo, nIndent = objGroupState.leafindent === undefined ? 0 : objGroupState.leafindent,
			bSkip = false;
	
	if(this.attr('groupstate').grouped){
		nSize = objGroupState.columnsinfo.size();
	}else if( this.attr('treestate').grouped) {
		if( rowData === undefined)
			return;
		
		nSize = rowData[objGroupState.level];
		if(nSize === undefined){
			heCell.innerHTML = '';
			return;
		}
		
		
		htGroupColumnsInfo = objGroupState.columnsinfo;
		var arrColumns = htGroupColumnsInfo.keys(true);
		var strKey = this._getKeyOfColID(arrColumns[nSize - 1]) === -1 ? arrColumns[nSize - 1]:  this._getKeyOfColID(arrColumns[nSize - 1]);
		cellData = rowData[strKey];

		
		var showLabel = htGroupColumnsInfo.get(arrColumns[nSize - 1]).showLabel,
		strLabel	= htGroupColumnsInfo.get(arrColumns[nSize - 1]).label;
		
		if(showLabel === true) cellData = rowData[strLabel];
		
		if(cellData === undefined)
			cellData = '';
		
		if(nSize > 1 && this.attr('treestate').exclude.length > 0){
			for(var t=0; t< this.attr('treestate').exclude.length ; t++ ){
				if(this.attr('treestate').exclude[t] === this._getKeyOfCol(nCol)){
					cellData = '';
					bSkip = true;
					break;
				}
			}
		}	
		
	}
		
	if(strLeafNodeKey !== undefined && strLeafNodeKey !== null && QBOX._.isString(strLeafNodeKey)){
		cellData = rowData[strLeafNodeKey];
	}
	if(type === 'step'){
		heDot.style.marginLeft = (20 - nIndent) + 'px';
	} else {
		heDot.style.marginLeft = ( (20 * nSize)  -nIndent ) + 'px';
	}
	
	QBOX.util.addClass(heDot, [css.GROUPTREEUI, css.GROUPTREEUI_DOT]);
	
	heCell.innerHTML = ''; // heCell child 초기화
	
	if((type === 'tree' || type === 'step') && hidekeydata)
		return true;
	
	if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
		heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
	}
	else {
		QBOX.util.textContent(heCell, cellData);
	}

	if(bSkip === false)
	heCell.insertBefore(heDot, heCell.firstChild);
	var nRow = parseInt(heCell.getAttribute("data-row"));
	
	if(!isNaN(nRow) && nRow>0 && !isNaN(nRow) && nCol>0)
		this._setAriaLabel(heCell, nRow,nCol,cellData);	
	return true;
};

QBOX.QCELL.BasicQCELL.prototype._setGroupThroughGroupInfo = function(arrGroupColKeys){
	//QCELL생성 시 설정했던 그룹화 정보에서 colkey값에 대응하는 정보를 찾아 그룹화한다.
	var objGroupInfo = this.attr('groupinfo'),
	objGroupProps = {type	: objGroupInfo.type, columns	: []};

	QBOX._.each(arrGroupColKeys, function(colkey){
		objGroupProps.columns.push({
			key			: colkey,
			expand	: objGroupInfo.expand[colkey] === undefined ? true : objGroupInfo.expand[colkey],
			header	: objGroupInfo.header[colkey] === undefined ? {} : objGroupInfo.header[colkey],
			footer	: objGroupInfo.footer[colkey] === undefined ? {} : objGroupInfo.footer[colkey]
		});
	});

	return this._setGroup(objGroupProps);
};

// draggable의 clone대신 현재 header를 복사하여 사용
QBOX.QCELL.BasicQCELL.prototype._setGroupMakeHelper = function(e){
	var newSpan = QBOX.$(e.currentTarget).find('span').clone(true),
	newDiv = QBOX.$(e.currentTarget).clone(true).removeClass('ui-draggable-dragging').css({
        'position': 'relative',
        'top': 0, 
        'left': 0,
        'z-index': 9
    }).empty();
	newDiv.append(newSpan);
	
	if(!QBOX.$('.'+QBOX.QCELL.def.css.ROOT).children(':last').is('.rt-qc-ui-draggable')){
	   QBOX.$('.'+QBOX.QCELL.def.css.ROOT).append(newDiv); //This is the new div we are appending 
	   QBOX.$(newDiv).draggable({
		   connectToSortable: '.'+QBOX.QCELL.def.css.GROUPUI_INNER
	   }); //I want the appneded element draggable too
	}
	
	return QBOX.$('.'+QBOX.QCELL.def.css.ROOT).children(':last');
};

// target의 내부의 data-column을 가지고있는 tag에서 groupuiinfo정리 후 group화
QBOX.QCELL.BasicQCELL.prototype._setGroupUIInfo = function(heTargets){
	var groupuiInfo = this.attr('groupuiinfo');
	QBOX._.each(heTargets, function(heTarget){
		groupuiInfo.push(heTarget.getAttribute('data-column'));
	});
	this._setGroupUIForGroup();
};

// groupuiinfo를 통해 group을 구현시킨다
QBOX.QCELL.BasicQCELL.prototype._setGroupUIForGroup = function(){
	var groupuiInfo = this.attr('groupuiinfo');
	var colArr = [];
	for(var i = 0; i < groupuiInfo.length; i++){
		var keyTemp = {};
		keyTemp.key = groupuiInfo[i];
		colArr.push(keyTemp);
	}
	
	this._clearGroup();
	if(groupuiInfo.length > 0){
		this._clearGroup();
		this._setGroup({
			type: 'tree', //normal or tree
			columns: colArr
		});
	}
};
QBOX.QCELL.BasicQCELL.prototype._getGroupNode = function(arrRowData,strKeyOfCol){
	var objGroupState = this.attr('groupstate') , htNodes;
	arrGroupCols = objGroupState.columnsinfo.keys(true);
	var strData,strKey,objNode = null,i;
	
	htNodes = objGroupState.nodes;
	for(i=0;i<arrGroupCols.length;i++){
		strKey = this._getKeyOfColID (arrGroupCols[i]);
		if(strKey !== undefined ){
			strData = arrRowData[strKey];
			
			if(QBOX._.isUndefined(strData)){
				return null;
			}else{
				if(htNodes.get(strData) !== null){
					if(htNodes.get(strData).colkey === strKeyOfCol){
						return htNodes.get(strData);
					}					
					else {
						htNodes = htNodes.get(strData).childnodes;
					}
				}else return null;				
			}
		}
	
	}
	return null;
};

QBOX.QCELL.BasicQCELL.prototype._setExpandOfGroupUIRow = function(nRow, bExpand,objNode){
	var objGroupState = this.attr('groupstate'),
	arrOriginData = this.attr('data').input,
	arrGroupTreeUIRows = objGroupState.groupuirows[objNode.colid],
	arrGroupTreeUIRowNodes = objGroupState.groupuinodes[objNode.colid],
	arrGroupHeaderRows = objGroupState.headerrows,
	arrGroupHeaderRowNodes = objGroupState.headerrownodes,
	arrGroupFooterRows = objGroupState.footerrows,
	arrGroupFooterRowNodes = objGroupState.footerrownodes,
	arrGroupDataBackup,
	arrGroupTreeUIRowsBackup,
	arrGroupTreeUIRowNodesBackup,
	arrGroupHeaderRowsBackup,
	arrGroupHeaderRowNodesBackup,
	arrGroupFooterRowsBackup,
	arrGroupFooterRowNodesBackup,
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	nIdxOfGroupTreeUIRow = -1,
	nIdxOfGroupHeaderRow,
	nIdxOfGroupFooterRow,
	nLength, i,nIndex,nPrevRow,arrTempBackup,objTemp,strKey;
	
	if(objGroupState.type === 'group'){
		nIndex = 0;
		do{
			nIdxOfGroupTreeUIRow =   QBOX._.indexOf(arrGroupTreeUIRows, nRow -nIndex, true) ;	
		}while(nIdxOfGroupTreeUIRow === -1 && nRow-nHeaderRows -nIndex++ >=0);
				
	}
	
	if(nIdxOfGroupTreeUIRow > -1){
		var objQCell = this;
		nPrevRow = nRow;
		nRow = arrGroupTreeUIRows[nIdxOfGroupTreeUIRow];

		if(bExpand){//펼칠 때
			if(objNode.expand === false){//접혀 있어 펼칠 수 있을 때만

				var nBeforeCount = 0,	//펼치기 전 그리드 행 데이터 수
				nAddedRowCount = 0,		//펼쳐졌을 때 펼치기 전과의 행 데이터 수 차이
				strDataType = this.attr('data').type,
				strColID = objNode.colid,
				fnSetHeaderTextCallback = function(arrTexts, colkey){
					objQCell._setGroupHeaderFooterText(objNode, rowData, arrTexts, colkey,true);
				},
				fnSetFooterTextCallback = function(arrTexts, colkey){
					objQCell._setGroupHeaderFooterText(objNode, rowData, arrTexts, colkey,false);
				},
				fnPushTargetRowDataCallback = function(idx){
					//idx: 그리드의 행 인덱스가 아니라 JSON 데이터의 인덱스를 의미
					objGroupState.data.push(arrOriginData[idx]);
				},
				htGroupColumnsInfo = objGroupState.columnsinfo,
				objGroupColumnInfo = htGroupColumnsInfo.get(strColID),
				rowDataTemp = strDataType === 'array' ? [] : {},
				rowData;

				nIdxOfGroupHeaderRow = QBOX._.findIndex(arrGroupHeaderRows, function(row){
					return row > nRow;});//nRow보다 큰 값 중에서 가장 작은 값의 인덱스
				nIdxOfGroupFooterRow = QBOX._.findIndex(arrGroupFooterRows, function(row){
					return row > nRow;});

				/* STEP 1: 현재 행 이후의 정보들을 임시로 백업한다. */
				arrTempBackup = objGroupState.data.splice(nRow - nHeaderRows , 1);						//그리드 데이터 백업
				arrGroupDataBackup = objGroupState.data.splice(nRow - nHeaderRows, objGroupState.data.length - (nRow - nHeaderRows ));						//그리드 데이터 백업

				nBeforeCount = objGroupState.data.length;	//펼치기 전의 그리드 행 데이터 수를 저장한다.
				objNode.expand = true;						//expand 플래그를 true로 설정해야 this._makeGroupDatum()에서 자동으로 데이터를 생성한다.

				/* 현재 노드의 헤더 행 추가 */
				
				/* STEP 3: 펼쳐져서 표시될 데이터를 생성하여 그리드 행 데이터로 추가한다. */
				var obj = {};
				obj[objNode.colkey] = objNode.key;
				if(objNode.isparent){//현재 노드가 자식 노드를 가지고 있으면
					var nTemp = objGroupState.data.length;
					this._makeGroupDatum(objNode.childnodes,obj);					
					objTemp=arrTempBackup[0];
					for(strKey in objTemp){
						if(!QBOX._.has(objGroupState.data[nTemp],strKey)){
							objGroupState.data[nTemp][strKey] = objTemp[strKey];
						}								
					}
					
				} else{
					var nFirst = objGroupState.data.length;
					//현재 노드가 최 하위 노드이면 'childnodes'정보를 탐색하여 자식 노드들을 만들 필요가 없으니 행 데이터를 바로 추가한다.
					QBOX._.each(objNode.data.values().sort(QBOX.st.asc), fnPushTargetRowDataCallback);
					objGroupState.data[nFirst]['qc_row_ui_' + objNode.colid] = true;
					objGroupState.data[nFirst]['qc_row_ui_' + objNode.colid + '_nodes'] = objNode;
					if(objNode.footer)
					nBeforeCount++;
				}
				
				nAddedRowCount = objGroupState.data.length - nBeforeCount;		//펼쳐져서 추가된 행의 수를 계산한다.

				objGroupState.data = objGroupState.data.concat(arrGroupDataBackup);
				
				this._initGroupData();

			} else{
				return false;
			}
		} else{//접을 때
			if(objNode.expand){//펼쳐져 있어 접을 수 있을 때만 접기를 수행
				var nRemovedRowCount = 0,	//삭제 할 행 데이터 수
				nRemovedGroupHeaderRowCount = 0,//objGroupState.headerrows, objGroupState.headerrownodes 배열에서 삭제되어야 할 개수
				nRemovedGroupFooterRowCount = 0;//objGroupState.footerrows, objGroupState.footerrownodes 배열에서 삭제되어야 할 개수

				nIdxOfGroupHeaderRow = QBOX._.findLastIndex(arrGroupHeaderRows, function(row){ return row < nPrevRow;});//nRow보다 작은 값중에서 가장 큰 값의 인덱스
				nIdxOfGroupFooterRow = QBOX._.findLastIndex(arrGroupFooterRows, function(row){ return row < nPrevRow;});


				/* STEP 1: 현재 행 이전의 정보들을 임시로 백업한다. */
				arrGroupDataBackup = objGroupState.data.splice(0, nRow - nHeaderRows + 1);		//그리드 데이터 백업
	

				/* STEP 3: 접어서 삭제 될 행 수를 계산한다. */
				if(objNode.isparent){//자식 노드가 있는 경우
					var nRemovedGroupTreeUIRowCount = 0,		//objGroupState.treeuirows, objGroupState.treeuirownodes 배열에서 삭제되어야 할 개수
					nNextExpandedGroupTreeUIRow;

					nNextExpandedGroupTreeUIRow = this._seekNextExpandedGroupUIRow(nRow,objNode.level,objNode.colid);

					/* STEP 3-2: 삭제 될 행 수와 삭제될 행 중에 접고/펼치기 UI를 표시하는 행의 수를 계산 */
					if(nNextExpandedGroupTreeUIRow > -1){
						nRemovedRowCount = nNextExpandedGroupTreeUIRow - nRow -1;

					} else{
						nRemovedRowCount = this.attr('rows') - nRow - 1;

						nRemovedGroupTreeUIRowCount = arrGroupTreeUIRows.length;
					}



				} else{
					/* STEP 3-1: 현재 행이 최하위 노드인 경우  삭제 될 행 수는 'data'속성값과 같다. */
					nRemovedRowCount = objNode.data.size() -1;
				}

				/* STEP 6: 계산된 수 만큼 행 데이터를 삭제한다. */
				arrTempBackup = objGroupState.data.splice(0, nRemovedRowCount);

				objGroupState.data = arrGroupDataBackup.concat(objGroupState.data);
				this._initGroupData();
				objNode.expand = false;
			} else{
				return false;
			}
		}
		
		var bRet = this._setCurrentData(objGroupState.data.RT_clone(), false);
		
		if(objNode.expand && QBOX._.isFunction(objGroupState.expand)){
			objGroupState.expand(objNode.colid,objNode.colkey,objNode.key,nRow,this._getColOfID(objNode.colid));
		}else if(!objNode.expand && QBOX._.isFunction(objGroupState.collapse)){
			objGroupState.collapse(objNode.colid,objNode.colkey,objNode.key,nRow,this._getColOfID(objNode.colid));
		}

		return bRet;
	}

	return false;
};

QBOX.QCELL.BasicQCELL.prototype._setGroupUICell = function(heCell, objNode, cellData){
	var objQCell = this,
	css = QBOX.QCELL.def.css,
	heArrow = document.createElement('span'),
	heFolder = document.createElement('span'),
	nRow = parseInt(heCell.getAttribute('data-row'));

	QBOX.util.bind([heArrow, heFolder], 'click', function(event){
		objQCell._setExpandOfGroupUIRow(nRow, !(objNode.expand),objNode);
	});

	heArrow.style.marginLeft = '0px';

	//레벨 별 paddingleft 처리
	QBOX.util.addClass(heArrow, [css.GROUPTREEUI, css.GROUPTREEUI_ARROW, objNode.expand ? css.GROUPTREEUI_ARROW_EXPAND : css.GROUPTREEUI_ARROW_COLLAPSE]);
	QBOX.util.addClass(heFolder, [css.GROUPTREEUI, css.GROUPTREEUI_FOLDER, objNode.expand ? css.GROUPTREEUI_FOLDER_EXPAND : css.GROUPTREEUI_FOLDER_COLLAPSE]);

	heCell.innerHTML = ''; // heCell child 초기화

	QBOX.util.textContent(heCell, cellData);

	heCell.insertBefore(heFolder, heCell.firstChild);
	heCell.insertBefore(heArrow, heCell.firstChild);

	return true;
};

QBOX.QCELL.BasicQCELL.prototype._seekNextExpandedGroupUIRow = function(nRow,nLevel,strKey){
	var objGroupState = this.attr('groupstate'),
	arrGroupTreeUIRows = objGroupState.groupuirows[strKey],
	arrGroupTreeUIRowNodes = objGroupState.groupuinodes[strKey],
	nNextExpandedGroupTreeUIRow = -1;

	/* nNextExpandedGroupTreeUIRow 계산방법
	 * 현재 행과 level값이 같은 행이 존재하면 그 행 이전까지 접는다.
	 * 현재 행과 level값이 같은 행이 없다면 부모 노드와 level값이 같은 행의 존재 여부를 확인하여 그 행 이전까지 접는다.
	 * 부모 노드와 level값이 같은 행도 없다면 또 상위 부모 노드로 탐색하면서 같은 작업을 반복한다.
	 * level이 0이면서 level값이 같은 행이 존재하지 않으면 현재 행 이후의 모든 행을 제거한다.
	 */

	if(nLevel > 0){
		//현재 level값을 가진 행을 찾되 부모 level과 같은 행이 나타나기 이전까지만 찾아야 한다.
		QBOX.$.each(arrGroupTreeUIRows, function(idx, row){
			var objNodeTemp = arrGroupTreeUIRowNodes[idx];

			if(objNodeTemp.level === (nLevel - 1)){
				return false;
			} else if(objNodeTemp.level === nLevel){
				nNextExpandedGroupTreeUIRow = row;

				return false;
			}
		});
	} else{
		QBOX.$.each(arrGroupTreeUIRows, function(idx, row){
			if(arrGroupTreeUIRowNodes[idx].level === nLevel && nRow < row){
				nNextExpandedGroupTreeUIRow = row;

				return false;
			}
		});
	}

	if(nNextExpandedGroupTreeUIRow === -1 && nLevel > 0){
		return this._seekNextExpandedGroupUIRow(nLevel - 1);
	} else{
		return nNextExpandedGroupTreeUIRow;
	}
};

QBOX.QCELL.BasicQCELL.prototype._setGrandTotal = function(objGroupProps){
	//0 정보 생성
	//1. 로우 추가.
	//2. 정보 설정
	//3. 화면 반영
	
	var objQCell = this,i,rowData,fnSetTotalHeaderFooterTextCallback = function(arrTexts, colkey){
		objQCell._setGroupTotalHeaderFooterText(rowData, arrTexts, colkey,false,false);
	};
	
	var arrHeaders = [],arrFooter = [];
	
	if(QBOX._.isArray(objGroupProps.footer)){
		for(i=0;i<objGroupProps.footer.length; i++){
			rowData = {_rtqc_state:'gt'};
			QBOX._.each(objGroupProps.footer[i], fnSetTotalHeaderFooterTextCallback);
			arrFooter.push(QBOX._.clone(rowData));
			
		}		
	}		
	
	if(QBOX._.isArray(objGroupProps.header)){
		for(i=0;i<objGroupProps.header.length; i++){
			rowData = {_rtqc_state:'gt'};
			QBOX._.each(objGroupProps.header[i], fnSetTotalHeaderFooterTextCallback);	
			arrHeaders.push(QBOX._.clone(rowData));
			
		}
		
	}
	
	for(i=0; i<arrFooter.length;i++){
		this.insertRow(this.getRows(), arrFooter[i]);
	}
	
	for(i=arrHeaders.length -1 ; i>=0;i--){
		this.insertRow(this.getRows('header'), arrHeaders[i]);
	}
	
	return false;
};
QBOX.QCELL.BasicQCELL.prototype._clearGrandTotal = function(){
	var nHeaderRows = this.getRows('header');
	for(var i = this.getRows()-1 ; i>=nHeaderRows ; i-- ){
		var objRowData = this.getRowData(i);
		if(objRowData._rtqc_state === 'gt')
			this._deleteRows(i,1);
	}
};


QBOX.QCELL.BasicQCELL.prototype._setTree = function(objGroupProps){
	
	if(this.attr('useall') === true){
		QBOX.QCELL.isForceDynamic = true;
		this.attr('usetreeall' ,true, 'boolean');		
		this._rebuild();
		this._setTree(objGroupProps);
		return;
	}
	
	if(this._checkValidationOfGroupProps(objGroupProps)){
		
		var objQCell = this,
		objGroupState = this.attr('treestate'),
		htGroupColumnsInfo = objGroupState.columnsinfo,
		nHeaderCols = this.attr('headercols');

		this.attr('_treeProps', QBOX._.clone(objGroupProps),'object');
		
		objGroupState.grouped = true;

		objGroupState.level = QBOX._.has(objGroupProps, 'level') && QBOX._.isString(objGroupProps.level) ? objGroupProps.level : 'level';
		
		objGroupState.treeUIColumn = QBOX._.has(objGroupProps, 'treeUIColumn') && QBOX._.isString(objGroupProps.treeUIColumn) ? objGroupProps.treeUIColumn : 'level';
		
		objGroupState.expand = QBOX._.has(objGroupProps, 'expand') && QBOX._.isFunction(objGroupProps.expand) ? objGroupProps.expand : null ;
		objGroupState.collapse = QBOX._.has(objGroupProps, 'collapse') && QBOX._.isFunction(objGroupProps.collapse) ? objGroupProps.collapse : null ;
		objGroupState.leafindent = QBOX._.has(objGroupProps, 'leafindent') ? objGroupProps.leafindent : 0;
		
		objGroupState.linkedcheckbox = objGroupProps.linkedcheckbox === 'rowheader' ? '_rt_qc_rowheader' : objGroupProps.linkedcheckbox ;
		objGroupState.exclude = objGroupProps.exclude === undefined? [] : objGroupProps.exclude; 
		
		if(QBOX._.has(objGroupProps, 'sort') &&  QBOX._.isString(objGroupProps.sort)){
			if(objGroupProps.sort === 'none'){
				objGroupState.sort ='none';				
			}
			else if(objGroupProps.sort === 'asc'){
				objGroupState.sort ='asc';				
			}
			else if(objGroupProps.sort === 'desc'){
				objGroupState.sort ='desc';
			}				
			else{
				objGroupState.sort ='asc';
			}			
		}else{
			objGroupState.sort ='asc';
		}

		QBOX._.each(objGroupProps.columns, function(objGroupColumnProps, nIdx){
			var arrColsOfKey = objQCell._getColsOfKey(objGroupColumnProps.key);

			//if(arrColsOfKey.length > 0){
				//동일한 key값을 가진 컬럼이 한 개 있을 경우 하나의 컬럼만 그룹화하도록 한다.
			var nCol = arrColsOfKey[0],
			strColID = arrColsOfKey.length > 0 ? objQCell._getColID(nCol) : objGroupColumnProps.key;
			

			
			if(arrColsOfKey.length > 0){
				var objQCol = objQCell._getQCellCol(nCol);
				objQCol.attr('disabled',true,'boolean');
				if(objGroupProps.movefirst !== false)
					objQCell._moveCols(nCol, 1, nHeaderCols + nIdx, true);
			}
			
			if(htGroupColumnsInfo.containsKey(strColID) === false){
				htGroupColumnsInfo.put(strColID, {
					header	: QBOX._.has(objGroupColumnProps, 'header') && QBOX._.isObject(objGroupColumnProps.header) ? QBOX._.clone(objGroupColumnProps.header) : {},
					footer	: QBOX._.has(objGroupColumnProps, 'footer') && QBOX._.isObject(objGroupColumnProps.footer) ? QBOX._.clone(objGroupColumnProps.footer) : {},
					headerFooterCallback : QBOX._.has(objGroupColumnProps, 'headerFooterCallback') && QBOX._.isFunction(objGroupColumnProps.headerFooterCallback) ? objGroupColumnProps.headerFooterCallback : undefined,
				});
				htGroupColumnsInfo.get(strColID).expand = QBOX._.has(objGroupColumnProps, 'expand') && QBOX._.isBoolean(objGroupColumnProps.expand) ? objGroupColumnProps.expand : true;
				htGroupColumnsInfo.get(strColID).showLabel = objGroupColumnProps.showLabel;
				htGroupColumnsInfo.get(strColID).label = objGroupColumnProps.label;
			}
			//}
		});
		objQCell._initColStyles();
		QBOX._.each(objGroupProps.outer, function(objGroupOuterProps, nIdx){
			objGroupState.outer = {};
			objGroupState.outer.header = QBOX._.clone(objGroupOuterProps.header);
			objGroupState.outer.footer = QBOX._.clone(objGroupOuterProps.footer);	
			
			objGroupState.outer.headers = QBOX._.clone(objGroupOuterProps.headers);
			objGroupState.outer.footers = QBOX._.clone(objGroupOuterProps.footers);	
			
			
			objGroupState.outer.outerCallback = QBOX._.has(objGroupOuterProps, 'outerCallback') && QBOX._.isFunction(objGroupOuterProps.outerCallback) ? objGroupOuterProps.outerCallback : undefined;
		});

		return this._initTree();
	}

	return false;
};

QBOX.QCELL.BasicQCELL.prototype._initTree = function(){
	/* STEP 1: 그룹 기능을 구성하기 위한 노드 정보 생성 */
	this._makeTreeNodes();

	if(this._makeTreeData()){
		this.attr('useall', false, 'boolean');
		var arr = this.attr('treestate').data.RT_clone();
		if(this.attr('usetreeall')){
			if(this.attr('makefrozenbottomdata')){
				arr.push({'rt_qc_fbrd' : true});
			}
			
		}
		return this._setCurrentData(arr, false);
	}

	return false;
};
QBOX.QCELL.BasicQCELL.prototype._treecheckbox = function(nRow,nCol,bCheck){
	var objGroupState = this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate');
	
	if(objGroupState.grouped !== true || objGroupState.linkedcheckbox === undefined)
		return;
	//if(objGroupState.linkedcheckbox !== '_rt_qc_rowheader'){
		if(objGroupState.linkedcheckbox !== this._getKeyOfCol(nCol))
		return;		
	//}
	
	var orginData = this.attr('data').input;
	
	var objRowData = this.getRowData(nRow);
	
	if(objRowData._rt_qc_treeinfo === undefined){
		return;
	}
	var checkedValue = this._getColElement(nCol).attr('checkedvalue'),uncheckedValue = this._getColElement(nCol).attr('uncheckedvalue');
	if(objRowData._rt_qc_treeinfo.parent !== undefined){
		this._treecheckboxparentsub(objGroupState.linkedcheckbox,objRowData._rt_qc_treeinfo.parent,bCheck,checkedValue,uncheckedValue);		
	}
	
	if(objRowData._rt_qc_treeinfo.children !== undefined){
		for(var i = 0 ; i< objRowData._rt_qc_treeinfo.children.length ; i++){
			this._treecheckboxchildsub(objGroupState.linkedcheckbox, objRowData._rt_qc_treeinfo.children[i], bCheck,checkedValue,uncheckedValue);
		}
	}	
	
	this.refresh();
};
QBOX.QCELL.BasicQCELL.prototype._treecheckboxparentsubEx = function(objRow,key,checkedValue){
	var bRet = true;
	var orginData = this.attr('data').input;	
	if(objRow._rt_qc_treeinfo.children === undefined)
		return true;
	for(var i=0; i< objRow._rt_qc_treeinfo.children.length; i++){
		var objChild =orginData[objRow._rt_qc_treeinfo.children[i]];
		if(objChild === undefined)
			return false;
		if(objChild[key] !== checkedValue)
			return false;
		
		if(objChild._rt_qc_treeinfo !== undefined && objChild._rt_qc_treeinfo.children !== undefined)
			bRet = this._treecheckboxparentsubEx(objChild,key,checkedValue);
		if(bRet === false)break;
	}
	return bRet;
};
QBOX.QCELL.BasicQCELL.prototype._treecheckboxparentsub = function(key, nRow, bCheck,checkedValue,uncheckedValue){
	var orginData = this.attr('data').input;	
	var objRowData = orginData[nRow];
	
/*	if(key === '_rt_qc_rowheader'){
		var arrRowheaders = this.attr('rowheaders');
		for(var x=0;x<arrRowheaders.length;x++){
			if(arrRowheaders[x] === 'checkbox'){
				this._setRowheaderData(nRow + this.attr('headerrows'),x,bCheck);
			}
		}
	}else{*/
		bCheck = this._treecheckboxparentsubEx(objRowData,key,checkedValue);
		objRowData[key] = bCheck=== true? checkedValue:uncheckedValue;	
//	}
	
	
	if(objRowData._rt_qc_treeinfo === undefined){
		return;
	}
	
	if(objRowData._rt_qc_treeinfo.parent !== undefined){
		this._treecheckboxparentsub(key,objRowData._rt_qc_treeinfo.parent,bCheck,checkedValue,uncheckedValue);		
	}	
};
QBOX.QCELL.BasicQCELL.prototype._treecheckboxchildsub = function(key, nRow, bCheck,checkedValue,uncheckedValue){
	var orginData = this.attr('data').input;	
	var objRowData = orginData[nRow];
	
/*	if(key === '_rt_qc_rowheader'){
		var arrRowheaders = this.attr('rowheaders');
		for(var x=0;x<arrRowheaders.length;x++){
			if(arrRowheaders[x] === 'checkbox'){
				this._setRowheaderData(nRow + this.attr('headerrows'),x,bCheck);
			}
		}		
	}else{*/
		objRowData[key] = bCheck=== true? checkedValue:uncheckedValue;	
//	}

	
	if(objRowData._rt_qc_treeinfo === undefined){
		return;
	}
	
	if(objRowData._rt_qc_treeinfo.children !== undefined){
		for(var i = 0 ; i< objRowData._rt_qc_treeinfo.children.length ; i++){
			this._treecheckboxchildsub(key, objRowData._rt_qc_treeinfo.children[i], bCheck,checkedValue,uncheckedValue);
		}
	}		
	
};
QBOX.QCELL.BasicQCELL.prototype._makeTreeNodes = function(){
	
	var objGroupState = this.attr('treestate'),
	htGroupNodes = objGroupState.nodes,
	nGroupCols = objGroupState.columnsinfo.size(),
	strLevel = objGroupState.level ;

	htGroupNodes.clear();
	objGroupState.state = {};
	
	var objGroupColumnInfo =  objGroupState.columnsinfo,
	arrOriginData = this.attr('data').input.RT_clone(),
	htGroupColumnsInfo = objGroupState.columnsinfo,
	arrColumnsKey = htGroupColumnsInfo.keys(true) ;

	var tempNode = null,nLevel,htTempNodes ;
	for(var i = 0, nOriginDataCount = arrOriginData.length; i < nOriginDataCount; i++){
		var rowData = 	arrOriginData[i];
		htTempNodes =htGroupNodes;
		if(rowData[strLevel] !== undefined){
			nLevel = Number(rowData[strLevel]);
			for(var j=0; j<nLevel ; j++){
				
				var strKey = this._getKeyOfColID(arrColumnsKey[j]) === -1 ? arrColumnsKey[j]:  this._getKeyOfColID(arrColumnsKey[j]);
				if(strKey === undefined)
					continue;
				
				var strKeyData = rowData[strKey];
				
				if(htTempNodes.containsKey(strKeyData)){
					tempNode = htTempNodes.get(strKeyData);			
				}else{	
						var strIndex = '_rt_qc_index';				
						var strIndex2 = '_rt_qc_treeinfo';
						if(tempNode !== null){							
							rowData[strIndex2] = {};
							if(nLevel !== 1)
								rowData[strIndex2].parent = tempNode._rowData[strIndex];
							if(tempNode._rowData[strIndex2] === undefined){
								tempNode._rowData[strIndex2] = {};
							}
							if(nLevel >= tempNode._rowData[strKey]){
								
								if(tempNode._rowData[strIndex2].children === undefined){
									tempNode._rowData[strIndex2].children = [];
								}
								tempNode._rowData[strIndex2].children.push(i);				
							}			
						}
						var bExpand = htGroupColumnsInfo.get(arrColumnsKey[j]).expand;
						tempNode =  {
						colid	: arrColumnsKey[j],
						isparent: false,
						colkey	: strKey,
						level	: nLevel,
						key		: strKeyData,
						count	: 0, //전체 자식노드들의 총 수을 의미
						header	: QBOX._.size(objGroupColumnInfo.header) > 0 ? true : false,
						footer	: QBOX._.size(objGroupColumnInfo.footer) > 0 ? true : false,
						headerFooterCallback : objGroupColumnInfo.headerFooterCallback,
						parent	: tempNode,
						expand 	: bExpand,
						_rowData : rowData,
						showLabel : htGroupColumnsInfo.get(arrColumnsKey[j]).showLabel,
						label	:	htGroupColumnsInfo.get(arrColumnsKey[j]).label
					};

					rowData[strIndex] = i;
					

					
					htTempNodes.put(strKeyData,tempNode);
				}
				if(tempNode.childnodes === null || tempNode.childnodes === undefined)
					tempNode.childnodes= new _QHashtable();
					
				htTempNodes = tempNode.childnodes;	
				
			}
		}

	}

	return true;
};

QBOX.QCELL.BasicQCELL.prototype._makeTreeData = function(){
	var objGroupState = this.attr('treestate');

	objGroupState.data = [];
	objGroupState.treeuirows = [];
	objGroupState.treeuirownodes = [];
	objGroupState.headerrows = [];
	objGroupState.headerrownodes = [];
	objGroupState.footerrows = [];
	objGroupState.footerrownodes = [];
	
	objGroupState.groupuirows = {};
	objGroupState.groupuinodes = {};
	
	if(!QBOX._.isUndefined(objGroupState.outer) && (!QBOX._.isUndefined(objGroupState.outer.header ) || !QBOX._.isUndefined(objGroupState.outer.headers ) )){ //outer에 header가 선언되어 있는 경우
		//this._makeGroupDatumOuterHeader(objGroupState.nodes);
	}
	
	this._makeTreeDatum(objGroupState.nodes);
	
	if(objGroupState.nodes.size() === 0 && (!QBOX._.isUndefined(objGroupState.outer) && 
		(!QBOX._.isUndefined(objGroupState.outer.header) || !QBOX._.isUndefined(objGroupState.outer.footer) ||
		!QBOX._.isUndefined(objGroupState.outer.headers) || !QBOX._.isUndefined(objGroupState.outer.footers)))){// columns에 key설정없이 outer header나 footer가 설정되어 있는 경우
	//	this._makeGroupZeroData();
	}
	
	if(!QBOX._.isUndefined(objGroupState.outer) && (!QBOX._.isUndefined(objGroupState.outer.footer) ||!QBOX._.isUndefined(objGroupState.outer.footers) )){ //outer에 header가 선언되어 있는 경우
	//	this._makeGroupDatumOuterFooter(objGroupState.nodes);
	}

	return true;
	
};
QBOX.QCELL.BasicQCELL.prototype._makeTreeDatum = function(htNodes){
	var objQCell = this,
	objGroupState = this.attr('treestate'),
	htGroupColumnsInfo = objGroupState.columnsinfo,
	arrNodeList = objGroupState.sort === 'asc' ? htNodes.keys().sort() : objGroupState.sort === 'desc' ? htNodes.keys().sort().reverse() :htNodes.keys(true) ,  
	arrOriginData = this.attr('data').input,
	strDataType = this.attr('data').type,
	nHeaderRows = this.attr('headerrows'),nFirst,
	nLastIndex = -1,

	/*fnSetHeaderTextCallback = function(arrTexts, colkey){
		objQCell._setGroupHeaderFooterText(objNode, rowData, arrTexts, colkey,true);
	},
	fnSetFooterTextCallback = function(arrTexts, colkey){
		objQCell._setGroupHeaderFooterText(objNode, rowData, arrTexts, colkey,false);
	},	
	
	fnPushTargetRowDataCallback = function(idx){
		//idx: 그리드의 행 인덱스가 아니라 JSON 데이터의 인덱스를 의미
		objGroupState.data.push(arrOriginData[idx]);
		nLastIndex = idx;
	},*/
	i = -1;
	
	for(i = 0; i < arrNodeList.length; i++){//현재 노드집합의 리스트 수 만큼
		var rowDataTemp = strDataType === 'array' ? [] : {},
		rowData,
		key = arrNodeList[i];
		
		if(QBOX._.isUndefined(key)){
			break;
		}
		
		var objNode = htNodes.get(key),
		strColID = objNode.colid,
		objGroupColumnInfo = htGroupColumnsInfo.get(strColID), pKey;
		
		objNode.isparent = objNode.childnodes.size() > 0 ? true : false;
		
		if(objNode.isparent === true){
			objGroupState.treeuirows.push(nHeaderRows + objGroupState.data.length);	
			objGroupState.treeuirownodes.push(objNode);			
		}
		
		objGroupState.data.push(objNode._rowData);
		
		if(objNode.isparent === true && objNode.expand === true) {						
			this._makeTreeDatum(objNode.childnodes);
		}	
	}
};

QBOX.QCELL.BasicQCELL.prototype._seekNextExpandedTreeUIRow = function(objNode,nRow){
	var objGroupState = this.attr('treestate'),
	arrGroupTreeUIRows = objGroupState.treeuirows,
	arrGroupTreeUIRowNodes = objGroupState.treeuirownodes,
	nNextExpandedGroupTreeUIRow = -1 , 
	arrChildren = objNode.childnodes.keys(true) , tempRow = nRow +1 ;
	
	
	for(var i=0; i< arrChildren.length; i++){
		var childNode = objNode.childnodes.get(arrChildren[i]);
		if(childNode.isparent && childNode.expand === true )
			tempRow = this._seekNextExpandedTreeUIRow(childNode,tempRow );
		else 
			tempRow = tempRow +1;			
	}
	return tempRow;
};

QBOX.QCELL.BasicQCELL.prototype._insertTreeNode = function(arrKey, objData,strPosition){
	var objGroupState = this.attr('treestate'),htGroupColumnsInfo = objGroupState.columnsinfo,
		htNodes = objGroupState.nodes,objNode = null, nIndex =0,		
		arrColumnsKey = htGroupColumnsInfo.keys(true) , strPo = strPosition === undefined ? 'last' : 'first';
	
	var bFind = true;
	for(var i=0; i< arrKey.length -1; i++){
		if(arrKey[i].trim() === '')
			return false;
		if(htNodes.containsKey(arrKey[i])){
			bFind = true;
			objNode = htNodes.get(arrKey[i]);
			htNodes = objNode.childnodes;
			nIndex++;
		}else{			
			bFind = false;
			break;
		}		
	}
	
	var n;
	
	if(bFind === true){
		if(nIndex !== 0){
			if(arrKey[nIndex].trim() === '')
				return false;

			if(htNodes.containsKey(arrKey[nIndex])){
				return false;
			}
		}
		
		var objGroupColumnInfo = htGroupColumnsInfo.get(arrColumnsKey[nIndex]);
		
		if(objGroupColumnInfo === null )
			return false;	
		
		var bExpand = objGroupColumnInfo.expand;
		var strIndex = '_rt_qc_index';
		var objTempNode = {
						colid	: arrColumnsKey[nIndex],
						isparent: false,
						colkey	: arrColumnsKey[nIndex],
						level	: nIndex +1 ,
						key		: arrKey[nIndex],
						count	: 0, //전체 자식노드들의 총 수을 의미
						header	: QBOX._.size(objGroupColumnInfo.header) > 0 ? true : false,
						footer	: QBOX._.size(objGroupColumnInfo.footer) > 0 ? true : false,
						headerFooterCallback : objGroupColumnInfo.headerFooterCallback,
						parent	: null,
						expand 	: bExpand,
						_rowData : objData
					};

		objTempNode.childnodes = new _QHashtable();		
		var arrOriginData = this.attr('data').input;
		if(objNode === null){			
			objNode = htNodes.get(arrKey[0]);
			if(objNode === null){
				if(strPo === 'last'){
					objData[strIndex] = this.attr('data').input.length;					
					this.attr('data').input.push(objData);			
					htNodes.put( arrKey[nIndex],objTempNode);	
				}else{
					
					for(n = 0 ; n < arrOriginData.length; n++){
						if(arrOriginData[n][strIndex] > 0)
							arrOriginData[n][strIndex]++;
					}				
					objData[strIndex] = 0;				
					arrOriginData.RT_insertArray(0, [objData]);
					htNodes.putAt( arrKey[nIndex],objTempNode ,0);						
				}
			}else{
				return false;
			}			
		}else{
			if(strPo === 'last'){
				objData[strIndex] = this.attr('data').input.length;					
				this.attr('data').input.push(objData);			
				objNode.childnodes.put( arrKey[nIndex],objTempNode);	
			}else{
				var nParentRow = objNode._rowData[strIndex];
				if(!isNaN(nParentRow)){
				
					for(n = 0 ; n < arrOriginData.length; n++){
						if(arrOriginData[n][strIndex] > nParentRow)
							arrOriginData[n][strIndex]++;
					}				
					objData[strIndex] = nParentRow +1;				
					arrOriginData.RT_insertArray(nParentRow +1, [objData]);
					objNode.childnodes.putAt( arrKey[nIndex],objTempNode ,0);	
				}
			}
			
				
			objNode.isparent = true;			
		}

		
		if(this._makeTreeData()){
			var bRet = this._setCurrentData(this.attr('treestate').data.RT_clone(), false,true);
			this._setTreeState(this.attr('data').input.length,'i',objData);
			return bRet;
		}
		return false;
		
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._removeTreeNode = function(arrKey){
	var objGroupState = this.attr('treestate'),htGroupColumnsInfo = objGroupState.columnsinfo,
		htNodes = objGroupState.nodes,objNode = null, nIndex =0,		
		arrColumnsKey = htGroupColumnsInfo.keys(true) ;
	
	var bFind = true;
	for(var i=0; i< arrKey.length -1; i++){
		if(htNodes.containsKey(arrKey[i])){
			bFind = true;
			objNode = htNodes.get(arrKey[i]);
			htNodes = objNode.childnodes;
			nIndex++;
		}else{			
			bFind = false;
			break;
		}		
	}
	
	if(bFind === true){
		
		if(nIndex !== 0){			
			if(htNodes.containsKey(arrKey[nIndex]) === false){
				return false;
			}
		}
		
		if(objNode === null){			
			objNode = htNodes.get(arrKey[0]);
			if(objNode === null)
				return false;
		}
		
		var objCurrentNode = htNodes.get(arrKey[nIndex]);
		
		this._removeTreeDataNode(objCurrentNode);
		
		if(nIndex === 0 && arrKey.length === 1){
			htNodes.remove(arrKey[nIndex]);
		}else{			
			objNode.childnodes.remove( arrKey[nIndex]);		
			objNode.isparent = objNode.childnodes.size() > 0 ? true : false;			
		}

		
		if(this._makeTreeData()){
			return this._setCurrentData(this.attr('treestate').data.RT_clone(), false,true);
		}
		return false;
		
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._updateTreeNode = function(arrKey, objData){
	var objGroupState = this.attr('treestate'),htGroupColumnsInfo = objGroupState.columnsinfo,
		htNodes = objGroupState.nodes,objNode = null, nIndex =0,		
		arrColumnsKey = htGroupColumnsInfo.keys(true) ;
	
	var bFind = true;
	for(var i=0; i< arrKey.length -1; i++){
		if(htNodes.containsKey(arrKey[i])){
			bFind = true;
			objNode = htNodes.get(arrKey[i]);
			htNodes = objNode.childnodes;
			nIndex++;
		}else{			
			bFind = false;
			break;
		}		
	}
	
	if(bFind === true){
		
		if(nIndex !== 0){			
			if(htNodes.containsKey(arrKey[nIndex]) === false){
				return false;
			}
		}
		
		if(objNode === null){			
			objNode = htNodes.get(arrKey[0]);
			if(objNode === null)
				return false;
		}
		
		var objCurrentNode = htNodes.get(arrKey[nIndex]);
		var nRow = objCurrentNode._rowData._rt_qc_index,key;
		if(isNaN(nRow))
			return false;
		nRow = nRow + this.attr('headerrows');
		for(key in objData){
			objCurrentNode._rowData[key] = objData[key];
		}
		
		this._setTreeState(nRow,'u',objCurrentNode._rowData);
		
		this.refresh();
		
		return true;
		
	}
	
	return false;
};
QBOX.QCELL.BasicQCELL.prototype._removeTreeDataNodeSub = function(objNode){
	var strIndex = '_rt_qc_index';
	var arrOriginData = this.attr('data').input, nRow = 	objNode._rowData[strIndex];
	
	this._setTreeState(nRow,'d',objNode._rowData);
	
	arrOriginData.splice(nRow,1);
	for(var j=arrOriginData.length - 1; j >=0 ; j--){
		if(arrOriginData[j][strIndex] > nRow)
			arrOriginData[j][strIndex] = arrOriginData[j][strIndex] -1;
	}
};
QBOX.QCELL.BasicQCELL.prototype._removeTreeDataNode = function(objNode){
	var htChildren = objNode.childnodes,
	arrOriginData = this.attr('data').input, arrChildren = htChildren.keys();
	
	for(var i=0; i <arrChildren.length ; i++){
		var objChild = htChildren.get(arrChildren[i]);
		if(objChild.childnodes.size()) {
			this._removeTreeDataNode(objChild);
		}else{
			this._removeTreeDataNodeSub(objChild);
		}
	}

	this._removeTreeDataNodeSub(objNode);

	
};
QBOX.QCELL.BasicQCELL.prototype._setTreeState = function(nRow, strState,obj){
	var objData = obj !== undefined ? obj : this.attr('currentdata')[nRow - this.attr('headerrows')],
	treestate = this.attr('treestate'),	
	strKey = this._getTreeStateKey(objData);
	
	if(strKey === '')
		return false;
	
	if(treestate.state.update === undefined){
		treestate.state.update = new _QHashtable ();
	}		
	if(treestate.state.insert === undefined){
		treestate.state.insert = new _QHashtable ();
	}
	if(treestate.state.delete === undefined){
		treestate.state.delete = new _QHashtable ();
	}
	
	if(strState === 'u'){
		if(treestate.state.insert.containsKey(strKey)){
			treestate.state.insert.put(strKey,objData);
			return;
		}
		if(treestate.state.delete.containsKey(strKey)){
			treestate.state.delete.put(strKey,objData);
			return;
		}
		
		treestate.state.update.put(strKey,objData);
	}
	else if(strState === 'i'){
		if(treestate.state.update.containsKey(strKey)){
			treestate.state.update.remove(strKey);
		}
		if(treestate.state.delete.containsKey(strKey)){
			treestate.state.delete.remove(strKey);
		}		
		treestate.state.insert.put(strKey,objData);
		
	}else if(strState === 'd'){
		if(treestate.state.update.containsKey(strKey))
			treestate.state.update.remove(strKey);
		
		if(treestate.state.insert.containsKey(strKey)){
			treestate.state.insert.remove(strKey);
			return;
		}
		
		treestate.state.delete.put(strKey,objData);
	}
	
	
};
QBOX.QCELL.BasicQCELL.prototype._getTreeStateKey = function(objData){
	var treestate = this.attr('treestate'),	strKey = '' , strLevel = treestate.level ,
	arrColumsInfo = this.attr('treestate').columnsinfo.keys(true),htColumnsInfo = this.attr('treestate').columnsinfo;
	
	if(strLevel === undefined)
		return strKey;
	
	var nLevel = objData[strLevel];
	
	if(isNaN(nLevel))
		return '';
	
	for(var i=0; i < nLevel ; i++){
		var objCol = htColumnsInfo.get(arrColumsInfo[i]);
		if(objCol === null)
			return '';
		var strColID = arrColumsInfo[i];
		var colKey = this._getKeyOfColID(strColID) === -1 ? strColID :  this._getKeyOfColID(strColID);
		if(objData[colKey] === undefined || objData[colKey] === '')
			return '';
		
		strKey = strKey + '_qc_' + objData[colKey];
	}
	
	return strKey;
};
QBOX.QCELL.BasicQCELL.prototype._getTreeState = function(strState){
	var obj = {};
	
	if(strState === 'u'){
		obj.update = this._getTreeStateSub('u');
	}else if(strState === 'i'){
		obj.insert = this._getTreeStateSub('i');
	}else if(strState === 'd'){
		obj.delete = this._getTreeStateSub('d');
	}else{
		obj.update = this._getTreeStateSub('u');
		obj.insert = this._getTreeStateSub('i');
		obj.delete = this._getTreeStateSub('d');
	}
	
	return obj;
};
QBOX.QCELL.BasicQCELL.prototype._getTreeStateSub = function(strState){
	var arrState = [],treestate = this.attr('treestate'),htState;
	
	if(strState === 'u'){
		htState = treestate.state.update;
	}else if(strState === 'i'){
		htState = treestate.state.insert;
	}else if(strState === 'd'){
		htState = treestate.state.delete;	
	}
	
	if(htState === undefined)
		return arrState;
	
	var arrKey = htState.keys(true);
	for(var i=0;i<arrKey.length ; i++){
		arrState.push(htState.get(arrKey[i]));
	}
	return arrState;
};
QBOX.QCELL.BasicQCELL.prototype._clearTreeState = function(){
	var treestate = this.attr('treestate');
	treestate.state = {};
};

QBOX.QCELL.BasicQCELL.prototype._setHierachy = function(objGroupProps){
	/*
	qcell1._setGroup({
		type: 'tree',	//'normal' or 'tree' or 'step'
		columns: [		//그룹핑 할 컬럼 정보 설정
			{
				key		: 'si',	//그룹핑 할 컬럼의 key값
				expand	: true,	//tree, step 펼침 여부 설정('tree' || 'step' 타입 사용시에만 사용가능한 옵션)
				header	: {	//현재 그룹 레벨의 헤더 행 설정
					//통계함수:
					//childcount(),					//직계 자식노드의 수,ex> 서울특별시에 몇개의 구가 있는지 계산 시 사용
					//count(),						//전체 자식노드의 수,ex> 서울특별시에 몇개의 동이 있는지 계산 시 사용
					//countif(colkey, stdvalue),	//전체 자식노드들 중에서 특정 기준값을 가지는 자식노드의 수, ex> 성별이 남자인 사람의 수만 알고 싶은 경우
					//groupvalue(nLevel)			//그룹 헤더가 그려진 기준이 되는 그룹의 값
					//sum(colkey),					//데이터의 총합
					//average(colkey)				//데이터의 평균값

					"si" 	: ["groupvalue(0)",	"의 Header 행", " 수: ", "countif('cpNm', '강원도')", "건"],
					"gu" 	: ["groupvalue(0)", "에 있는 시군구 수: ", "childcount()", "개"],
					"dong"	: ["groupvalue(0)", "에 있는 읍면동 수: ", "count()", "개"],
					"people": ["groupvalue(0)", "의 총 인구 수: ", "sum()", "명", ", 읍면동 당 평균 인구 수: ", "average()", "명"]
				},
				footer	: {}
			},
			{key	: 'gu'},
			{key	: 'dong'}
		]
	});
	*/
	if(this._checkValidationOfHierachyProps(objGroupProps)){

		/*
		this.attr('groupstate', {
			grouped		: false,
			showpanel	: false,
			type		: 'normal',
			data		: [],
			columnsinfo	: new Hashtable(),
			nodes		: new Hashtable(),
			treeuirows		: [],
			treeuirownodes	: [],
			headerrows		: [],
			headerrownodes	: [],
			footerrows		: [],
			footerrownodes	: []
		}, 'object');
		*/
		var objQCell = this,
		objGroupState = this.attr('hierachystate'),
		htGroupColumnInfo = objGroupState.columninfo,
		nHeaderCols = this.attr('headercols');
		
		objGroupState.columninfo = objGroupProps.column;
		
		this.attr('_hierachyProps', QBOX._.clone(objGroupProps),'object');

		objGroupState.grouped = true;
		
		objGroupState.expand = QBOX._.has(objGroupProps, 'expand') && QBOX._.isFunction(objGroupProps.expand) ? objGroupProps.expand : null ;
		objGroupState.collapse = QBOX._.has(objGroupProps, 'collapse') && QBOX._.isFunction(objGroupProps.collapse) ? objGroupProps.collapse : null ;
		
		
		if(QBOX._.has(objGroupProps, 'sort') &&  QBOX._.isString(objGroupProps.sort)){
			if(objGroupProps.sort === 'none'){
				objGroupState.sort ='none';				
			}
			else if(objGroupProps.sort === 'asc'){
				objGroupState.sort ='asc';				
			}
			else if(objGroupProps.sort === 'desc'){
				objGroupState.sort ='desc';
			}				
			else{
				objGroupState.sort ='asc';
			}			
		}else{
			objGroupState.sort ='asc';
		}

		objQCell._initColStyles();
		QBOX._.each(objGroupProps.outer, function(objGroupOuterProps, nIdx){
			objGroupState.outer = {};
			objGroupState.outer.header = QBOX._.clone(objGroupOuterProps.header);
			objGroupState.outer.footer = QBOX._.clone(objGroupOuterProps.footer);	
			
			objGroupState.outer.headers = QBOX._.clone(objGroupOuterProps.headers);
			objGroupState.outer.footers = QBOX._.clone(objGroupOuterProps.footers);	
			
			
			objGroupState.outer.outerCallback = QBOX._.has(objGroupOuterProps, 'outerCallback') && QBOX._.isFunction(objGroupOuterProps.outerCallback) ? objGroupOuterProps.outerCallback : undefined;
		});
		
		this.attr('_heirachyinfo', objGroupProps , 'object');

		return this._initHeirachy();
	}

	return false;
};

QBOX.QCELL.BasicQCELL.prototype._checkValidationOfHierachyProps = function(objGroupProps){
	return QBOX._.has(objGroupProps, 'column') && QBOX._.isObject(objGroupProps.column);
};
QBOX.QCELL.BasicQCELL.prototype._initHeirachy = function(){
	/* STEP 1: 그룹 기능을 구성하기 위한 노드 정보 생성 */
	this._makeHeirachyNodes();

	/* STEP 2: 'nodes' 정보를 이용해 그리드 행 데이터 생성 */
	if(this._makeHierachyData()){

		/* STEP 3: 그룹데이터로 화면 갱신 */
		return this._setCurrentData(this.attr('hierachystate').data.RT_clone(), false);
	}

	return false;
};
QBOX.QCELL.BasicQCELL.prototype._getHierachyData = function(strVal){
		var arrRet = [];
		
		var nIndex =0;
		var objGroupState = this.attr('hierachystate'),objGroupColumnInfo = objGroupState.columninfo,
		arrGridData = this.attr('_filtering') === true ? this.attr('currentdata'):this.attr('data').input,strKey = objGroupColumnInfo.key;
		for(var i=0;i<arrGridData.length;i++){
			if(arrGridData[i][strKey] === strVal){
				arrRet.push(QBOX._.clone(arrGridData[i]));
				arrRet[nIndex][strKey] = '';
				arrRet[nIndex].check = false;
				nIndex++;
			}
		}
		
		return arrRet;
};
QBOX.QCELL.BasicQCELL.prototype._addHierachyData = function(e,row,col,val){
	var arr = this._getHierachyData(''+val);			
	if(arr.length > 0){
		e.currentTarget.textContent = '-';
		this.setCellDataEx(row,"rt_qc_state",'M');
	
		this.insertRows(row+1,arr);
		var THAT = this;
		setTimeout(function (){
			THAT._trigger('hierachyuiclick' ,{'nRow' : row, 'bExpand':true});
		});
	}
};
QBOX.QCELL.BasicQCELL.prototype._removeHierachyData = function(e,row,col,val){
	var arr = this._getHierachyData(''+val);			
	if(arr.length > 0){
		e.currentTarget.textContent = '+';
		this.setCellDataEx(row,"rt_qc_state",'P');
	
		this.deleteRows(row+1,arr.length);		
		var THAT = this;
		setTimeout(function (){
			THAT._trigger('hierachyuiclick' ,{'nRow' : row, 'bExpand':false});
		});
	}
};
QBOX.QCELL.BasicQCELL.prototype._makeHeirachyNodes = function(){
	var objGroupState = this.attr('hierachystate'),
	htGroupNodes = objGroupState.nodes,
	nGroupCol = this.getColOfKey(objGroupState.columninfo.key),
	arrData = this.attr('_filtering') === true ? this.attr('currentdata'):this.attr('data').input;

	htGroupNodes.clear();
	
	
	
	if(nGroupCol === -1)
		return false;
	
	var heColHtml = this._getColHtml(nGroupCol);
	var strID = this.getID();
	var fnCallback = function (id, row, col, val, obj){
		var str = val;
		if(obj.rt_qc_type !== undefined && obj.rt_qc_type === 'M'){
			if(obj.rt_qc_state === "P")
				str = '<button class="rt-qc-heirachy-button" onclick="QCELL.getInstance('+ "'" + strID + "'" + ')._addHierachyData(event,'+row + ',' + col + ',' + val+')">+</button>' +val;
			else
				str = '<button class="rt-qc-heirachy-button"  onclick="QCELL.getInstance('+"'" +strID +"'" +  ')._removeHierachyData(event,'+row + ',' + col + ',' + val+')">-</button>' +val;
		}else{
			str = '';
		}
		return str;
	};
	
	this._getColElement(nGroupCol).attr('renderer',fnCallback,'function');
	heColHtml.data = fnCallback;
	

	for(var i = 0, nOriginDataCount = arrData.length; i < nOriginDataCount; i++){
		/*
		 * 트리 구조 형태의 노드를 만들기 위해 최상위 그룹 level부터 자신의 level까지 탐색하여 노드를 생성해야 한다.
		 * ex> 현재 그룹 설정이 '시도', '시군구', '읍면동'으로 3개의 level로 설정되어 있는 경우 서울특별시의 강남구에 속한 '대치동'이란 노드를 생성하기 위해서는
		 * 0 level인 그룹에서 '서울특별시' 노드를 찾은 후 1 level에서 '강남구' 노드를 찾아 그 하위에 '대치동' 자식노드를 생성한다.
		 */
		
		this._makeHierachyNode(null, htGroupNodes, i, 0, 0);
		
	}

	return true;
};
QBOX.QCELL.BasicQCELL.prototype._makeHierachyData = function(){
	var objGroupState = this.attr('hierachystate'),
	objColInfo = objGroupState.columninfo,
	arrOriginData = this.attr('_filtering') === true ? this.attr('currentdata'):this.attr('data').input,
	htGroupNodes = objGroupState.nodes,
	arrNodes = htGroupNodes.keys(true);
	
	var arrData = [];
	for(var i = 0; i<arrNodes.length; i++){
		var objNode = htGroupNodes.get(arrNodes[i]);
		var arrValues = objNode.data.values().sort(QBOX.st.asc);
		
		if(objColInfo.header !== undefined){
			var objHeader = {};
			for(var strKey in objColInfo.header){
				var strData = '';
				
				var arrKeyData = objColInfo.header[strKey];
				
				for(var j=0; j< arrKeyData.length; j++){
					if(arrKeyData[j] === 'value()'){
						strData += objNode._rowData[strKey];
					}else if(arrKeyData[j] === 'childcount()'){
						strData += ''+objNode.count;
					}else{
						strData += arrKeyData[j];
					}
				}
				objHeader[strKey] = strData;
			}
			objHeader.rt_qc_type = 'M';
			objHeader.rt_qc_state = objColInfo.expand === true ? 'M' : 'P';
			arrData.push(objHeader);
			
			if(objColInfo.expand === true){
				for(var x=0;x<arrValues.length;x++){
					arrData.push(arrOriginData[ arrValues[x] ]);
				}
			}
			
			
		}
		
	}
	
	objGroupState.data = arrData;
	return true;
};
QBOX.QCELL.BasicQCELL.prototype._makeHierachyNode = function(objParentNode, htNodes, nIdx, nParentLevel, nLevel){
	var objGroupState = this.attr('hierachystate'),
	objGroupColumnInfo = objGroupState.columninfo,
	arrOriginData = this.attr('_filtering') === true ? this.attr('currentdata'):this.attr('data').input,
	htGroupNodes = objGroupState.nodes,
	htGroupColumnInfo = objGroupState.columninfo,
	rowData = arrOriginData[nIdx],
	colKey = htGroupColumnInfo.key,
	key = rowData[colKey],
	type = objGroupState.type;
	
	if(key === undefined)
		return;

	if(nParentLevel === nLevel){
		var bIsParent = true, objNode = null;
		if(!(htNodes.containsKey(key))){
			objNode = {
				
				level	: nLevel,
				key		: key,
				count	: 1, //전체 자식노드들의 총 수을 의미
				header	: QBOX._.size(objGroupColumnInfo.header) > 0 ? true : false,
				footer	: QBOX._.size(objGroupColumnInfo.footer) > 0 ? true : false,
				headerFooterCallback : objGroupColumnInfo.headerFooterCallback,
				parent	: objParentNode,
				_rowData : rowData
			};
			
			if(objGroupState.type === 'tree' || objGroupState.type === 'step' || objGroupState.type === 'group'){
				objNode.expand =  QBOX._.has(objGroupColumnInfo, 'expand') && (typeof objGroupColumnInfo.expand === 'boolean') ? objGroupColumnInfo.expand : true;
			}
			
			htNodes.put(key, objNode);			
			objNode.childnodes = new _QHashtable();			
			objNode.data = new _QHashSet();
			objNode.data.add(nIdx);
			
			
		} else{
			//console.log('중복된 데이터가 있는 경우를 의미한다.', key);
			objNode = htNodes.get(key);
			
			if(objNode.data === undefined || objNode.data === null)
				objNode.data = new _QHashSet();

			objNode.data.add(nIdx);

			while(objNode !== null){
				objNode.count += 1;

				objNode = objNode.parent;
			}
			
		}
	} 
};


QBOX.QCELL.BasicQCELL.prototype._setHSRange = function(){
	try{
		var objHSInfo = this.attr('hsinfo'),
		nHeaderCols = this.attr('headercols'), nCols = this.attr('cols');
		
		if(nCols - nHeaderCols > 0){
			//nStartCol와 nEndCol은 frozenCols가 결정된 후 세팅해야 한다.
			objHSInfo.nStartCol = nHeaderCols + this.attr('frozencols');
			objHSInfo.nEndCol = nCols - 1;
		} else{
			objHSInfo.nStartCol = objHSInfo.nEndCol = -1;
		}
		
		return true; 
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._setHSRange', e.message);
		return false;
	}
};

//QBOX.QCELL.BasicQCELL.prototype._initHSInfo = function(){
//	var objHSInfo = this.attr('hsinfo');
//	
//	objHSInfo.nLeftCol = objHSInfo.nStartCol;
//	//objHSInfo.nRightCol = this.attr('headercols') + objHSInfo.nDynamicCols - 1;
//	if(objHSInfo.nDynamicCols > this.attr('cols') - this.attr('headercols')){
//		objHSInfo.nRightCol = objHSInfo.nEndCol;
//	} else{
//		//nRightCol = nStartCol + "스크롤링 발생 시 동적으로 변경되는 dynamicRows의 수", nDynamicCols는 frozenCols까지 합한 값이다.
//		objHSInfo.nRightCol = objHSInfo.nStartCol + (objHSInfo.nDynamicCols - this.attr('frozencols')) - 1;
//	}
//};

QBOX.QCELL.BasicQCELL.prototype._initHSInfo = function(){
	var objHSInfo = this.attr('hsinfo');
	
	objHSInfo.bHScroll = false;	//HScrollbar 존재여부
	
	objHSInfo.nStartCol =		//headerCols, frozenCols를 제외한 첫번째 normalCol의 인덱스
	objHSInfo.nEndCol =			//headerCols, frozenCols를 제외한 마지막 normalCol의 인덱스
	objHSInfo.nLeftCol =		//동적컬럼의 첫번째 normalCol의 인덱스(현재 스크롤 위치에서  viewport 영역에 표시 할 첫 번째 일반 컬럼의 index)
	objHSInfo.nRightCol = -1;	//동적컬럼의 마지막 normalCol의 인덱스(현재 스크롤 위치에서  viewport 영역에 표시 할 마지막 일반컬럼의 index)
	
	objHSInfo.nAdjustCols =		//컬럼 셀 div들을  뜯어내지 않고 전체 left를 보정할 때 사용하는 보정 컬럼의 수
	objHSInfo.nDynamicCols =	//viewport 영역을 구성하는 동적 컬럼의 수
	objHSInfo.nLength =			//스크롤바의 길이
	objHSInfo.nLastPos =		//스크롤바의 마지막 위치 / nLengthPerCol -> 가로스크롤바의 마지막 위치가 nLengthPerCol값 단위를 기준으로 몇 번 이동할 수 있는지
	objHSInfo.nPos =			//스크롤바 위치 / nLengthPerCol -> 가로스크롤바의 현재 위치가 nLengthPerCol값 단위를 기준으로 몇 번 이동했는지
	objHSInfo.nLeft =			//현재 스크롤바의 위치
	objHSInfo.nBeforeLeft =		//스크롤바가 이동하기 전 스크롤바의 위치
	objHSInfo.nLengthPerCol = 0;//한 컬럼 당 평균 이동 거리(모든 컬럼은 colwidth에 상관없이 동일한 스크롤 이동거리를 갖는다.)
	
	objHSInfo.objUpdateInfo = {	//셀 갱신 시 필요한 정보를 저장
		bWholeUpdate	: false,
		//strDirection	: '',
		objParams		: {
			/*
				bWholePositionChanged	: false,
				nCutColsCount			: 0,//데이터와 위치를 갱신해야 하는 동적 컬럼의 수(ex> 가로스크롤바가 오른쪽으로 3칸 이동 시 3개의 일반컬럼을 표시하던 div들을 새로 나타해야 할 새로운 3개의 컬럼위치로 이동시키고 데이터를 갱신해야 한다.)
				nMovedCount				: 0,
				nAdjustedLeft			: 0,//이동한 가로스크롤바의 위치가 동적 컬럼을 변경하는 것이 아닌 left값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
			 */
		}
	};
};

QBOX.QCELL.BasicQCELL.prototype._updateHSInfo = function(){
	try{
		var objHSInfo = this.attr('hsinfo'), objUpdateInfo = objHSInfo.objUpdateInfo,
		nHeaderCols = this.attr('headercols'),
		nCols = this.attr('cols');
		
		objUpdateInfo.objParams = {};
		
		if(objHSInfo.bHScroll){
			var nAdjustedLeft = 0;//가로스크롤바의 위치가 동적 컬럼을 변경하는 것이 아닌 left값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
			
			objUpdateInfo.bWholeUpdate = true;
			
			objHSInfo.nLeftCol = objHSInfo.nStartCol + objHSInfo.nPos;
			
			if(objHSInfo.nDynamicCols > nCols - nHeaderCols){
				objHSInfo.nRightCol = objHSInfo.nEndCol;
			} else{
				var nFrozenCols = this.attr('frozencols');
				
				//"nRightCol" = nLeftCol + "스크롤링 발생 시 동적으로 변경되는 nDynamicCols의 수", nDynamicCols는 frozencols까지 합한 값이다.
				objHSInfo.nRightCol = objHSInfo.nLeftCol + (objHSInfo.nDynamicCols - nFrozenCols) - 1;
				
				//nRightCol이 nEndCol보다 크면 안된다.
				if(objHSInfo.nRightCol > objHSInfo.nEndCol){//스크롤바의 위치가 보정 범위 내에 있을 때
					objHSInfo.nLeftCol -= objHSInfo.nRightCol - objHSInfo.nEndCol; 
					objHSInfo.nRightCol = objHSInfo.nEndCol;
					
					if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
						var nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth,
						nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1);
						
						nAdjustedLeft = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
					} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
						nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
					}
				}
			}
			
			objUpdateInfo.objParams.nAdjustedLeft = nAdjustedLeft;
		} else{
			objUpdateInfo.bWholeUpdate = false;
			
			if(nCols > 0){
				objHSInfo.nLeftCol = nHeaderCols;
				objHSInfo.nRightCol = nCols - 1;
			} else{
				objHSInfo.nLeftCol = objHSInfo.nRightCol = -1;
			}
			
			objUpdateInfo.objParams.nAdjustedLeft = 0;
		}
		this._adjustFrozenCount();		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._updateHSInfo', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype.onHScroll = function(nScrollLeft){
	var objHSInfo = this.attr('hsinfo'), objQCell = this;
	nMovedCount = 0;
	
	if(Math.abs(objHSInfo.nLeft - nScrollLeft) >= objHSInfo.nLengthPerCol){//한 컬럼 당 평균 이동 거리(nLengthPerCol)이상으로 가로스크롤바가 움직였을 때만 QCELL의 스크롤바가 이동했다고 판단한다.
		nMovedCount = parseInt(-(nScrollLeft - objHSInfo.nLeft) / objHSInfo.nLengthPerCol);//nMovedCount:스크롤바가 이동한 카운트
		
		objHSInfo.nBeforeLeft = objHSInfo.nLeft;
		objHSInfo.nLeft = objHSInfo.nLeft - (nMovedCount * objHSInfo.nLengthPerCol);//가로스크롤바가 nLengthPerCol값 단위로 딱딱 맞아떨어지게 이동하면 좋겠지만 그렇지 않기 때문에 scrollLeft값으로 설정하면 안되고, 이동한 컬럼 수 만큼 nLengthPerCol값을 곱한 값을 더 해 줘야 한다.
		objHSInfo.nPos = -(objHSInfo.nLeft / objHSInfo.nLengthPerCol);
		
		this._adjustScrollPos();	
		this._syncHSInfo();
		this._updateNCs();
	}
	// 맨마지막 컬럼에서 스크롤 이동시 값 초기화 안되는 문제 수정
	this.attr('adjustcol', false, 'boolean');
};

QBOX.QCELL.BasicQCELL.prototype._syncHSInfo = function(){
	var objHSInfo = this.attr('hsinfo'), objQCell = this, objUpdateInfo = objHSInfo.objUpdateInfo,
	nMovedCount = (objHSInfo.nBeforeLeft - objHSInfo.nLeft) / objHSInfo.nLengthPerCol,
	nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
	nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth,
	nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
	nAdjustCountBeforeScrolling = 0;	//nAdjustCountBeforeScrolling:이동하기 전 가로 스크롤바위치가 보정영역인 경우의 보정 컬럼 수, 가로스크롤바가 왼쪽으로 이동 시 이동하기 전 가로스크롤바의 위치가 보정영역이였던 경우 보정영역 내 스크롤 이동 구간만큼은 nLeftCol, nRightCol값이 변하지 않아야 한다.
	
	objUpdateInfo.objParams = {};
	
	if(Math.abs(nMovedCount) >= objHSInfo.nDynamicCols - nFrozenCols){//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 많은 경우
		var nAdjustCount = 0,//nAdjustCount: 보정 컬럼 수
		nAdjustedLeft = 0;//이동한 가로스크롤바의 위치가 동적 컬럼을 변경하는 것이 아닌 left값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
		
		objUpdateInfo.bWholeUpdate = true;
		
		if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
			objUpdateInfo.strDirection = 'right';
			//if(objHSInfo.nRightCol + nMovedCount > objHSInfo.nEndCol){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
			if(objHSInfo.nPos > objHSInfo.nLastPos - objHSInfo.nAdjustCols){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
				//nAdjustCount = (objHSInfo.nRightCol + nMovedCount) - objHSInfo.nEndCol;
				nAdjustCount = objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols);
				
				objHSInfo.nLeftCol += nMovedCount - nAdjustCount;
				objHSInfo.nRightCol += nMovedCount - nAdjustCount;
				
				if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
					nAdjustedLeft = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
				} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
					//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
					nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
				}
			} else{
				objHSInfo.nLeftCol += nMovedCount;
				objHSInfo.nRightCol += nMovedCount;
			}
//			if(nAdjustCount > 0){
//				if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
//					nAdjustedLeft = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
//				} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
//					//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//					nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
//				}
//			}
		} else{//가로 스크롤바가 왼쪽으로 이동했을 때
			objUpdateInfo.strDirection = 'left';
			
			if(objHSInfo.nPos >= objHSInfo.nLastPos - objHSInfo.nAdjustCols){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
				nAdjustCount = objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols);
				nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nAdjustCount - 1);
			} else{//이동한 스크롤바의 위치가 보정 범위 밖에 있을 때
				//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간만큼은 nLeftCol, nRightCol값이 변하지 않아야 한다.
				nAdjustCountBeforeScrolling = objHSInfo.nPos - nMovedCount >= objHSInfo.nLastPos - objHSInfo.nAdjustCols ? objHSInfo.nPos - nMovedCount - (objHSInfo.nLastPos - objHSInfo.nAdjustCols) : 0;
				//console.log("스크롤바가 이동하기 전 기준 보정영역범위:", nAdjustCountBeforeScrolling);
				
				objHSInfo.nLeftCol += nMovedCount + nAdjustCountBeforeScrolling;
				objHSInfo.nRightCol += nMovedCount + nAdjustCountBeforeScrolling;
			}
		}
		
		objUpdateInfo.objParams.nAdjustedLeft = nAdjustedLeft;
	} else{//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 적은 경우
		var nCutColsCount = 0;//nCutColsCount:데이터와 위치를 갱신해야 하는 동적 컬럼의 수(ex> 가로스크롤바가 오른쪽으로 3칸 이동 시 3개의 일반컬럼을 표시하던 div들을 새로 나타해야 할 새로운 3개의 컬럼위치로 이동시키고 데이터를 갱신해야 한다.)
		
		objUpdateInfo.bWholeUpdate = false;
		objUpdateInfo.objParams.nMovedCount = nMovedCount;
		
		if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
			objUpdateInfo.strDirection = 'right';
			//if(objHSInfo.nRightCol + nMovedCount > objHSInfo.nEndCol){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
			if(objHSInfo.nPos > objHSInfo.nLastPos - objHSInfo.nAdjustCols){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
				nCutColsCount = objHSInfo.nEndCol - objHSInfo.nRightCol;
				objUpdateInfo.objParams.bWholePositionChanged = true;
			} else{//이동한 스크롤바의 위치가 보정 범위 밖에 있을 때
				nCutColsCount = nMovedCount;
				objUpdateInfo.objParams.bWholePositionChanged = false;
			}
			
			objHSInfo.nLeftCol += nCutColsCount;
			objHSInfo.nRightCol += nCutColsCount;
		} else{//가로 스크롤바가 왼쪽으로 이동했을 때
			objUpdateInfo.strDirection = 'left';
			
			//모두 뜯지 않아야 하는 경우 발생 시, nAdjustCols 범위 안에 있는지 여부 확인
			if(objHSInfo.nPos >= objHSInfo.nLastPos - objHSInfo.nAdjustCols){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
				objUpdateInfo.objParams.bWholePositionChanged = true;
			} else{//이동한 스크롤바의 위치가 보정 범위 밖에 있을 때
				objUpdateInfo.objParams.bWholePositionChanged = false;
				
				//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간만큼은 nLeftCol, nRightCol값이 변하지 않아야 한다.
				nAdjustCountBeforeScrolling = objHSInfo.nPos - nMovedCount >= objHSInfo.nLastPos - objHSInfo.nAdjustCols ? objHSInfo.nPos - nMovedCount - (objHSInfo.nLastPos - objHSInfo.nAdjustCols) : 0;
				nCutColsCount = Math.abs(nMovedCount) - nAdjustCountBeforeScrolling;
				
				objHSInfo.nLeftCol -= nCutColsCount;
				objHSInfo.nRightCol -= nCutColsCount;
			}
		}
		
		objUpdateInfo.objParams.nCutColsCount = nCutColsCount;
	}
};

//QBOX.QCELL.BasicQCELL.prototype.onHScroll2 = function(nScrollLeft){
//	var objHSInfo = this.attr('hsinfo'), objQCell = this;
//	/*
//	this.attr('hsinfo', {
//		bHScroll			: false,	//HScrollbar 존재여부
//		nLastPos		: 0,		//스크롤바의 마지막 위치 / nLengthPerCol -> 가로스크롤바의 마지막 위치가 nLengthPerCol값 단위를 기준으로 몇 번 이동할 수 있는지
//		nMovedCount			: 0,		//스크롤바 위치 / nLengthPerCol -> 가로스크롤바의 현재 위치가 nLengthPerCol값 단위를 기준으로 몇 번 이동했는지
//		nLength				: 0,		//스크롤바의 길이
//		nStartCol			: -1,		//headerCols, frozenCols를 제외한 첫번째 일반 컬럼의 index
//		nEndCol				: -1,		//headerCols, frozenCols를 제외한 마지막 일반 컬럼의 index
//		nLeftCol			: -1,		//동적컬럼의 첫번째 index(현재 스크롤 위치에서  viewport 영역에 표시 할 첫 번째 일반 컬럼의 index)
//		nRightCol			: -1,		//동적컬럼의 마지막 index(현재 스크롤 위치에서  viewport 영역에 표시 할 마지막 일반컬럼의 index)
//		nAdjustCols			: 0,		//컬럼 셀 div들을  뜯어내지 않고 전체 left를 보정할 때 사용하는 보정 컬럼의 수
//		nDynamicCols		: 0,		//viewport 영역을 구성하는 동적 컬럼의 수
//		nLeft				: 0,		//현재 스크롤바의 위치
//		nBeforeLeft			: 0,		//스크롤바가 이동하기 전 스크롤바의 위치
//		nLengthPerCol		: 0			//한 컬럼 당 평균 이동 거리(모든 컬럼은 colwidth에 상관없이 동일한 스크롤 이동거리를 갖는다.)
//	}, 'object');
//	*/
//	/*
//	 * 가로 스크롤 고려사항
//	 * 1. nLengthPerCol(한 컬럼 당 평균 이동 거리)이상으로 가로스크롤바가 움직였을 때만 QCELL의 스크롤바가 이동했다고 판단한다.
//	 * 2. 가로스크롤바가 nLengthPerCol만큼 이동하면  틀고정 컬럼들을 제외한 가장 좌측에 있는 컬럼이 사라져야 하고, 사라진 컬럼 수만큼의 다음 컬럼이 화면에 나타나야 한다.
//	 * 3. QCELL의 컬럼이 표시되는 영역은 viewport영역과 colheader영역이다.
//	 * 4. QCELL 생성 시 _calculateDynamicCols()를 수행하여 viewport영역에 가장 많은 컬럼이 표시되는 경우를 기준으로 objHSInfo.nDynamicCols(동적 컬럼의 수)가 결정되었다.
//	 * 5. objHSInfo.nRightCol값이 마지막 컬럼인덱스 인 경우라도 가로스크롤바가 이동 할 수 있는 경우가 있을 수 있다.
//	 * 6. 이러한 경우 일반적인 경우처럼 이동한 컬럼 수만큼 동적 컬럼의 위치와 데이터를 갱신하는 것이 아니라 위치만 조절해야 한다.(이미 동적 컬럼의 가장 우측 컬럼이 마지막 컬럼이기 때문에 left값만 조절하면 화면에 표시 할 수 있다.)
//	 */
//	
//	if(Math.abs(objHSInfo.nLeft - nScrollLeft) >= objHSInfo.nLengthPerCol){//한 컬럼 당 평균 이동 거리(nLengthPerCol)이상으로 가로스크롤바가 움직였을 때만 QCELL의 스크롤바가 이동했다고 판단한다.
//		var arrHeaderText = this.attr('headertext'),
//		arrNormalColsCellDOMs = this._getCellGroupDOMs('col', 'normal'),
//		arrMovedDynamicColsCellDOMs = [],
//		arrCurrentData = this.attr('currentdata'),
//		bWholePositionChanged = false,
//		nHeaderRows = this.attr('headerrows'),
//		nHeaderCols = this.attr('headercols'),
//		nFrozenCols = this.attr('frozencols'),
//		nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth, nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
//		nAdjustedLeft = 0,					//nAdjustedLeft:이동한 가로스크롤바의 위치가 동적 컬럼을 변경하는 것이 아닌 left값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
//		nAdjustColWidths = 0,				//nAdjustColWidths:현재 컬럼의 left값 설정을 위해 이전 컬럼의 colWidth값을  nAdjustColWidths에 누적함 
//		nAdjustCountBeforeScrolling = 0,	//nAdjustCountBeforeScrolling:이동하기 전 가로 스크롤바위치가 보정영역인 경우의 보정 컬럼 수, 가로스크롤바가 왼쪽으로 이동 시 이동하기 전 가로스크롤바의 위치가 보정영역이였던 경우 보정영역 내 스크롤 이동 구간만큼은 nLeftCol, nRightCol값이 변하지 않아야 한다.
//		nMovedCount = parseInt(-(nScrollLeft - objHSInfo.nLeft) / objHSInfo.nLengthPerCol);//nMovedCount:스크롤바가 이동한 카운트
//		
//		objHSInfo.nBeforeLeft = objHSInfo.nLeft;
//		objHSInfo.nLeft = objHSInfo.nLeft - (nMovedCount * objHSInfo.nLengthPerCol);//가로스크롤바가 nLengthPerCol값 단위로 딱딱 맞아떨어지게 이동하면 좋겠지만 그렇지 않기 때문에 scrollLeft값으로 설정하면 안되고, 이동한 컬럼 수 만큼 nLengthPerCol값을 곱한 값을 더 해 줘야 한다.
//		objHSInfo.nPos = -(objHSInfo.nLeft / objHSInfo.nLengthPerCol);
//		
//		if(Math.abs(nMovedCount) >= objHSInfo.nDynamicCols - nFrozenCols){//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 많은 경우
//			var nAdjustCount = 0;//nAdjustCount: 보정 컬럼 수
//			if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
//				if(objHSInfo.nRightCol + nMovedCount > objHSInfo.nEndCol){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
//					nAdjustCount = (objHSInfo.nRightCol + nMovedCount) - objHSInfo.nEndCol;
//				}
//				
//				objHSInfo.nLeftCol += nMovedCount - nAdjustCount;
//				objHSInfo.nRightCol += nMovedCount - nAdjustCount;
//				
//				if(nAdjustCount > 0){
//					if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
//						nAdjustedLeft = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
//					} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
//						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//						nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
//					}
//				}
//			} else{//가로 스크롤바가 왼쪽으로 이동했을 때
//				//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간만큼은 nLeftCol, nRightCol값이 변하지 않아야 한다.
//				nAdjustCountBeforeScrolling = objHSInfo.nPos - nMovedCount >= objHSInfo.nLastPos - objHSInfo.nAdjustCols ? objHSInfo.nPos - nMovedCount - (objHSInfo.nLastPos - objHSInfo.nAdjustCols) : 0;
//				//console.log("스크롤바가 이동하기 전 기준 AdjustCols:", nAdjustCountBeforeScrolling);
//				
//				if(objHSInfo.nPos >= objHSInfo.nLastPos - objHSInfo.nAdjustCols){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
//					nAdjustCount = objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols);
//					nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nAdjustCount - 1);
//				} else{//이동한 스크롤바의 위치가 보정 범위 밖에 있을 때
//					objHSInfo.nLeftCol += nMovedCount + nAdjustCountBeforeScrolling;
//					objHSInfo.nRightCol += nMovedCount + nAdjustCountBeforeScrolling;
//				}
//			}
//			
//			nAdjustColWidths = nFrozenColsWidth;
//			_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
//				var nCol, nColWidth, nCellLeft, keyOfCol;
//				
//				nCol = objHSInfo.nLeftCol + idx;
//				nColWidth = objQCell._getColWidth(nCol);
//				nCellLeft = nAdjustColWidths - nAdjustedLeft;
//				keyOfCol = objQCell._getKeyOfCol(nCol);
//				
//				_.each(arrNormalColCellDOMs, function(heCell){
//					
//					heCell.setAttribute('data-col', nCol + '');
//					heCell.style.left = nCellLeft + 'px';
//					heCell.style.width = nColWidth + 'px';
//					
//					if(heCell.getAttribute('data-footer') !== 'true'){
//						var nRow = parseInt(heCell.getAttribute('data-row'));
//						
//						heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//						
//						if(nRow < nHeaderRows){
//							heCell.innerHTML = arrHeaderText[nCol][nRow];
//						} else{
//							heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//						}
//					}
//				});
//				
//				nAdjustColWidths += nColWidth;
//			});
//		} else{//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 적은 경우
//			var nCutColsCount = 0;//nCutColsCount:데이터와 위치를 갱신해야 하는 동적 컬럼의 수(ex> 가로스크롤바가 오른쪽으로 3칸 이동 시 3개의 일반컬럼을 표시하던 div들을 새로 나타해야 할 새로운 3개의 컬럼위치로 이동시키고 데이터를 갱신해야 한다.)
//			
//			if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
//				if(objHSInfo.nRightCol + nMovedCount > objHSInfo.nEndCol){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
//					nCutColsCount = objHSInfo.nEndCol - objHSInfo.nRightCol;
//					bWholePositionChanged = true;
//				} else{//이동한 스크롤바의 위치가 보정 범위 밖에 있을 때
//					nCutColsCount = nMovedCount;
//				}
//				
//				objHSInfo.nLeftCol += nCutColsCount;
//				objHSInfo.nRightCol += nCutColsCount;
//			} else{//가로 스크롤바가 왼쪽으로 이동했을 때
//				//모두 뜯지 않아야 하는 경우 발생 시, nAdjustCols 범위 안에 있는지 여부 확인
//				if(objHSInfo.nPos >= objHSInfo.nLastPos - objHSInfo.nAdjustCols){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
//					bWholePositionChanged = true;
//				} else{//이동한 스크롤바의 위치가 보정 범위 밖에 있을 때
//					//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간만큼은 nLeftCol, nRightCol값이 변하지 않아야 한다.
//					nAdjustCountBeforeScrolling = objHSInfo.nPos - nMovedCount >= objHSInfo.nLastPos - objHSInfo.nAdjustCols ? objHSInfo.nPos - nMovedCount - (objHSInfo.nLastPos - objHSInfo.nAdjustCols) : 0;
//					nCutColsCount = Math.abs(nMovedCount) - nAdjustCountBeforeScrolling;
//					
//					objHSInfo.nLeftCol -= nCutColsCount;
//					objHSInfo.nRightCol -= nCutColsCount;
//				}
//			}
//			
//			if(nCutColsCount > 0){
//				//var nMovedColWidths = 0, nStandardCol;
//				var nStandardCol;
//				
//				if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
//					arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(0, nCutColsCount);
//					//nMovedColWidths = -(this._getSumOfColWidth(objHSInfo.nLeftCol - nCutColsCount, objHSInfo.nLeftCol - 1));
//					//nAdjustColWidths = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nRightCol - nCutColsCount);
//					nAdjustColWidths = nFrozenColsWidth;
//					nStandardCol = objHSInfo.nLeftCol;
//				} else{//가로 스크롤바가 왼쪽으로 이동했을 때
//					arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(arrNormalColsCellDOMs.length - nCutColsCount, nCutColsCount);
//					//nMovedColWidths = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nCutColsCount - 1);
//					//nAdjustColWidths = nFrozenColsWidth;
//					nAdjustColWidths = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nCutColsCount - 1);
//					nStandardCol = objHSInfo.nLeftCol + nCutColsCount;
//				}
//				
//				if(!bWholePositionChanged){
//					//계속 화면에 표시해야 하는 컬럼 셀들은 갱신하지 않고 left값만 세팅
//					_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
//						var nCol, nColWidth, nCellLeft;
//						
//						nCol = nStandardCol + idx;
//						nColWidth = objQCell._getColWidth(nCol);
//						nCellLeft = nAdjustColWidths;
//						
//						_.each(arrNormalColCellDOMs, function(heCell){
//							heCell.style.left = nCellLeft + 'px';
//						});
//						
//						nAdjustColWidths += nColWidth;
//					});
//				}
//				
//				//화면에 표시하지 않아야 하는 컬럼 셀들은 가장 우측에 표시되고 있는 컬럼 옆으로 이동시킨 후 갱신해야 한다.
//				nStandardCol = nMovedCount > 0 ? objHSInfo.nRightCol - nCutColsCount + 1 : objHSInfo.nLeftCol;
//				nAdjustColWidths = nMovedCount > 0 ? nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nRightCol - nCutColsCount) : nFrozenColsWidth;
//				_.each(arrMovedDynamicColsCellDOMs, function(arrMovedColCellDOMs, idx){
//					var nCol, nColWidth, nCellLeft, keyOfCol;
//					
//					nCol = nStandardCol + idx;
//					nColWidth = objQCell._getColWidth(nCol);
//					nCellLeft = nAdjustColWidths;
//					keyOfCol = objQCell._getKeyOfCol(nCol);
//					
//					_.each(arrMovedColCellDOMs, function(heCell){
//						heCell.setAttribute('data-col', nCol + '');
//						heCell.style.width = nColWidth + 'px';
//						if(!bWholePositionChanged){
//							heCell.style.left = nCellLeft + 'px';
//						}
//						
//						if(heCell.getAttribute('data-footer') !== 'true'){
//							var nRow = parseInt(heCell.getAttribute('data-row'));
//							
//							heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//							
//							if(nRow < nHeaderRows){
//								heCell.innerHTML = arrHeaderText[nCol][nRow];
//							} else{
//								heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//							}
//						}
//					});
//					
//					nAdjustColWidths += nColWidth;
//				});
//			}
//			
//			if(bWholePositionChanged){
//				//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 left를 보정해야 하는 경우다.
//				if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
//					arrNormalColsCellDOMs = arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs);
//					
//					if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
//						nAdjustedLeft = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
//					} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
//						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//						nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
//					}
//				} else{//가로 스크롤바가 왼쪽으로 이동했을 때
//					arrNormalColsCellDOMs = arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs);
//					nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos)) - 1);
//				}
//				
//				nAdjustColWidths = nFrozenColsWidth;
//				_.each(arrNormalColsCellDOMs, function(arrMovedColCellDOMs, idx){
//					var nCol, nColWidth, nCellLeft;
//					
//					nCol = objHSInfo.nLeftCol + idx;
//					nColWidth = objQCell._getColWidth(nCol);
//					nCellLeft = nAdjustColWidths - nAdjustedLeft;
//					
//					_.each(arrMovedColCellDOMs, function(heCell){
//						heCell.style.left = nCellLeft + 'px';
//					});
//					
//					nAdjustColWidths += nColWidth;
//				});
//				
//				this._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs);
//			} else{
//				if(nMovedCount > 0){
//					this._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs));
//				} else{
//					this._setCellGroupDOMs('col', 'normal', arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs));
//				}
//			}
//		}
//		arrMovedDynamicColsCellDOMs.RT_clear();
//		arrMovedDynamicColsCellDOMs = null;
//	}
//};

//QBOX.QCELL.BasicQCELL.prototype.onHScroll1 = function(nScrollLeft){
//	var objQCell = this,
//	objHSInfo = this.attr('hsinfo');
//	
//	if(Math.abs(objHSInfo.nLeft - nScrollLeft) >= objHSInfo.nLengthPerCol){//한 컬럼 당 평균 이동 거리(nLengthPerCol)이상으로 가로스크롤바가 움직였을 때만
//		var arrHeaderText = this.attr('headertext'),
//		arrNormalColsCellDOMs = this._getCellGroupDOMs('col', 'normal'),
//		arrMovedDynamicColsCellDOMs = [],
//		arrCurrentData = this.attr('currentdata'),
//		bWholePositionChanged = false;
//		nHeaderRows = this.attr('headerrows'),
//		nHeaderCols = this.attr('headercols'),
//		nFrozenCols = this.attr('frozencols'),
//		nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth,
//		nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
//		nCutColsCount = 0,		//데이터와 위치를 갱신해야 하는 동적 컬럼의 수(ex> 가로스크롤바가 오른쪽으로 3칸 이동 시 3개의 일반컬럼을 표시하던 div들을 새로 나타해야 할 새로운 3개의 컬럼위치로 이동시키고 데이터를 갱신해야 한다.)
//		nAdjustedLeft = 0,		//이동한 스크롤바의 위치가 동적 컬럼을 변경하는 것이 아닌 left값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
//		nAdjustColWidths = 0,	//현재 컬럼의 left값 설정을 위해 이전 컬럼의 colWidth값을  nAdjustColWidths에 누적함 
//		nMoveCount = parseInt(-(nScrollLeft - objHSInfo.nLeft) / objHSInfo.nLengthPerCol);//nMoveCount:스크롤바가 이동한 컬럼 수
//		
//		objHSInfo.nBeforeLeft = objHSInfo.nLeft;
//		objHSInfo.nLeft = objHSInfo.nLeft - (nMoveCount * objHSInfo.nLengthPerCol);//scrollLeft값으로 설정하면 안되고, 이동한 컬럼 수 만큼 nLengthPerCol값을 곱한 값을 더 해 줘야 한다.
//		objHSInfo.nPos += nMoveCount;
//		
//		if(nMoveCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
//			console.log('가로 스크롤바가 오른쪽으로 이동했을 때');
//			
//			/*
//			오른쪽으로 스크롤이 이동했을 때 아이디어
//			1. 동적 컬럼 수보다 더 많이 이동한 경우 전체 셀을 갱신한다.
//				1-1. 마지막 동적 컬럼인덱스와 이동한 컬럼 수의 합이 QCELL의 마지막 컬럼인덱스보다 작거나 같은 경우(일반적인 경우)
//				1-2. 마지막 동적 컬럼인덱스와 이동한 컬럼 수의 합이 QCELL의 마지막 컬럼인덱스보다 큰 경우(전체 cell들의 left값을 보정해야 하는 경우임)
//			2. 동적 컬럼 수보다 적게 이동한 경우
//				2-1. 이동한 컬럼 수와 갱신 해 줘야 할 동적 컬럼 수가 같은 경우(일반적인 경우)
//				2-2. 이동한 컬럼 수 보다 갱신 해 줘야 할 동적 컬럼 수가 적은 경우(마지막 동적 컬럼이 QCELL의 마지막 컬럼인 경우이며, 전체 cell들의 left값을 보정해야 하는 경우임)
//				2-2-1. 가로스크롤바가 우측 끝인 경우(viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우)
//				2-2-2. 가로스크롤바가 우측 끝이 아닌 경우(이동한 컬럼들 중에서 동적 컬럼을 갱신하지 않고 left값만 조정해 줘야 하는 컬럼들의 colWidth 합 만큼 left를 이동시켜야 하는 경우)
//			 */
//			
//			//if(nCutColsCount >= objHSInfo.nDynamicCols - nFrozenCols){
//			if(nMoveCount >= objHSInfo.nDynamicCols - nFrozenCols){//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 많은 경우
//				//console.log('전체 갱신을 해야 하는 경우, nMoveCount:', nMoveCount, ', nCutColsCount:', nCutColsCount, ', nLeftCol:', objHSInfo.nLeftCol, ', nRightCol:', objHSInfo.nRightCol);
//				//전체 갱신을 해야 하는 경우, nMoveCount: 12 , nCutColsCount: 8 , nLeftCol: 7 , nRightCol: 14
//				//여기서는 뜯지 않으니 nCutColsCount가 필요없다.
//				
//				//이동한 수만큼 nLeftCol, nRightCol값을 세팅하되, AdjustCols 내 위치인 경우를 고려한다.
//				var nAdjustCols = objHSInfo.nRightCol + nMoveCount > objHSInfo.nEndCol ? (objHSInfo.nRightCol + nMoveCount) - objHSInfo.nEndCol : 0;
//				
//				objHSInfo.nLeftCol += nMoveCount - nAdjustCols;
//				objHSInfo.nRightCol += nMoveCount - nAdjustCols;
//				
//				if(nAdjustCols > 0){
//					if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
//						nAdjustedLeft = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
//					} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
//						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//						nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
//					}
//				}
//				
//				nAdjustColWidths = nFrozenColsWidth;
//				_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
//					var nCol, nColWidth, nCellLeft;
//					nCol = objHSInfo.nLeftCol + idx;
//					nColWidth = objQCell._getColWidth(nCol);
//					nCellLeft = nAdjustColWidths - nAdjustedLeft;
//					keyOfCol = objQCell._getKeyOfCol(nCol);
//					_.each(arrNormalColCellDOMs, function(heCell){
//						var nRow = parseInt(heCell.getAttribute('data-row'));
//						heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//						heCell.setAttribute('data-col', nCol + '');
//						heCell.style.left = nCellLeft + 'px';
//						heCell.style.width = nColWidth + 'px';
//						
//						if(nRow < nHeaderRows){
//							heCell.innerHTML = arrHeaderText[nCol][nRow];
//						} else{
//							heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//						}
//					});
//					nAdjustColWidths += nColWidth;
//				});
//			} else{
//				if(objHSInfo.nPos < objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//					console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때');
//					nCutColsCount = nMoveCount;
//				} else{
//					console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때');
//					nCutColsCount = objHSInfo.nEndCol - objHSInfo.nRightCol;
//					bWholePositionChanged = true;
//				}
//				
//				objHSInfo.nLeftCol += nCutColsCount;
//				objHSInfo.nRightCol += nCutColsCount;
////			
////			if(objHSInfo.nRightCol + nMoveCount <= objHSInfo.nEndCol){//최우측 컬럼인덱스와 이동한 컬럼 수의 합이 전체 컬럼 수보다 작은 경우
////				//console.log('이동한 컬럼카운트만큼 모두 뜯어낼 수 있으면');
////				nCutColsCount = nMoveCount;
////			} else{//최우측 컬럼인덱스와 이동한 컬럼 수의 합이 전체 컬럼 수보다 큰 경우
////				//console.log('이동한 컬럼카운트만큼 모두 뜯어낼 수 없으면');
////				nCutColsCount = objHSInfo.nEndCol - objHSInfo.nRightCol;
////				bWholePositionChanged = true;
////			}
////			
////			objHSInfo.nLeftCol += nCutColsCount;
////			objHSInfo.nRightCol += nCutColsCount;
//				
//				if(nCutColsCount > 0){
//					//console.log("nCutColsCount:", nCutColsCount);
//					var nRightColLeft,
//					nMovedColWidths;
//					//console.log("before arrNormalColsCellDOMs.length:", arrNormalColsCellDOMs.length);
//					arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(0, nCutColsCount);
//					//console.log(objHSInfo.nDynamicCols - nFrozenCols);
//					//console.log("after arrNormalColsCellDOMs.length:", arrNormalColsCellDOMs.length);
//					//계속 화면에 표시해야 하는 컬럼 셀들은 갱신하지 않고 left값만 세팅
//					nMovedColWidths = this._getSumOfColWidth(objHSInfo.nLeftCol - nCutColsCount, objHSInfo.nLeftCol - 1);
//					_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs){
//						var nCellLeft = 0;
//						_.each(arrNormalColCellDOMs, function(heCell, idx){
//							if(idx === 0){
//								nCellLeft = parseFloat(heCell.style.left) - (nMovedColWidths);
//							}
//							heCell.style.left = nCellLeft + 'px';
//						});
//					});
//					
//					//화면에 표시하지 않아야 하는 컬럼 셀들은 가장 우측에 표시되고 있는 컬럼 옆으로 이동시킨 후 갱신해야 한다.
//					//console.log('objHSInfo.nLeftCol:', objHSInfo.nLeftCol, ', objHSInfo.nRightCol:', objHSInfo.nRightCol);
//					//console.log('DOM\'s rightCol:', arrNormalColsCellDOMs[arrNormalColsCellDOMs.length - 1][0].getAttribute('data-col'));
//					//console.log('calc rightCol:', objHSInfo.nRightCol - nCutColsCount);
//					//nRightColLeft = parseFloat(arrNormalColsCellDOMs[arrNormalColsCellDOMs.length - 1][0].style.left);
//					//console.log('DOM\'s rightColLeft:', nRightColLeft);
//					//console.log('calc rightColLeft:', this._getSumOfColWidth(objHSInfo.nLeftCol - nCutColsCount, objHSInfo.nRightCol - nCutColsCount));
//					nAdjustColWidths = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nRightCol - nCutColsCount);
//					_.each(arrMovedDynamicColsCellDOMs, function(arrMovedColCellDOMs, idx){
//						var nCol, nColWidth, nCellLeft, keyOfCol;
//						
//						nCol = objHSInfo.nRightCol - nCutColsCount + (idx + 1);
//						nColWidth = objQCell._getColWidth(nCol);
//						//nAdjustColWidths += objQCell._getColWidth(nCol - 1);
//						//nCellLeft = nRightColLeft + nAdjustColWidths;
//						nCellLeft = nAdjustColWidths;
//						keyOfCol = objQCell._getKeyOfCol(nCol);
//						
//						_.each(arrMovedColCellDOMs, function(heCell){
//							var nRow = parseInt(heCell.getAttribute('data-row'));
//							
//							heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//							heCell.setAttribute('data-col', nCol + '');
//							heCell.style.left = nCellLeft + 'px';
//							heCell.style.width = nColWidth + 'px';
//							
//							if(nRow < nHeaderRows){
//								heCell.innerHTML = arrHeaderText[nCol][nRow];
//							} else{
//								heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//							}
//						});
//						nAdjustColWidths += nColWidth;
//					});
//				}
//				
//				if(bWholePositionChanged){
//					//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 left를 보정해야 하는 경우다.
//					arrNormalColsCellDOMs = arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs);
//					
//					if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
//						nAdjustedLeft = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
//					} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
//						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//						nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
//					}
//					
//					nAdjustColWidths = nFrozenColsWidth;
//					_.each(arrNormalColsCellDOMs, function(arrMovedColCellDOMs, idx){
//						var nCol, nColWidth, nCellLeft;
//						
//						nCol = objHSInfo.nLeftCol + idx;
//						nColWidth = objQCell._getColWidth(nCol);
//						nCellLeft = nAdjustColWidths - nAdjustedLeft;
//						_.each(arrMovedColCellDOMs, function(heCell){
//							heCell.style.left = nCellLeft + 'px';
//						});
//						
//						nAdjustColWidths += nColWidth;
//					});
//					
//					this._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs);
//				} else{
//					objQCell._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs));
//				}
//			}
//		} else{//왼쪽으로 스크롤이 이동했을 때
//			console.log('가로스크롤바가 왼쪽으로 이동했을 때');
//			/*
//			왼쪽으로 스크롤이 이동했을 때
//			1. 일반적으로는 이동한 컬럼의 width만큼 left를 더주면 된다.
//			2. 뜯어낼 수 있는 최대 컬럼 수는 왼쪽에 붙여넣을 때 첫번째 일반 컬럼인덱스와 같은 경우이다.
//			3.
//			 */
//			
//			//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간은 nLeftCol, nRightCol값이 변하지 않아야 한다. 
//			var nAdjustColsBeforeScrolling = objHSInfo.nPos - nMoveCount >= objHSInfo.nLastPos - objHSInfo.nAdjustCols ? objHSInfo.nPos - nMoveCount - (objHSInfo.nLastPos - objHSInfo.nAdjustCols) : 0;
//			console.log("스크롤바가 이동하기 전 기준 AdjustCols:", nAdjustColsBeforeScrolling);
//			
//			if(Math.abs(nMoveCount) >= objHSInfo.nDynamicCols - nFrozenCols){//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 많은 경우
//				console.log('전체 갱신을 해야 하는 경우, nMoveCount:', nMoveCount, ', nLeftCol:', objHSInfo.nLeftCol, ', nRightCol:', objHSInfo.nRightCol);
//				//전체 갱신을 해야 하는 경우, nMoveCount: 12 , nCutColsCount: 8 , nLeftCol: 7 , nRightCol: 14
//				//여기서는 뜯지 않으니 nCutColsCount가 필요없다.
//				
//				//이동한 수만큼 nLeftCol, nRightCol값을 세팅하되, AdjustCols 내 위치인 경우를 고려한다.
//				//이전 가로스크롤바 위치: objHSInfo.nPos - nMoveCount 또는 objHSInfo.nBeforeLeft / objHSInfo.nLengthPerCol
//				//console.log("beforeLeftCol:", objHSInfo.nLeftCol);
//				
//				//console.log("스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위:", objHSInfo.nLastPos - objHSInfo.nAdjustCols);
//				//console.log("이전 스크롤바 위치:", objHSInfo.nPos - nMoveCount);
//				//console.log("nMoveCount:", nMoveCount);
//				
//				//objHSInfo.nLeftCol += nMoveCount + nAdjustColsBeforeScrolling;
//				//objHSInfo.nRightCol += nMoveCount + nAdjustColsBeforeScrolling;
//				
//				//console.log("aferLeftCol:", objHSInfo.nLeftCol);
//				
//				if(objHSInfo.nPos < objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//					console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때');
//					
//					objHSInfo.nLeftCol += nMoveCount + nAdjustColsBeforeScrolling;
//					objHSInfo.nRightCol += nMoveCount + nAdjustColsBeforeScrolling;
//				} else{
//					console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때');
//					//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//					var nAdjustCols = objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols);
//					//console.log('nAdjustCols:', nAdjustCols);
//					nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nAdjustCols - 1);
//				}
//				/*
//				if(objHSInfo.nPos >= objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//					console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때');
//					//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//					var nAdjustCols = objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols);
//					//console.log('nAdjustCols:', nAdjustCols);
//					nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nAdjustCols - 1);
//				} else{
//					objHSInfo.nLeftCol += nMoveCount + nAdjustColsBeforeScrolling;
//					objHSInfo.nRightCol += nMoveCount + nAdjustColsBeforeScrolling;
//				}
//				 */
//				nAdjustColWidths = nFrozenColsWidth;
//				_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
//					var nCol, nColWidth, nCellLeft, keyOfCol;
//					
//					nCol = objHSInfo.nLeftCol + idx;
//					nColWidth = objQCell._getColWidth(nCol);
//					nCellLeft = nAdjustColWidths - nAdjustedLeft;
//					keyOfCol = objQCell._getKeyOfCol(nCol);
//					
//					_.each(arrNormalColCellDOMs, function(heCell){
//						var nRow = parseInt(heCell.getAttribute('data-row'));
//						
//						heCell.style.left = nCellLeft + 'px';
//						heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//						heCell.setAttribute('data-col', nCol + '');
//						heCell.style.left = nCellLeft + 'px';
//						heCell.style.width = nColWidth + 'px';
//						
//						if(nRow < nHeaderRows){
//							heCell.innerHTML = arrHeaderText[nCol][nRow];
//						} else{
//							heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//						}
//					});
//					
//					nAdjustColWidths += nColWidth;
//				});
//			} else{
//				//모두 뜯지 않아야 하는 경우 발생 시, nAdjustCols 범위 안에 있는지 여부 확인
//				
//				//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간은 nLeftCol, nRightCol값이 변하지 않아야 한다. 
//				
//				//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//				if(objHSInfo.nPos < objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//					console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때');
//					
//					nCutColsCount = Math.abs(nMoveCount) - nAdjustColsBeforeScrolling;
//					
//					//console.log("nCutColsCount:", nCutColsCount);
//					
//					objHSInfo.nLeftCol -= nCutColsCount;
//					objHSInfo.nRightCol -= nCutColsCount;
//				} else{
//					console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때');
//					//nCutColsCount = 0;
//					//console.log("nCutColsCount:", nCutColsCount);
//					bWholePositionChanged = true;
//				}
//				
//				if(nCutColsCount > 0){
//					var nLeftColLeft,
//					nMovedColWidths;
//					arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(arrNormalColsCellDOMs.length - nCutColsCount, nCutColsCount);
//					
//					//계속 화면에 표시해야 하는 컬럼 셀들은 갱신하지 않고 left값만 세팅
//					nMovedColWidths = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nCutColsCount - 1);
//					_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs){
//						var nCellLeft = 0;
//						_.each(arrNormalColCellDOMs, function(heCell, idx){
//							if(idx === 0){
//								nCellLeft = parseFloat(heCell.style.left) + (nMovedColWidths);
//							}
//							heCell.style.left = nCellLeft + 'px';
//						});
//					});
//					
//					//화면에 표시하지 않아야 하는 컬럼 셀들은 가장 좌측에 표시되고 있는 컬럼 옆으로 이동시킨 후 갱신해야 한다.
//					console.log('nLeftCol:', objHSInfo.nLeftCol, 'nBeforeLeftCol:', arrNormalColsCellDOMs[0][0].getAttribute('data-col'));
//					nAdjustColWidths = nFrozenColsWidth;
//					_.each(arrMovedDynamicColsCellDOMs, function(arrMovedColCellDOMs, idx){
//						var nCol, nColWidth, nCellLeft, keyOfCol;
//						
//						nCol = objHSInfo.nLeftCol + idx;
//						nColWidth = objQCell._getColWidth(nCol);
//						nCellLeft = nAdjustColWidths;
//						keyOfCol = objQCell._getKeyOfCol(nCol);
//						
//						_.each(arrMovedColCellDOMs, function(heCell){
//							var nRow = parseInt(heCell.getAttribute('data-row'));
//							heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//							heCell.setAttribute('data-col', nCol + '');
//							heCell.style.left = nCellLeft + 'px';
//							heCell.style.width = nColWidth + 'px';
//							if(nRow < nHeaderRows){
//								heCell.innerHTML = arrHeaderText[nCol][nRow];
//							} else{
//								heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//							}
//						});
//						nAdjustColWidths += nColWidth;
//					});
//				}
//				
//				if(bWholePositionChanged){
//					//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 left를 보정해야 하는 경우다.
//					arrNormalColsCellDOMs = arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs);
//					
//					//console.log("objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos):", objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos));
//					nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos)) - 1);
//					
//					nAdjustColWidths = nFrozenColsWidth;
//					_.each(arrNormalColsCellDOMs, function(arrMovedColCellDOMs, idx){
//						var nCol, nColWidth, nCellLeft;
//						
//						nCol = objHSInfo.nLeftCol + idx;
//						nColWidth = objQCell._getColWidth(nCol);
//						nCellLeft = nAdjustColWidths - nAdjustedLeft;
//						
//						_.each(arrMovedColCellDOMs, function(heCell){
//							heCell.style.left = nCellLeft + 'px';
//						});
//						
//						nAdjustColWidths += nColWidth;
//					});
//					
//					this._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs);
//				} else{
//					this._setCellGroupDOMs('col', 'normal', arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs));
//				}
//			}
//		}
//	}
//};
//
//QBOX.QCELL.BasicQCELL.prototype.whileHScrolling = function(params){
//	//prototype함수이지만, mCustomScrollbar의 이벤트 콜백으로 호출되기 때문에 this가 QCELL 객체가 아니다.
//	//	this.mcs = {
//	//	"left": 0,
//	//	"draggerLeft": 0,
//	//	"leftPct": 0,
//	//	"direction": "x",
//	//	"target": objQCell
//	//};
//	var objQCell = this.mcs.target,
//	nScrollLeft = this.mcs.left;
//	if(handle){
//		console.log(2);
//		QBOX.util.cancelAnimationFrame(handle);
//		handle = null;
//	} else{
//		console.log(1);
//		handle = QBOX.util.requestAnimationFrame(function(){
//			console.log(11);
//			var objHSInfo = objQCell.attr('hsinfo');
//			
//			if(Math.abs(objHSInfo.nLeft - nScrollLeft) >= objHSInfo.nLengthPerCol){//한 컬럼 당 평균 이동 거리(nLengthPerCol)이상으로 가로스크롤바가 움직였을 때만
//				var arrHeaderText = objQCell.attr('headertext'),
//				arrNormalColsCellDOMs = objQCell._getCellGroupDOMs('col', 'normal'),
//				arrMovedDynamicColsCellDOMs = [],
//				arrCurrentData = objQCell.attr('currentdata'),
//				nHeaderRows = objQCell.attr('headerrows'),
//				nHeaderCols = objQCell.attr('headercols'),
//				nFrozenCols = objQCell.attr('frozencols'),
//				nViewPortOffsetWidth = objQCell.attr('layoutsize').viewport.offsetWidth,
//				nFrozenColsWidth = objQCell._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
//				nMoveCount = parseInt(-(nScrollLeft - objHSInfo.nLeft) / objHSInfo.nLengthPerCol),//nMoveCount:스크롤바가 이동한 컬럼 수
//				nCutColsCount = 0, //데이터와 위치를 갱신해야 하는 동적 컬럼의 수(ex> 가로스크롤바가 오른쪽으로 3칸 이동 시 3개의 일반컬럼을 표시하던 div들을 새로 나타해야 할 새로운 3개의 컬럼위치로 이동시키고 데이터를 갱신해야 한다.)
//				nAdjustedLeft = 0,		//left값 보정이 필요할 때 사용
//				nAdjustColWidths = 0,	//left값 설정을 위해 사용
//				bWholePositionChanged = false;
//				
//				objHSInfo.nBeforeLeft = objHSInfo.nLeft;
//				objHSInfo.nLeft = objHSInfo.nLeft - (nMoveCount * objHSInfo.nLengthPerCol);//scrollLeft값으로 설정하면 안되고, 이동한 컬럼 수 만큼 nLengthPerCol값을 곱한 값을 더 해 줘야 한다.
//				objHSInfo.nPos += nMoveCount;
//				
//				if(nMoveCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
//					console.log('가로 스크롤바가 오른쪽으로 이동했을 때');
//					
//					/*
//				오른쪽으로 스크롤이 이동했을 때 아이디어
//				1. 동적 컬럼 수보다 더 많이 이동한 경우 전체 셀을 갱신한다.
//					1-1. 마지막 동적 컬럼인덱스와 이동한 컬럼 수의 합이 QCELL의 마지막 컬럼인덱스보다 작거나 같은 경우(일반적인 경우)
//					1-2. 마지막 동적 컬럼인덱스와 이동한 컬럼 수의 합이 QCELL의 마지막 컬럼인덱스보다 큰 경우(전체 cell들의 left값을 보정해야 하는 경우임)
//				2. 동적 컬럼 수보다 적게 이동한 경우
//					2-1. 이동한 컬럼 수와 갱신 해 줘야 할 동적 컬럼 수가 같은 경우(일반적인 경우)
//					2-2. 이동한 컬럼 수 보다 갱신 해 줘야 할 동적 컬럼 수가 적은 경우(마지막 동적 컬럼이 QCELL의 마지막 컬럼인 경우이며, 전체 cell들의 left값을 보정해야 하는 경우임)
//						2-2-1. 가로스크롤바가 우측 끝인 경우(viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우)
//						2-2-2. 가로스크롤바가 우측 끝이 아닌 경우(이동한 컬럼들 중에서 동적 컬럼을 갱신하지 않고 left값만 조정해 줘야 하는 컬럼들의 colWidth 합 만큼 left를 이동시켜야 하는 경우)
//					 */
//					
//					//if(nCutColsCount >= objHSInfo.nDynamicCols - nFrozenCols){
//					if(nMoveCount >= objHSInfo.nDynamicCols - nFrozenCols){//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 많은 경우
//						//console.log('전체 갱신을 해야 하는 경우, nMoveCount:', nMoveCount, ', nCutColsCount:', nCutColsCount, ', nLeftCol:', objHSInfo.nLeftCol, ', nRightCol:', objHSInfo.nRightCol);
//						//전체 갱신을 해야 하는 경우, nMoveCount: 12 , nCutColsCount: 8 , nLeftCol: 7 , nRightCol: 14
//						//여기서는 뜯지 않으니 nCutColsCount가 필요없다.
//						
//						//이동한 수만큼 nLeftCol, nRightCol값을 세팅하되, AdjustCols 내 위치인 경우를 고려한다.
//						var nAdjustCols = objHSInfo.nRightCol + nMoveCount > objHSInfo.nEndCol ? (objHSInfo.nRightCol + nMoveCount) - objHSInfo.nEndCol : 0;
//						
//						objHSInfo.nLeftCol += nMoveCount - nAdjustCols;
//						objHSInfo.nRightCol += nMoveCount - nAdjustCols;
//						
//						if(nAdjustCols > 0){
//							if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
//								nAdjustedLeft = nFrozenColsWidth + objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
//							} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
//								//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//								nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - nAdjustCols) - 1);
//							}
//						}
//						
//						nAdjustColWidths = nFrozenColsWidth;
//						_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
//							var nCol, nColWidth, nCellLeft;
//							nCol = objHSInfo.nLeftCol + idx;
//							nColWidth = objQCell._getColWidth(nCol);
//							nCellLeft = nAdjustColWidths - nAdjustedLeft;
//							keyOfCol = objQCell._getKeyOfCol(nCol);
//							_.each(arrNormalColCellDOMs, function(heCell){
//								var nRow = parseInt(heCell.getAttribute('data-row'));
//								heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//								heCell.setAttribute('data-col', nCol + '');
//								heCell.style.left = nCellLeft + 'px';
//								heCell.style.width = nColWidth + 'px';
//								
//								if(nRow < nHeaderRows){
//									heCell.innerHTML = arrHeaderText[nCol][nRow];
//								} else{
//									heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//								}
//							});
//							nAdjustColWidths += nColWidth;
//						});
//					} else{
//						if(objHSInfo.nPos < objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//							console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때');
//							nCutColsCount = nMoveCount;
//						} else{
//							console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때');
//							nCutColsCount = objHSInfo.nEndCol - objHSInfo.nRightCol;
//							bWholePositionChanged = true;
//						}
//						
//						objHSInfo.nLeftCol += nCutColsCount;
//						objHSInfo.nRightCol += nCutColsCount;
////					
////					if(objHSInfo.nRightCol + nMoveCount <= objHSInfo.nEndCol){//최우측 컬럼인덱스와 이동한 컬럼 수의 합이 전체 컬럼 수보다 작은 경우
////						//console.log('이동한 컬럼카운트만큼 모두 뜯어낼 수 있으면');
////						nCutColsCount = nMoveCount;
////					} else{//최우측 컬럼인덱스와 이동한 컬럼 수의 합이 전체 컬럼 수보다 큰 경우
////						//console.log('이동한 컬럼카운트만큼 모두 뜯어낼 수 없으면');
////						nCutColsCount = objHSInfo.nEndCol - objHSInfo.nRightCol;
////						bWholePositionChanged = true;
////					}
////					
////					objHSInfo.nLeftCol += nCutColsCount;
////					objHSInfo.nRightCol += nCutColsCount;
//						
//						if(nCutColsCount > 0){
//							//console.log("nCutColsCount:", nCutColsCount);
//							var nRightColLeft,
//							nMovedColWidths;
//							//console.log("before arrNormalColsCellDOMs.length:", arrNormalColsCellDOMs.length);
//							arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(0, nCutColsCount);
//							//console.log(objHSInfo.nDynamicCols - nFrozenCols);
//							//console.log("after arrNormalColsCellDOMs.length:", arrNormalColsCellDOMs.length);
//							//계속 화면에 표시해야 하는 컬럼 셀들은 갱신하지 않고 left값만 세팅
//							nMovedColWidths = objQCell._getSumOfColWidth(objHSInfo.nLeftCol - nCutColsCount, objHSInfo.nLeftCol - 1);
//							_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs){
//								var nCellLeft = 0;
//								_.each(arrNormalColCellDOMs, function(heCell, idx){
//									if(idx === 0){
//										nCellLeft = parseFloat(heCell.style.left) - (nMovedColWidths);
//									}
//									heCell.style.left = nCellLeft + 'px';
//								});
//							});
//							
//							//화면에 표시하지 않아야 하는 컬럼 셀들은 가장 우측에 표시되고 있는 컬럼 옆으로 이동시킨 후 갱신해야 한다.
//							nRightColLeft = parseFloat(arrNormalColsCellDOMs[arrNormalColsCellDOMs.length - 1][0].style.left);
//							_.each(arrMovedDynamicColsCellDOMs, function(arrMovedColCellDOMs, idx){
//								var nCol, nColWidth, nCellLeft, keyOfCol;
//								
//								nCol = objHSInfo.nRightCol - nCutColsCount + (idx + 1);
//								nColWidth = objQCell._getColWidth(nCol);
//								nAdjustColWidths += objQCell._getColWidth(nCol - 1);
//								nCellLeft = nRightColLeft + nAdjustColWidths;
//								keyOfCol = objQCell._getKeyOfCol(nCol);
//								
//								_.each(arrMovedColCellDOMs, function(heCell){
//									var nRow = parseInt(heCell.getAttribute('data-row'));
//									
//									heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//									heCell.setAttribute('data-col', nCol + '');
//									heCell.style.left = nCellLeft + 'px';
//									heCell.style.width = nColWidth + 'px';
//									
//									if(nRow < nHeaderRows){
//										heCell.innerHTML = arrHeaderText[nCol][nRow];
//									} else{
//										heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//									}
//								});
//							});
//						}
//						
//						if(bWholePositionChanged){
//							//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 left를 보정해야 하는 경우다.
//							arrNormalColsCellDOMs = arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs);
//							
//							if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
//								nAdjustedLeft = nFrozenColsWidth + objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
//							} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
//								//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//								nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
//							}
//							
//							nAdjustColWidths = nFrozenColsWidth;
//							_.each(arrNormalColsCellDOMs, function(arrMovedColCellDOMs, idx){
//								var nCol, nColWidth, nCellLeft;
//								
//								nCol = objHSInfo.nLeftCol + idx;
//								nColWidth = objQCell._getColWidth(nCol);
//								nCellLeft = nAdjustColWidths - nAdjustedLeft;
//								_.each(arrMovedColCellDOMs, function(heCell){
//									heCell.style.left = nCellLeft + 'px';
//								});
//								
//								nAdjustColWidths += nColWidth;
//							});
//							
//							objQCell._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs);
//						} else{
//							objQCell._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs));
//						}
//					}
//				} else{//왼쪽으로 스크롤이 이동했을 때
//					console.log('가로스크롤바가 왼쪽으로 이동했을 때');
//					/*
//				왼쪽으로 스크롤이 이동했을 때
//				1. 일반적으로는 이동한 컬럼의 width만큼 left를 더주면 된다.
//				2. 뜯어낼 수 있는 최대 컬럼 수는 왼쪽에 붙여넣을 때 첫번째 일반 컬럼인덱스와 같은 경우이다.
//				3.
//					 */
//					
//					//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간은 nLeftCol, nRightCol값이 변하지 않아야 한다. 
//					var nAdjustColsBeforeScrolling = objHSInfo.nPos - nMoveCount >= objHSInfo.nLastPos - objHSInfo.nAdjustCols ? objHSInfo.nPos - nMoveCount - (objHSInfo.nLastPos - objHSInfo.nAdjustCols) : 0;
//					console.log("스크롤바가 이동하기 전 기준 AdjustCols:", nAdjustColsBeforeScrolling);
//					
//					if(Math.abs(nMoveCount) >= objHSInfo.nDynamicCols - nFrozenCols){//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 많은 경우
//						console.log('전체 갱신을 해야 하는 경우, nMoveCount:', nMoveCount, ', nLeftCol:', objHSInfo.nLeftCol, ', nRightCol:', objHSInfo.nRightCol);
//						//전체 갱신을 해야 하는 경우, nMoveCount: 12 , nCutColsCount: 8 , nLeftCol: 7 , nRightCol: 14
//						//여기서는 뜯지 않으니 nCutColsCount가 필요없다.
//						
//						//이동한 수만큼 nLeftCol, nRightCol값을 세팅하되, AdjustCols 내 위치인 경우를 고려한다.
//						//이전 가로스크롤바 위치: objHSInfo.nPos - nMoveCount 또는 objHSInfo.nBeforeLeft / objHSInfo.nLengthPerCol
//						//console.log("beforeLeftCol:", objHSInfo.nLeftCol);
//						
//						//console.log("스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위:", objHSInfo.nLastPos - objHSInfo.nAdjustCols);
//						//console.log("이전 스크롤바 위치:", objHSInfo.nPos - nMoveCount);
//						//console.log("nMoveCount:", nMoveCount);
//						
//						//objHSInfo.nLeftCol += nMoveCount + nAdjustColsBeforeScrolling;
//						//objHSInfo.nRightCol += nMoveCount + nAdjustColsBeforeScrolling;
//						
//						//console.log("aferLeftCol:", objHSInfo.nLeftCol);
//						
//						if(objHSInfo.nPos < objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//							console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때');
//							
//							objHSInfo.nLeftCol += nMoveCount + nAdjustColsBeforeScrolling;
//							objHSInfo.nRightCol += nMoveCount + nAdjustColsBeforeScrolling;
//						} else{
//							console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때');
//							//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//							var nAdjustCols = objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols);
//							//console.log('nAdjustCols:', nAdjustCols);
//							nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nAdjustCols - 1);
//						}
//						/*
//					if(objHSInfo.nPos >= objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//						console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때');
//						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//						var nAdjustCols = objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols);
//						//console.log('nAdjustCols:', nAdjustCols);
//						nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nAdjustCols - 1);
//					} else{
//						objHSInfo.nLeftCol += nMoveCount + nAdjustColsBeforeScrolling;
//						objHSInfo.nRightCol += nMoveCount + nAdjustColsBeforeScrolling;
//					}
//						 */
//						nAdjustColWidths = nFrozenColsWidth;
//						_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
//							var nCol, nColWidth, nCellLeft, keyOfCol;
//							
//							nCol = objHSInfo.nLeftCol + idx;
//							nColWidth = objQCell._getColWidth(nCol);
//							nCellLeft = nAdjustColWidths - nAdjustedLeft;
//							keyOfCol = objQCell._getKeyOfCol(nCol);
//							
//							_.each(arrNormalColCellDOMs, function(heCell){
//								var nRow = parseInt(heCell.getAttribute('data-row'));
//								
//								heCell.style.left = nCellLeft + 'px';
//								heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//								heCell.setAttribute('data-col', nCol + '');
//								heCell.style.left = nCellLeft + 'px';
//								heCell.style.width = nColWidth + 'px';
//								
//								if(nRow < nHeaderRows){
//									heCell.innerHTML = arrHeaderText[nCol][nRow];
//								} else{
//									heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//								}
//							});
//							
//							nAdjustColWidths += nColWidth;
//						});
//					} else{
//						//모두 뜯지 않아야 하는 경우 발생 시, nAdjustCols 범위 안에 있는지 여부 확인
//						
//						//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간은 nLeftCol, nRightCol값이 변하지 않아야 한다. 
//						
//						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//						if(objHSInfo.nPos < objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//							console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때');
//							
//							nCutColsCount = Math.abs(nMoveCount) - nAdjustColsBeforeScrolling;
//							
//							//console.log("nCutColsCount:", nCutColsCount);
//							
//							objHSInfo.nLeftCol -= nCutColsCount;
//							objHSInfo.nRightCol -= nCutColsCount;
//						} else{
//							console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때');
//							//nCutColsCount = 0;
//							//console.log("nCutColsCount:", nCutColsCount);
//							bWholePositionChanged = true;
//						}
//						
//						if(nCutColsCount > 0){
//							var nLeftColLeft,
//							nMovedColWidths;
//							arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(arrNormalColsCellDOMs.length - nCutColsCount, nCutColsCount);
//							
//							//계속 화면에 표시해야 하는 컬럼 셀들은 갱신하지 않고 left값만 세팅
//							nMovedColWidths = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nCutColsCount - 1);
//							_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs){
//								var nCellLeft = 0;
//								_.each(arrNormalColCellDOMs, function(heCell, idx){
//									if(idx === 0){
//										nCellLeft = parseFloat(heCell.style.left) + (nMovedColWidths);
//									}
//									heCell.style.left = nCellLeft + 'px';
//								});
//							});
//							
//							//화면에 표시하지 않아야 하는 컬럼 셀들은 가장 좌측에 표시되고 있는 컬럼 옆으로 이동시킨 후 갱신해야 한다.
//							console.log('nLeftCol:', objHSInfo.nLeftCol, 'nBeforeLeftCol:', arrNormalColsCellDOMs[0][0].getAttribute('data-col'));
//							nAdjustColWidths = nFrozenColsWidth;
//							_.each(arrMovedDynamicColsCellDOMs, function(arrMovedColCellDOMs, idx){
//								var nCol, nColWidth, nCellLeft, keyOfCol;
//								
//								nCol = objHSInfo.nLeftCol + idx;
//								nColWidth = objQCell._getColWidth(nCol);
//								nCellLeft = nAdjustColWidths;
//								keyOfCol = objQCell._getKeyOfCol(nCol);
//								
//								_.each(arrMovedColCellDOMs, function(heCell){
//									var nRow = parseInt(heCell.getAttribute('data-row'));
//									heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//									heCell.setAttribute('data-col', nCol + '');
//									heCell.style.left = nCellLeft + 'px';
//									heCell.style.width = nColWidth + 'px';
//									if(nRow < nHeaderRows){
//										heCell.innerHTML = arrHeaderText[nCol][nRow];
//									} else{
//										heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//									}
//								});
//								nAdjustColWidths += nColWidth;
//							});
//						}
//						
//						if(bWholePositionChanged){
//							//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 left를 보정해야 하는 경우다.
//							arrNormalColsCellDOMs = arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs);
//							
//							//console.log("objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos):", objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos));
//							nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos)) - 1);
//							
//							nAdjustColWidths = nFrozenColsWidth;
//							_.each(arrNormalColsCellDOMs, function(arrMovedColCellDOMs, idx){
//								var nCol, nColWidth, nCellLeft;
//								
//								nCol = objHSInfo.nLeftCol + idx;
//								nColWidth = objQCell._getColWidth(nCol);
//								nCellLeft = nAdjustColWidths - nAdjustedLeft;
//								
//								_.each(arrMovedColCellDOMs, function(heCell){
//									heCell.style.left = nCellLeft + 'px';
//								});
//								
//								nAdjustColWidths += nColWidth;
//							});
//							
//							objQCell._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs);
//						} else{
//							objQCell._setCellGroupDOMs('col', 'normal', arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs));
//						}
//					}
//				}
//			}
//		});
//	}
//};
//
//QBOX.QCELL.BasicQCELL.prototype.whileHScrolling2 = function(params){
//	//prototype함수이지만, mCustomScrollbar의 이벤트 콜백으로 호출되기 때문에 this가 QCELL 객체가 아니다.
//	//	this.mcs = {
//	//	"left": 0,
//	//	"draggerLeft": 0,
//	//	"leftPct": 0,
//	//	"direction": "x",
//	//	"target": objQCell
//	//};
//	var objQCell = this.mcs.target,
//	nScrollLeft = this.mcs.left;
//	
//	window.requestAnimationFrame(function(){
//		var objHSInfo = objQCell.attr('hsinfo');
//		
//		if(Math.abs(objHSInfo.nLeft - nScrollLeft) >= objHSInfo.nLengthPerCol){//한 컬럼 당 평균 이동 거리(nLengthPerCol)이상으로 가로스크롤바가 움직였을 때만
//			var arrHeaderText = objQCell.attr('headertext'),
//			arrNormalColsCellDOMs = objQCell._getCellGroupDOMs('col', 'normal'),
//			arrMovedDynamicColsCellDOMs = [],
//			arrCurrentData = objQCell.attr('currentdata'),
//			nHeaderRows = objQCell.attr('headerrows'),
//			nHeaderCols = objQCell.attr('headercols'),
//			nFrozenCols = objQCell.attr('frozencols'),
//			nViewPortOffsetWidth = objQCell.attr('layoutsize').viewport.offsetWidth,
//			nFrozenColsWidth = objQCell._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
//			nMoveCount = parseInt(-(nScrollLeft - objHSInfo.nLeft) / objHSInfo.nLengthPerCol),//nMoveCount:스크롤바가 이동한 컬럼 수
//			nCutColsCount = 0, //데이터와 위치를 갱신해야 하는 동적 컬럼의 수(ex> 가로스크롤바가 오른쪽으로 3칸 이동 시 3개의 일반컬럼을 표시하던 div들을 새로 나타해야 할 새로운 3개의 컬럼위치로 이동시키고 데이터를 갱신해야 한다.)
//			nAdjustedLeft = 0,		//left값 보정이 필요할 때 사용
//			nAdjustColWidths = 0,	//left값 설정을 위해 사용
//			bWholePositionChanged = false;
//			
//			objHSInfo.nBeforeLeft = objHSInfo.nLeft;
//			objHSInfo.nLeft = objHSInfo.nLeft - (nMoveCount * objHSInfo.nLengthPerCol);//scrollLeft값으로 설정하면 안되고, 이동한 컬럼 수 만큼 nLengthPerCol값을 곱한 값을 더 해 줘야 한다.
//			objHSInfo.nPos += nMoveCount;
//			
//			if(nMoveCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
//				console.log('가로 스크롤바가 오른쪽으로 이동했을 때');
//				
//				/*
//				오른쪽으로 스크롤이 이동했을 때 아이디어
//				1. 동적 컬럼 수보다 더 많이 이동한 경우 전체 셀을 갱신한다.
//					1-1. 마지막 동적 컬럼인덱스와 이동한 컬럼 수의 합이 QCELL의 마지막 컬럼인덱스보다 작거나 같은 경우(일반적인 경우)
//					1-2. 마지막 동적 컬럼인덱스와 이동한 컬럼 수의 합이 QCELL의 마지막 컬럼인덱스보다 큰 경우(전체 cell들의 left값을 보정해야 하는 경우임)
//				2. 동적 컬럼 수보다 적게 이동한 경우
//					2-1. 이동한 컬럼 수와 갱신 해 줘야 할 동적 컬럼 수가 같은 경우(일반적인 경우)
//					2-2. 이동한 컬럼 수 보다 갱신 해 줘야 할 동적 컬럼 수가 적은 경우(마지막 동적 컬럼이 QCELL의 마지막 컬럼인 경우이며, 전체 cell들의 left값을 보정해야 하는 경우임)
//						2-2-1. 가로스크롤바가 우측 끝인 경우(viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우)
//						2-2-2. 가로스크롤바가 우측 끝이 아닌 경우(이동한 컬럼들 중에서 동적 컬럼을 갱신하지 않고 left값만 조정해 줘야 하는 컬럼들의 colWidth 합 만큼 left를 이동시켜야 하는 경우)
//				*/
//				
//				//if(nCutColsCount >= objHSInfo.nDynamicCols - nFrozenCols){
//				if(nMoveCount >= objHSInfo.nDynamicCols - nFrozenCols){//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 많은 경우
//					//console.log('전체 갱신을 해야 하는 경우, nMoveCount:', nMoveCount, ', nCutColsCount:', nCutColsCount, ', nLeftCol:', objHSInfo.nLeftCol, ', nRightCol:', objHSInfo.nRightCol);
//					//전체 갱신을 해야 하는 경우, nMoveCount: 12 , nCutColsCount: 8 , nLeftCol: 7 , nRightCol: 14
//					//여기서는 뜯지 않으니 nCutColsCount가 필요없다.
//					
//					//이동한 수만큼 nLeftCol, nRightCol값을 세팅하되, AdjustCols 내 위치인 경우를 고려한다.
//					var nAdjustCols = objHSInfo.nRightCol + nMoveCount > objHSInfo.nEndCol ? (objHSInfo.nRightCol + nMoveCount) - objHSInfo.nEndCol : 0;
//					
//					objHSInfo.nLeftCol += nMoveCount - nAdjustCols;
//					objHSInfo.nRightCol += nMoveCount - nAdjustCols;
//					
//					if(nAdjustCols > 0){
//						if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
//							nAdjustedLeft = nFrozenColsWidth + objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
//						} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
//							//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//							nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - nAdjustCols) - 1);
//						}
//					}
//					
//					nAdjustColWidths = nFrozenColsWidth;
//					_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
//						var nCol, nColWidth, nCellLeft;
//						nCol = objHSInfo.nLeftCol + idx;
//						nColWidth = objQCell._getColWidth(nCol);
//						nCellLeft = nAdjustColWidths - nAdjustedLeft;
//						keyOfCol = objQCell._getKeyOfCol(nCol);
//						_.each(arrNormalColCellDOMs, function(heCell){
//							var nRow = parseInt(heCell.getAttribute('data-row'));
//							heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//							heCell.setAttribute('data-col', nCol + '');
//							heCell.style.left = nCellLeft + 'px';
//							heCell.style.width = nColWidth + 'px';
//							
//							if(nRow < nHeaderRows){
//								heCell.innerHTML = arrHeaderText[nCol][nRow];
//							} else{
//								heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//							}
//						});
//						nAdjustColWidths += nColWidth;
//					});
//				} else{
//					if(objHSInfo.nRightCol + nMoveCount <= objHSInfo.nEndCol){//최우측 컬럼인덱스와 이동한 컬럼 수의 합이 전체 컬럼 수보다 작은 경우
//						//console.log('이동한 컬럼카운트만큼 모두 뜯어낼 수 있으면');
//						nCutColsCount = nMoveCount;
//					} else{//최우측 컬럼인덱스와 이동한 컬럼 수의 합이 전체 컬럼 수보다 큰 경우
//						//console.log('이동한 컬럼카운트만큼 모두 뜯어낼 수 없으면');
//						nCutColsCount = objHSInfo.nEndCol - objHSInfo.nRightCol;
//						bWholePositionChanged = true;
//					}
//					
//					objHSInfo.nLeftCol += nCutColsCount;
//					objHSInfo.nRightCol += nCutColsCount;
//					
//					if(nCutColsCount > 0){
//						//console.log("nCutColsCount:", nCutColsCount);
//						var nRightColLeft,
//						nMovedColWidths;
//						//console.log("before arrNormalColsCellDOMs.length:", arrNormalColsCellDOMs.length);
//						arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(0, nCutColsCount);
//						//console.log(objHSInfo.nDynamicCols - nFrozenCols);
//						//console.log("after arrNormalColsCellDOMs.length:", arrNormalColsCellDOMs.length);
//						//계속 화면에 표시해야 하는 컬럼 셀들은 갱신하지 않고 left값만 세팅
//						nMovedColWidths = objQCell._getSumOfColWidth(objHSInfo.nLeftCol - nCutColsCount, objHSInfo.nLeftCol - 1);
//						_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs){
//							var nCellLeft = 0;
//							_.each(arrNormalColCellDOMs, function(heCell, idx){
//								if(idx === 0){
//									nCellLeft = parseFloat(heCell.style.left) - (nMovedColWidths);
//								}
//								heCell.style.left = nCellLeft + 'px';
//							});
//						});
//						
//						//화면에 표시하지 않아야 하는 컬럼 셀들은 가장 우측에 표시되고 있는 컬럼 옆으로 이동시킨 후 갱신해야 한다.
//						nRightColLeft = parseFloat(arrNormalColsCellDOMs[arrNormalColsCellDOMs.length - 1][0].style.left);
//						_.each(arrMovedDynamicColsCellDOMs, function(arrMovedColCellDOMs, idx){
//							var nCol, nColWidth, nCellLeft, keyOfCol;
//							
//							nCol = objHSInfo.nRightCol - nCutColsCount + (idx + 1);
//							nColWidth = objQCell._getColWidth(nCol);
//							nAdjustColWidths += objQCell._getColWidth(nCol - 1);
//							nCellLeft = nRightColLeft + nAdjustColWidths;
//							keyOfCol = objQCell._getKeyOfCol(nCol);
//							
//							_.each(arrMovedColCellDOMs, function(heCell){
//								var nRow = parseInt(heCell.getAttribute('data-row'));
//								
//								heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//								heCell.setAttribute('data-col', nCol + '');
//								heCell.style.left = nCellLeft + 'px';
//								heCell.style.width = nColWidth + 'px';
//								
//								if(nRow < nHeaderRows){
//									heCell.innerHTML = arrHeaderText[nCol][nRow];
//								} else{
//									heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//								}
//							});
//						});
//					}
//					
//					if(bWholePositionChanged){
//						//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 left를 보정해야 하는 경우다.
//						arrNormalColsCellDOMs = arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs);
//						
//						if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
//							nAdjustedLeft = nFrozenColsWidth + objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
//						} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
//							//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//							nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
//						}
//						
//						nAdjustColWidths = nFrozenColsWidth;
//						_.each(arrNormalColsCellDOMs, function(arrMovedColCellDOMs, idx){
//							var nCol, nColWidth, nCellLeft;
//							
//							nCol = objHSInfo.nLeftCol + idx;
//							nColWidth = objQCell._getColWidth(nCol);
//							nCellLeft = nAdjustColWidths - nAdjustedLeft;
//							_.each(arrMovedColCellDOMs, function(heCell){
//								heCell.style.left = nCellLeft + 'px';
//							});
//							
//							nAdjustColWidths += nColWidth;
//						});
//						
//						objQCell._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs);
//					} else{
//						objQCell._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs));
//					}
//				}
//			} else{//왼쪽으로 스크롤이 이동했을 때
//				console.log('가로스크롤바가 왼쪽으로 이동했을 때');
//				/*
//				왼쪽으로 스크롤이 이동했을 때
//				1. 일반적으로는 이동한 컬럼의 width만큼 left를 더주면 된다.
//				2. 뜯어낼 수 있는 최대 컬럼 수는 왼쪽에 붙여넣을 때 첫번째 일반 컬럼인덱스와 같은 경우이다.
//				3.
//				*/
//				
//				//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간은 nLeftCol, nRightCol값이 변하지 않아야 한다. 
//				var nAdjustColsBeforeScrolling = objHSInfo.nPos - nMoveCount >= objHSInfo.nLastPos - objHSInfo.nAdjustCols ? objHSInfo.nPos - nMoveCount - (objHSInfo.nLastPos - objHSInfo.nAdjustCols) : 0;
//				console.log("스크롤바가 이동하기 전 기준 AdjustCols:", nAdjustColsBeforeScrolling);
//				
//				if(Math.abs(nMoveCount) >= objHSInfo.nDynamicCols - nFrozenCols){//스크롤바로 이동한 컬럼 수가 동적 컬럼 수보다 많은 경우
//					console.log('전체 갱신을 해야 하는 경우, nMoveCount:', nMoveCount, ', nLeftCol:', objHSInfo.nLeftCol, ', nRightCol:', objHSInfo.nRightCol);
//					//전체 갱신을 해야 하는 경우, nMoveCount: 12 , nCutColsCount: 8 , nLeftCol: 7 , nRightCol: 14
//					//여기서는 뜯지 않으니 nCutColsCount가 필요없다.
//					
//					//이동한 수만큼 nLeftCol, nRightCol값을 세팅하되, AdjustCols 내 위치인 경우를 고려한다.
//					//이전 가로스크롤바 위치: objHSInfo.nPos - nMoveCount 또는 objHSInfo.nBeforeLeft / objHSInfo.nLengthPerCol
//					//console.log("beforeLeftCol:", objHSInfo.nLeftCol);
//					
//					//console.log("스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위:", objHSInfo.nLastPos - objHSInfo.nAdjustCols);
//					//console.log("이전 스크롤바 위치:", objHSInfo.nPos - nMoveCount);
//					//console.log("nMoveCount:", nMoveCount);
//					
//					objHSInfo.nLeftCol += nMoveCount + nAdjustColsBeforeScrolling;
//					objHSInfo.nRightCol += nMoveCount + nAdjustColsBeforeScrolling;
//					
//					//console.log("aferLeftCol:", objHSInfo.nLeftCol);
//					
//					if(objHSInfo.nPos >= objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//						var nAdjustCols = objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols);
//						//console.log('nAdjustCols:', nAdjustCols);
//						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//						nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nAdjustCols - 1);
//					}
//					
//					nAdjustColWidths = nFrozenColsWidth;
//					_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
//						var nCol, nColWidth, nCellLeft, keyOfCol;
//						
//						nCol = objHSInfo.nLeftCol + idx;
//						nColWidth = objQCell._getColWidth(nCol);
//						nCellLeft = nAdjustColWidths - nAdjustedLeft;
//						keyOfCol = objQCell._getKeyOfCol(nCol);
//						
//						_.each(arrNormalColCellDOMs, function(heCell){
//							var nRow = parseInt(heCell.getAttribute('data-row'));
//							
//							heCell.style.left = nCellLeft + 'px';
//							heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//							heCell.setAttribute('data-col', nCol + '');
//							heCell.style.left = nCellLeft + 'px';
//							heCell.style.width = nColWidth + 'px';
//							
//							if(nRow < nHeaderRows){
//								heCell.innerHTML = arrHeaderText[nCol][nRow];
//							} else{
//								heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//							}
//						});
//						
//						nAdjustColWidths += nColWidth;
//					});
//				} else{
//					//모두 뜯지 않아야 하는 경우 발생 시, nAdjustCols 범위 안에 있는지 여부 확인
//					
//					//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간은 nLeftCol, nRightCol값이 변하지 않아야 한다. 
//					
//					//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
//					if(objHSInfo.nPos < objHSInfo.nLastPos - objHSInfo.nAdjustCols){
//						console.log('보정 범위 밖에서 움직였을 때');
//						
//						nCutColsCount = Math.abs(nMoveCount) - nAdjustColsBeforeScrolling;
//						
//						//console.log("nCutColsCount:", nCutColsCount);
//						
//						objHSInfo.nLeftCol -= nCutColsCount;
//						objHSInfo.nRightCol -= nCutColsCount;
//					} else{
//						console.log('보정 범위 내에서 움직였을 때');
//						//nCutColsCount = 0;
//						//console.log("nCutColsCount:", nCutColsCount);
//						bWholePositionChanged = true;
//					}
//					
//					if(nCutColsCount > 0){
//						var nLeftColLeft,
//						nMovedColWidths;
//						arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(arrNormalColsCellDOMs.length - nCutColsCount, nCutColsCount);
//						
//						//계속 화면에 표시해야 하는 컬럼 셀들은 갱신하지 않고 left값만 세팅
//						nMovedColWidths = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nCutColsCount - 1);
//						_.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs){
//							var nCellLeft = 0;
//							_.each(arrNormalColCellDOMs, function(heCell, idx){
//								if(idx === 0){
//									nCellLeft = parseFloat(heCell.style.left) + (nMovedColWidths);
//								}
//								heCell.style.left = nCellLeft + 'px';
//							});
//						});
//						
//						//화면에 표시하지 않아야 하는 컬럼 셀들은 가장 좌측에 표시되고 있는 컬럼 옆으로 이동시킨 후 갱신해야 한다.
//						console.log('nLeftCol:', objHSInfo.nLeftCol, 'nBeforeLeftCol:', arrNormalColsCellDOMs[0][0].getAttribute('data-col'));
//						nAdjustColWidths = nFrozenColsWidth;
//						_.each(arrMovedDynamicColsCellDOMs, function(arrMovedColCellDOMs, idx){
//							var nCol, nColWidth, nCellLeft, keyOfCol;
//							
//							nCol = objHSInfo.nLeftCol + idx;
//							nColWidth = objQCell._getColWidth(nCol);
//							nCellLeft = nAdjustColWidths;
//							keyOfCol = objQCell._getKeyOfCol(nCol);
//							
//							_.each(arrMovedColCellDOMs, function(heCell){
//								var nRow = parseInt(heCell.getAttribute('data-row'));
//								heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
//								heCell.setAttribute('data-col', nCol + '');
//								heCell.style.left = nCellLeft + 'px';
//								heCell.style.width = nColWidth + 'px';
//								if(nRow < nHeaderRows){
//									heCell.innerHTML = arrHeaderText[nCol][nRow];
//								} else{
//									heCell.innerHTML = arrCurrentData[nRow - nHeaderRows][keyOfCol];
//								}
//							});
//							nAdjustColWidths += nColWidth;
//						});
//					}
//					
//					if(bWholePositionChanged){
//						//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 left를 보정해야 하는 경우다.
//						arrNormalColsCellDOMs = arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs);
//						
//						//console.log("objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos):", objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos));
//						nAdjustedLeft = objQCell._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos)) - 1);
//						
//						nAdjustColWidths = nFrozenColsWidth;
//						_.each(arrNormalColsCellDOMs, function(arrMovedColCellDOMs, idx){
//							var nCol, nColWidth, nCellLeft;
//							
//							nCol = objHSInfo.nLeftCol + idx;
//							nColWidth = objQCell._getColWidth(nCol);
//							nCellLeft = nAdjustColWidths - nAdjustedLeft;
//							
//							_.each(arrMovedColCellDOMs, function(heCell){
//								heCell.style.left = nCellLeft + 'px';
//							});
//							
//							nAdjustColWidths += nColWidth;
//						});
//						
//						objQCell._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs);
//					} else{
//						objQCell._setCellGroupDOMs('col', 'normal', arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs));
//					}
//				}
//			}
//		}
//	});
//};

QBOX.QCELL.BasicQCELL.prototype._resizeHScrollbar = function(){
	try{
		var htElementPool = this.attr('elementpool'),
		heHScrollThumb = htElementPool.get('hscrollthumb'),
		$jqHScrollbar = htElementPool.get('$jqhscrollbar'),
		objLayoutSize = this.attr('layoutsize'), objHSInfo = this.attr('hsinfo');
		
		/*
		if(스크롤바를 표시 할 때){
			nLengthPerCol계산
			nLastPos계산
			nAdjustCols계산
			nPos,nLeft보정
			nLength계산
			nHScrollThumbLength계산
		} else{
			nLengthPerCol = 0;
			nLastPos = 0;
			nPos = 0;
			nLeft = 0;
			nBeforeLeft = 0;
			nAdjustCols = 0;
			nLength = 0;
			nHScrollThumbLength = 0;
		}
		*/
		if(objHSInfo.bHScroll){
			/*
			 * 가로 스크롤바 길이 비율의 문제
			 * colheader, viewport, footer 영역에 표시되는 셀들 중에서 frozencol영역이 아닌 셀들만 가로 스크롤바를 이용한 스크롤링이 가능
			 * 현재 화면에 보이는  컬럼 수가 전체 컬럼 수의 30%라면 스크롤바의 모양은 70%를 이동 할 수 있는 모양이 되어야 한다.
			 */
			
			var nViewPortDisplayCols = 0,//viewport에 표시되고 있는 컬럼의 수
			nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'), nCols = this.attr('cols'),
			nViewPortOffsetWidth = objLayoutSize.viewport.offsetWidth,
			nHScrollbarClientWidth = objLayoutSize.hscrollbar.clientWidth,
			nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
			fnCallback, j;
			
			//viewport에 표시되고 있는 컬럼의 수 = width의 합이 viewport의 width보다 크거나 같을 때까지의 컬럼 수
			for(j = nHeaderCols; j < nCols ; j++){
				if(this._getSumOfColWidth(nHeaderCols, j) >= nViewPortOffsetWidth){
					nViewPortDisplayCols = j - nHeaderCols + 1;
					break;
				}
			}
			//console.log('viewport에 표시되고 있는 컬럼의 수:', nViewPortDisplayCols);
			
			//objHSInfo.nLengthPerCol = Math.round(this._getSumOfColWidth(objHSInfo.nStartCol, objHSInfo.nEndCol) / (objHSInfo.nEndCol - objHSInfo.nStartCol));
			objHSInfo.nLengthPerCol = Math.round(nHScrollbarClientWidth / nViewPortDisplayCols);//"한 컬럼 당 scroll 이동 거리" = 가로스크롤바영역의 width / 화면에 표시되고 있는 컬럼의 수
			objHSInfo.nAdjustCols = 0;
			//"HScrollbar가 이동할 수 있는 열의 수" = "화면에 표시되지 않은 컬럼의 수" + (마지막 동적컬럼 div가 이미 마지막 컬럼(nEndCol)으로 세팅되었지만, (동적 컬럼의 width합 + frozenCols의 합)이 viewport의 width보다 커서 left를 이동시켜야 하는 컬럼의 수)
			objHSInfo.nLastPos = objHSInfo.nEndCol - (objHSInfo.nStartCol + (objHSInfo.nDynamicCols - nFrozenCols) - 1);//nEndCol - "스크롤바가 맨 왼쪽에 있을 때의 nRightCol" - 1
			for(j = objHSInfo.nStartCol + objHSInfo.nLastPos; j <= objHSInfo.nEndCol; j++){
				//가로스크롤바가 끝까지 움직였을 때의 nLeftCol:objHSInfo.nStartCol + objHSInfo.nLastPos
				var nVal = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nStartCol + objHSInfo.nLastPos + objHSInfo.nAdjustCols, objHSInfo.nEndCol);
				if(nVal > nViewPortOffsetWidth){
					objHSInfo.nAdjustCols += 1;
				} else{
					break;
				}
			}
			objHSInfo.nLastPos += objHSInfo.nAdjustCols;
			//console.log('HScrollbar가 이동할 수 있는 열의 수:' + objHSInfo.nLastPos);
			
			if(objHSInfo.nPos > objHSInfo.nLastPos){
				objHSInfo.nPos = objHSInfo.nLastPos;
				objHSInfo.nLeft = -(objHSInfo.nPos * objHSInfo.nLengthPerCol);
			}
			
			if(objHSInfo.nLeft !== -(objHSInfo.nPos * objHSInfo.nLengthPerCol)){//nLeft값이 갱신된 nLengthPerCol의 배수가 아닌 경우
				//가로스크롤바가 움직인 상태에서 가로스크롤바 영역의 사이즈가 변경된 후 _resizeHScrollbar() 수행 시 nLeft값을 보정
				objHSInfo.nLeft = -(objHSInfo.nPos * objHSInfo.nLengthPerCol);
			}
			
			objHSInfo.nLength = objHSInfo.nLastPos * objHSInfo.nLengthPerCol;
			
			if(isNaN(objHSInfo.nLength)){
				$jqHScrollbar.rt_qc_mCSbar('destroy');
				objHSInfo.nLengthPerCol = objHSInfo.nLastPos = objHSInfo.nPos = objHSInfo.nLeft = objHSInfo.nBeforeLeft = objHSInfo.nAdjustCols = objHSInfo.nLength = 0;
				heHScrollThumb.style.width = '0px';
				return true;
			}
			
			//"heHScrollThumb의 width" = "가로스크롤바 영역의 width" + ("한 열 당 평균스크롤 이동 거리" * "HScrollbar가 이동할 수 있는 열의 수")
			heHScrollThumb.style.width = (nHScrollbarClientWidth + objHSInfo.nLength) + 'px';
			//console.log('heHScrollThumb의 길이:' + heHScrollThumb.style.width);
			
			var THAT = this;
			
			fnCallback = function(params){
				try{
					var nScrollLeft = this.mcs.left;
					QBOX.util.rAF(function(){
						THAT.onHScroll(nScrollLeft);	
						THAT._trigger("scrollmove");
					});				
					
				}
				catch(e){
					QCELL.log('err', 'HScrollbar.onScroll ', e.message);						
				}				

			};
			
			/*
			$jqHScrollbar.mCustomScrollbar('destroy').mCustomScrollbar({
				axis:'x',
				theme:'qcell-default',
				setWidth:'100%',
				setHeight:'100%',
				scrollInertia:0,//모멘텀 에니메이션 효과 간격
				snapAmount: objHSInfo.nLengthPerCol,//scrollDragger를 마우스로 드래그하거나 scrollbar 영역을 클릭하여 스크롤바 이동 시 고정값으로 이동하도록 기본 고정값 설정
				mouseWheel:{
					enable:true,
					preventDefault:true,
					normalizeDelta:true,//OS/브라우저별로 다른 delta값을 일반화하여 동일하게 동작하도록 설정한다.
					scrollAmount:objHSInfo.nLengthPerCol//마우스 휠 이벤트 발생 시 이동할 pixel값
				},
				scrollButtons:{
					enable:true,
					scrollAmount:objHSInfo.nLengthPerCol//,//스크롤이동버튼 클릭 시 이동할 pixel값
					//scrollType:'stepped'
				},
				keyboard:{enable:false},
				advanced:{updateOnContentResize:false},
				callbacks:{
					onScroll		: fnCallback,
					whileScrolling	: fnCallback
				},
				target:this
			});
			*/
			
			QBOX.$($jqHScrollbar).rt_qc_mCSbar('destroy').rt_qc_mCSbar({
				axis:'x',
				theme:'qcell-default',
				setWidth:'100%',
				setHeight:'100%',
				scrollInertia:0,//모멘텀 에니메이션 효과 간격
				snapAmount: objHSInfo.nLengthPerCol,//scrollDragger를 마우스로 드래그하거나 scrollbar 영역을 클릭하여 스크롤바 이동 시 고정값으로 이동하도록 기본 고정값 설정
				mouseWheel:{
					enable:true,
					preventDefault:true,
					normalizeDelta:true,//OS/브라우저별로 다른 delta값을 일반화하여 동일하게 동작하도록 설정한다.
					scrollAmount:objHSInfo.nLengthPerCol//마우스 휠 이벤트 발생 시 이동할 pixel값
				},
				scrollButtons:{
					enable:true,
					scrollAmount:objHSInfo.nLengthPerCol//,//스크롤이동버튼 클릭 시 이동할 pixel값
					//scrollType:'stepped'
				},
				keyboard:{enable:false},
				advanced:{updateOnContentResize:false},
				callbacks:{
					onScroll		: fnCallback,
					whileScrolling	: fnCallback
				},
				target:this
			});
			
			if(objHSInfo.nLeft < 0){//_rebuild()를 연속으로 수행 시에 스크립트 오류가 난다. scrollTo가 비동기로 처리되서 그런 듯...
				$jqHScrollbar.rt_qc_mCSbar('scrollTo', objHSInfo.nLeft, '', {ignorecallback:true});
			}
			
			fnCallback = null;
		} else{
			$jqHScrollbar.rt_qc_mCSbar('destroy');
			objHSInfo.nLengthPerCol = objHSInfo.nLastPos = objHSInfo.nPos = objHSInfo.nLeft = objHSInfo.nBeforeLeft = objHSInfo.nAdjustCols = objHSInfo.nLength = 0;
			heHScrollThumb.style.width = '0px';
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._resizeHScrollbar', e.message);
		return false;
	}
};

//QBOX.QCELL.BasicQCELL.prototype._resizeHScrollbar1 = function(){
//	var htElementPool = this.attr('elementpool'),
//	heHScrollbar = htElementPool.get('hscrollbar'), heHScrollThumb = htElementPool.get('hscrollthumb'),
//	objLayoutSize = this.attr('layoutsize'), objHSInfo = this.attr('hsinfo'),
//	fnHScrollCallback,
//	nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
//	nViewPortOffsetWidth = objLayoutSize.viewport.offsetWidth,
//	nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
//	nHScrollbarClientWidth = objLayoutSize.hscrollbar.clientWidth,/*가로스크롤바영역의 width*/
//	nHScrollThumbLength = 0;/*HScrollThumb의 길이*/
//	
//	if(objHSInfo.bHScroll){
//		/*
//		 * 가로 스크롤바 길이 비율의 문제
//		 * colheader, viewport, footer 영역에 표시되는 셀들 중에서 frozencol영역이 아닌 셀들만 가로 스크롤바를 이용한 스크롤링이 가능
//		 * 현재 화면에 보이는  컬럼 수가 전체 컬럼 수의 30%라면 스크롤바의 모양은 70%를 이동 할 수 있는 모양이 되어야 한다.
//		 */
//		//heHScrollbar.style.display = '';
//		
//		objHSInfo.nLengthPerCol = Math.round(this._getSumOfColWidth(objHSInfo.nStartCol, objHSInfo.nEndCol) / (objHSInfo.nEndCol - objHSInfo.nStartCol));
//		//"HScrollbar가 이동할 수 있는 열의 수" = "화면에 표시되지 않은 컬럼의 수" + (마지막 동적컬럼 div가 이미 마지막 컬럼(nEndCol)으로 세팅되었지만, (동적 컬럼의 width합 + frozenCols의 합)이 viewport의 width보다 커서 left를 이동시켜야 하는 컬럼의 수)
//		objHSInfo.nLastPos = objHSInfo.nEndCol - objHSInfo.nRightCol;
//		objHSInfo.nAdjustCols = 0;
//		while(true){
//			//가로스크롤바가 끝까지 움직였을 때의 nLeftCol:objHSInfo.nLeftCol + objHSInfo.nLastPos
//			var nVal = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol + objHSInfo.nLastPos + objHSInfo.nAdjustCols, objHSInfo.nEndCol);
//			console.log(nVal);
//			if(nVal > nViewPortOffsetWidth){
//				objHSInfo.nAdjustCols += 1;
//			} else{
//				break;
//			}
//		}
//		objHSInfo.nLastPos += objHSInfo.nAdjustCols;
//		objHSInfo.nLength = objHSInfo.nLastPos * objHSInfo.nLengthPerCol;
//		
//		//"HScrollThumb의 길이" = "가로스크롤바 영역의 width" + ("한 컬럼 당 평균스크롤 이동 거리" * "HScrollbar가 이동할 수 있는 열의 수")
//		nHScrollThumbLength = nHScrollbarClientWidth + objHSInfo.nLength;
//		
//		heHScrollThumb.style.width = nHScrollThumbLength + 'px';
//		//console.log('HScrollbar가 이동할 수 있는 열의 수:' + objHSInfo.nLength);
//		//console.log('HScrollThumb의 길이:' + nHScrollThumbLength);
//		
//		fnHScrollCallback = function(params){
//			var objQCell = this.mcs.target,
//			nScrollLeft = this.mcs.left;
//			QBOX.util.rAF(function(){
//				objQCell.onHScroll(nScrollLeft);
//			});
//		};
//		
//		htElementPool.get('$jqhscrollbar').mCustomScrollbar('destroy').mCustomScrollbar({
//			axis:'x',
//			theme:'3d-thick-dark',
//			setWidth:'100%',
//			setHeight:'100%',
//			scrollInertia:0,//모멘텀 에니메이션 효과 간격
//			snapAmount: objHSInfo.nLengthPerCol,//scrollDragger를 마우스로 드래그하거나 scrollbar 영역을 클릭하여 스크롤바 이동 시 고정값으로 이동하도록 기본 고정값 설정
//			mouseWheel:{
//				enable:true,
//				preventDefault:true,
//				normalizeDelta:true,//OS/브라우저별로 다른 delta값을 일반화하여 동일하게 동작하도록 설정한다.
//				scrollAmount:objHSInfo.nLengthPerCol//마우스 휠 이벤트 발생 시 이동할 pixel값
//			},
//			scrollButtons:{
//				enable:true,
//				scrollAmount:objHSInfo.nLengthPerCol/*,//스크롤이동버튼 클릭 시 이동할 pixel값
//				scrollType:'stepped'*/
//			},
//			keyboard:{enable:false},
//			advanced:{updateOnContentResize:false},
//			callbacks:{
//				onScroll		: fnHScrollCallback,
//				whileScrolling		: fnHScrollCallback
//			},
//			target:this
//		});
//		
//		fnHScrollCallback = null;
//	} else{
//		htElementPool.get('$jqhscrollbar').mCustomScrollbar('destroy');
//		this._initHSInfo();
//	}
//};

QBOX.QCELL.BasicQCELL.prototype._scrollLeft = function(nCol){
	var objHSInfo = this.attr('hsinfo');
	
	if(objHSInfo.bHScroll){
		var nPos, nLeft;
		
		if(nCol < objHSInfo.nStartCol){
			nCol = objHSInfo.nStartCol;
		} else{
			//가로스크롤바가 끝까지 움직였을 때의 nLeftCol:objHSInfo.nStartCol + objHSInfo.nLastPos
			if(nCol > objHSInfo.nStartCol + objHSInfo.nLastPos){
				nCol = objHSInfo.nStartCol + objHSInfo.nLastPos;
			}
		}
		
		nPos = nCol - objHSInfo.nStartCol;
		//console.log("nPos:" + nPos);
		nLeft = -1 * (nPos) * objHSInfo.nLengthPerCol;
		
		this.attr('isscrollleft',false,'boolean'); //scroll 여부 초기화
		if(!isNaN(nLeft) && nLeft !== objHSInfo.nLeft){
			//console.log('nCol:' + nCol + ', nBeforeLeft:' + objHSInfo.nLeft + ', nLeft:' + nLeft);
			this.attr('isscrollleft',true,'boolean');// scroll 상태 저장
			QBOX.$(this.attr('elementpool').get('$jqhscrollbar')).rt_qc_mCSbar('scrollTo', nLeft);
		}
	}
};

//2018-01-08(sai1515): 세로스크롤바에 걸쳐저 있는 셀을 클릭했을 경우 완전히 보여지도록 가로 스르콜을 보정해 주는 내부 함수.
QBOX.QCELL.BasicQCELL.prototype._adjustCol = function(){
	try{
		var nRow = this._getSelectedRow() !== -1 ? this._getSelectedRow() : this._idx('row', 'focus'),
		nCol = this._getSelectedCol() !== -1 ? this._getSelectedCol() : this._idx('col', 'focus'),
		heCell = this._getCellDOM(nRow, nCol),
		objHSInfo = this.attr('hsinfo');
		
		if(objHSInfo.bHScroll){
			if(objHSInfo.nAdjustCols > 0){
				if(nCol >= this.attr('headercols') + this.attr('frozencols')){
					switch(this._getHScrollAdjustment(heCell)){
						case 'left': {
							this._scrollLeft(objHSInfo.nStartCol + objHSInfo.nPos - 1);
							this.attr('adjustcol', true, 'boolean');
							break;
						}
						case 'right': {
							this._scrollLeft(objHSInfo.nStartCol + objHSInfo.nPos + 1);
							this.attr('adjustcol', true, 'boolean');
							break;
						}
						default: {
							this.attr('adjustcol', false, 'boolean');
							break;
						}
					}
				} else{
					this.attr('adjustcol', false, 'boolean');
				}
				
				/*if(objHSInfo.nPos !== objHSInfo.nLastPos && objHSInfo.nRightCol === this._idx('col', 'focus')){
					this._scrollLeft(objHSInfo.nLeftCol + 1);
					this.attr('adjustcol', true, 'boolean');
				} else if(objHSInfo.nPos === objHSInfo.nLastPos && objHSInfo.nLeftCol === this._idx('col', 'focus')){
					this._scrollLeft(objHSInfo.nLeftCol);
					this.attr('adjustcol', true, 'boolean');
				} else{
					this.attr('adjustcol', false, 'boolean');
				}*/
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._adjustCol', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._getHScrollAdjustment = function(heCell){
	//셀이 반쯤 걸친 셀인지 여부(왼쪽으로 걸쳤는지, 오른쪽으로 걸쳐는지 반환)
	//headerCols, frozenCols아닌 셀인 경우에만 사용해야 한다.
	var objHSInfo = this.attr('hsinfo');
	
	if(objHSInfo.bHScroll){
		var nStandard = 0;
		
		if(objHSInfo.nPos === objHSInfo.nLastPos){
			var nHeaderCols = this.attr('headercols'),
			nFrozenCols = this.attr('frozencols');
			
			if(nFrozenCols > 0){
				nStandard += this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1);
			}
			
			if(heCell.offsetLeft < nStandard){
				return 'left';
			}
		} else{
			nStandard += this.attr('layoutsize').viewport.offsetWidth;
			
			if(heCell.offsetLeft + heCell.offsetWidth > nStandard){
				return 'right';
			}
		}
	}
	
	return 'none';
};

QBOX.QCELL.BasicQCELL.prototype._MoveHScrollbarToDragging = function(event){
	if(this.attr('dragging')){//dragging을 이용한 가로스크롤바 이동
		/*
		 * 마우스 Dragging을 이용한 스크롤바 이동 시 커서가 멈춰있는 경우에도 스크롤바가 움직여야 하는 경우에 "mousemove" 이벤트가 발생하지 않아 셀의 인덱스 번호로는 처리할 수 없다.
		 * 마우스 이벤트가 걸려있는 container의 브라우저 기준 X좌표값과 현재 커서의 clientX값을 이용하여 처리한다.
		 * */
		var objHSInfo = this.attr('hsinfo');
		
		if(objHSInfo.bHScroll){//가로스크롤바가 있는 경우에만
			var objQCell = this,
			objLayoutSize = this.attr('layoutsize'),
			nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
			nHeaderColsWidth = this._getSumOfColWidth(0, nHeaderCols - 1),
			nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
			nLeftBoundary = objLayoutSize.container.clientX + /*headercols영역의 width*/nHeaderColsWidth + /*frozencols영역의 width*/nFrozenColsWidth,//dragging시 가로스크롤바를 오른쪽으로 움직여야 하는 경계선 -> frozenCols영역과 normalCols영역이 접한 경계선
			nRightBoundary = objLayoutSize.container.clientX + /*headercols영역의 width*/nHeaderColsWidth + objLayoutSize.viewport.offsetWidth,//dragging시 가로스크롤바를 왼쪽으로 움직여야 하는 경계선 -> 세로스크롤바영역과 normalCols영역이 접한 경계선
			nBoundaryWidth = 30,
			nMovedCount = 0;
			
			//console.log("container.clientX:", objLayoutSize.container.clientX, ", event.clientX:", event.clientX);
			
			if(nLeftBoundary + /*기준두께*/nBoundaryWidth >= event.clientX){
				if(this.attr('colmove') || (this._idx('col', 'focus') >= nHeaderCols + nFrozenCols)){//컬럼 이동을 위한 Dragging 상태이거나 포커스 셀의 열이 normalCols인 경우에만, 포커스 셀의 행이 normalCols가 아닌 경우 세로스크롤바만 움직여야 하는 경우이다.
					if(objHSInfo.nPos > 0){//가로 스크롤바가 왼쪽으로 움직일 수 있는 위치인지 고려
						if(nLeftBoundary >= event.clientX){//커서의 위치가 첫번째 normalCol의 위치보다 더 왼쪽에 있는 경우
							nMovedCount = -5;
							
							if(objHSInfo.nPos + nMovedCount < 0){
								nMovedCount = -(objHSInfo.nPos);
							}
						} else{//커서의 위치가 nLeftBoundary에 nBoundaryWidth만큼 근접한 경우
							nMovedCount = -1;
						}
					}
				}
			} else if(nRightBoundary - /*기준두께*/nBoundaryWidth <= event.clientX){//커서의 위치가 nRightBoundary에 nBoundaryWidth만큼 근접한 경우
				if(objHSInfo.nPos < objHSInfo.nLastPos){//가로 스크롤바가 오른쪽으로 움직일 수 있는 위치인지 고려
					if(nRightBoundary <= event.clientX){//커서의 위치가 화면에 보이는 오른쪽 normalCol의 위치보다 더 오른쪽에 있는 경우
						nMovedCount = 5;
						
						if(objHSInfo.nPos + nMovedCount > objHSInfo.nLastPos){
							nMovedCount = objHSInfo.nLastPos - objHSInfo.nPos;
						}
					} else{//커서의 위치가 nRightBoundary에 nBoundaryWidth만큼 근접한 경우
						nMovedCount = 1;
					}
				}
			}
			
			//스피드 변화 시
			if(nMovedCount !== this.attr('hdcount')){
				if(this.attr('hdhandle') !== null){
					//console.log('clearInterval 4');
					clearInterval(this.attr('hdhandle'));
					this.attr('hdhandle', null, 'number');
				}
				
				this.attr('hdcount', nMovedCount, 'number');
			}
			
			if(nMovedCount !== 0){
				if(this.attr('hdhandle') === null){
					this.attr('hdhandle', setInterval(function(){
						//console.log('interval활성화중');
						if(nMovedCount < 0 ? objHSInfo.nPos > 0 : objHSInfo.nPos < objHSInfo.nLastPos){
							if(objQCell.attr('selectmode').indexOf('row') === -1){
								var nDragRow = objQCell._idx('row', 'cursor'),
								nDragCol = nMovedCount < 0 ? objQCell._getLeftColOfScreen() : objQCell._getRightColOfScreen();
								
								objQCell._updateIdx('drag', nDragRow, nDragCol);
								
								if(objQCell.attr('colmove') === false && objQCell.attr('colresize') === false){
									objQCell._selectDragArea(event);
								}
							}
							
							objQCell._scrollLeft(objHSInfo.nStartCol + objHSInfo.nPos + nMovedCount);
						} else{
							//console.log('clearInterval 1');
							clearInterval(objQCell.attr('hdhandle'));
							objQCell.attr('hdhandle', null, 'number');
							objQCell.attr('hdcount', 0, 'number');
						}
					}, 100), 'number');
				}
			} else{
				if(this.attr('hdhandle') !== null){
					//console.log('clearInterval 2');
					clearInterval(objQCell.attr('hdhandle'));
					objQCell.attr('hdhandle', null, 'number');
					objQCell.attr('hdcount', 0, 'number');
				}
			}
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._getLeftColOfScreen = function(){
	//실제 화면에서 보이는 첫번째 normalCol의 인덱스 번호를 반환한다.
	var objHSInfo = this.attr('hsinfo');
/*	
	if(this.attr('useall') || this.attr('usetreeall')){
		return objHSInfo.nLeftCol;
	}		
*/	
	if(objHSInfo.bHScroll === false || objHSInfo.nPos <= objHSInfo.nLastPos - objHSInfo.nAdjustCols){//보정구간에 있을 때
		return objHSInfo.nLeftCol;
	} else{
		var arrNormalColsCellDOMs = this._getCellGroupDOMs('col', 'normal'),
		objLayoutSize = this.attr('layoutsize'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
		nLeftBoundary = /*frozencols영역의 width*/nFrozenColsWidth,
		nLength = arrNormalColsCellDOMs.length,
		j = 0,
		nCol;
		
		while(j < nLength){
			var heCell = arrNormalColsCellDOMs[j][0];
			
			
			if(heCell.offsetLeft + heCell.offsetWidth > nLeftBoundary){
				nCol = parseInt(heCell.getAttribute('data-col'));
				break;
			}
			
			j += 1;
		}
		
		return nCol;
	}
};

QBOX.QCELL.BasicQCELL.prototype._getRightColOfScreen = function(){
	//실제 화면에서 보이는 마지막 normalCol의 인덱스 번호를 반환한다.
	var objHSInfo = this.attr('hsinfo');
/*
	if(this.attr('useall') || this.attr('usetreeall')){
		return objHSInfo.nRightCol;
	}	
*/	
	if(objHSInfo.bHScroll === false || objHSInfo.nPos === objHSInfo.nLastPos){
		return objHSInfo.nRightCol;
	} else{
		var arrNormalColsCellDOMs = this._getCellGroupDOMs('col', 'normal'),
		objLayoutSize = this.attr('layoutsize'),
		nRow = this.attr('headerrows') -1,
		nRightBoundary = objLayoutSize.viewport.offsetWidth,//dragging시 가로스크롤바를 왼쪽으로 움직여야 하는 경계선 -> 세로스크롤바영역과 normalCols영역이 접한 경계선
		nLength = arrNormalColsCellDOMs.length,
		j = 0,
		nCol;
		
		arrNormalColsCellDOMs.reverse();
		
		while(j < nLength){
			var heCell = arrNormalColsCellDOMs[j][nRow];
			
			nCol = parseInt(heCell.getAttribute('data-col'));
			
			if(heCell.offsetWidth !== 0 && heCell.offsetLeft < nRightBoundary){
				break;
			}
			
			j += 1;
		}
		
		return nCol;
	}
};

QBOX.QCELL.BasicQCELL.prototype._excelUpload = function(properties) {
	var result = true,
	objQcell = QBOX._.clone(this);
	
	if( properties.progressui !== undefined && properties.progressui === true ) {
		objQcell._showProgressUI(properties.progressui, properties);
	}
	
	if( QBOX.$.browser.msie && QBOX.$.browser.version < 10) { //브라우저가 IE이며 9이하일 때
		if(objQcell._excelUpload_checkRequiredProps(properties, "url") && objQcell._excelUpload_checkValidationOfProps(properties)){
			objQcell._excelUploadURL(properties);
		} else {
			result = false;
		}
	} else {
		if(QBOX._.isUndefined(properties.event)){
			if(objQcell._excelUpload_checkRequiredProps(properties, "url") && objQcell._excelUpload_checkValidationOfProps(properties)){
				objQcell._excelUploadURL(properties);
			} else {
				result = false;
			}
		} else {
			if(objQcell._excelUpload_checkRequiredProps(properties, "loc") && objQcell._excelUpload_checkValidationOfProps(properties)){
				objQcell._excelUploadLOC(properties);
			} else {
				result = false;
			}
		}
	}
	
	if( properties.progressui !== undefined && properties.progressui === true ) {
		objQcell._showProgressUI(false);
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._excelUpload_checkRequiredProps = function(properties, type) {
	var result = true;
	if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
		var arrRequiredProps;
		if(type === "loc") {
			arrRequiredProps = ["event", "headerrows"];
		} else {
			arrRequiredProps = ["cellname", "fileid", "headerrows", "url"];
		}
		for(var i = 0, length = arrRequiredProps.length; i < length; i++ ){
			var key = arrRequiredProps[i];
			if(properties[key] === undefined){
				QBOX.QCELL.log('err', 'QCELL.BasicQCELL._excelUpload_checkRequiredProps', 'Please check "' + key + '" property.');
				result = false;
				break;
			}
		}
		arrRequiredProps.RT_clear();
		arrRequiredProps = null;
	} else{
		QBOX.QCELL.log('err', 'QCELL.BasicQCELL._excelUpload_checkRequiredProps', 'Please check first parameter\'s type is "object".');
		result = false;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._excelUpload_checkValidationOfProps = function(properties){
	var result = true,
	objQcell = QBOX._.clone(this);
	QBOX.$.each(properties, function(key, val){
		result = objQcell._excelUpload_checkValidationOfProp(key, val);
		return result;
	});
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._excelUpload_checkValidationOfProp = function(key, val){
	var result = true, defaultmsg = true, datatype = '';
	
	switch(key){
		/* string type */
		case 'cellname': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			}
			
			break;
		}
		
		case 'fileid': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			}
			
			break;
		}
		
		case 'url': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			}
			
			break;
		}
		/* number type */
		case 'headerrows': {
			datatype = 'number';
			if(QBOX._.isNumber(Number(val)) === false){
				result = false;
			}
			
			break;
		}
		
		/* object type */
		case 'event': {
			datatype = 'object';
			if(QBOX._.isObject(val) === false || QBOX._.isArray(val)){
				result = false;
			}
			
			break;
		}
		default: break;
	}
	
	if(result === false && defaultmsg){
		QBOX.QCELL.log('err', 'QCELL.BasicQCELL._excelUpload_checkValidationOfProp', 'Please check "' + key + '" property\'s type is "' + datatype + '".');
	}
	
	return result;
};

//IE9이하나, url을 통해 엑셀업로드
QBOX.QCELL.BasicQCELL.prototype._excelUploadURL = function(properties) {
	var strAPI = this.attr('id') + '._excelUploadURL';
	try {
		var cellname = properties.cellname,
		fileid = properties.fileid,
		hrows = properties.headerrows,
		url = properties.url,
		iframeId = "___iFame", fileName = "file",
		iframe = QBOX.$("<iframe></iframe>").attr("id", iframeId).attr("name", iframeId).css("display", "none"),
		form = QBOX.$("<form></form>").attr("action", url).attr("method", "post").attr("target", iframeId).attr("enctype", "multipart/form-data"),
		old_file = QBOX.$("#"+fileid), new_file = QBOX.$(old_file).clone();
		
		old_file[0].name = fileName;
		old_file.before(new_file);
	
		var isRowHeader = this.attr('rowheaders').length > 0 ? true : false,
			keys = QBOX._.clone(this.attr("colkeys"));
		
		if(isRowHeader) { //rowHeader 설정이 되어있을 때 key배열 중 첫번째 데이터 삭제
			keys.shift();
		}
		
		var ipt_keys = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'keys').val(keys),
			ipt_hRows = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'rows').val(hrows),
			ipt_obj = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'objName').val(cellname),
			ipt_ifrmId = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'ifrmId').val(iframeId),
			ipt_fileName = QBOX.$("<input>").attr('type', 'hidden').attr('name', 'fileName').val(fileName);
		
		if( QBOX._.isElement(QBOX.$("#"+iframeId)) ) { //iframeId와 동일한 엘리먼트의 존재 확인
			QBOX.$("#"+iframeId).remove();
		}
	
		form.append(old_file).append(ipt_keys).append(ipt_hRows).append(ipt_obj).append(ipt_ifrmId).append(ipt_fileName);
		iframe.appendTo('body').append(form);
		form.submit().remove();
		
		return true;
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
};

//IE9외의 브라우저에서의 자체 엑셀업로드
QBOX.QCELL.BasicQCELL.prototype._excelUploadLOC = function(properties) {
	var strAPI = this.attr('id') + '._excelUploadLOC';
	try {
		var event = properties.event,
		file = event.target.files[0];
		
		if(file){
			var fileExt = file.name.split(".").pop(-1); 
			filename = file.name;
			
			if(fileExt.toLowerCase() == "xlsx") {
				var rABS = typeof FileReader !== "undefined" && (FileReader.prototype||{}).readAsBinaryString,
				reader = new FileReader(),
				headerrows = properties.headerrows,
				objQCell = QBOX._.clone(this);
				
				if(rABS) {
					reader.readAsBinaryString(file);
				} else {
					reader.readAsArrayBuffer(file);
				}
				
				reader.onload = function(event) {
					var data = event.target.result;
					
					if( !rABS ) {
						data = new Uint8Array(data);
					}
					properties.cellformula = properties.cellformula === undefined? false : properties.cellformula;
					
					if(!QBOX._.isBoolean(properties.cellformula)){
						properties.cellformula = false;
					}
					
					var opt = {type: rABS ? 'binary' : 'array',cellFormula: properties.cellformula };
					
					if(properties.password !== undefined){
						opt.password = properties.password;
					}
					var bAppend = false;
					
					if(properties.mode !== undefined){
						bAppend = properties.mode === 'append' ? true : false;
					}
					
					objQCell._process_wb(XLSX.read(data, opt ), headerrows,bAppend,properties.beforeUploadCallback ,properties.cellformula);
					
					if(properties.state === true){
						var nRows = objQCell.getRows(), nHeader = objQCell.getRows('header'),
							i;
						for(i= nHeader; i<nRows; i++){
							objQCell._setRowState(i,'i');
						}
					}
					
					var THAT = objQCell;
					setTimeout(function(){
						if(THAT._trigger !== undefined)
							THAT._trigger("exceluploadlocend");
					}, 0);
					
					objQCell = null;
					
					
				};
			} else {
				QBOX.QCELL.log("err", strAPI, this.attr('msg').err.FILE_EXT_NOT_XLSX);
				return false;
			}
		}
		
		return true;
	} catch (e) {
		QBOX.QCELL.log('err', strAPI, e.message);
		return false;
	}
};

//workbook으로부터 데이터를 변형하여 QCell에 입력 
QBOX.QCELL.BasicQCELL.prototype._process_wb = function(wb, rows,bAppend,fnCallback,bFomula) {
	var data, nData = [];
		datatype = this.attr("rowdatatype");
	var	n = 0, i = 0,j ,arrCols = [];
	
	data = this._wbToJson(wb,bFomula);
	
	var isRowHeader = this.attr('rowheaders').length > 0 ? true : false,
		keys = QBOX._.clone(this.attr("colkeys"));
	
	if(isRowHeader){
		var x=0;
		for(x=0;x<this.attr('rowheaders').length;x++)
			keys.shift();
	}
	
	for(j=this.getCols('header'); j<this.getCols();j++){
		var objFormat = this._getColFormat(j);
		if(objFormat !== null){
			if(objFormat.type === 'number'){
				arrCols.push({col : j, key : this._getKeyOfCol (j) , rule: objFormat.rule});
			}
		}
	}
	var arrHeaders = [];
	for(; n < rows; n++) {
		arrHeaders.push(data.shift());
	}
	
	if(fnCallback !== undefined && QBOX._.isFunction(fnCallback)){
		if(fnCallback(arrHeaders) === false){
			return;
		}
	}
	
	for(; i < data.length; i++) {
		var jsonArr = {};
		for( j = 0; j < keys.length; j++){
			jsonArr[keys[j]] = data[i][j];
		}
		
		for(j=0; j <arrCols.length ; j++){
			var obj = arrCols[j];
			if(isNaN(Number(jsonArr[obj.key]))){
				obj.rule = obj.rule === undefined ? '' : obj.rule;
				var tempData;
				if(jsonArr[obj.key] !== undefined){
					tempData = QBOX.$.parseNumber(jsonArr[obj.key], obj.rule);
					if(isNaN(Number(tempData))){
						tempData = 0;
					}					
				}else{
					tempData = 0;
				}
				jsonArr[obj.key] = tempData;
			}
			else
				jsonArr[obj.key] = Number(jsonArr[obj.key]);
			
		}
		nData.push(jsonArr);
	}
	
	if(bAppend === true){
		var arrTemp = QBOX._.clone(this.attr('currentdata'));
		arrTemp = arrTemp.concat(nData);
		this._setData(arrTemp);
	}else{
		this._setData(nData);	
	}
	
	
};
QBOX.QCELL.BasicQCELL.prototype._convertJSON = function (result) {
	var arrResult = [],nCR = 0,i,x;	
	try{
		var isCharacterALetter = function (char) {
			return (/[a-zA-Z]/).test(char);
			};
		
		for(i=0; i< result.length; i++){
			var strCell = result[i];
			var nIndex = strCell.indexOf("=");
			
			if(nIndex === -1){
				continue;
			}else{
				var strKey = strCell.slice(0,nIndex);
				var strData = strCell.slice(nIndex + 1,strCell.length);
				strData = QBOX.util.replaceAll(strData , "'",'');
				
				x=0;
				while(isCharacterALetter(strKey.charAt(x)))
					x++;
				
				var nRow = Number(strKey.slice(x,strKey.length));
				if(isNaN(nRow))
					continue;
						
				if(nCR  != nRow){
					while(nCR !== nRow){
						
						arrResult.push([]);
						nCR++;
					}
				}
				arrResult[nCR -1].push(strData);
			}
			
		}		
	}catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._convertJSON', e.message);
		arrResult =[];
	}


	
	return arrResult;
};	

//workbook의 데이터를 json으로 변환
QBOX.QCELL.BasicQCELL.prototype._wbToJson = function (workbook,bFomula) {
	var result = [],roa;
	workbook.SheetNames.forEach(function(sheetName) {
		if(bFomula !== true){
			roa = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], {header:1});
			result = roa;			
		}else{
			roa = XLSX.utils.sheet_to_formulae(workbook.Sheets[sheetName], {header:1});
			result = roa;		
			
		}
	});
	
	if(bFomula === true){
		result = this._convertJSON(result);
	}

	return result;
};

//workbook의 데이터를 csv로 변환
QBOX.QCELL.BasicQCELL.prototype._wbToCsv = function (workbook) {
	var result = [];
	workbook.SheetNames.forEach(function(sheetName) {
		var csv = XLSX.utils.sheet_to_csv(workbook.Sheets[sheetName]);
		if(csv.length){
			result.push(csv);
		}
	});
	return result.join("\n");
};

//split처리. 특수문자가 들어가 있는 경우를 위해 특수처리
QBOX.QCELL.BasicQCELL.prototype._splitAttrString = function (theStr) {
	var attrs = [];

	var RefString = function(s) {
		this.value = s;
	};
	RefString.prototype.toString = function() {
		return this.value;
	};
	RefString.prototype.charAt = String.prototype.charAt;
	var data = new RefString(theStr);

	var getBlock = function(endChr, restString) {
		var block = '';
		var currChr = '';
		while ((currChr != endChr) && (restString.value !== '')) {
			if (/'|"/.test(currChr)) {
				block = $.trim(block) + getBlock(currChr, restString);
			}
			else if (/\{/.test(currChr)) {
				block = $.trim(block) + getBlock('}', restString);
			}
			else if (/\[/.test(currChr)) {
				block = $.trim(block) + getBlock(']', restString);
			}
			else {
				block += currChr;
			}
			currChr = restString.charAt(0);
			restString.value = restString.value.slice(1);
		}
		return $.trim(block);
	};

	do {
		var attr = getBlock(',', data);
		attrs.push(attr);
	}
	while (data.value !== '');
	
	return attrs;
};
QBOX.QCELL.BasicQCELL.prototype._beforeFocusCell = function(){
	
};
QBOX.QCELL.BasicQCELL.prototype._clearFocusAllCSS = function(){
	
	var vsinfo = this.attr('vsinfo');
	var hsinfo = this.attr('hsinfo');
	
	for(var i=vsinfo.nTopRow; i<= vsinfo.nBottomRow; i++){
		for (var j=hsinfo.nLeftCol; j <= hsinfo.nRightCol; j++){
			var heCell = this._getCellDOM(i,j);
			if(heCell !== null){
				this._removeFocusStyleClass(heCell);
			}
		}
	}

};
QBOX.QCELL.BasicQCELL.prototype._adjustScrollPos = function(){
	if(this.attr('useall') || this.attr('usetreeall')){
		var heHC = document.getElementById('colheader-' + this.getID()),
		heV = document.getElementById('viewport-' + this.getID()),nSL =heV.scrollLeft,nST = heV.scrollTop,
		heR = document.getElementById('rowheader-' + this.getID());
		
		if(nSL !== heHC.scrollLeft){
			heHC.scrollLeft = nSL;
		}
		
		if(nSL > 0){			
				heHC.scrollLeft = 0;
				heV.scrollLeft = 0;
		}
		
		if(nST !== heR.scrollTop){
			heR.scrollTop = nST;
		}
		
		if(nST > 0){			
				heR.scrollTop = 0;
				heV.scrollTop = 0;
		}			
	}	
};
QBOX.QCELL.BasicQCELL.prototype._scrollToFocusCell = function(nRow, nCol){
	try{
		var nRows = this.attr('rows'), nCols = this.attr('cols'),
		nHeaderCols = this.attr('headercols'), nHeaderRows = this.attr('headerrows'),
		nFrozenCols = this.attr('frozencols'), nFrozenRows = this.attr('frozenrows'),
		nFrozenBottomRows = this.attr('frozenbottomrows'),
		nTopRowOfScreen = this._getTopRowOfScreen(), nBottomRowOfScreen = this._getBottomRowOfScreen(),
		nLeftColOfScreen = this._getLeftColOfScreen(), nRightColOfScreen = this._getRightColOfScreen(),
		nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth,
		nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
		nTotalViewPortNormalColWidth, i, nColWidth, nTargetCol, bFlag = true;
		
		this._adjustScrollPos();
		
		this._beforeFocusCell();
		
		if(nRow < nTopRowOfScreen){//focus 셀의 행 인덱스가 보이지 않는 상단에 위치 할 경우
			/* 세로 스크롤 보정 start */
			if(nFrozenRows > 0){//frozenrows 설정되어 있을 경우
				//frozenrows 영역은 항상 보여지고 있는 영역이기 때문에 스크롤 변경이 필요 없음
				if(nRow >= nHeaderRows + nFrozenRows){//focus 셀의 행이 frozenrows 영역이 아닐 경우
					this._scrollTop(nRow);
				}
			} else{
				this._scrollTop(nRow);
			}
			/* 세로 스크롤 보정 end */
			
			/* 가로 스크롤 보정 start */
			if(nCol < nLeftColOfScreen){//focus 셀의 열 인덱스가 보이지 않는 좌측일 경우
				if(nFrozenCols > 0){//frozencols 설정되어 있을 경우
					//frozencols 영역은 항상 보여지고 있는 영역이기 때문에 스크롤 변경이 필요 없음
					if(nCol >= nHeaderCols + nFrozenCols){//focus 셀의 열이 frozencols 영역이 아닐 경우
						this._scrollLeft(nCol);
					}
				} else{
					this._scrollLeft(nCol);
				}
			} else if(nCol > nRightColOfScreen){//focus 셀의 열 인덱스가 보이지 않는 우측일 경우
				nTotalViewPortNormalColWidth = nFrozenColsWidth;
				
				if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
					if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
						for(i = nCol + 1; i < nCols; i++){
							if(this._cellValue(nRow, nCol) === this._cellValue(nRow, i)){
								nCol = i;
							} else{
								break;
							}
						}
					}
				}
				
				for(i = nCol; i >= nHeaderCols; i--){
					nColWidth = this._getColWidth(i);
					
					nTotalViewPortNormalColWidth +=  nColWidth;
					
					if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
						nTargetCol = i;
						break;
					}
				}
				
				this._scrollLeft(nTargetCol + 1);
			} else{//focus 셀의 열 인덱스가 현재 보여지는 화면 안에 있을 경우
				if(nCol === nLeftColOfScreen){
					this._scrollLeft(nCol);
				} else if(nCol === nRightColOfScreen){
					nTotalViewPortNormalColWidth = nFrozenColsWidth;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
							for(i = nCol + 1; i < nCols; i++){
								if(this._cellValue(nRow, nCol) === this._cellValue(nRow, i)){
									nCol = i;
								} else{
									break;
								}
							}
						}
					}
					
					for(i = nCol; i >= nHeaderCols; i--){
						nColWidth = this._getColWidth(i);
						
						nTotalViewPortNormalColWidth +=  nColWidth;
						
						if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
							nTargetCol = i;
							break;
						}
					}
					
					this._scrollLeft(nTargetCol + 1);
				} else{
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
							for(i = nCol; i <= nRightColOfScreen; i++){
								if(this._cellValue(nRow, nCol) !== this._cellValue(nRow, i)){
									bFlag = false;
									break;
								}
							}
							
							if(bFlag){
								nTotalViewPortNormalColWidth = nFrozenColsWidth;
								
								if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
									if(this.attr('merge').data !== 'col'){
										for(i = nCol + 1; i < nCols; i++){
											if(this._cellValue(nRow, nCol) === this._cellValue(nRow, i)){
												nCol = i;
											} else{
												break;
											}
										}
									}
								}
								
								for(i = nCol; i >= nHeaderCols; i--){
									nColWidth = this._getColWidth(i);
									
									nTotalViewPortNormalColWidth +=  nColWidth;
									
									if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
										nTargetCol = i;
										break;
									}
								}
								
								this._scrollLeft(nTargetCol + 1);
							}
						}
					}
				}
			}
			/* 가로 스크롤 보정 end */
		} else if(nRow > nBottomRowOfScreen){//focus 셀의 행 인덱스가 보이지 않는 하단일 경우
			/* 세로 스크롤 보정 start */
			if(nFrozenBottomRows > 0){
				if(nRow < nRows - nFrozenBottomRows){//frozenbottomrows 영역이 아닐 경우
					this._scrollTop(nRow - (nBottomRowOfScreen - nTopRowOfScreen) + 1);
				}
			} else{
				this._scrollTop(nRow - (nBottomRowOfScreen - nTopRowOfScreen) + 1);
			}
			/* 세로 스크롤 보정 end */
			
			
			/* 가로 스크롤 보정 start */
			if(nCol < nLeftColOfScreen){
				if(nFrozenCols > 0){
					if(nCol >= nHeaderCols + nFrozenCols){//frozencols 영역이 아닐 경우
						this._scrollLeft(nCol);
					}
				} else{
					this._scrollLeft(nCol);
				}
			} else if(nCol > nRightColOfScreen){
				nTotalViewPortNormalColWidth = nFrozenColsWidth;
				
				if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
					if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
						for(i = nCol + 1; i < nCols; i++){
							if(this._cellValue(nRow, nCol) === this._cellValue(nRow, i)){
								nCol = i;
							} else{
								break;
							}
						}
					}
				}
				
				for(i = nCol; i >= nHeaderCols; i--){
					nColWidth = this._getColWidth(i);
					
					nTotalViewPortNormalColWidth +=  nColWidth;
					
					if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
						nTargetCol = i;
						break;
					}
				}
				
				this._scrollLeft(nTargetCol + 1);
			} else{
				if(nCol === nLeftColOfScreen){
					this._scrollLeft(nCol);
				} else if(nCol === nRightColOfScreen){
					nTotalViewPortNormalColWidth = nFrozenColsWidth;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
							for(i = nCol + 1; i < nCols; i++){
								if(this._cellValue(nRow, nCol) === this._cellValue(nRow, i)){
									nCol = i;
								} else{
									break;
								}
							}
						}
					}
					
					for(i = nCol; i >= nHeaderCols; i--){
						nColWidth = this._getColWidth(i);
						
						nTotalViewPortNormalColWidth +=  nColWidth;
						
						if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
							nTargetCol = i;
							break;
						}
					}
					
					this._scrollLeft(nTargetCol + 1);
				} else{
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
							for(i = nCol; i <= nRightColOfScreen; i++){
								if(this._cellValue(nRow, nCol) !== this._cellValue(nRow, i)){
									bFlag = false;
									break;
								}
							}
							
							if(bFlag){
								nTotalViewPortNormalColWidth = nFrozenColsWidth;
								
								if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
									if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
										for(i = nCol + 1; i < nCols; i++){
											if(this._cellValue(nRow, nCol) === this._cellValue(nRow, i)){
												nCol = i;
											} else{
												break;
											}
										}
									}
								}
								
								for(i = nCol; i >= nHeaderCols; i--){
									nColWidth = this._getColWidth(i);
									
									nTotalViewPortNormalColWidth +=  nColWidth;
									
									if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
										nTargetCol = i;
										break;
									}
								}
								
								this._scrollLeft(nTargetCol + 1);
							}
						}
					}
				}
			}
			/* 가로 스크롤 보정 end */
		} else{//focus 셀의 행 인덱스가 현재 보여지는 화면 안에 있을 경우
			/* 세로 스크롤 보정 start */
			if(nRow === nBottomRowOfScreen){
				if(this.attr('useall') !== true && this.attr('usetreeall') !== true)
					this._scrollTop(nRow - (nBottomRowOfScreen - nTopRowOfScreen) + 1);
				else{
					if( (this.getIdx('row','click') === this.getIdx('row','cursor') && this.getIdx('row','click') === this.getIdx('row','focus')) &&(this.getIdx('col','click') === this.getIdx('col','cursor') && this.getIdx('col','click') === this.getIdx('col','focus')))
						this._scrollTop(nRow - (nBottomRowOfScreen - nTopRowOfScreen) + 1);
				}
			} else if(nRow === nTopRowOfScreen){
				if(this.attr('useall') || this.attr('usetreeall')){
					this._scrollTop(nRow);
				}else{
					this._scrollTop(nRow);	
				}
				
			}
			/* 세로 스크롤 보정 end */
			
			/* 가로 스크롤 보정 start */
			if(nCol < nLeftColOfScreen){
				if(nFrozenCols > 0){
					if(nCol >= nHeaderCols + nFrozenCols){//frozencols 영역이 아닐 경우
						this._scrollLeft(nCol);
					}
				} else{
					this._scrollLeft(nCol);
				}
			} else if(nCol > nRightColOfScreen){
				nTotalViewPortNormalColWidth = nFrozenColsWidth;
				
				if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
					if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
						for(i = nCol + 1; i < nCols; i++){
							if(this._cellValue(nRow, nCol) === this._cellValue(nRow, i)){
								nCol = i;
							} else{
								break;
							}
						}
					}
				}
				
				for(i = nCol; i >= nHeaderCols; i--){
					nColWidth = this._getColWidth(i);
					
					nTotalViewPortNormalColWidth +=  nColWidth;
					
					if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
						nTargetCol = i;
						break;
					}
				}
				
				this._scrollLeft(nTargetCol + 1);
			} else{
				if(nCol === nLeftColOfScreen){
					this._adjustCol();
				} else if(nCol === nRightColOfScreen){
					nTotalViewPortNormalColWidth = nFrozenColsWidth;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
							for(i = nCol + 1; i < nCols; i++){
								if(this._cellValue(nRow, nCol) === this._cellValue(nRow, i)){
									nCol = i;
								} else{
									break;
								}
							}
						}
					}
					
					for(i = nCol; i >= nHeaderCols; i--){
						nColWidth = this._getColWidth(i);
						
						nTotalViewPortNormalColWidth +=  nColWidth;
						
						if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
							nTargetCol = i;
							break;
						}
					}
					
					this._scrollLeft(nTargetCol + 1);
				} else{
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
							for(i = nCol; i <= nRightColOfScreen; i++){
								if(this._cellValue(nRow, nCol) !== this._cellValue(nRow, i)){
									bFlag = false;
									break;
								}
							}
							
							if(bFlag){
								nTotalViewPortNormalColWidth = nFrozenColsWidth;
								
								if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
									if(this.attr('merge').data !== 'col' && this.attr('merge').data !== 'group'){
										for(i = nCol + 1; i < nCols; i++){
											if(this._cellValue(nRow, nCol) === this._cellValue(nRow, i)){
												nCol = i;
											} else{
												break;
											}
										}
									}
								}
								
								for(i = nCol; i >= nHeaderCols; i--){
									nColWidth = this._getColWidth(i);
									
									nTotalViewPortNormalColWidth +=  nColWidth;
									
									if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
										nTargetCol = i;
										break;
									}
								}
								
								this._scrollLeft(nTargetCol + 1);
							}
						}
					}
				}
			}
			/* 가로 스크롤 보정 end */
		}
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._scrollToFocusCell', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype._leftKey = function(bShift, bCtrl){
	try{
		var nFocusRow = this._idx('row', 'focus', 'current'),
		nFocusCol = this._idx('col', 'focus', 'current'),
		nLastSelectRow = this._getSelectedRow(),
		nLastSelectCol = this._getSelectedCol(),
		nCols = this.attr('cols'),
		nHeaderCols = this.attr('headercols'),
		arrSelectedCols, arrDeselectedCols, objIndex;
		
		this._onScrollHideEditCellsDOM();

		if(!bShift && !bCtrl){//ctrl키 shift키 모두 누르지 않았을 경우
			if(nFocusCol > nHeaderCols && nFocusCol < nCols){ //left 동작 범위
				/* index 계산 */
				--nFocusCol;
				
				if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
					objIndex = this._findNextCell(nFocusRow, nFocusCol, 'left');
					
					nFocusRow = objIndex.row;
					nFocusCol = objIndex.col;
				}
				
				/* selected & focus */
				this._focusCell(nFocusRow, nFocusCol);
				
				switch(this.attr('selectmode')){
					case 'row': case 'rows': {
						this._clearSelection();
						this._selectRow(nFocusRow);
						break;
					}
					case 'col': case 'cols': {
						this._clearSelection();
						this._selectCol(nFocusCol);
						break;
					}
					case 'group': {
						this._clearSelection();
						this._selectGroup(nFocusRow, nFocusCol);
						break;
					}
					default: { //cell, cells 포함
						this._clearSelection();
						this._selectCell(nFocusRow, nFocusCol);
						break;
					}
				}
				
				/* 스크롤 변경 */
				this._scrollToFocusCell(nFocusRow, nFocusCol);
				
			}
		} else{
			if(bShift && !bCtrl){//shift키만 눌럿을 경우.
				if(nLastSelectCol > nHeaderCols && nLastSelectCol < nCols){ //left 동작 범위
					/* index 계산 */
					--nLastSelectCol;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						switch(this.attr('selectmode')){
							case 'row': case 'rows': case 'col': case 'cell': {
								objIndex = this._findNextCell(nFocusRow, nFocusCol, 'left');
								break;
							}
							case 'cols': {
								objIndex = this._findNextCell(nFocusRow, nLastSelectCol, 'left');
								break;
							}
							default: {//cells
								objIndex = this._findNextCell(nLastSelectRow, nLastSelectCol, 'left');
								break;
							}
						}
						nLastSelectRow = objIndex.row;
						nLastSelectCol = objIndex.col;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'row': case 'rows': case 'col': case 'cell': {
							break;
						}
						case 'cols': {
							if(nFocusCol >= this._getSelectedCol()){
								arrSelectedCols = QBOX._.range(nLastSelectCol, nFocusCol + 1).reverse();
								
								this._selectCols(arrSelectedCols);
							} else{
								arrDeselectedCols = QBOX._.range(nFocusCol, this._getSelectedCol() + 1);
								arrSelectedCols = QBOX._.range(nFocusCol, nLastSelectCol + 1);
								
								this._deselectCols(arrDeselectedCols);
								this._selectCols(arrSelectedCols);
							}
							break;
						}
						default: {//cells
							if(nFocusCol >= this._getSelectedCol()){
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							} else{
								this._deselectCellRange(nFocusRow, nFocusCol, this._getSelectedRow(), this._getSelectedCol());
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							}
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nLastSelectRow, nLastSelectCol);

				}
			} else if(!bShift && bCtrl){//ctrl키만 눌럿을 경우.
				if(nFocusCol > nHeaderCols && nFocusCol < nCols){ //left 동작 범위
					/* index 계산 */
					nFocusCol = nHeaderCols;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						objIndex = this._findNextCell(nFocusRow, nFocusCol, 'left');
						
						nFocusRow = objIndex.row;
						nFocusCol = objIndex.col;
					}
					
					/* selected & focus */
					this._focusCell(nFocusRow, nFocusCol);
					
					switch(this.attr('selectmode')){
						case 'row': case 'rows':{
							this._clearSelection();
							this._selectRow(nFocusRow);
							break;
						}
						case 'col': case 'cols': {
							this._clearSelection(true);
							this._selectCol(nFocusCol);
							break;
						}
						default: {//cell, cells
							this._clearSelection(true);
							this._selectCell(nFocusRow, nFocusCol);					
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nFocusRow, nFocusCol);

				}
			} else if(bShift && bCtrl){// 둘다 눌럿을 경우.
				if(nLastSelectCol > nHeaderCols && nLastSelectCol < nCols){ //left 동작 범위
					/* index 계산 */
					nLastSelectCol = nHeaderCols;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						switch(this.attr('selectmode')){
							case 'row': case 'rows': case 'col': case 'cell': {
								objIndex = this._findNextCell(nFocusRow, nFocusCol, 'left');
								break;
							}
							case 'cols': {
								objIndex = this._findNextCell(nFocusRow, nLastSelectCol, 'left');
								break;
							}
							default: {//cells
								objIndex = this._findNextCell(nLastSelectRow, nLastSelectCol, 'left');
								break;
							}
						}
						nLastSelectRow = objIndex.row;
						nLastSelectCol = objIndex.col;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'row': case 'rows': case 'col': case 'cell': {
							break;
						}
						case 'cols': {
							if(nFocusCol >= this._getSelectedCol()){
								arrSelectedCols = QBOX._.range(nLastSelectCol, this._getSelectedCol()).reverse();
								
								this._selectCols(arrSelectedCols);
							} else{
								arrDeselectedCols = QBOX._.range(nFocusCol, this._getSelectedCol() + 1);
								arrSelectedCols = QBOX._.range(nLastSelectCol, nFocusCol + 1).reverse();
								
								this._deselectCols(arrDeselectedCols);
								this._selectCols(arrSelectedCols);
							}
							break;
						}
						default: {//cells
							if(nFocusCol >= this._getSelectedCol()){
								this._selectCellRange(nFocusRow, this._getSelectedCol() - 1, nLastSelectRow, nLastSelectCol);
							} else{
								this._deselectCellRange(nFocusRow, nFocusCol, nLastSelectRow, this._getSelectedCol());
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							}
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nLastSelectRow, nLastSelectCol);
					
				}
			}
		}
		
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._leftKey', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype._rightKey = function(bShift, bCtrl){
	try{
		var nFocusRow = this._idx('row', 'focus', 'current'),
		nFocusCol = this._idx('col', 'focus', 'current'),
		nLastSelectRow = this._getSelectedRow(),
		nLastSelectCol = this._getSelectedCol(),
		nCols = this.attr('cols'),
		nHeaderCols = this.attr('headercols'),
		arrSelectedCols, arrDeselectedCols, objIndex;
		
		this._onScrollHideEditCellsDOM();
		
		if(!bShift && !bCtrl){//ctrl키 shift키 모두 누르지 않았을 경우
			if(nFocusCol >= nHeaderCols && nFocusCol < nCols - 1){ //right 동작 범위
				/* index 계산 */
				++nFocusCol;
				
				if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
					objIndex = this._findNextCell(nFocusRow, nFocusCol, 'right');
					
					nFocusRow = objIndex.row;
					nFocusCol = objIndex.col;
				}
				
				/* selected & focus */
				this._focusCell(nFocusRow, nFocusCol);
				
				switch(this.attr('selectmode')){
					case 'row': case 'rows': {
						this._clearSelection();
						this._selectRow(nFocusRow);
						break;
					}
					case 'col': case 'cols': {
						this._clearSelection(true);
						this._selectCol(nFocusCol);
						break;
					}
					case 'group': {
						this._clearSelection(true);
						this._selectGroup(nFocusRow, nFocusCol);
						break;
					}
					default: { //cell, cells 포함
						this._clearSelection(true);
						this._selectCell(nFocusRow, nFocusCol);
						break;
					}
				}
				
				/* 스크롤 변경 */					
				this._scrollToFocusCell(nFocusRow, nFocusCol);
			}
		} else{
			if(bShift && !bCtrl){//shift키만 눌럿을 경우.
				if(nLastSelectCol >= nHeaderCols && nLastSelectCol < nCols - 1){ //right 동작 범위
					/* index 계산 */
					++nLastSelectCol;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						switch(this.attr('selectmode')){
							case 'row': case 'rows': case 'col': case 'cell': {
								objIndex = this._findNextCell(nFocusRow, nFocusCol, 'right');
								break;
							}
							case 'cols': {
								objIndex = this._findNextCell(nFocusRow, nLastSelectCol, 'right');
								break;
							}
							default: {//cells
								objIndex = this._findNextCell(nLastSelectRow, nLastSelectCol, 'right');
								break;
							}
						}
						nLastSelectRow = objIndex.row;
						nLastSelectCol = objIndex.col;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'row': case 'rows': case 'col': case 'cell': {
							break;
						}
						case 'cols': {
							if(nFocusCol > this._getSelectedCol()){
								arrDeselectedCols = QBOX._.range(this._getSelectedCol(), nFocusCol + 1);
								arrSelectedCols = QBOX._.range(nLastSelectCol, nFocusCol + 1).reverse();
								
								this._deselectCols(arrDeselectedCols);
								this._selectCols(arrSelectedCols);
							} else{
								this._selectCol(nLastSelectCol);
							}
							break;
						}
						default: {//cells
							if(nFocusCol > this._getSelectedCol()){
								this._deselectCellRange(nFocusRow, nFocusCol, this._getSelectedRow(), this._getSelectedCol());
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							} else{
								if(nFocusRow === this._getSelectedRow()){
									this._selectCell(nLastSelectRow, nLastSelectCol);
								} else{
									this._selectCellRange(nFocusRow, nLastSelectCol, nLastSelectRow, nLastSelectCol);
								}
								
							}
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nLastSelectRow, nLastSelectCol);
				}
			} else if(!bShift && bCtrl){//ctrl키만 눌럿을 경우.
				if(nFocusCol >= nHeaderCols && nFocusCol < nCols - 1){ //right 동작 범위
					/* index 계산 */
					nFocusCol = nCols - 1;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						objIndex = this._findNextCell(nFocusRow, nFocusCol, 'right');
						
						nFocusRow = objIndex.row;
						nFocusCol = objIndex.col;
					}
					
					/* selected & focus */
					this._focusCell(nFocusRow, nFocusCol);
					
					switch(this.attr('selectmode')){
						case 'row': case 'rows':{
							this._clearSelection();
							this._selectRow(nFocusRow);
							break;
						}
						case 'col': case 'cols': {
							this._clearSelection();
							this._selectCol(nFocusCol);
							break;
						}
						default: {//cell, cells
							this._clearSelection(true);
							this._selectCell(nFocusRow, nFocusCol);					
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nFocusRow, nFocusCol);
				}
			} else if(bShift && bCtrl){// 둘다 눌럿을 경우.
				if(nLastSelectCol >= nHeaderCols && nLastSelectCol < nCols - 1){ //right 동작 범위
					/* index 계산 */
					nLastSelectCol = nCols - 1;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						switch(this.attr('selectmode')){
							case 'row': case 'rows': case 'col': case 'cell': {
								objIndex = this._findNextCell(nFocusRow, nFocusCol, 'right');
								break;
							}
							case 'cols': {
								objIndex = this._findNextCell(nFocusRow, nLastSelectCol, 'right');
								break;
							}
							default: {//cells
								objIndex = this._findNextCell(nLastSelectRow, nLastSelectCol, 'right');
								break;
							}
						}
						nLastSelectRow = objIndex.row;
						nLastSelectCol = objIndex.col;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'row': case 'rows': case 'col': case 'cell': {
							break;
						}
						case 'cols': {
							if(nFocusCol >= this._getSelectedCol()){
								arrDeselectedCols = QBOX._.range(this._getSelectedCol(), nFocusCol + 1);
								arrSelectedCols =  QBOX._.range(nFocusCol, nLastSelectCol + 1);
								
								this._deselectCols(arrDeselectedCols);
								this._selectCols(arrSelectedCols);
							} else{
								arrSelectedCols =  QBOX._.range(nFocusCol, nLastSelectCol + 1);
								this._selectCols(arrSelectedCols);
							}
							break;
						}
						default: {//cells
							if(nFocusCol > this._getSelectedCol()){
								this._deselectCellRange(nFocusRow, nFocusCol, nLastSelectRow, this._getSelectedCol());
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							} else{
								this._selectCellRange(nFocusRow, this._getSelectedCol() + 1, nLastSelectRow, nLastSelectCol);
							}
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nLastSelectRow, nLastSelectCol);
				}
			}
		}
		
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._rightKey', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype._tabKey = function(bShift, bCtrl){
	try{
		var nFocusRow = this._idx('row', 'focus', 'current'),
		nFocusCol = this._idx('col', 'focus', 'current'),
		nLastSelectRow = this._getSelectedRow(),
		nLastSelectCol = this._getSelectedCol(),
		nCols = this.attr('cols'),
		nHeaderCols = this.attr('headercols'),
		nRows = this.attr('rows'),
		nHeaderRows = this.attr('headerrows'),
		arrSelectedCols, arrDeselectedCols, objIndex;
		
		this._onScrollHideEditCellsDOM();
		
		if(!bShift ){//ctrl키 shift키 모두 누르지 않았을 경우
			if(nFocusCol >= nHeaderCols && nFocusCol < nCols - 1){ //right 동작 범위
				/* index 계산 */
				++nFocusCol;
				
				if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
					objIndex = this._findNextCell(nFocusRow, nFocusCol, 'right');
					
					nFocusRow = objIndex.row;
					nFocusCol = objIndex.col;
				}			
	
			}else{
					nFocusRow++;
					nFocusCol = nHeaderCols;
					
					if(nRows == nFocusRow)
						return;
			}
		} else{
			if(nFocusCol > nHeaderCols && nFocusCol < nCols){ //left 동작 범위
				/* index 계산 */
				--nFocusCol;
				
				if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
					objIndex = this._findNextCell(nFocusRow, nFocusCol, 'left');
					
					nFocusRow = objIndex.row;
					nFocusCol = objIndex.col;
				}
				

				
			}else{
					nFocusRow--;
					nFocusCol = nCols -1;
					
					if(nFocusRow < nHeaderRows)
						return;
			}
		} 
		/* selected & focus */
		this._focusCell(nFocusRow, nFocusCol);
		
		switch(this.attr('selectmode')){
			case 'row': case 'rows': {
				this._clearSelection();
				this._selectRow(nFocusRow);
				break;
			}
			case 'col': case 'cols': {
				this._clearSelection();
				this._selectCol(nFocusCol);
				break;
			}
			case 'group': {
				this._clearSelection();
				this._selectGroup(nFocusRow, nFocusCol);
				break;
			}
			default: { //cell, cells 포함
				this._clearSelection();
				this._selectCell(nFocusRow, nFocusCol);
				break;
			}
		}
		
		/* 스크롤 변경 */
		this._scrollToFocusCell(nFocusRow, nFocusCol);			
		
		
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._rightKey', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype._upKey = function(bShift, bCtrl){
	try{
		var nFocusRow = this._idx('row', 'focus', 'current'),
		nFocusCol = this._idx('col', 'focus', 'current'),
		nLastSelectRow = this._getSelectedRow(),
		nLastSelectCol = this._getSelectedCol(),
		nRows = this.attr('rows'),
		nHeaderRows = this.attr('headerrows'),
		arrSelectedRows, arrDeselectedRows, objIndex;
		
		this._onScrollHideEditCellsDOM();
		
		if(!bShift && !bCtrl){//ctrl키 shift키 모두 누르지 않았을 경우
			if(nFocusRow > nHeaderRows && nFocusRow < nRows){ //up 동작 범위
				/* index 계산 */
				--nFocusRow;
				
				if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
					objIndex = this._findNextCell(nFocusRow, nFocusCol, 'up');
					
					nFocusRow = objIndex.row;
					nFocusCol = objIndex.col;
				}
				
				/* selected & focus */
				this._focusCell(nFocusRow, nFocusCol);
				
				switch(this.attr('selectmode')){
					case 'row': case 'rows': {
						this._clearSelection();
						this._selectRow(nFocusRow);
						break;
					}
					case 'col': case 'cols': {
						this._clearSelection();
						this._selectCol(nFocusCol);
						break;
					}
					case 'group': {
						this._clearSelection();
						this._selectGroup(nFocusRow, nFocusCol);
						break;
					}
					default: { //cell, cells 포함
						this._clearSelection();
						this._selectCell(nFocusRow, nFocusCol);
						break;
					}
				}
				
				/* 스크롤 변경 */
				this._scrollToFocusCell(nFocusRow, nFocusCol);
			}
		} else{
			if(bShift && !bCtrl){//shift키만 눌럿을 경우.
				if(nLastSelectRow > nHeaderRows && nLastSelectRow < nRows){ //up 동작 범위
					/* index 계산 */
					--nLastSelectRow;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						switch(this.attr('selectmode')){
							case 'row': case 'col': case 'cols': case 'cell': {
								objIndex = this._findNextCell(nFocusRow, nFocusCol, 'up');
								break;
							}
							case 'rows': {
								objIndex = this._findNextCell(nLastSelectRow, nFocusCol, 'up');
								break;
							}
							default: {//cells
								objIndex = this._findNextCell(nLastSelectRow, nLastSelectCol, 'up');
								break;
							}
						}
						nLastSelectRow = objIndex.row;
						nLastSelectCol = objIndex.col;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'row': case 'col': case 'cols': case 'cell': {
							break;
						}
						case 'rows': {
							if(nFocusRow >= this._getSelectedRow()){
								arrSelectedRows = QBOX._.range(nLastSelectRow, nFocusRow + 1).reverse();
								
								this._selectRows(arrSelectedRows);
							} else{
								arrDeselectedRows = QBOX._.range(nFocusRow, this._getSelectedRow() + 1);
								arrSelectedRows = QBOX._.range(nFocusRow, nLastSelectRow + 1);
								
								this._deselectRows(arrDeselectedRows);
								this._selectRows(arrSelectedRows);
							}
							break;
						}
						default: {//cells
							if(nFocusRow >= this._getSelectedRow()){
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							} else{
								this._deselectCellRange(nFocusRow, nFocusCol, this._getSelectedRow(), nLastSelectCol);
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							}
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nLastSelectRow, nLastSelectCol);
				}
			} else if(!bShift && bCtrl){//ctrl키만 눌럿을 경우.
				if(nFocusRow > nHeaderRows && nFocusRow < nRows){ //up 동작 범위
					/* index 계산 */
					nFocusRow = nHeaderRows;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						objIndex = this._findNextCell(nFocusRow, nFocusCol, 'up');
						
						nFocusRow = objIndex.row;
						nFocusCol = objIndex.col;
					}
					
					/* selected & focus */
					this._focusCell(nFocusRow, nFocusCol);
					
					switch(this.attr('selectmode')){
						case 'row': case 'rows':{
							this._clearSelection();
							this._selectRow(nFocusRow);
							break;
						}
						case 'col': case 'cols': {
							this._clearSelection();
							this._selectCol(nFocusCol);
							break;
						}
						default: {//cell, cells
							this._clearSelection();
							this._selectCell(nFocusRow, nFocusCol);					
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nFocusRow, nFocusCol);
				}
			} else if(bShift && bCtrl){// 둘다 눌럿을 경우.
				if(nLastSelectRow > nHeaderRows && nLastSelectRow < nRows){ //up 동작 범위
					/* index 계산 */
					nLastSelectRow = nHeaderRows;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						switch(this.attr('selectmode')){
							case 'row': case 'col': case 'cols': case 'cell': {
								objIndex = this._findNextCell(nFocusRow, nFocusCol, 'up');
								break;
							}
							case 'rows': {
								objIndex = this._findNextCell(nLastSelectRow, nFocusCol, 'up');
								break;
							}
							default: {//cells
								objIndex = this._findNextCell(nLastSelectRow, nLastSelectCol, 'up');
								break;
							}
						}
						nLastSelectRow = objIndex.row;
						nLastSelectCol = objIndex.col;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'row': case 'col': case 'cols': case 'cell': {
							break;
						}
						case 'rows': {
							if(nFocusRow >= this._getSelectedRow()){
								arrSelectedRows = QBOX._.range(nLastSelectRow, this._getSelectedRow()).reverse();
								
								this._selectRows(arrSelectedRows);
							} else{
								arrDeselectedRows = QBOX._.range(nFocusRow, this._getSelectedRow() + 1);
								arrSelectedRows = QBOX._.range(nLastSelectRow, nFocusRow + 1).reverse();
								
								this._deselectRows(arrDeselectedRows);
								this._selectRows(arrSelectedRows);
							}
							break;
						}
						default: {//cells
							if(nFocusRow >= this._getSelectedRow()){
								this._selectCellRange(this._getSelectedRow() - 1, nFocusCol, nLastSelectRow, nLastSelectCol);
							} else{
								this._deselectCellRange(nFocusRow, nFocusCol, this._getSelectedRow(), nLastSelectCol);
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							}
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nLastSelectRow, nLastSelectCol);
				}
			}
		}
		
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._upKey', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype._downKey = function(bShift, bCtrl){
	try{
		var nFocusRow = this._idx('row', 'focus', 'current'),
		nFocusCol = this._idx('col', 'focus', 'current'),
		nLastSelectRow = this._getSelectedRow(),
		nLastSelectCol = this._getSelectedCol(),
		nRows = this.attr('rows'),
		nHeaderRows = this.attr('headerrows'),
		arrSelectedRows, arrDeselectedRows, objIndex;
		
		this._onScrollHideEditCellsDOM();
		
		if(!bShift && !bCtrl){//ctrl키 shift키 모두 누르지 않았을 경우
			if(nFocusRow >= nHeaderRows && nFocusRow < nRows - 1){ //down 동작 범위
				/* index 계산 */
				++nFocusRow;
				
				if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
					objIndex = this._findNextCell(nFocusRow, nFocusCol, 'down');
					
					nFocusRow = objIndex.row;
					nFocusCol = objIndex.col;
				}
				
				/* selected & focus */
				this._focusCell(nFocusRow, nFocusCol);
				
				switch(this.attr('selectmode')){
					case 'row': case 'rows': {
						this._clearSelection();
						this._selectRow(nFocusRow);
						break;
					}
					case 'col': case 'cols': {
						this._clearSelection();
						this._selectCol(nFocusCol);
						break;
					}
					case 'group': {
						this._clearSelection();
						this._selectGroup(nFocusRow, nFocusCol);
						break;
					}
					default: { //cell, cells 포함
						this._clearSelection();
						this._selectCell(nFocusRow, nFocusCol);
						break;
					}
				}
				
				/* 스크롤 변경 */
				this._scrollToFocusCell(nFocusRow, nFocusCol);
			}else{
				var THAT = this;
				setTimeout(function(){
					THAT._resizeHScrollbar();
				});				
			}
		} else{
			if(bShift && !bCtrl){//shift키만 눌럿을 경우.
				if(nLastSelectRow >= nHeaderRows && nLastSelectRow < nRows - 1){ //down 동작 범위
					/* index 계산 */
					++nLastSelectRow;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						switch(this.attr('selectmode')){
							case 'row': case 'col': case 'cols': case 'cell': {
								objIndex = this._findNextCell(nFocusRow, nFocusCol, 'down');
								break;
							}
							case 'rows': {
								objIndex = this._findNextCell(nLastSelectRow, nFocusCol, 'down');
								break;
							}
							default: {//cells
								objIndex = this._findNextCell(nLastSelectRow, nLastSelectCol, 'down');
								break;
							}
						}
						nLastSelectRow = objIndex.row;
						nLastSelectCol = objIndex.col;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'row': case 'col': case 'cols': case 'cell': {
							break;
						}
						case 'rows': {
							if(nFocusRow > this._getSelectedRow()){
								arrDeselectedRows = QBOX._.range(this._getSelectedRow(), nFocusRow + 1);
								arrSelectedRows = QBOX._.range(nLastSelectRow, nFocusRow + 1).reverse();
								
								this._deselectRows(arrDeselectedRows);
								this._selectRows(arrSelectedRows);
							} else{
								this._selectRow(nLastSelectRow);
							}
							break;
						}
						default: {//cells
							if(nFocusRow <= this._getSelectedRow()){
								this._selectCellRange(nLastSelectRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							} else{
								this._deselectCellRange(nFocusRow, nFocusCol, this._getSelectedRow(), nLastSelectCol);
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							}
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nLastSelectRow, nLastSelectCol);
				}
			} else if(!bShift && bCtrl){//ctrl키만 눌럿을 경우.
				if(nFocusRow >= nHeaderRows && nFocusRow < nRows - 1){ //down 동작 범위
					/* index 계산 */
					nFocusRow = nRows - 1;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						objIndex = this._findNextCell(nFocusRow, nFocusCol, 'down');
						
						nFocusRow = objIndex.row;
						nFocusCol = objIndex.col;
					}
					
					/* selected & focus */
					this._focusCell(nFocusRow, nFocusCol);
					
					switch(this.attr('selectmode')){
						case 'row': case 'rows':{
							this._clearSelection();
							this._selectRow(nFocusRow);
							break;
						}
						case 'col': case 'cols': {
							this._clearSelection();
							this._selectCol(nFocusCol);
							break;
						}
						default: {//cell, cells
							this._clearSelection();
							this._selectCell(nFocusRow, nFocusCol);					
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nFocusRow, nFocusCol);
				}
			} else if(bShift && bCtrl){// 둘다 눌럿을 경우.
				if(nLastSelectRow >= nHeaderRows && nLastSelectRow < nRows - 1){ //down 동작 범위
					/* index 계산 */
					nLastSelectRow = nRows - 1;
					
					if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
						switch(this.attr('selectmode')){
							case 'row': case 'col': case 'cols': case 'cell': {
								objIndex = this._findNextCell(nFocusRow, nFocusCol, 'down');
								break;
							}
							case 'rows': {
								objIndex = this._findNextCell(nLastSelectRow, nFocusCol, 'down');
								break;
							}
							default: {//cells
								objIndex = this._findNextCell(nLastSelectRow, nLastSelectCol, 'down');
								break;
							}
						}
						nLastSelectRow = objIndex.row;
						nLastSelectCol = objIndex.col;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'row': case 'col': case 'cols': case 'cell': {
							break;
						}
						case 'rows': {
							if(nFocusRow <= this._getSelectedRow()){
								arrSelectedRows = QBOX._.range(this._getSelectedRow(), nLastSelectRow + 1);
								
								this._selectRows(arrSelectedRows);
							} else{
								arrDeselectedRows = QBOX._.range(this._getSelectedRow(), nFocusRow + 1);
								arrSelectedRows = QBOX._.range(nFocusRow, nLastSelectRow + 1);
								
								this._deselectRows(arrDeselectedRows);
								this._selectRows(arrSelectedRows);
							}
							break;
						}
						default: {//cells
							if(nFocusRow <= this._getSelectedRow()){
								this._selectCellRange(this._getSelectedRow()+1, nFocusCol, nLastSelectRow, nLastSelectCol);
							} else{
								this._deselectCellRange(nFocusRow, nFocusCol, this._getSelectedRow(), this._getSelectedCol());
								this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							}
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollToFocusCell(nLastSelectRow, nLastSelectCol);
				}
			}
		}
		
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._downKey', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype._pageUpKey = function(bShift, bCtrl){
	try{
		var nFocusRow = this._idx('row', 'focus', 'current'),
		nFocusCol = this._idx('col', 'focus', 'current'),
		nLastSelectRow = this._getSelectedRow(),
		nLastSelectCol = this._getSelectedCol(),
		objVSInfo = this.attr('vsinfo'),
		nTopRow = this._getTopRowOfScreen(),
		nBottomRow = this._getBottomRowOfScreen();
		
		if(!bShift && !bCtrl){//ctrl키 shift키 모두 누르지 않았을 경우
			if(nFocusRow > this.attr('headerrows') && nFocusRow < this.attr('rows')){ //Pageup 동작 범위
				/* index 계산 */			
				if(this.attr('frozenrows') > 0 && (nFocusRow <= (this.attr('frozenrows') + this.attr('headerrows')) - 1)){
					//focus가 현재 frozenrows 영역에 위치할 경우
					return false;
				} else{
					if(nFocusRow >= nTopRow && nFocusRow <= nBottomRow){
						//focus가 현재 보이는 영역에 위치한 경우
						nFocusRow -= (nBottomRow - nTopRow);
						nTopRow -= (nBottomRow - nTopRow);
					} else{//focus가 현재 보이지 않는 영역에 있을 경우
						nFocusRow = nTopRow - (nBottomRow - nTopRow);
						nTopRow = nTopRow - (nBottomRow - nTopRow);
					}
				}
				
				if(nFocusRow <= this.attr('headerrows')){
					return false;
				}
				
				/* selected & focus */
				this._focusCell(nFocusRow, nFocusCol);
				
				switch(this.attr('selectmode')){
					case 'row': case 'rows':{
						this._clearSelection();
						this._selectRow(nFocusRow);
						break;
					}
					case 'col': case 'cols': {
						this._clearSelection();
						this._selectCol(nFocusCol);
						break;
					}
					case 'group': {
						this._clearSelection();
						var THAT = this;
						setTimeout(function(){ // page up, down 키 동작시 딜레이가 생겨 setTimeout으로 처리
							THAT._selectGroup(nFocusRow, nFocusCol);
						}, 100);
						break;
					}
					default: {//cell, cells
						this._clearSelection();
						this._selectCell(nFocusRow, nFocusCol);					
						break;
					}
				}
				
				/* 스크롤 변경 */
				this._scrollTop(nTopRow);
			}
		} else{
			if(bShift && !bCtrl){//shift키만 눌럿을 경우.
				if(nLastSelectRow > this.attr('headerrows') && nLastSelectRow < this.attr('rows')){ //Pageup 동작 범위
					/* index 계산 */
					if(this.attr('frozenrows') > 0 && (nLastSelectRow <= (this.attr('frozenrows') + this.attr('headerrows')) - 1)){
						//마지막 선택된 셀이 현재 frozenrows 영역에 위치할 경우
						nLastSelectRow = this.attr('headerrows');
						nTopRow = nLastSelectRow;
					} else{
						if(nLastSelectRow >= nTopRow && nLastSelectRow <= nBottomRow){
							//마지막 선택된 셀이 현재 보이는 영역에 위치한 경우
							nLastSelectRow -= (nBottomRow - nTopRow);
							nTopRow -= (nBottomRow - nTopRow);
						} else{//마지막 선택된 셀이 현재 보이지 않는 영역에 있을 경우
							nLastSelectRow = nTopRow;
							nTopRow = nTopRow - (nBottomRow - nTopRow);
						}
					}
					
					if(nLastSelectRow <= this.attr('headerrows')){
						nLastSelectRow = this.attr('headerrows');
						nTopRow = nLastSelectRow;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'rows':{
							var arrDeselectedRows, arrSelectedRows;
							if(nFocusRow < this._getSelectedRow()){
								arrDeselectedRows = QBOX._.range(nFocusRow, this._getSelectedRow() + 1);
								if(nFocusRow < nLastSelectRow){
									arrSelectedRows = QBOX._.range(nFocusRow, nLastSelectRow + 1);
								} else{
									arrSelectedRows = QBOX._.range(nLastSelectRow, nFocusRow + 1).reverse();
								}
							} else{
								arrDeselectedRows = QBOX._.range(this._getSelectedRow(), nFocusRow + 1);
								arrSelectedRows = QBOX._.range(nLastSelectRow, nFocusRow + 1).reverse();
							}
							
							this._deselectRows(arrDeselectedRows);
							this._selectRows(arrSelectedRows);
							break;
						}
						case 'row': case 'col': case 'cols': case 'cell':{
							return false;
						}
						default: {//cells
							this._deselectCellRange(nFocusRow, nFocusCol, this._getSelectedRow(), nLastSelectCol);
							this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							break;
						}
					}
					/* 스크롤 변경 */
					this._scrollTop(nTopRow);
				}
			}
		}
		
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._pageUpKey', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._pageDownKey = function(bShift, bCtrl){
	try{
		var nFocusRow = this._idx('row', 'focus', 'current'),
		nFocusCol = this._idx('col', 'focus', 'current'),
		nLastSelectRow = this._getSelectedRow(),
		nLastSelectCol = this._getSelectedCol(),
		objVSInfo = this.attr('vsinfo'),
		nTopRow = this._getTopRowOfScreen(),
		nBottomRow = this._getBottomRowOfScreen();
		
		if(!bShift && !bCtrl){//ctrl키 shift키 모두 누르지 않았을 경우
			if(nFocusRow >= this.attr('headerrows') && nFocusRow < this.attr('rows') - 1){ //Pagedown 동작 범위
				/* index 계산 */
				if(nFocusRow >= this.attr('rows') - this.attr('frozenbottomrows')){ //focus가 현재 frozenbottomrows 영역에 위치할 경우
					return false;
				} else{
					if(nFocusRow >= nTopRow && nFocusRow <= nBottomRow){
						//focus가 현재 보이는 영역에 위치한 경우
						nFocusRow += (nBottomRow - nTopRow);
					} else{//focus가 현재 보이지 않는 영역에 있을 경우
						nFocusRow = nBottomRow;
					}
				}
				
				if(nFocusRow >= this.attr('rows')){
					return false;
				}
				
				/* selected & focus */
				this._focusCell(nFocusRow, nFocusCol);
				
				switch(this.attr('selectmode')){
					case 'row': case 'rows':{
						this._clearSelection();
						this._selectRow(nFocusRow);
						break;
					}
					case 'col': case 'cols': {
						this._clearSelection();
						this._selectCol(nFocusCol);
						break;
					}
					case 'group': {
						this._clearSelection();
						var THAT = this;
						setTimeout(function(){ // page up, down 키 동작시 딜레이가 생겨 setTimeout으로 처리
							THAT._selectGroup(nFocusRow, nFocusCol);
						}, 100);
						break;
					}
					default: {//cell, cells
						this._clearSelection();
						this._selectCell(nFocusRow, nFocusCol);					
						break;
					}
				}
				
				/* 스크롤 변경 */
				nTopRow += (nBottomRow - nTopRow);
				this._scrollTop(nTopRow);
			}
		} else{
			if(bShift && !bCtrl){//shift키만 눌럿을 경우.
				if(nLastSelectRow >= this.attr('headerrows') && nLastSelectRow < this.attr('rows') - 1){ //Pagedown 동작 범위
					/* index 계산 */	
					if(nLastSelectRow >= this.attr('rows') - this.attr('frozenbottomrows')){
						//마지막 선택된 셀이 현재 frozenbottomrows 영역에 위치할 경우
						nLastSelectRow = this.attr('rows') - 1;
						nTopRow = nLastSelectRow;
					} else if(nLastSelectRow <= (this.attr('frozenrows') + this.attr('headerrows')) - 1){
						//마지막 선택된 셀이 현재 frozenrows 영역에 위치할 경우
						nLastSelectRow = objVSInfo.nStartRow + (nBottomRow - nTopRow);
						nTopRow = nLastSelectRow;
					} else{
						if(nLastSelectRow < nTopRow || nLastSelectRow > nBottomRow){
							//마지막 선택된 셀이 현재 보이지 않는 영역에 있을 경우
							nLastSelectRow += (nBottomRow - nTopRow);
							nTopRow = nLastSelectRow;
						} else{//마지막 선택된 셀이 현재 보이는 영역에 있는 경우
							nLastSelectRow += (nBottomRow - nTopRow);
							nTopRow += (nBottomRow - nTopRow);
						}
					}
					
					if(nLastSelectRow > this.attr('rows')){
						nLastSelectRow = this.attr('rows') - 1;
						nTopRow = nLastSelectRow;
					}
					
					/* selected & focus */
					switch(this.attr('selectmode')){
						case 'rows':{
							var arrDeselectedRows, arrSelectedRows;
							
							if(nFocusRow > this._getSelectedRow()){
								arrDeselectedRows = QBOX._.range(this._getSelectedRow(), nFocusRow + 1);
								if(nFocusRow > nLastSelectRow){
									arrSelectedRows = QBOX._.range(nLastSelectRow, nFocusRow + 1).reverse();
								} else{
									arrSelectedRows = QBOX._.range(nFocusRow, nLastSelectRow + 1);
								}
							} else{
								arrDeselectedRows = QBOX._.range(nFocusRow, this._getSelectedRow() + 1);
								arrSelectedRows = QBOX._.range(nFocusRow, nLastSelectRow + 1);
							}
							
							this._deselectRows(arrDeselectedRows);
							this._selectRows(arrSelectedRows);
							break;
						}
						case 'row': case 'col': case 'cols': case 'cell': {
							return false;
						}
						default: {//cells
							this._deselectCellRange(nFocusRow, nFocusCol, this._getSelectedRow(), nLastSelectCol);
							this._selectCellRange(nFocusRow, nFocusCol, nLastSelectRow, nLastSelectCol);
							break;
						}
					}
					
					/* 스크롤 변경 */
					this._scrollTop(nTopRow);
				}
			}
		}
		
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._pageDownKey', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._createMergeInfo = function(){
	return this._createHeaderMergeInfo() && this._createDataMergeInfo();
};

QBOX.QCELL.BasicQCELL.prototype._createHeaderMergeInfo = function(){
	var objMergeType = this.attr("merge"),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	arrHeaderText = this.attr('headertext'),
	objHSInfo = this.attr('hsinfo'),
	nFrozenCols = this.attr('frozencols');

	if(objMergeType.header !== 'none'){
		var arrHeaderInfo = this.attr('merge_header_info');

		if(!QBOX._.isUndefined(arrHeaderInfo) && !QBOX._.isNull(arrHeaderInfo)){
			arrHeaderInfo.RT_clear();
		}
		arrHeaderInfo = [];

		var arrText = [],
		i,
		j,
		arrRowText,
		strHeaderCellText;

		if(nFrozenCols){

			for (i = 0; i < nHeaderRows; i++){
				arrRowText = [];
				j = 0;
				for (j = 0; j < nHeaderCols; j++){
					arrRowText.push('');
				}
				for (j = nHeaderCols; j < nFrozenCols + nHeaderCols; j++){
					strHeaderCellText = arrHeaderText[j][i] === undefined ? '' : arrHeaderText[j][i];
					arrRowText.push(strHeaderCellText);
				}
				arrText.push(arrRowText);
			}

			this._merge(objMergeType.header, nHeaderCols, arrHeaderInfo, arrText, 0, nHeaderCols);

			arrText = [];

			for (i = 0; i < nHeaderRows; i++){
				arrRowText = [];
				j = 0;
				for (j = 0; j < nHeaderCols; j++){
					arrRowText.push('');
				}
				for (j = nFrozenCols + nHeaderCols; j < arrHeaderText.length; j++){
					strHeaderCellText = arrHeaderText[j][i] === undefined ? '' : arrHeaderText[j][i];
					arrRowText.push(strHeaderCellText);
				}
				arrText.push(arrRowText);
			}

			this._merge(objMergeType.header, nHeaderCols, arrHeaderInfo, arrText, 0, nFrozenCols + nHeaderCols);

		} else {

			for (i = 0; i < nHeaderRows; i++){
				arrRowText = [];
				j = 0;
				for (j = 0; j < nHeaderCols; j++){
					arrRowText.push('');
				}
				for (j = nHeaderCols; j < arrHeaderText.length; j++){
					strHeaderCellText = arrHeaderText[j][i] === undefined ? '' : arrHeaderText[j][i];
					arrRowText.push(strHeaderCellText);
				}
				arrText.push(arrRowText);
			}

			this._merge(objMergeType.header, nHeaderCols, arrHeaderInfo, arrText, 0, nHeaderCols);
		}
		this.attr('merge_header_info', arrHeaderInfo, 'array');
	}
	
	return true;
};

QBOX.QCELL.BasicQCELL.prototype._isMergeCell = function(nRow, nCol){
	var arrMergeInfos = nRow < this.attr('headerrows') ? this.attr('merge_header_info') : this.attr('merge_data_info');

	if(QBOX._.isArray(arrMergeInfos)){
		return this._findMergeInfo(nRow, nCol, arrMergeInfos);
	}

	return false;
};

QBOX.QCELL.BasicQCELL.prototype._isMasterCell = function (nRow, nCol){
	var objMergeInfo = this._getMergeInfo(nRow, nCol);
	
	if(objMergeInfo !== null){
		return objMergeInfo.nStartRow === nRow && objMergeInfo.nStartCol === nCol;
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._isLastHeaderRowMasterCell = function (nRow, nCol){
	//병합된 셀이면서 마스터 셀이고 마지막 headerRow까지 병합된 셀인지 체크
	var objMergeInfo = this._getMergeInfo(nRow, nCol);
	
	if(objMergeInfo !== null){
		if(objMergeInfo.nStartRow === nRow && objMergeInfo.nStartCol === nCol){
			return objMergeInfo.nEndRow === this.attr('headerrows') - 1;
		}
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._merge = function(strType, nStartCol, arrInfo, arrText, nTopRow, nLeftCol){
	if(strType === 'row'){
		this._mergeRow(0, nStartCol, arrInfo, arrText, nTopRow, nLeftCol);
	} else if(strType === 'col'){
		this._mergeCol(0, nStartCol, arrInfo, arrText, nTopRow, nLeftCol);
	} else if(strType === 'rowandcol'){
		this._mergeRowAndCol(0, nStartCol, arrInfo, arrText, nTopRow, nLeftCol);
	} else if(strType === 'colandrow'){
		this._mergeColAndRow(0, nStartCol, arrInfo, arrText, nTopRow, nLeftCol);
	} else if(strType === 'group'){
		this._mergeGroup(0, nStartCol, arrInfo, arrText, nTopRow, nLeftCol);
	} else if(strType === 'groupandrow'){   
		this._mergeGroupAndRow(0, nStartCol, arrInfo, arrText, nTopRow, nLeftCol);
	}
};


QBOX.QCELL.BasicQCELL.prototype._makeMergeText = function(nStartRow, nStartCol, nEndRow, nEndCol, arrText){
	var nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var arrCurrentData = this.attr('currentdata');

	if(arrCurrentData.length > 0){
		for (var i = nStartRow; i < nEndRow; i++){
			var arrRowText = [],
			j = 0;
			if(arrCurrentData[i - nHeaderRows] === undefined)
				break;
			
			for (j = 0; j < nHeaderCols; j++)
				arrRowText.push('');
			for (j = nStartCol; j <= nEndCol; j++){
				var keyOfCol = this._getKeyOfCol(j);
				var strCellData = arrCurrentData[i - nHeaderRows][keyOfCol] === undefined ? '' : arrCurrentData[i - nHeaderRows][keyOfCol];
				arrRowText.push(strCellData);
			}
			arrText.push(arrRowText);
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._createDataMergeInfo = function(){
	var arrCurrentData = this.attr('currentdata'),
	objVSInfo = this.attr('vsinfo'),
	objHSInfo = this.attr('hsinfo'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	nFrozenCols = this.attr('frozencols'),
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows'),
	objMergeType = this.attr("merge");
	
	if(objMergeType.data === 'group' || objMergeType.data === 'groupandrow'){
		this._createDataGroupMergeInfo();
	} else if(objMergeType.data !== 'none'){
		var arrMergeInfo = this.attr('merge_data_info');

		if(!QBOX._.isUndefined(arrMergeInfo) && !QBOX._.isNull(arrMergeInfo)){
			arrMergeInfo.RT_clear();
		}
		arrMergeInfo = [];
		var arrText = [];
		var nStartRow = objVSInfo.nTopRow,
		nStartCol = objHSInfo.nLeftCol;

		if(nFrozenCols){
			//FCT + FC
			this._createFCDataMergeInfo(arrMergeInfo, nHeaderRows, nHeaderRows + nFrozenRows - 1);
			this._createFCDataMergeInfo(arrMergeInfo, objVSInfo.nTopRow, objVSInfo.nBottomRow);

		} else {
			nStartCol = nHeaderCols;
		}

		if(nFrozenRows){
			if(nFrozenRows && objVSInfo.bVScroll){
				this._createFRDataMergeInfo(arrMergeInfo);
			} else {
				nStartRow = nHeaderRows;
			}
		}
		
		if(nStartRow < 0 )
			return true;

		this._makeMergeText(nStartRow, nStartCol, objVSInfo.nBottomRow + 1, objHSInfo.nRightCol, arrText);
		this._merge(objMergeType.data, nHeaderCols, arrMergeInfo, arrText, nStartRow, nStartCol);

		if(nFrozenBottomRows){
			if(nFrozenCols && objVSInfo.bVScroll){
				this._createFCDataMergeInfo(arrMergeInfo, arrCurrentData.length - nFrozenBottomRows + nHeaderRows, arrCurrentData.length + nHeaderRows - 1);
			}
			this._createFRBDataMergeInfo(arrMergeInfo, nStartCol);
		}

		this.attr('merge_data_info', arrMergeInfo, 'array');
	}

	return true;
};

QBOX.QCELL.BasicQCELL.prototype._createDataGroupMergeInfo = function(){
	var arrCurrentData = this.attr('currentdata'),
	objVSInfo = this.attr('vsinfo'),
	objHSInfo = this.attr('hsinfo'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	nFrozenCols = this.attr('frozencols'),
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows'),
	objMergeType = this.attr("merge");

	var arrMergeInfo = this.attr('merge_data_info');

	if(!QBOX._.isUndefined(arrMergeInfo) && !QBOX._.isNull(arrMergeInfo)){
		arrMergeInfo.RT_clear();
	}
	
	arrMergeInfo = [];
	var arrText = [];
	var nStartRow = objVSInfo.nTopRow,
	nStartCol = objHSInfo.nLeftCol;
	var nCase = 0;

	if(nFrozenRows){
		this._makeMergeText(nHeaderRows, nHeaderCols, nHeaderRows + nFrozenRows, objHSInfo.nRightCol, arrText);
		this._merge(objMergeType.data, nHeaderCols, arrMergeInfo, arrText, nHeaderRows, nHeaderCols);

		arrText.RT_clear();
	}

	this._makeMergeText(nStartRow, nHeaderCols, objVSInfo.nBottomRow + 1, objHSInfo.nRightCol, arrText);
	this._merge(objMergeType.data, nHeaderCols, arrMergeInfo, arrText, nStartRow, nHeaderCols);

	arrText.RT_clear();

	if(nFrozenBottomRows){
		var nStart = arrCurrentData.length - nFrozenBottomRows + nHeaderRows;
		var nEnd = arrCurrentData.length + nHeaderRows;
		this._makeMergeText(nStart, nHeaderCols, nEnd, objHSInfo.nRightCol, arrText);
		this._merge(objMergeType.data, nHeaderCols, arrMergeInfo, arrText, nStart, nHeaderCols);
	}
	
	this.attr('merge_data_info', arrMergeInfo, 'array');
};

QBOX.QCELL.BasicQCELL.prototype._createFRDataMergeInfo = function(arrMergeInfo){
	var arrCurrentData = this.attr('currentdata'),
	objVSInfo = this.attr('vsinfo'),
	objHSInfo = this.attr('hsinfo'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	nFrozenCols = this.attr('frozencols'),
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows'),
	objMergeType = this.attr("merge");

	if(objMergeType.data == 'none'){
		return;
	}

	var arrText = [];
	var nStartCol = objHSInfo.nLeftCol;

	this._makeMergeText(nHeaderRows, objHSInfo.nLeftCol, nFrozenRows + nHeaderRows, objHSInfo.nRightCol, arrText);
	this._merge(objMergeType.data, nHeaderCols, arrMergeInfo, arrText, nHeaderRows, nStartCol);
};

QBOX.QCELL.BasicQCELL.prototype._createFRBDataMergeInfo = function(arrMergeInfo, nStartCol){
	var arrCurrentData = this.attr('currentdata'),
	objVSInfo = this.attr('vsinfo'),
	objHSInfo = this.attr('hsinfo'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	nFrozenCols = this.attr('frozencols'),
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows'),
	objMergeType = this.attr("merge");

	if(objMergeType.data === 'none'){
		return;
	}

	var arrText = [];

	this._makeMergeText(arrCurrentData.length - nFrozenBottomRows + nHeaderRows, nStartCol, arrCurrentData.length + nHeaderRows, objHSInfo.nRightCol, arrText);
	this._merge(objMergeType.data, nHeaderCols, arrMergeInfo, arrText, arrCurrentData.length - nFrozenBottomRows + nHeaderRows, nStartCol);
};

QBOX.QCELL.BasicQCELL.prototype._createFCDataMergeInfo = function(arrMergeInfo, nStartRow, nEndRow){
	var arrCurrentData = this.attr('currentdata'),
	objVSInfo = this.attr('vsinfo'),
	objHSInfo = this.attr('hsinfo'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	nFrozenCols = this.attr('frozencols'),
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows'),
	objMergeType = this.attr("merge");

	if(objMergeType.data == 'none'){
		return;
	}

	var arrText = [];

	this._makeMergeText(nStartRow, nHeaderCols, nEndRow + 1, nFrozenCols + nHeaderCols - 1, arrText);
	this._merge(objMergeType.data, nHeaderCols, arrMergeInfo, arrText, nStartRow, nHeaderCols);
};

QBOX.QCELL.BasicQCELL.prototype._makeMergeInfo = function(nStartRow, nStartCol, nEndRow, nEndCol, strMergeData){
	var objMergeData = {};
	objMergeData.nStartRow = nStartRow;
	objMergeData.nStartCol = nStartCol;
	objMergeData.nEndRow = nEndRow;
	objMergeData.nEndCol = nEndCol;
	objMergeData.strMergeData = strMergeData;

	return objMergeData;
};

QBOX.QCELL.BasicQCELL.prototype._findMergeInfo = function(nRow, nCol, arrInfo){
	for (var i = 0; i < arrInfo.length; i++){
		var objInfo = arrInfo[i];

		if(objInfo.nStartRow <= nRow && objInfo.nEndRow >= nRow)
			if(objInfo.nStartCol <= nCol && objInfo.nEndCol >= nCol)
				return true;
	}
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._getMergeInfo = function (nRow, nCol){
   var arrMergeInfos = nRow < this.attr('headerrows') ? this.attr('merge_header_info') : this.attr('merge_data_info'),
   result = null;
   
   if(QBOX._.isArray(arrMergeInfos)){
      QBOX.$.each(arrMergeInfos, function(idx, objMergeInfo){
         if(objMergeInfo.nStartRow <= nRow && objMergeInfo.nEndRow >= nRow && objMergeInfo.nStartCol <= nCol && objMergeInfo.nEndCol >= nCol){
            result = objMergeInfo;
            return false;//찾은 이후에는 loop break
         }
      });
   }
   
   return result;
};

QBOX.QCELL.BasicQCELL.prototype._mergeCol = function(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol){

	var nCols = arrText.length ? arrText[0].length : 0,
	objMergeData = null;
	var nDif = nLeftCol - nStartCol;
	var nColIndex = nLeftCol;

	for (var j = nStartCol; j < nCols; j++){
		if(this._getColDataMergeCol(nColIndex)){
			var strCompText = arrText[nStartRow][j] === undefined ? '' : arrText[nStartRow][j];
			var nIndex = 0;
			for (var i = nStartRow + 1; i < arrText.length; i++){
				
				if(strCompText !== arrText[i][j]){
					if(nIndex){
						objMergeData = this._makeMergeInfo(i - ++nIndex + nStartRow + nTopRow, nColIndex, i - 1 + nTopRow, nColIndex, strCompText);
						nIndex = 0;
						arrInfo.push(objMergeData);
					}
					strCompText = arrText[i][j];
				} else {
					nIndex++;
				}
			}
			if(nIndex){
				objMergeData = this._makeMergeInfo(i - ++nIndex + nStartRow + nTopRow, nColIndex, i - 1 + nTopRow, nColIndex, strCompText);
				arrInfo.push(objMergeData);
			}
			
		}
		nColIndex++;
	}
};
QBOX.QCELL.BasicQCELL.prototype._mergeColAndRow = function(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol){
	var nDif = nLeftCol - nStartCol;
	var nCols = arrText.length ? arrText[0].length : 0;
	var objMergeData = null;
	for (var j = nStartCol; j < nCols; j++){
		var strCompText = arrText[nStartRow][j] === undefined ? '' : arrText[nStartRow][j];
		var nIndex = 0;

		for (var i = nStartRow + 1; i < arrText.length; i++){
			if(strCompText !== arrText[i][j]){
				if(nIndex){
					if(!this._findMergeInfo(i - ++nIndex + nStartRow + nTopRow, j + nDif, arrInfo)){
						objMergeData = this._makeMergeInfo(i - nIndex + nStartRow + nTopRow, j + nDif, i - 1 + nTopRow, j + nDif, strCompText);
						this._mergeColAndRowSub(objMergeData, arrText, nTopRow, nDif);

						arrInfo.push(objMergeData);
					}
					nIndex = 0;
				} else {
					if(!this._findMergeInfo(i - 1 + nTopRow, j + nDif, arrInfo)){
						objMergeData = this._makeMergeInfo(i - 1 + nTopRow, j + nDif, i - 1 + nTopRow, j + nDif, strCompText);
						this._mergeColAndRowSub(objMergeData, arrText, nTopRow, nDif);

						if(objMergeData.nStartRow == objMergeData.nEndRow && objMergeData.nStartCol == objMergeData.nEndCol){
							objMergeData = null;
						} else {
							arrInfo.push(objMergeData);
						}
					} else {
						nIndex = 0;
					}

				}
				strCompText = arrText[i][j];
			} else {
				nIndex++;
			}
		}
		if(nIndex){
			if(!this._findMergeInfo(i - ++nIndex + nStartRow + nTopRow, j + nDif, arrInfo)){
				objMergeData = this._makeMergeInfo(i - nIndex + nStartRow + nTopRow, j + nDif, i - 1 + nTopRow, j + nDif, strCompText);
				this._mergeColAndRowSub(objMergeData, arrText, nTopRow, nDif);
				arrInfo.push(objMergeData);
			} else {
				if(!this._findMergeInfo(i + nTopRow - 1, j + nDif, arrInfo)){
					objMergeData = this._makeMergeInfo(i + nTopRow - 1, j + nDif, i + nTopRow - 1, j + nDif, strCompText);
					this._mergeColAndRowSub(objMergeData, arrText, nTopRow, nDif);

					if(objMergeData.nStartRow == objMergeData.nEndRow && objMergeData.nStartCol == objMergeData.nEndCol){
						objMergeData = null;
					} else {
						arrInfo.push(objMergeData);
					}
				}
			}
		} else {
			if(!this._findMergeInfo(i - 1 + nTopRow, j + nDif, arrInfo)){
				objMergeData = this._makeMergeInfo(i - 1 + nTopRow, j + nDif, i - 1 + nTopRow, j + nDif, strCompText);
				this._mergeColAndRowSub(objMergeData, arrText, nTopRow, nDif);

				if(objMergeData.nStartRow == objMergeData.nEndRow && objMergeData.nStartCol == objMergeData.nEndCol){
					objMergeData = null;
				} else {
					arrInfo.push(objMergeData);
				}
			}

		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._mergeColAndRowSub = function(objInfo, arrText, nTopRow, nLeftCol){
	var nRow = objInfo.nEndRow + 1;
	var nCols = arrText.length ? arrText[0].length : 0;
	var nStartCol = objInfo.nEndCol + 1;

	for (var j = nStartCol - nLeftCol; j < nCols; j++){

		for (var i = objInfo.nStartRow - nTopRow; i <= objInfo.nEndRow - nTopRow; i++){

			var strCompText = arrText[i][j];
			if(strCompText !== objInfo.strMergeData)
				return;
		}

		if(objInfo.nStartRow - 1 - nTopRow >= 0){
			if(arrText[objInfo.nStartRow - 1 - nTopRow][j] == objInfo.strMergeData)
				return;
		}
		if(objInfo.nEndRow + 1 < arrText.length){
			if(arrText[objInfo.nEndRow + 1 - nTopRow][j] == objInfo.strMergeData)
				return;
		}
		objInfo.nEndCol++;
	}
};

QBOX.QCELL.BasicQCELL.prototype._mergeRowAndCol = function(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol){
	var nDif = nLeftCol - nStartCol;
	for (var i = nStartRow; i < arrText.length; i++){
		var arrRowText = arrText[i];
		if(!arrRowText.length)
			break;
		var strCompText = arrRowText[nStartCol] === undefined ? '' : arrRowText[nStartCol];
		var nIndex = 0,
		j = nStartCol + 1,
		objMergeData = null;
		for (j = nStartCol + 1; j < arrRowText.length; j++){
			if(strCompText !== arrRowText[j]){
				if(nIndex){
					if(!this._findMergeInfo(i + nTopRow, j - ++nIndex + nDif, arrInfo)){
						objMergeData = this._makeMergeInfo(i + nTopRow, j - nIndex + nDif, i + nTopRow, j - 1 + nDif, strCompText);
						this._mergeRowAndColSub(objMergeData, arrText, nTopRow, nDif);
						arrInfo.push(objMergeData);
					}
					nIndex = 0;
				} else {
					if(!this._findMergeInfo(i + nTopRow, j - 1 + nDif, arrInfo)){
						objMergeData = this._makeMergeInfo(i + nTopRow, j - 1 + nDif, i + nTopRow, j - 1 + nDif, strCompText);
						this._mergeRowAndColSub(objMergeData, arrText, nTopRow, nDif);

						if(objMergeData.nStartRow == objMergeData.nEndRow && objMergeData.nStartCol == objMergeData.nEndCol){
							objMergeData = null;
						} else {
							arrInfo.push(objMergeData);
						}
					}
				}
				strCompText = arrText[i][j];
			} else {
				nIndex++;
			}
		}
		if(nIndex){
			if(!this._findMergeInfo(i + nTopRow, j - ++nIndex + nDif, arrInfo)){
				objMergeData = this._makeMergeInfo(i + nTopRow, j - nIndex + nDif, i + nTopRow, j + nDif - 1, strCompText);
				this._mergeRowAndColSub(objMergeData, arrText, nTopRow, nDif);
				arrInfo.push(objMergeData);
			}
		} else {
			if(!this._findMergeInfo(i + nTopRow, j - 1 + nDif, arrInfo)){
				objMergeData = this._makeMergeInfo(i + nTopRow, j - 1 + nDif, i + nTopRow, j - 1 + nDif, strCompText);
				this._mergeRowAndColSub(objMergeData, arrText, nTopRow, nDif);

				if(objMergeData.nStartRow == objMergeData.nEndRow && objMergeData.nStartCol == objMergeData.nEndCol){
					objMergeData = null;
				} else {
					arrInfo.push(objMergeData);
				}
			}
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._mergeRowAndColSub = function(objInfo, arrText, nTopRow, nLeftCol){
	var nRow = objInfo.nEndRow + 1;
	for (var i = nRow - nTopRow; i < arrText.length; i++){
		var nStartCol = objInfo.nStartCol - nLeftCol;
		for (var j = nStartCol; j <= objInfo.nEndCol - nLeftCol; j++){
			var strCompText = arrText[i][j];
			if(!QBOX._.isUndefined(strCompText) && strCompText !== objInfo.strMergeData)
				return;
		}
		if(arrText[i][nStartCol - 1] === objInfo.strMergeData || arrText[i][objInfo.nEndCol + 1 - nLeftCol] === objInfo.strMergeData)
			return;
		objInfo.nEndRow++;
	}
};

QBOX.QCELL.BasicQCELL.prototype._mergeRow = function(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol){

	var nDif = nLeftCol - nStartCol;

	for (var i = nStartRow; i < arrText.length; i++){
		var arrRowText = arrText[i],
		objMergeData = null;
		if(!arrRowText.length)
			break;
		var strCompText = arrRowText[nStartCol] === undefined ? '' : arrRowText[nStartCol];
		var nIndex = 0;
		for (var j = nStartCol + 1; j < arrRowText.length; j++){
			if(strCompText !== arrRowText[j]){
				if(nIndex){
					objMergeData = this._makeMergeInfo(i + nTopRow, j + nDif - ++nIndex, i + nTopRow, j - 1 + nDif, strCompText);
					nIndex = 0;
					arrInfo.push(objMergeData);
				}
				strCompText = arrText[i][j];
			} else {
				nIndex++;
			}
		}
		if(nIndex){
			objMergeData = this._makeMergeInfo(i + nTopRow, j - ++nIndex + nDif, i + nTopRow, j - 1 + nDif, strCompText);
			strCompText = arrRowText[j];
			nIndex = 0;
			arrInfo.push(objMergeData);
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._mergeGroup = function(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol){
	var nDif = nLeftCol - nStartCol;
	this._mergeGroupSub(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol, arrText.length, nStartCol);
};

QBOX.QCELL.BasicQCELL.prototype._mergeGroupSub = function(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol, nEndRow, nDif){
	var nCols = arrText.length ? arrText[0].length : 0;

	if(nStartCol == nCols)
		return;
	
	if(arrText.length === 0)
		return;
	if(!this._getColDataMergeCol(nStartCol))
		return;
	
	var i = nStartRow;
	var strCompText = arrText[nStartRow][nStartCol] === undefined ? '' : arrText[nStartRow][nStartCol];
	var nIndex = 0;
	var objMergeData = null;
	for (i = nStartRow + 1; i < nEndRow; i++){
		var arrRowText = arrText[i];
		if(strCompText !== arrRowText[nStartCol]){
			if(nIndex){
				objMergeData = this._makeMergeInfo(i + nTopRow - ++nIndex, nStartCol + nLeftCol - nDif, i + nTopRow - 1, nStartCol + nLeftCol - nDif, strCompText);
				nIndex = 0;
				arrInfo.push(objMergeData);
				this._mergeGroupSub(objMergeData.nStartRow - nTopRow, nStartCol + 1, arrInfo, arrText, nTopRow, nLeftCol, i, nDif);
			}
			strCompText = arrRowText[nStartCol];
		} else {
			nIndex++;
		}
	}
	if(nIndex){
		objMergeData = this._makeMergeInfo(i + nTopRow - ++nIndex, nStartCol + nLeftCol - nDif, i + nTopRow - 1, nStartCol + nLeftCol - nDif, strCompText);
		nIndex = 0;
		arrInfo.push(objMergeData);
		this._mergeGroupSub(objMergeData.nStartRow - nTopRow, nStartCol + 1, arrInfo, arrText, nTopRow, nLeftCol, i, nDif);
	}
};

QBOX.QCELL.BasicQCELL.prototype._updateMergeHeader = function(){
	var arrHeaderInfo = this.attr('merge_header_info');
	this._updateMergeSub(arrHeaderInfo,true);

	return true;
};

QBOX.QCELL.BasicQCELL.prototype._updateMergeData = function(){
	var arrMergeInfo = this.attr('merge_data_info');
	this._updateMergeSub(arrMergeInfo,false);

	return true;
};

QBOX.QCELL.BasicQCELL.prototype._updateMerge = function(){
	this._updateMergeHeader();
	this._updateMergeData();
	
	var THAT = this;
	setTimeout(function (){
		THAT._trigger('redrawed');			
	},0);

	return true;
};

QBOX.QCELL.BasicQCELL.prototype._updateMergeSub = function(arrHeaderInfo,bHeader){

	if(QBOX._.isUndefined(arrHeaderInfo) || QBOX._.isNull(arrHeaderInfo))
		return;

	var THAT = this;
	QBOX._.each(arrHeaderInfo, function(objHeaderInfo){
		var masterCell = null,
		masterWidth = 0,
		masterHeight = 0,
		orginWidth = 0,
		orginHeight = 0,
		arrCells = [],
		bFirstRow = true,
		bFirstCol = true;
		var tempWidth = 0,
		tempHeight = 0;
		var cloneRemove = null, cloneSort = null,cloneFilter = null, cloneCheckbox = null,bDatepicker = THAT._getColType(objHeaderInfo.nStartCol) === 'datepicker' ? true : false;

		for (var i = objHeaderInfo.nStartRow; i <= objHeaderInfo.nEndRow; i++){
			for (var j = objHeaderInfo.nStartCol; j <= objHeaderInfo.nEndCol; j++){
				var htCell = THAT._getCellDOM(i, j);

				if(!QBOX._.isNull(htCell) && QBOX._.isNull(masterCell)){
					masterCell = htCell;
					orginWidth = htCell.offsetWidth;
					orginHeight = htCell.offsetHeight;
				}
				if(htCell){
					tempWidth += htCell.offsetWidth;
					tempHeight = htCell.offsetHeight;

					if(htCell != masterCell){
						arrCells.push(htCell);
						htCell.style.display = 'none';
						//2018-02-07(sai1515): display:none 스타일이 적용될 경우 focus가 빠지게 되어 keydown 이벤트 동작되지 않는 문제가 있어서 viewportinner에 focus 주는 로직 추가.
						//THAT.attr("elementpool").get('$viewportinner')[0].focus();
					}
				}
				
				if(bHeader && htCell && (i!==objHeaderInfo.nStartRow && i===objHeaderInfo.nEndRow && j===objHeaderInfo.nStartCol )){
					var x=0, child;
					for(x=0; x < htCell.childNodes.length ; x++){
						child = htCell.childNodes[x];
						if(QBOX.$(child).hasClass("rt-qc-sortarea")){// || $(child).hasClass("rt-qc-filterarea")){
							cloneSort = child.cloneNode(true);						
							masterCell.appendChild(cloneSort);
						} 
						else if(QBOX.$(child).hasClass("rt-qc-filterarea")){	
							cloneFilter = child.cloneNode(true);
							masterCell.appendChild(cloneFilter);
							
						}
						else if(QBOX.$(child).hasClass("rt-qc-colheader-checkbox")){	
							cloneCheckbox = child.cloneNode(true);
							masterCell.textContent = "";
							masterCell.appendChild(cloneCheckbox);
							
						}else if(QBOX.$(child).hasClass("rt-qc-removearea")){	
							cloneRemove = child.cloneNode(true);							
							masterCell.appendChild(cloneRemove);							
						}
					}
					
				}
			}
			if(tempWidth)
				masterWidth = tempWidth;
			if(tempHeight)
				masterHeight += tempHeight;

			tempWidth = 0;
		}

		if(masterCell){
			objHeaderInfo.masterCell = masterCell;
			objHeaderInfo.orginWidth = orginWidth;
			objHeaderInfo.orginHeight = orginHeight;
			objHeaderInfo.arCells = arrCells;
			objHeaderInfo.cloneSort = cloneSort;
			
			if(cloneSort || cloneFilter ||cloneCheckbox || cloneRemove){	
				var objQCellCol = THAT._getQCellCol(objHeaderInfo.nStartCol);
				
				if(cloneSort){
					cloneSort.style.top = masterHeight - (masterHeight / 2 + 5) + 'px';
					objHeaderInfo.sortCol = objHeaderInfo.nStartCol;
					objQCellCol.attr('cloneSort_master',QBOX.$(masterCell),'jquery');
					objQCellCol.attr('cloneSort_sort',QBOX.$(cloneSort),'jquery');
					objQCellCol.attr('cloneSort_master_height',masterHeight,'number');					
				}
				if(cloneFilter){
					objQCellCol.attr('colfilterarea',QBOX.$(cloneFilter),'jquery');
					QBOX.$(cloneFilter).on('mousedown', THAT.attr('eventparam'), QBOX.QCELL.BasicQCELL._createFilterAreaSub);
				}
				if(cloneCheckbox){
					objQCellCol.attr('headerelement',masterCell.childNodes[0],'element');
					QBOX.$(objQCellCol.attr('headerelement')).on('click', {target : objQCellCol.attr('colelement')}, QBOX.st.eventProcess);
				}
				if(cloneRemove){
					cloneRemove.style.top = masterHeight - (masterHeight / 2 + 7) + 'px';
								
				}

			}

			masterCell.style.width = masterWidth + 'px';
			masterCell.style.height = masterHeight + 'px';
			
			if(bDatepicker === true && bHeader === false){
				masterCell.children[0].style.height =  masterHeight + 'px';
				masterCell.children[0].children[0].style.height =  masterHeight + 'px';
			}
			
			if(THAT._getColWordwrap(objHeaderInfo.nStartCol)){
				masterCell.style.whiteSpace = 'pre-wrap';
			}else{
				if(bHeader){
					masterCell.style.display = 'flex';
					masterCell.style.justifyContent = 'center';
					masterCell.style.alignItems = 'center';					
				}else{
					masterCell.style.lineHeight = (masterHeight - 2) + 'px';
				}
				
				masterCell.style.whiteSpace = 'nowrap';

			}			
		}
	});
};

QBOX.QCELL.BasicQCELL.prototype._clearMergeHeader = function(){
	var arrHeaderInfo = this.attr('merge_header_info');
	this._clearMergeSub(arrHeaderInfo,true);
};

QBOX.QCELL.BasicQCELL.prototype._clearMergeData = function(){
	var arrMergeInfo = this.attr('merge_data_info');
	this._clearMergeSub(arrMergeInfo,false);
};

QBOX.QCELL.BasicQCELL.prototype._clearMerge = function(){
	this._clearMergeHeader();
	this._clearMergeData();
};

QBOX.QCELL.BasicQCELL.prototype._clearMergeSub = function(arrHeaderInfo,bHeader){

	if(QBOX._.isUndefined(arrHeaderInfo) || QBOX._.isNull(arrHeaderInfo))
		return;
	var THAT = this;

	QBOX._.each(arrHeaderInfo, function(objHeaderInfo){
		var arrCells = objHeaderInfo.arCells;

		if(arrCells){
			for (var i = 0; i < arrCells.length; i++){
				arrCells[i].style.display = '';
			}
			arrCells.RT_clear();
		}
		if(!QBOX._.isUndefined(objHeaderInfo.masterCell) && !QBOX._.isNull(objHeaderInfo.masterCell)){
			objHeaderInfo.masterCell.style.width = objHeaderInfo.orginWidth + 'px';
			objHeaderInfo.masterCell.style.height = objHeaderInfo.orginHeight + 'px';
			
			if(THAT._getColWordwrap(objHeaderInfo.nStartCol)){
				objHeaderInfo.masterCell.style.whiteSpace = 'pre-wrap';
			}else{
				
				if(bHeader){
					objHeaderInfo.masterCell.style.whiteSpace = 'nowrap';	
					objHeaderInfo.masterCell.style.display = 'flex';
					objHeaderInfo.masterCell.style.justifyContent = 'center';
					objHeaderInfo.masterCell.style.alignItems = 'center';					
				}else{
					objHeaderInfo.masterCell.style.lineHeight = (objHeaderInfo.orginHeight - 2) + 'px';
				}

			}			
			
			if(objHeaderInfo.cloneSort){
				//objHeaderInfo.masterCell.removeChild(objHeaderInfo.cloneSort);
				QBOX.$(objHeaderInfo.masterCell).find('.'+QBOX.$(objHeaderInfo.cloneSort).attr("class")).remove();
				
				var objQCellCol = THAT._getQCellCol(objHeaderInfo.sortCol);
				objQCellCol.attr('cloneSort_master',null,'jquery');
				objQCellCol.attr('cloneSort_sort',null,'jquery');			
				
				objHeaderInfo.cloneSort = null;
			}
			objHeaderInfo.masterCell = null;
		}
	});
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellRow = function(nRow, nCol, strArrowKey){

	if(strArrowKey == 'up' || strArrowKey == 'down' || strArrowKey == 'left'){
		return this._findNextCellRowLeft(nRow, nCol);
	} else if(strArrowKey == 'right'){
		return this._findNextCellRowRight(nRow, nCol);
	}
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellRowLeft = function(nRow, nCol){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');
	var bFrozen = false,
	nFrozenCols = this.attr('frozencols');

	if(nFrozenCols){
		if(nCol >= nHeaderCols + nFrozenCols){
			bFrozen = true;
		}
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(startRow < 0){
		return {
			'row': 0 + nHeaderRows,
			'col': nCol
		};
	}

	if(startRow >= nRows){
		return {
			'row': nRows + nHeaderRows,
			'col': nCol
		};
	}

	var strData = arrCurrentData[startRow][this._getKeyOfCol(nCol)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nCol)];
	var nColIndex = nCol - 1;
	var strCompData = '';

	do {
		if(nColIndex < 0){
			return {
				'row': nRow,
				'col': 0 + nHeaderCols
			};
		}

		strCompData = arrCurrentData[startRow][this._getKeyOfCol(nColIndex)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nColIndex)];

		if(strData !== strCompData){
			return {
				'row': nRow,
				'col': nColIndex + 1
			};
		}
		if(nFrozenCols){
			if(bFrozen && nColIndex + nHeaderCols <= nHeaderCols + nFrozenCols){
				return {
					'row': nRow,
					'col': nColIndex + 1
				};
			}
		}

		nColIndex--;

	} while (1);

	return {
		'row': 0 + nHeaderRows,
		'col': 0 + nHeaderCols
	};
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellRowRight = function(nRow, nCol){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');
	var bFrozen = false,
	nFrozenCols = this.attr('frozencols');

	if(nFrozenCols){
		if(nCol < nHeaderCols + nFrozenCols){
			bFrozen = true;
		}
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(startRow < 0){
		return {
			'row': 0 + nHeaderRows,
			'col': nCol
		};
	}

	if(startRow >= nRows){
		return {
			'row': nRows + nHeaderRows,
			'col': nCol
		};
	}

	var strPrevData = '',
	strOriginData = arrCurrentData[startRow][this._getKeyOfCol(nCol)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nCol)];

	if(nCol - 1 >= 0){
		strPrevData = arrCurrentData[startRow][this._getKeyOfCol(nCol - 1)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nCol - 1)];
	} else {
		strPrevData = strOriginData;
	}

	if(strPrevData === strOriginData && nCol != nHeaderCols + nFrozenCols){
		var strCompData = '';
		var i = 0;
		for (i = nCol + 1; i < nCols; i++){
			strCompData = arrCurrentData[startRow][this._getKeyOfCol(i)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(i)];
			if(strCompData !== strOriginData){
				return {
					'row': nRow,
					'col': i
				};
			}
			if(nFrozenCols){
				if(bFrozen && i + nHeaderCols >= nHeaderCols + nFrozenCols){
					return {
						'row': nRow,
						'col': i
					};
				}
			}
		}
		for (i = nCol - 1; i >= 0; i--){
			strCompData = arrCurrentData[startRow][this._getKeyOfCol(i)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(i)];

			if(strCompData !== strOriginData){
				return {
					'row': nRow,
					'col': i + 1
				};
			}
			if(nFrozenCols){
				if(bFrozen && i + nHeaderCols >= nHeaderCols + nFrozenCols){
					return {
						'row': nRow,
						'col': nHeaderCols + nFrozenCols
					};
				}
			}
		}
		return {
			'row': nRow,
			'col': nHeaderCols
		};
	}
	return {
		'row': nRow,
		'col': nCol
	};
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellCol = function(nRow, nCol, strArrowKey){

	if(this._getColDataMergeCol(nCol) === false)
		return {
			'row': nRow,
			'col': nCol
		};
		
	if(strArrowKey == 'up' || strArrowKey == 'right' || strArrowKey == 'left'){
		return this._findNextCellColUp(nRow, nCol);
	} else if(strArrowKey == 'down'){
		return this._findNextCellColDown(nRow, nCol);
	}
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellColUp = function(nRow, nCol){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');
	var bFrozen = false,
	bFrozenBottom = false,
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows');
	
	if(nFrozenRows){
		if(nRow >= nHeaderRows + nFrozenRows){
			bFrozen = true;
		}
	}
	if(nFrozenBottomRows){
		if(nRow >= nHeaderRows + nRows - nFrozenBottomRows){
			bFrozenBottom = true;
		}
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(startRow < 0){
		return {
			'row': 0 + nHeaderRows,
			'col': nCol
		};
	}

	if(startRow >= nRows){
		return {
			'row': nRows + nHeaderRows,
			'col': nCol
		};
	}
	var strKey = this._getKeyOfCol(nCol);
	var strData = arrCurrentData[startRow][strKey] === undefined ? '' : arrCurrentData[startRow][strKey];
	var nRowIndex = startRow - 1;
	var strCompData = '';

	do {
		if(nRowIndex < 0){
			return {
				'row': nHeaderRows,
				'col': nCol
			};
		}

		strCompData = arrCurrentData[nRowIndex][strKey] === undefined ? '' : arrCurrentData[nRowIndex][strKey];

		if(strData !== strCompData){
			return {
				'row': nRowIndex + 1 + nHeaderRows,
				'col': nCol
			};
		}
		if(nFrozenRows){
			if(bFrozen && nRowIndex + nHeaderRows < nHeaderRows + nFrozenRows){
				return {
					'row': nRowIndex + nHeaderRows + 1,
					'col': nCol
				};
			}
		}

		if(nFrozenBottomRows){
			if(bFrozenBottom && nRowIndex + nHeaderRows < nHeaderRows + nRows - nFrozenBottomRows){
				return {
					'row': nRowIndex + nHeaderRows + 1,
					'col': nCol
				};
			}
		}

		nRowIndex--;

	} while (1);

	return {
		'row': nRow,
		'col': nCol
	};
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellColDown = function(nRow, nCol){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');
	
	var bFrozen = false,
	bFrozenBottom = false,
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows');

	if(nFrozenRows){
		if(nRow < nHeaderRows + nFrozenRows){
			bFrozen = true;
		}
	}
	if(nFrozenBottomRows){
		if(nRow < nHeaderRows + nRows - nFrozenBottomRows){
			bFrozenBottom = true;
		}
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(startRow < 0){
		return {
			'row': 0 + nHeaderRows,
			'col': nCol
		};
	}

	if(startRow >= nRows){
		return {
			'row': nRows + nHeaderRows,
			'col': nCol
		};
	}
	var strKey = this._getKeyOfCol(nCol);
	var strPrevData = '',
	strOriginData = arrCurrentData[startRow][strKey] === undefined ? '' : arrCurrentData[startRow][strKey];

	if(startRow - 1 >= 0){
		strPrevData = arrCurrentData[startRow - 1][strKey] === undefined ? '' : arrCurrentData[startRow - 1][strKey];
	} else {
		strPrevData = strOriginData;
	}

	if(strPrevData === strOriginData && nRow != nHeaderRows + nFrozenRows){
		var strCompData = '';
		var i = 0;

		for (i = startRow + 1; i < nRows; i++){
			strCompData = arrCurrentData[i][strKey] === undefined ? '' : arrCurrentData[i][strKey];
			if(strCompData !== strOriginData){
				return {
					'row': i + nHeaderRows,
					'col': nCol
				};
			}
			if(nFrozenRows){
				if(bFrozen && i + nHeaderRows >= nHeaderRows + nFrozenRows){
					return {
						'row': i + nHeaderRows,
						'col': nCol
					};
				}
			}
			if(nFrozenBottomRows){
				if(bFrozenBottom && i + nHeaderRows >= nHeaderRows + nRows - nFrozenBottomRows){
					return {
						'row': i + nHeaderRows,
						'col': nCol
					};
				}
			}
		}

		if(i == nRows){
			return this._findNextCellCol(nRow, nCol, 'up');
		}

		return {
			'row': nRow - 1,
			'col': nCol
		};
	}

	return {
		'row': nRow,
		'col': nCol
	};
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellRowAndCol = function(nRow, nCol, strArrowKey){

	if(strArrowKey == 'up' || strArrowKey == 'down' || strArrowKey == 'left'){
		return this._findNextCellRowAndColLeft(nRow, nCol, strArrowKey);
	} else if(strArrowKey == 'right'){
		return this._findNextCellRowAndColRight(nRow, nCol);
	}
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellRowAndColUpAndDown = function(nStartRow, nStartCol, nRow, nCol, strArrowKey){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');
	var bFrozenRows = false,
	bFrozenBottom = false,
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows');
	var startRow = nStartRow - nHeaderRows;

	if(nFrozenRows){
		if(nRow >= nHeaderRows + nFrozenRows){
			bFrozenRows = true;
		}
	}
	if(nFrozenBottomRows){
		if(nRow >= nHeaderRows + nRows - nFrozenBottomRows){
			bFrozenBottom = true;
		}
	}

	var strData = arrCurrentData[startRow][this._getKeyOfCol(nStartCol)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nStartCol)];
	var i = 0;
	var nRowIndex = 0;
	var strCompData = '';
	if(strArrowKey == 'down'){
		var strPrevData = '';
		var strKey = this._getKeyOfCol(nStartCol);
		if(startRow - 1 >= 0){
			strPrevData = arrCurrentData[startRow - 1][strKey] === undefined ? '' : arrCurrentData[startRow - 1][strKey];
		} else {
			strPrevData = strData;
		}

		if(strPrevData === strData && nRow != nHeaderRows + nFrozenRows){
			strCompData = '';
			for (i = startRow + 1; i < nRows; i++){
				strCompData = arrCurrentData[i][strKey] === undefined ? '' : arrCurrentData[i][strKey];
				if(strCompData !== strData){
					return {
						'row': i + nHeaderRows,
						'col': nStartCol
					};
				}
				if(nFrozenRows){
					if(!bFrozenRows && i + nHeaderRows >= nHeaderRows + nFrozenRows){
						return {
							'row': i + nHeaderRows,
							'col': nStartCol
						};
					}
				}
				if(nFrozenBottomRows){
					if(!bFrozenBottom && i + nHeaderRows >= nHeaderRows + nRows - nFrozenBottomRows){
						return {
							'row': i + nHeaderRows,
							'col': nStartCol
						};
					}
				}
			}
			if(i == nRows){
				return this._findNextCellRowAndCol(nRow, nCol, 'up');
			}
			return {
				'row': nRow - 1,
				'col': nStartCol
			};
		}
		return {
			'row': nStartRow,
			'col': nStartCol
		};

	} else {
		for (i = startRow - 1; i >= 0; i--){
			var j = 0;
			strCompData = '';

			if(nFrozenRows){
				if(bFrozenRows && i + nHeaderRows < nHeaderRows + nFrozenRows){
					return {
						'row': nHeaderRows + nFrozenRows,
						'col': nStartCol
					};
				}
			}

			if(nFrozenBottomRows){
				if(bFrozenBottom && i + nHeaderRows < nHeaderRows + nRows - nFrozenBottomRows){
					return {
						'row': nHeaderRows + nRows - nFrozenBottomRows,
						'col': nStartCol
					};
				}
			}

			for (j = nStartCol; j <= nCol; j++){
				strCompData = arrCurrentData[i][this._getKeyOfCol(j)] === undefined ? '' : arrCurrentData[i][this._getKeyOfCol(j)];
				if(strData !== strCompData){
					return {
						'row': nStartRow - nRowIndex,
						'col': nStartCol
					};
				}
			}
			nRowIndex++;
		}
	}

	return {
		'row': nHeaderRows,
		'col': nStartCol
	};
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellRowAndColLeft = function(nRow, nCol, strArrowKey){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');
	var bFrozen = false,
	nFrozenCols = this.attr('frozencols');

	if(nFrozenCols){
		if(nCol >= nHeaderCols + nFrozenCols){
			bFrozen = true;
		}
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(startRow < 0){
		return {
			'row': 0 + nHeaderRows,
			'col': nCol
		};
	}

	if(startRow >= nRows){
		return {
			'row': nRows + nHeaderRows,
			'col': nCol
		};
	}

	var strData = arrCurrentData[startRow][this._getKeyOfCol(nCol)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nCol)];
	var nColIndex = nCol - 1;
	var strCompData = '';

	do {
		if(nColIndex < 0){
			return this._findNextCellRowAndColUpAndDown(nRow, 0 + nHeaderCols, nRow, nCol, strArrowKey);
		}

		strCompData = arrCurrentData[startRow][this._getKeyOfCol(nColIndex)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nColIndex)];

		if(strData !== strCompData){
			return this._findNextCellRowAndColUpAndDown(nRow, nColIndex + 1, nRow, nCol, strArrowKey);
		}
		if(nFrozenCols){
			if(bFrozen && nColIndex + nHeaderCols <= nHeaderCols + nFrozenCols){
				return this._findNextCellRowAndColUpAndDown(nRow, nColIndex + 1, nRow, nCol, strArrowKey);
			}
		}

		nColIndex--;

	} while (1);

	return {
		'row': 0 + nHeaderRows,
		'col': 0 + nHeaderCols
	};
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellRowAndColRight = function(nRow, nCol, strArrowKey){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');
	var bFrozen = false,
	nFrozenCols = this.attr('frozencols');

	if(nFrozenCols){
		if(nCol < nHeaderCols + nFrozenCols)
			bFrozen = true;
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(startRow < 0){
		return {
			'row': 0 + nHeaderRows,
			'col': nCol
		};
	}

	if(startRow >= nRows){
		return {
			'row': nRows + nHeaderRows,
			'col': nCol
		};
	}

	var strPrevData = '',
	strOriginData = arrCurrentData[startRow][this._getKeyOfCol(nCol)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nCol)];

	if(nCol - 1 >= 0){
		strPrevData = arrCurrentData[startRow][this._getKeyOfCol(nCol - 1)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nCol - 1)];
	} else {
		strPrevData = strOriginData;
	}

	if(strPrevData === strOriginData && nCol != nHeaderCols + nFrozenCols){
		var strCompData = '';
		var i = 0;
		for (i = nCol + 1; i < nCols; i++){
			strCompData = arrCurrentData[startRow][this._getKeyOfCol(i)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(i)];
			if(strCompData !== strOriginData){
				return this._findNextCellRowAndColUpAndDown(nRow, i, nRow, i, strArrowKey);
			}
			if(nFrozenCols){
				if(bFrozen && i + nHeaderCols >= nHeaderCols + nFrozenCols){
					return this._findNextCellRowAndColUpAndDown(nRow, i, nRow, i, strArrowKey);
				}
			}
		}
		for (i = nCol - 1; i >= 0; i--){
			strCompData = arrCurrentData[startRow][this._getKeyOfCol(i)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(i)];

			if(strCompData !== strOriginData){
				return this._findNextCellRowAndColUpAndDown(nRow, i + 1, nRow, i + 1, strArrowKey);
			}
			if(nFrozenCols){
				if(bFrozen && i + nHeaderCols >= nHeaderCols + nFrozenCols){
					return this._findNextCellRowAndColUpAndDown(nRow, nHeaderCols + nFrozenCols, nRow, nHeaderCols + nFrozenCols, strArrowKey);
				}
			}
		}
		return this._findNextCellRowAndColUpAndDown(nRow, nHeaderCols, nRow, nHeaderCols, strArrowKey);
	}
	return this._findNextCellRowAndColUpAndDown(nRow, nCol, nRow, nCol, strArrowKey);
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellColAndRow = function(nRow, nCol, strArrowKey){

	if(strArrowKey == 'up' || strArrowKey == 'right' || strArrowKey == 'left'){
		return this._findNextCellColAndRowUp(nRow, nCol, strArrowKey);
	} else if(strArrowKey == 'down'){
		return this._findNextCellColAndRowDown(nRow, nCol, strArrowKey);
	}
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellColAndRowLeftAndRight = function(nStartRow, nStartCol, nRow, nCol, strArrowKey){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nStartRow - nHeaderRows,
	endRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');
	var bFrozen = false,
	nFrozenCols = this.attr('frozencols');

	if(nFrozenCols){
		if(nCol >= nHeaderCols + nFrozenCols){
			bFrozen = true;
		}
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(startRow < 0){
		return {
			'row': 0 + nHeaderRows,
			'col': nCol
		};
	}

	if(startRow >= nRows){
		return {
			'row': nRows + nHeaderRows,
			'col': nCol
		};
	}

	var strData = arrCurrentData[startRow][this._getKeyOfCol(nCol)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nCol)];
	var nColIndex = nCol - 1;
	var strCompData = '';
	var strKey = '';
	var i = 0;

	if(strArrowKey == 'right'){
		var strPrevData = '',
		strOriginData = arrCurrentData[startRow][this._getKeyOfCol(nCol)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nCol)];

		if(nCol - 1 >= 0){
			strPrevData = arrCurrentData[startRow][this._getKeyOfCol(nCol - 1)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(nCol - 1)];
		} else {
			strPrevData = strOriginData;
		}

		if(strPrevData === strOriginData && nCol != nHeaderCols + nFrozenCols){
			strCompData = '';

			for (i = nCol + 1; i < nCols; i++){
				strCompData = arrCurrentData[startRow][this._getKeyOfCol(i)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(i)];
				if(strCompData !== strOriginData){
					return this._findNextCellColAndRowUp(nStartRow, i, 'up');
				}
				if(nFrozenCols){
					if(!bFrozen && i + nHeaderCols >= nHeaderCols + nFrozenCols){
						return {
							'row': nStartRow,
							'col': i
						};
					}
				}
			}
			for (i = nCol - 1; i >= 0; i--){
				strCompData = arrCurrentData[startRow][this._getKeyOfCol(i)] === undefined ? '' : arrCurrentData[startRow][this._getKeyOfCol(i)];

				if(strCompData !== strOriginData){
					return {
						'row': nStartRow,
						'col': i + 1
					};
				}
				if(nFrozenCols){
					if(!bFrozen && i + nHeaderCols >= nHeaderCols + nFrozenCols){
						return {
							'row': nStartRow,
							'col': nHeaderCols + nFrozenCols
						};
					}
				}
			}
			return {
				'row': nStartRow,
				'col': nHeaderCols
			};
		}
		return {
			'row': nStartRow,
			'col': nCol
		};

	} else {
		do {
			if(nColIndex < 0){
				return {
					'row': nStartRow,
					'col': 0 + nHeaderCols
				};
			}
			strKey = this._getKeyOfCol(nColIndex);
			for (i = startRow; i <= endRow; i++){
				strCompData = arrCurrentData[i][strKey] === undefined ? '' : arrCurrentData[i][strKey];
				if(strData !== strCompData){
					return {
						'row': nStartRow,
						'col': nColIndex + 1
					};
				}
			}
			if(nFrozenCols){
				if(bFrozen && nColIndex + nHeaderCols <= nHeaderCols + nFrozenCols){
					return {
						'row': nStartRow,
						'col': nColIndex + 1
					};
				}
			}

			nColIndex--;

		} while (1);

	}

	return {
		'row': 0 + nHeaderRows,
		'col': 0 + nHeaderCols
	};
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellColAndRowUp = function(nRow, nCol, strArrowKey){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');
	var bFrozen = false,
	bFrozenBottom = false,
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows');

	if(nFrozenRows){
		if(nRow >= nHeaderRows + nFrozenRows){
			bFrozen = true;
		}
	}
	if(nFrozenBottomRows){
		if(nRow >= nHeaderRows + nRows - nFrozenBottomRows){
			bFrozenBottom = true;
		}
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(startRow < 0){
		return {
			'row': 0 + nHeaderRows,
			'col': nCol
		};
	}

	if(startRow >= nRows){
		return {
			'row': nRows + nHeaderRows,
			'col': nCol
		};
	}
	var strKey = this._getKeyOfCol(nCol);
	var strData = arrCurrentData[startRow][strKey] === undefined ? '' : arrCurrentData[startRow][strKey];
	var nRowIndex = startRow - 1;
	var strCompData = '';

	do {
		if(nRowIndex < 0){
			return this._findNextCellColAndRowLeftAndRight(nHeaderRows, nCol, nRow, nCol, strArrowKey);
		}

		strCompData = arrCurrentData[nRowIndex][strKey] === undefined ? '' : arrCurrentData[nRowIndex][strKey];

		if(strData !== strCompData){
			return this._findNextCellColAndRowLeftAndRight(nRowIndex + 1 + nHeaderRows, nCol, nRow, nCol, strArrowKey);
		}
		if(nFrozenRows){
			if(bFrozen && nRowIndex + nHeaderRows < nHeaderRows + nFrozenRows){
				return this._findNextCellColAndRowLeftAndRight(nRowIndex + 1 + nHeaderRows, nCol, nRow, nCol, strArrowKey);
			}
		}

		if(nFrozenBottomRows){
			if(bFrozenBottom && nRowIndex + nHeaderRows < nHeaderRows + nRows - nFrozenBottomRows){
				return this._findNextCellColAndRowLeftAndRight(nRowIndex + 1 + nHeaderRows, nCol, nRow, nCol, strArrowKey);
			}
		}

		nRowIndex--;

	} while (1);

	return {
		'row': nRow,
		'col': nCol
	};
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellColAndRowDown = function(nRow, nCol, strArrowKey){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');

	var bFrozen = false,
	bFrozenBottom = false,
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows');

	if(nFrozenRows){
		if(nRow < nHeaderRows + nFrozenRows){
			bFrozen = true;
		}
	}
	if(nFrozenBottomRows){
		if(nRow < nHeaderRows + nRows - nFrozenBottomRows){
			bFrozenBottom = true;
		}
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(startRow < 0){
		return {
			'row': 0 + nHeaderRows,
			'col': nCol
		};
	}

	if(startRow >= nRows){
		return {
			'row': nRows + nHeaderRows,
			'col': nCol
		};
	}
	var strKey = this._getKeyOfCol(nCol);
	var strPrevData = '',
	strOriginData = arrCurrentData[startRow][strKey] === undefined ? '' : arrCurrentData[startRow][strKey];

	if(startRow - 1 >= 0){
		strPrevData = arrCurrentData[startRow - 1][strKey] === undefined ? '' : arrCurrentData[startRow - 1][strKey];
	} else {
		strPrevData = strOriginData;
	}

	if(strPrevData === strOriginData && nRow != nHeaderRows + nFrozenRows){
		var strCompData = '';
		var i = 0;

		for (i = startRow + 1; i < nRows; i++){
			strCompData = arrCurrentData[i][strKey] === undefined ? '' : arrCurrentData[i][strKey];
			if(strCompData !== strOriginData){
				return this._findNextCellColAndRowLeftAndRight(i + nHeaderRows, nCol, i + nHeaderRows, nCol, strArrowKey);
			}
			if(nFrozenRows){
				if(bFrozen && i + nHeaderRows >= nHeaderRows + nFrozenRows){
					return this._findNextCellColAndRowLeftAndRight(i + nHeaderRows, nCol, i + nHeaderRows, nCol, strArrowKey);
				}
			}
			if(nFrozenBottomRows){
				if(bFrozenBottom && i + nHeaderRows >= nHeaderRows + nRows - nFrozenBottomRows){
					return this._findNextCellColAndRowLeftAndRight(i + nHeaderRows, nCol, i + nHeaderRows, nCol, strArrowKey);
				}
			}
		}
		if(i == nRows){
			return this._findNextCellColAndRow(nRow, nCol, 'up');
		}
		return this._findNextCellColAndRowLeftAndRight(nRow - 1, nCol, nRow - 1, nCol, strArrowKey);
	}
	return this._findNextCellColAndRowLeftAndRight(nRow, nCol, nRow, nCol, strArrowKey);
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellGroup = function(nRow, nCol, strArrowKey){
	
	if(this._getColDataMergeCol(nCol) === false)
		return {
			'row': nRow,
			'col': nCol
		};
		
	if(strArrowKey == 'up' || strArrowKey == 'left' || strArrowKey == 'right'){
		return this._findNextCellGroupUp(nRow, nCol, strArrowKey);
	} else {
		return this._findNextCellGroupDown(nRow, nCol);
	}
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellGroupUp = function(nRow, nCol, strArrowKey){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols,
	nRows = arrCurrentData.length + nHeaderRows,
	nCols = this.attr('cols'),
	bFrozen = false,
	bFrozenBottom = false,
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows'),
	nStartRow = nHeaderRows,
	nEndRow = nRow;

	if(nFrozenRows){
		if(nRow >= nHeaderRows + nFrozenRows){
			bFrozen = true;
		}
	}
	if(nFrozenBottomRows){
		if(nRow >= nRows - nFrozenBottomRows){
			bFrozenBottom = true;
		}
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(nFrozenRows && bFrozen){
		nStartRow = nHeaderRows + nFrozenRows;
	} else if(nFrozenRows && !bFrozen){
		nStartRow = nHeaderRows;
	}

	if(nFrozenBottomRows && bFrozenBottom){
		nStartRow = nRows - nFrozenBottomRows;
	}

	return this._findNextCellGroupUpSub(nRow, nCol, nStartRow, nHeaderCols);
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellGroupUpSub = function(nRow, nCol, nStartRow, nStartCol){

	if(nStartRow == nRow){
		return {
			'row': nRow,
			'col': nCol
		};
	}
	if(nStartCol > nCol){
		return {
			'row': nStartRow,
			'col': nCol
		};
	}

	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length,
	nCols = this.attr('cols');

	if(nStartCol > nCols){
		return {
			'row': nStartRow,
			'col': nCol
		};
	}

	var strKey = this._getKeyOfCol(nStartCol);
	var strOrginData = arrCurrentData[startRow][strKey] === undefined ? '' : arrCurrentData[startRow][strKey];
	var strCompData = '';

	for (var i = nRow - 1; i >= nStartRow; i--){
		strCompData = arrCurrentData[i - nHeaderRows][strKey] === undefined ? '' : arrCurrentData[i - nHeaderRows][strKey];

		if(strOrginData !== strCompData){
			return this._findNextCellGroupUpSub(nRow, nCol, i + 1, ++nStartCol);
		}

	}

	return this._findNextCellGroupUpSub(nRow, nCol, nStartRow, ++nStartCol);
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellGroupDown = function(nRow, nCol, strArrowKey){
	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols'),
	startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols,
	nRows = arrCurrentData.length + nHeaderRows,
	nCols = this.attr('cols'),
	bFrozen = false,
	bFrozenBottom = false,
	nFrozenRows = this.attr('frozenrows'),
	nFrozenBottomRows = this.attr('frozenbottomrows'),
	nStartRow = nRow,
	nEndRow = nRows;

	if(nFrozenRows){
		if(nRow >= nHeaderRows + nFrozenRows){
			bFrozen = true;
		}
	}
	if(nFrozenBottomRows){
		if(nRow >= nRows - nFrozenBottomRows){
			bFrozenBottom = true;
		}
	}

	if(nRow == nHeaderRows){
		return {
			'row': nRow,
			'col': nCol
		};
	} else if(nRow == nHeaderRows + nFrozenRows){
		return {
			'row': nRow,
			'col': nCol
		};
	} else if(nRow == nRows - nFrozenBottomRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(!nRows){
		return {
			'row': nRow,
			'col': nCol
		};
	}

	if(nFrozenBottomRows && !bFrozenBottom){
		nEndRow = nRows - nFrozenBottomRows;
	}

	if(nFrozenRows && !bFrozen){
		nEndRow = nHeaderRows + nFrozenRows;
	}

	return this._findNextCellGroupDownSub(nRow, nCol, nEndRow, nHeaderCols);
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellGroupDownSub = function(nRow, nCol, nEndRow, nStartCol){

	if(nEndRow == nRow){
		return {
			'row': nRow,
			'col': nCol
		};
	}
	if(nStartCol > nCol){
		return {
			'row': nEndRow,
			'col': nCol
		};
	}

	var arrCurrentData = this.attr('currentdata'),
	nHeaderRows = this.attr('headerrows'),
	nHeaderCols = this.attr('headercols');
	var startRow = nRow - nHeaderRows,
	startCol = nCol - nHeaderCols;
	var nRows = arrCurrentData.length + nHeaderRows,
	nCols = this.attr('cols');

	if(nStartCol > nCols){
		return {
			'row': nStartRow,
			'col': nCol
		};
	}

	var strKey = this._getKeyOfCol(nStartCol);
	var strOrginData = arrCurrentData[startRow][strKey] === undefined ? '' : arrCurrentData[startRow][strKey];
	var strPrevData = arrCurrentData[startRow - 1][strKey] === undefined ? '' : arrCurrentData[startRow - 1][strKey];
	var strCompData = '';

	if(strPrevData === strOrginData){
		var i = 0;
		for (i = nRow + 1; i < nEndRow; i++){
			strCompData = arrCurrentData[i - nHeaderRows][strKey] === undefined ? '' : arrCurrentData[i - nHeaderRows][strKey];
			if(strOrginData !== strCompData){
				return this._findNextCellGroupDownSub(nRow, nCol, i, ++nStartCol);
			}
		}
		if(nStartCol == nCol && i == nRows){
			return this._findNextCellGroupUp(nRow, nCol, 'up');
		} else {
			return this._findNextCellGroupDownSub(nRow, nCol, nEndRow, ++nStartCol);
		}
	} else {
		return this._findNextCellGroupDownSub(nRow, nCol, nRow, ++nStartCol);
	}
};

QBOX.QCELL.BasicQCELL.prototype._findNextCell = function(nRow, nCol, strArrowKey){
	var objMergeType = this.attr("merge");
	if(objMergeType.data == 'none'){
		return {
			'row': nRow,
			'col': nCol
		};
	}
	var strType = objMergeType.data;
	if(strType === 'row'){
		return this._findNextCellRow(nRow, nCol, strArrowKey);
	} else if(strType === 'col'){
		return this._findNextCellCol(nRow, nCol, strArrowKey);
	} else if(strType === 'rowandcol'){
		return this._findNextCellRowAndCol(nRow, nCol, strArrowKey);
	} else if(strType === 'colandrow'){
		return this._findNextCellColAndRow(nRow, nCol, strArrowKey);
	} else if(strType == 'group'){
		return this._findNextCellGroup(nRow, nCol, strArrowKey);
	} else if(strType === 'groupandrow'){
		return this._findNextCellGroupAndRow(nRow, nCol, strArrowKey);
	}

	return {
		'row': nRow,
		'col': nCol
	};
};

QBOX.QCELL.BasicQCELL.prototype._mergeGroupAndRow = function(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol){
	this._mergeGroupAndRowSub(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol, arrText.length, nStartCol);
};

QBOX.QCELL.BasicQCELL.prototype._mergeGroupAndRowSub = function(nStartRow, nStartCol, arrInfo, arrText, nTopRow, nLeftCol, nEndRow, nDif){
	var nCols = arrText.length ? arrText[0].length : 0;

	if(nStartCol == nCols)
		return;
	
	if(arrText.length === 0)
		return;
	if(!this._getColDataMergeCol(nStartCol))
		return;
	
	var i = nStartRow,x,
	nHeader = this.attr('headercols') > 0 ? 0 : 1;
	var strCompText = arrText[nStartRow][nStartCol] === undefined ? '' : arrText[nStartRow][nStartCol];
	var nIndex = 0;
	var objMergeData = null;
	for (i = nStartRow + 1; i < nEndRow; i++){
		var arrRowText = arrText[i];
		if(strCompText !== arrRowText[nStartCol]){
			if(nIndex){
				objMergeData = this._makeMergeInfo(i + nTopRow - ++nIndex, nStartCol + nLeftCol - nDif, i + nTopRow - 1, nStartCol + nLeftCol - nDif, strCompText);
				nIndex = 0;
				arrInfo.push(objMergeData);
				this._mergeGroupAndRowSub(objMergeData.nStartRow - nTopRow, nStartCol + 1, arrInfo, arrText, nTopRow, nLeftCol, i, nDif);
			}else{
				for(x = nStartCol +1 ; x<nCols; x++){
					if(strCompText !== arrText[i-1][x]){
						objMergeData = this._makeMergeInfo(i + nTopRow-1, nStartCol + nLeftCol - nDif, i + nTopRow -1, x - nDif - nHeader, strCompText);
						if(objMergeData.nStartCol === objMergeData.nEndCol)
							break;
						
						arrInfo.push(objMergeData);
						
						break;
					}
					if( x+1 === nCols){
						objMergeData = this._makeMergeInfo(i + nTopRow-1, nStartCol + nLeftCol - nDif, i + nTopRow -1, x - nDif -nHeader, strCompText);
						if(objMergeData.nStartCol === objMergeData.nEndCol)
							break;
						
						arrInfo.push(objMergeData);
					}
				}
			}
			strCompText = arrRowText[nStartCol];
		} else {
			nIndex++;
		}
	}
	if(nIndex){
		objMergeData = this._makeMergeInfo(i + nTopRow - ++nIndex, nStartCol + nLeftCol - nDif, i + nTopRow - 1, nStartCol + nLeftCol - nDif, strCompText);
		nIndex = 0;
		arrInfo.push(objMergeData);
		this._mergeGroupAndRowSub(objMergeData.nStartRow - nTopRow, nStartCol + 1, arrInfo, arrText, nTopRow, nLeftCol, i, nDif);
	}else{

		for(x = nStartCol +1 ; x<nCols; x++){
			if(strCompText !== arrText[i-1][x]){
				objMergeData = this._makeMergeInfo(i+ nTopRow-1, nStartCol + nLeftCol - nDif, i+ nTopRow-1 , x - nDif-nHeader, strCompText);
				if(objMergeData.nStartCol === objMergeData.nEndCol)
					break;
				
				arrInfo.push(objMergeData);
				
				break;
			}
			if( x+1 === nCols){
				objMergeData = this._makeMergeInfo(i+ nTopRow-1, nStartCol + nLeftCol - nDif, i+ nTopRow-1 , x - nDif-nHeader, strCompText);
				if(objMergeData.nStartCol === objMergeData.nEndCol)
					break;
						
				arrInfo.push(objMergeData);
			}
		}		
	}
};

QBOX.QCELL.BasicQCELL.prototype._findNextCellGroupAndRow = function(nRow, nCol, strArrowKey){
	if(this._getColDataMergeCol(nCol) === false)
		return {
			'row': nRow,
			'col': nCol
		};
		
	var arrMergeInfo = this.attr('merge_data_info'),objMergeInfo;
	
	for(var i=0; i < arrMergeInfo.length ; i++){
		objMergeInfo = arrMergeInfo[i];
		if((objMergeInfo.nStartRow <= nRow && nRow <= objMergeInfo.nEndRow) && (objMergeInfo.nStartCol <= nCol && nCol <= objMergeInfo.nEndCol) ){
			if(strArrowKey === 'down'){
				if(objMergeInfo.nEndRow +1 === this.getRows()){
					return {
					'row': objMergeInfo.nStartRow,
					'col': objMergeInfo.nStartCol
				};	
				}
				
				if(nRow === objMergeInfo.nStartRow && nCol ===objMergeInfo.nStartCol){
					return {
						'row': objMergeInfo.nStartRow,
						'col': objMergeInfo.nStartCol
					};
				}
				if(objMergeInfo.nStartRow ===objMergeInfo.nEndRow){
					return {
						'row': objMergeInfo.nStartRow,
						'col': objMergeInfo.nStartCol
					};
				}
				return {
				'row': objMergeInfo.nEndRow +1,
				'col': objMergeInfo.nStartCol
				};
			}else if(strArrowKey === 'right'){
				if(nRow === objMergeInfo.nStartRow && nCol ===objMergeInfo.nStartCol){
					return {
						'row': objMergeInfo.nStartRow,
						'col': objMergeInfo.nStartCol
					};
				}
				return {
				'row': objMergeInfo.nStartRow ,
				'col': objMergeInfo.nEndCol +1
				};				
				
			
			}else{
				return {
					'row': objMergeInfo.nStartRow,
					'col': objMergeInfo.nStartCol
				};				
			}		
		}
	}
	return {
			'row': nRow,
			'col': nCol
		};
};

QBOX.QCELL.BasicQCELL.prototype._afterPaginationNext = function(){
	var objQCell = this,
	objPaginationInfo = this.attr('paginationinfo'),
	fnBeforeSend = objPaginationInfo.beforeSendCallback,
	fnSendFail	=	objPaginationInfo.sendFailCallback,
	fnSendDone	=	objPaginationInfo.sendDoneCallback,
	fnSendAlways = objPaginationInfo.sendAlwaysCallback,
	fnParsingError = objPaginationInfo.parsingErrorCallback,	
	bUseProgress = objPaginationInfo.useProgress === undefined ? false :objPaginationInfo.useProgress, 
	data = (objPaginationInfo.currentData !== undefined && QBOX._.isArray(objPaginationInfo.currentData) && objPaginationInfo.currentData.length>0)? objPaginationInfo.currentData : QBOX._.clone(this.attr('data').input);
	
	
	objPaginationInfo.lastindex = Math.ceil( objPaginationInfo.datacount / objPaginationInfo.pageunit );
	
	if(objPaginationInfo.mode === 'simple') { // mode 'simple' 일 때
		// 버튼 활성화에 대한 처리 - 현재 페이지가 마지막 페이지 이전일 때
		if(objPaginationInfo.pageindex < objPaginationInfo.lastindex){ // next, last 버튼 활성화
			objPaginationInfo.nextpage = true;
			objPaginationInfo.lastpage = true;
		}
		
		// 버튼 활성화에 대한 처리 - 현재 페이지가 첫 페이지 이후일 때
		if(objPaginationInfo.pageindex > objPaginationInfo.firstindex){ // prev, first 버튼 활성화
			objPaginationInfo.prevpage = true;
			objPaginationInfo.firstpage = true;
		}
	} else { // mode 'extend' 일 때
		// 페이지 정보를 표출할 (pagecount 단위당) 갯수 snum = 시작 페이지 번호 묶음 값, lnum = 마지막 페이지 번호 묶음 값  
		var snum = Math.ceil(objPaginationInfo.pageindex / objPaginationInfo.pagecount),
		lnum = Math.ceil(objPaginationInfo.lastindex / objPaginationInfo.pagecount);
		
		//console.log('snum:'+snum + ', lnum:'+lnum);
		
		if(snum < lnum && objPaginationInfo.pageindex !== objPaginationInfo.lastindex) { // 시작번호가 마지막 번호보다 작을 때 
			objPaginationInfo.nextpage = true; // next 버튼 활성화
		}
		
		if(snum > 1) { // 현재 페이지 번호가 1보다 클 때
			objPaginationInfo.prevpage = true; // prev 버튼 활성화
		}
		
		if(objPaginationInfo.pageindex < objPaginationInfo.lastindex) { // 현재 페이지 번호가 마지막 페이지 번호보다 작을 때
			objPaginationInfo.lastpage = true; // last 버튼 활성화
		}
		
		if(objPaginationInfo.pageindex > 1) { // 현재 페이지 번호가 1보다 크면
			objPaginationInfo.firstpage = true; // first 버튼 활성화
		}
	}
	
	// 데이터가 존재하지 않을 시 UI에 표시 방법 설정
	if(objPaginationInfo.result.length === 0){
		objPaginationInfo.pageindex = 0;
		objPaginationInfo.firstindex = 0;
		
		// pagination 데이터를 담아두는 result에 데이터가 없으면 페이지정보와 전체 데이터 정보 0으로 초기화
		objPaginationInfo.datacount = 0;
		objPaginationInfo.lastindex = 0;
		
		// next, last 버튼 비활성화
		objPaginationInfo.nextpage = false;
		objPaginationInfo.lastpage = false;
	} else {
		objPaginationInfo.firstindex = 1;
	}
	
	if(this.attr('_afterpagination') === 'create'){
		var hePaginationPanel = this.attr('_afterpagination_hep') , heDiv = this.attr('_afterpagination_div');
		
		hePaginationPanel.appendChild(this._createPaginationInner(heDiv));
		
		this._updateCurrentData(QBOX._.clone(objPaginationInfo.result));
		
		// pagination을 통해 current data를 셋팅 한 이후 rowheaderdata를 초기화 한다.                                     
		this._initRowheaderData();		
	}else if(this.attr('_afterpagination') === 'movepage'){
		this._updatePagination(); // pagination UI 업데이트
		
		this._trigger('aftermovepage'); // 'aftermovepage' 페이지 정보가 변경되었을 때의 이벤트 발생
	}
};
QBOX.QCELL.BasicQCELL.prototype._afterPagination = function(){
	var objQCell = this,
	objPaginationInfo = this.attr('paginationinfo'),
	fnBeforeSend = objPaginationInfo.beforeSendCallback,
	fnSendFail	=	objPaginationInfo.sendFailCallback,
	fnSendDone	=	objPaginationInfo.sendDoneCallback,
	fnParsingError = objPaginationInfo.parsingErrorCallback,	
	fnSendAlways = objPaginationInfo.sendAlwaysCallback,
	bUseProgress = objPaginationInfo.useProgress === undefined ? false :objPaginationInfo.useProgress, 
	data = (objPaginationInfo.currentData !== undefined && QBOX._.isArray(objPaginationInfo.currentData) && objPaginationInfo.currentData.length>0)? objPaginationInfo.currentData : QBOX._.clone(this.attr('data').input);	
	// 데이터 초기화
	objPaginationInfo.result.RT_clear();
	
	// server 통신하며, locaonce가 false이거나 무설정일 경우 ajax 통신 설정
	// 통신 결과를 json으로 받으며, 전체데이터의 count를 datacount라는 key로 받으며
	// data는 data라는 key값으로 받는다
	if(QBOX._.isUndefined(objPaginationInfo.url) === false && (QBOX._.isUndefined(objPaginationInfo.loadonce) === true || objPaginationInfo.loadonce === false) ){
		var arrsortinfo = [];
		// 전체 정렬 사용시
		
		if(objPaginationInfo.totalsort === true && QBOX._.isEmpty(this.attr('sortinfo')) === false) {
			QBOX._.each(this.attr('sortinfo'), function(sortinfo, idx){
				var arrsort = {};
				arrsort.sortKey = objQCell._getKeyOfCol(sortinfo[0]);
				arrsort.sortType = sortinfo[1];
				arrsortinfo.push(arrsort);
			});
			objPaginationInfo.sort = arrsortinfo;
		}
		
		// sort 초기화 선언시
		if(objPaginationInfo.initsort){
			objPaginationInfo.sort = undefined;
			objQCell._clearSortUI();
			objPaginationInfo.initsort = false;
		
		}
		//QBOX.$.ajaxSettings.async = false;
		var param = { pageindex: objPaginationInfo.pageindex, pageunit: objPaginationInfo.pageunit, param: JSON.stringify(objPaginationInfo.param), sort: JSON.stringify(objPaginationInfo.sort)};
		
		if(fnBeforeSend !== undefined && QBOX._.isFunction(fnBeforeSend)){
			param = fnBeforeSend(param);
		}
		if(bUseProgress === true){
			this.showProgress();
		}
		setTimeout(function(){
			QBOX.$.post(objPaginationInfo.url, param, function(result){
				try{
					result = result instanceof Object ? result : JSON.parse(result);
					objPaginationInfo.result = result instanceof Object ? result.data instanceof Object ? QBOX._.clone(result.data) : QBOX._.clone(JSON.parse(result.data)) : QBOX._.clone(JSON.parse(result.data));
					objPaginationInfo.datacount = result instanceof Object ? QBOX._.clone(result.datacount) : 0;
					objQCell._afterPaginationNext();					
				}catch(e){
					if(fnParsingError !== undefined && QBOX._.isFunction(fnParsingError)){
						fnParsingError(e,result);
					}
					result = {};
					objPaginationInfo.result = {};
					objPaginationInfo.datacount =  0;
					objQCell._afterPaginationNext();
					
				}
			}).done(function(){
				if(fnSendDone !== undefined && QBOX._.isFunction(fnSendDone)){
					fnSendDone();
				}
			}).fail(function(){
				if(fnSendFail !== undefined && QBOX._.isFunction(fnSendFail)){
					fnSendFail();
				}
			}).always(function(){			
				if(fnSendAlways !== undefined && QBOX._.isFunction(fnSendAlways)){
					fnSendAlways();
				}
				if(bUseProgress === true){
					objQCell.hideProgress();
				}			
			},100);
			//QBOX.$.ajaxSettings.async = true;
			
		});
		
	} else {
		var i = 0;
		
		// 전체 정렬 사용
		if(objPaginationInfo.totalsort === true && (QBOX._.isEmpty(this.attr('sortinfo')) === false)) {
			
			var arrSortList = QBOX._.clone(this.attr('sortinfo')), 
			arrTempSortList = [];
			
			// 데이터 정렬 조건 clone
			QBOX._.each(arrSortList, function(arrTemp){
				arrTempSortList.push(QBOX._.clone(arrTemp));
			});
			
			// 데이터 정렬 조건 중 컬럼 인덱스 -> key 로 변경
			for(i = 0; i < arrTempSortList.length; i++){
				arrTempSortList[i][0] = this._getKeyOfCol(arrTempSortList[i][0]);
			}
			
			// 단일 정렬
			if(arrTempSortList.length === 1) {
				QBOX.util.RT_sortBy	(data,arrTempSortList[0][0], arrTempSortList[0][1], arrTempSortList[0][2]);
//				data.RT_sortBy(arrTempSortList[0][0], arrTempSortList[0][1], arrTempSortList[0][2]);
			}
			// 다중 정렬
			else if(arrTempSortList.length > 1) {
				QBOX.util.RT_sortBy	(data,arrTempSortList);				
//				data.RT_sortBy(arrTempSortList);
			}
		}
		
		// locaonce가 false일 경우는 pageInfo.result가 바로 셋팅되기 때문에 아래의 for문을 이용하지 않는다. 
		// 현재 페이지의 데이터 구하기
		for(i = ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit); i < (objPaginationInfo.pageindex  * objPaginationInfo.pageunit); i++) {
			if(QBOX._.isUndefined(data[i]) === false){
				objPaginationInfo.result.push(data[i]);
			} else {
				break;
			}
			
			if(i === (data.length - 1)){
				break;
			}
		}
		objQCell._afterPaginationNext();
	}
	

};
QBOX.QCELL.BasicQCELL.prototype._calculatePaginationInfo = function(PageNo, PageUnit){
	var objQCell = this,
	objPaginationInfo = this.attr('paginationinfo'),
	fnBeforeSend = objPaginationInfo.beforeSendCallback,
	fnSendFail	=	objPaginationInfo.sendFailCallback,
	fnSendDone	=	objPaginationInfo.sendDoneCallback,
	fnParsingError = objPaginationInfo.parsingErrorCallback,		
	fnSendAlways = objPaginationInfo.sendAlwaysCallback,
	bUseProgress = objPaginationInfo.useProgress === undefined ? false :objPaginationInfo.useProgress, 
	data = (objPaginationInfo.currentData !== undefined && QBOX._.isArray(objPaginationInfo.currentData) && objPaginationInfo.currentData.length>0)? objPaginationInfo.currentData : QBOX._.clone(this.attr('data').input);
	
	if(this.attr('isResizing') === true){
		this.attr('isResizing', false ,'boolean');
		return;
	}
	this.attr('isResizing', false ,'boolean');
	// pagination 속성 초기화
	objPaginationInfo.firstpage 	= false;
	objPaginationInfo.prevpage 		= false;
	objPaginationInfo.nextpage 		= false;
	objPaginationInfo.lastpage 		= false;
	objPaginationInfo.firstindex 	= 1;
	objPaginationInfo.lastindex 	= QBOX._.isUndefined(objPaginationInfo.lastindex) 	? 1 : objPaginationInfo.lastindex;
	objPaginationInfo.pageindex 	= QBOX._.isUndefined(objPaginationInfo.pageindex) 	? 1 : objPaginationInfo.pageindex;
	objPaginationInfo.datacount 	= data.length;
	objPaginationInfo.result 		= QBOX._.isUndefined(objPaginationInfo.result) 		? [] : objPaginationInfo.result;
	objPaginationInfo.load 			= QBOX._.isUndefined(objPaginationInfo.load) 		? false : objPaginationInfo.load;
	objPaginationInfo.totalsort		= QBOX._.isUndefined(objPaginationInfo.totalsort) 	? false : objPaginationInfo.totalsort;
	objPaginationInfo.initsort		= QBOX._.isUndefined(objPaginationInfo.initsort) ? false : objPaginationInfo.initsort;
	objPaginationInfo.mode			= QBOX._.isUndefined(objPaginationInfo.mode)		? "simple" : objPaginationInfo.mode;
	objPaginationInfo.pagecount		= QBOX._.isUndefined(objPaginationInfo.pagecount)	? 5 : objPaginationInfo.pagecount;
	objPaginationInfo.extendmove	= QBOX._.isUndefined(objPaginationInfo.extendmove) 	? false : objPaginationInfo.extendmove;
	
	// 이동할 페이지 정보가 있으면 pageindex에 setting
	if( QBOX._.isUndefined(PageNo) === false ) {
		objPaginationInfo.pageindex = PageNo;
	} 
	
	// 이동할 페이지 정보가 첫페이지 보다 낮거나 마지막 페이지보다 높을 경우 처리
	if(PageNo <= objPaginationInfo.firstindex) {
		objPaginationInfo.pageindex = objPaginationInfo.firstindex;
	} else if(PageNo >= objPaginationInfo.lastindex){
		objPaginationInfo.pageindex = objPaginationInfo.lastindex;
	}
	
	// 화면에 표시할 데이터의 개수 처리, 현재 페이지를 1로 변환
	if( QBOX._.isUndefined(PageUnit) === false ) {
		objPaginationInfo.pageunit = PageUnit;
		objPaginationInfo.pageindex = objPaginationInfo.firstindex;
	}
	
	if(objPaginationInfo.allowsameindex !== true){
		if(objPaginationInfo.pageindex === this.attr('_prevPageIndex') && 
				objPaginationInfo.pageunit === this.attr('_prevPageUnit'))
			return;
		
	}
	
	if(this.attr('bRebuildWithPrevData') === true){
		return;
	}
	
	// server 통신하며, loadonce가 true일 경우 ajax 통신 설정
	// 통신 결과를 json으로 받으며, 전체데이터의 count를 datacount라는 key로 받으며
	// data는 data라는 key값으로 받는다
	if(QBOX._.isUndefined(objPaginationInfo.url) === false && (QBOX._.isUndefined(objPaginationInfo.loadonce) === false && objPaginationInfo.loadonce === true) && objPaginationInfo.load === false){
		// 전체 정렬 사용시
		if(objPaginationInfo.totalsort === true && QBOX._.isEmpty(this.attr('sortinfo')) === false) {
			objPaginationInfo.sort = QBOX._.clone(this.attr('sortinfo'));
		}
		
		// sort 초기화 선언시 
		if(objPaginationInfo.initsort){
			objPaginationInfo.sort = undefined;
			objQCell._clearSortUI();
			objPaginationInfo.initsort = false;
		}
		
		QBOX.$.ajaxSettings.async = false;
		var objParam = {param: JSON.stringify(objPaginationInfo.param), sort: JSON.stringify(objPaginationInfo.sort)};
		if(fnBeforeSend !== undefined && QBOX._.isFunction(fnBeforeSend)){
			objParam = fnBeforeSend(objParam);
		}
		if(bUseProgress === true){
			this.showProgress();
		}
		setTimeout(function(){
			QBOX.$.post(objPaginationInfo.url,objParam , function(result){
				try{
					result = result instanceof Object ? result : JSON.parse(result);
					
					objQCell.attr('data').input = result instanceof Object ? result.data instanceof Object ? QBOX._.clone(result.data) : QBOX._.clone(JSON.parse(result.data)) : QBOX._.clone(JSON.parse(result.data));
					data = result instanceof Object ? result.data instanceof Object ? QBOX._.clone(result.data) : QBOX._.clone(JSON.parse(result.data)) : QBOX._.clone(JSON.parse(result.data));
					objPaginationInfo.datacount = result instanceof Object ? QBOX._.clone(data.length) : 0;
					objPaginationInfo.load = true;
					
					objQCell.attr('_prevPageIndex', objPaginationInfo.pageindex ,'number' );
					objQCell.attr('_prevPageUnit', objPaginationInfo.pageunit ,'number' );
				}catch(e){
					if(fnParsingError !== undefined && QBOX._.isFunction(fnParsingError)){
						fnParsingError(e,result);
					}
					
					objQCell.attr('data').input = [];
					data = [];
					objPaginationInfo.datacount = 0;
					objPaginationInfo.load = true;
					
					objQCell.attr('_prevPageIndex', objPaginationInfo.pageindex ,'number' );
					objQCell.attr('_prevPageUnit', objPaginationInfo.pageunit ,'number' );
				}
				
				
			}).done(function(){
				if(fnSendDone !== undefined && QBOX._.isFunction(fnSendDone)){
					fnSendDone();
				}
			}).fail(function(){
				if(fnSendFail !== undefined && QBOX._.isFunction(fnSendFail)){
					fnSendFail();
				}
			}).always(function(){			
				if(fnSendAlways !== undefined && QBOX._.isFunction(fnSendAlways)){
					fnSendAlways();
				}
				if(bUseProgress === true){
					objQCell.hideProgress();
				}
				
			},100);
			QBOX.$.ajaxSettings.async = true;
			
			objQCell._afterPagination();
		});
	}else{
		objQCell._afterPagination();	
	}
	
	
};

// 페이지 이동 및 출력 갯수 변경
QBOX.QCELL.BasicQCELL.prototype._movePage = function(pageNo, pageUnit){
	var objPaginationInfo = this.attr('paginationinfo');
	
	// colsearch 제거
	if(this.attr('colsearchuivisible')){
		this._removeColSearUIArea();
	}
	
	// contextmenu 제거
	if(!this._isContextMenu()){
		this._removeContextMenu();
	}
	
	// 전체 정렬 미사용시 sortUI 제거
	if(QBOX._.isUndefined(objPaginationInfo.totalsort) || objPaginationInfo.totalsort === false){
		this._clearSortUI();
	}
	this.attr('_afterpagination' , 'movepage','string');	
	this._calculatePaginationInfo(pageNo, pageUnit); // pagination 재계산
	


};

//currentdata 변경 및 화면처리
QBOX.QCELL.BasicQCELL.prototype._updatePagination = function(){
	var htElementPool = this.attr('elementpool'),
	hePaginationPanel = htElementPool.get('paginationpanel');
	
	this._setCurrentData(QBOX._.clone(this.attr('paginationinfo').result), true);
	
	// pagination UI 삭제 후 재생성
	htElementPool.get('$paginationpanel').empty();
	hePaginationPanel.appendChild(this._createPaginationInner(document.createElement('div')));
	
	// page이동이나, 화면 변경시 전체 checkbox의 선택 및 해제
	if(QBOX.QCELL.module === 'normal') { // 사용하는 QCELL module이 normal이고
		for(var nCol = this.attr('headercols'), ed = this.attr('cols'); nCol < ed; nCol++){ // 전체 col 중
			if(this._getColType(nCol) === 'checkbox'){ // type이 'checkbox'인 col이 있고
				var objCheckedvalue = this._getColElement(nCol).attr('checkedvalue'),
				nDatalength = this.attr('currentdata').length,
				nHeaderrows = this.attr('headerrows'),
				nCount = 0;
				
				for(var i = 0; i < nDatalength; i++){ // data의 갯 수만큼 data영역의 checkbox가 check 되어 있는지 확인
					var nRow = i + nHeaderrows;
					if(this._cellValue(nRow ,nCol) === objCheckedvalue) {
						nCount++;
					}
				}
				
				if(nCount === nDatalength){ // check된 수가 data의 수와 동일한 지 판단
					if(this._getColElement(nCol)._isHeaderCheckbox(nCol) && this._getColElement(nCol)._getHeaderCheckedState(nCol) === false) { // 전체 선택 checkbox가 있고, 전체 선택 checkbox가 check되어 있지 않으면
						this._getColElement(nCol)._setHeaderChecked(nCol, true); // 전체 checkbox 선택
					}
				} else {
					if(this._getColElement(nCol)._isHeaderCheckbox(nCol) && this._getColElement(nCol)._getHeaderCheckedState(nCol)) { // 전체 선택 checkbox가 있고, 전체 선택 checkbox가 check되어 있으면
						this._getColElement(nCol)._setHeaderChecked(nCol, false); // 전체 checkbox 해제
					}
				}
			}
		}
	}
};

// pagination에 param값 변경 시 처리
QBOX.QCELL.BasicQCELL.prototype._setPaginationParam = function(property){
	try{
		this.attr('paginationinfo').param = QBOX._.clone(property);
		// loadonce가 동작하면 load값이 true로 변경되는데 이에 대한 초기화
		this.attr('paginationinfo').load = false;
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._setPaginationParam', e.message);
		return false;
	}
};
QBOX.QCELL.BasicQCELL.prototype._calculatePaginationInfoCreate = function(PageNo, PageUnit){
	var objQCell = this,
	objPaginationInfo = this.attr('paginationinfo'),
	fnBeforeSend = objPaginationInfo.beforeSendCallback,
	fnSendFail	=	objPaginationInfo.sendFailCallback,
	fnSendDone	=	objPaginationInfo.sendDoneCallback,
	fnSendAlways = objPaginationInfo.sendAlwaysCallback,
	fnParsingError = objPaginationInfo.parsingErrorCallback,
	bUseProgress = objPaginationInfo.useProgress === undefined ? false :objPaginationInfo.useProgress, 
	data = (objPaginationInfo.currentData !== undefined && QBOX._.isArray(objPaginationInfo.currentData) && objPaginationInfo.currentData.length>0)? objPaginationInfo.currentData : QBOX._.clone(this.attr('data').input);
	
	if(this.attr('isResizing') === true){
		this.attr('isResizing', false ,'boolean');
		return;
	}
	this.attr('isResizing', false ,'boolean');
	// pagination 속성 초기화
	objPaginationInfo.firstpage 	= false;
	objPaginationInfo.prevpage 		= false;
	objPaginationInfo.nextpage 		= false;
	objPaginationInfo.lastpage 		= false;
	objPaginationInfo.firstindex 	= 1;
	objPaginationInfo.lastindex 	= QBOX._.isUndefined(objPaginationInfo.lastindex) 	? 1 : objPaginationInfo.lastindex;
	objPaginationInfo.pageindex 	= QBOX._.isUndefined(objPaginationInfo.pageindex) 	? 1 : objPaginationInfo.pageindex;
	objPaginationInfo.datacount 	= data.length;
	objPaginationInfo.result 		= QBOX._.isUndefined(objPaginationInfo.result) 		? [] : objPaginationInfo.result;
	objPaginationInfo.load 			= QBOX._.isUndefined(objPaginationInfo.load) 		? false : objPaginationInfo.load;
	objPaginationInfo.totalsort		= QBOX._.isUndefined(objPaginationInfo.totalsort) 	? false : objPaginationInfo.totalsort;
	objPaginationInfo.initsort		= QBOX._.isUndefined(objPaginationInfo.initsort) ? false : objPaginationInfo.initsort;
	objPaginationInfo.mode			= QBOX._.isUndefined(objPaginationInfo.mode)		? "simple" : objPaginationInfo.mode;
	objPaginationInfo.pagecount		= QBOX._.isUndefined(objPaginationInfo.pagecount)	? 5 : objPaginationInfo.pagecount;
	objPaginationInfo.extendmove	= QBOX._.isUndefined(objPaginationInfo.extendmove) 	? false : objPaginationInfo.extendmove;
	
	// 이동할 페이지 정보가 있으면 pageindex에 setting
	if( QBOX._.isUndefined(PageNo) === false ) {
		objPaginationInfo.pageindex = PageNo;
	} 
	
	// 이동할 페이지 정보가 첫페이지 보다 낮거나 마지막 페이지보다 높을 경우 처리
	if(PageNo <= objPaginationInfo.firstindex) {
		objPaginationInfo.pageindex = objPaginationInfo.firstindex;
	} else if(PageNo >= objPaginationInfo.lastindex){
		objPaginationInfo.pageindex = objPaginationInfo.lastindex;
	}
	
	// 화면에 표시할 데이터의 개수 처리, 현재 페이지를 1로 변환
	if( QBOX._.isUndefined(PageUnit) === false ) {
		objPaginationInfo.pageunit = PageUnit;
		objPaginationInfo.pageindex = objPaginationInfo.firstindex;
	}
	
	if(objPaginationInfo.allowsameindex !== true){
		if(objPaginationInfo.pageindex === this.attr('_prevPageIndex') && 
				objPaginationInfo.pageunit === this.attr('_prevPageUnit'))
			return;
		
	}
	
	if(this.attr('bRebuildWithPrevData') === true){
		return;
	}
	
	// server 통신하며, loadonce가 true일 경우 ajax 통신 설정
	// 통신 결과를 json으로 받으며, 전체데이터의 count를 datacount라는 key로 받으며
	// data는 data라는 key값으로 받는다
	if(QBOX._.isUndefined(objPaginationInfo.url) === false && (QBOX._.isUndefined(objPaginationInfo.loadonce) === false && objPaginationInfo.loadonce === true) && objPaginationInfo.load === false){
		// 전체 정렬 사용시
		if(objPaginationInfo.totalsort === true && QBOX._.isEmpty(this.attr('sortinfo')) === false) {
			objPaginationInfo.sort = QBOX._.clone(this.attr('sortinfo'));
		}
		
		// sort 초기화 선언시 
		if(objPaginationInfo.initsort){
			objPaginationInfo.sort = undefined;
			objQCell._clearSortUI();
			objPaginationInfo.initsort = false;
		}
		
		QBOX.$.ajaxSettings.async = false;
		var objParam = {param: JSON.stringify(objPaginationInfo.param), sort: JSON.stringify(objPaginationInfo.sort)};
		if(fnBeforeSend !== undefined && QBOX._.isFunction(fnBeforeSend)){
			objParam = fnBeforeSend(objParam);
		}
		if(bUseProgress === true){
			this.showProgress();
		}
		QBOX.$.post(objPaginationInfo.url,objParam , function(result){
			try{
				result = result instanceof Object ? result : JSON.parse(result);
				objQCell.attr('data').input = result instanceof Object ? result.data instanceof Object ? QBOX._.clone(result.data) : QBOX._.clone(JSON.parse(result.data)) : QBOX._.clone(JSON.parse(result.data));
				data = result instanceof Object ? result.data instanceof Object ? QBOX._.clone(result.data) : QBOX._.clone(JSON.parse(result.data)) : QBOX._.clone(JSON.parse(result.data));
				objPaginationInfo.datacount = result instanceof Object ? QBOX._.clone(data.length) : 0;
				objPaginationInfo.load = true;
				
				objQCell.attr('_prevPageIndex', objPaginationInfo.pageindex ,'number' );
				objQCell.attr('_prevPageUnit', objPaginationInfo.pageunit ,'number' );
				
			}catch (e){
				if(fnParsingError !== undefined && QBOX._.isFunction(fnParsingError)){
					fnParsingError(e,result);
				}
				objQCell.attr('data').input = [];
				data = [];
				objPaginationInfo.datacount = 0;
				objPaginationInfo.load = true;
				
				objQCell.attr('_prevPageIndex', objPaginationInfo.pageindex ,'number' );
				objQCell.attr('_prevPageUnit', objPaginationInfo.pageunit ,'number' );

			}
		}).done(function(){
			if(fnSendDone !== undefined && QBOX._.isFunction(fnSendDone)){
				fnSendDone();
			}
		}).fail(function(){
			if(fnSendFail !== undefined && QBOX._.isFunction(fnSendFail)){
				fnSendFail();
			}
		}).always(function(){			
			if(fnSendAlways !== undefined && QBOX._.isFunction(fnSendAlways)){
				fnSendAlways();
			}
			if(bUseProgress === true){
				objQCell.hideProgress();
			}
			
		});
		QBOX.$.ajaxSettings.async = true;
	}
	
	// 데이터 초기화
	objPaginationInfo.result.RT_clear();
	
	// server 통신하며, locaonce가 false이거나 무설정일 경우 ajax 통신 설정
	// 통신 결과를 json으로 받으며, 전체데이터의 count를 datacount라는 key로 받으며
	// data는 data라는 key값으로 받는다
	if(QBOX._.isUndefined(objPaginationInfo.url) === false && (QBOX._.isUndefined(objPaginationInfo.loadonce) === true || objPaginationInfo.loadonce === false) ){
		var arrsortinfo = [];
		// 전체 정렬 사용시
		
		if(objPaginationInfo.totalsort === true && QBOX._.isEmpty(this.attr('sortinfo')) === false) {
			QBOX._.each(this.attr('sortinfo'), function(sortinfo, idx){
				var arrsort = {};
				arrsort.sortKey = objQCell._getKeyOfCol(sortinfo[0]);
				arrsort.sortType = sortinfo[1];
				arrsortinfo.push(arrsort);
			});
			objPaginationInfo.sort = arrsortinfo;
		}
		
		// sort 초기화 선언시
		if(objPaginationInfo.initsort){
			objPaginationInfo.sort = undefined;
			objQCell._clearSortUI();
			objPaginationInfo.initsort = false;
		
		}
		QBOX.$.ajaxSettings.async = false;
		var param = { pageindex: objPaginationInfo.pageindex, pageunit: objPaginationInfo.pageunit, param: JSON.stringify(objPaginationInfo.param), sort: JSON.stringify(objPaginationInfo.sort)};
		
		if(fnBeforeSend !== undefined && QBOX._.isFunction(fnBeforeSend)){
			param = fnBeforeSend(param);
		}
		if(bUseProgress === true){
			this.showProgress();
		}		
		QBOX.$.post(objPaginationInfo.url, param, function(result){
			try{
				result = result instanceof Object ? result : JSON.parse(result);
				objPaginationInfo.result = result instanceof Object ? result.data instanceof Object ? QBOX._.clone(result.data) : QBOX._.clone(JSON.parse(result.data)) : QBOX._.clone(JSON.parse(result.data));
				objPaginationInfo.datacount = result instanceof Object ? QBOX._.clone(result.datacount) : 0;
				
			}catch (e){
				if(fnParsingError !== undefined && QBOX._.isFunction(fnParsingError)){
					fnParsingError(e,result);
				}
				
				objPaginationInfo.result = {};
				objPaginationInfo.datacount = 0;
				
			}
		}).done(function(){
			if(fnSendDone !== undefined && QBOX._.isFunction(fnSendDone)){
				fnSendDone();
			}
		}).fail(function(){
			if(fnSendFail !== undefined && QBOX._.isFunction(fnSendFail)){
				fnSendFail();
			}
		}).always(function(){			
			if(fnSendAlways !== undefined && QBOX._.isFunction(fnSendAlways)){
				fnSendAlways();
			}
			if(bUseProgress === true){
				objQCell.hideProgress();
			}			
		});
		QBOX.$.ajaxSettings.async = true;
	} else {
		var i = 0;
		
		// 전체 정렬 사용
		if(objPaginationInfo.totalsort === true && (QBOX._.isEmpty(this.attr('sortinfo')) === false)) {
			
			var arrSortList = QBOX._.clone(this.attr('sortinfo')), 
			arrTempSortList = [];
			
			// 데이터 정렬 조건 clone
			QBOX._.each(arrSortList, function(arrTemp){
				arrTempSortList.push(QBOX._.clone(arrTemp));
			});
			
			// 데이터 정렬 조건 중 컬럼 인덱스 -> key 로 변경
			for(i = 0; i < arrTempSortList.length; i++){
				arrTempSortList[i][0] = this._getKeyOfCol(arrTempSortList[i][0]);
			}
			
			// 단일 정렬
			if(arrTempSortList.length === 1) {
				QBOX.util.RT_sortBy	(data,arrTempSortList[0][0], arrTempSortList[0][1], arrTempSortList[0][2]);
//				data.RT_sortBy(arrTempSortList[0][0], arrTempSortList[0][1], arrTempSortList[0][2]);
			}
			// 다중 정렬
			else if(arrTempSortList.length > 1) {
				QBOX.util.RT_sortBy	(data,arrTempSortList);				
//				data.RT_sortBy(arrTempSortList);
			}
		}
		
		// locaonce가 false일 경우는 pageInfo.result가 바로 셋팅되기 때문에 아래의 for문을 이용하지 않는다. 
		// 현재 페이지의 데이터 구하기
		for(i = ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit); i < (objPaginationInfo.pageindex  * objPaginationInfo.pageunit); i++) {
			if(QBOX._.isUndefined(data[i]) === false){
				objPaginationInfo.result.push(data[i]);
			} else {
				break;
			}
			
			if(i === (data.length - 1)){
				break;
			}
		}
	}
	
	// 마지막 페이지 계산
	objPaginationInfo.lastindex = Math.ceil( objPaginationInfo.datacount / objPaginationInfo.pageunit );
	
	if(objPaginationInfo.mode === 'simple') { // mode 'simple' 일 때
		// 버튼 활성화에 대한 처리 - 현재 페이지가 마지막 페이지 이전일 때
		if(objPaginationInfo.pageindex < objPaginationInfo.lastindex){ // next, last 버튼 활성화
			objPaginationInfo.nextpage = true;
			objPaginationInfo.lastpage = true;
		}
		
		// 버튼 활성화에 대한 처리 - 현재 페이지가 첫 페이지 이후일 때
		if(objPaginationInfo.pageindex > objPaginationInfo.firstindex){ // prev, first 버튼 활성화
			objPaginationInfo.prevpage = true;
			objPaginationInfo.firstpage = true;
		}
	} else { // mode 'extend' 일 때
		// 페이지 정보를 표출할 (pagecount 단위당) 갯수 snum = 시작 페이지 번호 묶음 값, lnum = 마지막 페이지 번호 묶음 값  
		var snum = Math.ceil(objPaginationInfo.pageindex / objPaginationInfo.pagecount),
		lnum = Math.ceil(objPaginationInfo.lastindex / objPaginationInfo.pagecount);
		
		//console.log('snum:'+snum + ', lnum:'+lnum);
		
		if(snum < lnum && objPaginationInfo.pageindex !== objPaginationInfo.lastindex) { // 시작번호가 마지막 번호보다 작을 때 
			objPaginationInfo.nextpage = true; // next 버튼 활성화
		}
		
		if(snum > 1) { // 현재 페이지 번호가 1보다 클 때
			objPaginationInfo.prevpage = true; // prev 버튼 활성화
		}
		
		if(objPaginationInfo.pageindex < objPaginationInfo.lastindex) { // 현재 페이지 번호가 마지막 페이지 번호보다 작을 때
			objPaginationInfo.lastpage = true; // last 버튼 활성화
		}
		
		if(objPaginationInfo.pageindex > 1) { // 현재 페이지 번호가 1보다 크면
			objPaginationInfo.firstpage = true; // first 버튼 활성화
		}
	}
	
	// 데이터가 존재하지 않을 시 UI에 표시 방법 설정
	if(objPaginationInfo.result.length === 0){
		objPaginationInfo.pageindex = 0;
		objPaginationInfo.firstindex = 0;
		
		// pagination 데이터를 담아두는 result에 데이터가 없으면 페이지정보와 전체 데이터 정보 0으로 초기화
		objPaginationInfo.datacount = 0;
		objPaginationInfo.lastindex = 0;
		
		// next, last 버튼 비활성화
		objPaginationInfo.nextpage = false;
		objPaginationInfo.lastpage = false;
	} else {
		objPaginationInfo.firstindex = 1;
	}
};
QBOX.QCELL.BasicQCELL.prototype._initProps = function(){
	try{
		var arrQCellCols = this.attr('qcellcols'),
		htColKeysInfo = this.attr('colkeysinfo'),
		nHeaderRows = 0, nFrozenRows = this.attr('frozenrows'),
		nCols = 0, nHeaderCols = 0;
		
		//cols, 컬럼 이동/추가/삭제 시 동기화 필요
		this.attr('cols', nCols = arrQCellCols.length, 'number');
		
		//headercols
		this.attr('headercols', nHeaderCols = this.attr('rowheaders').length, 'number');
		
		//headerrows
		this.attr('headerrows', nHeaderRows = QBOX._.max(arrQCellCols, function(objQCellCol){return objQCellCol.attr('title').length;}).attr('title').length, 'number');
		
		//colwidths, 컬럼 이동/추가/삭제 시 동기화 필요
		this.attr('colwidths', QBOX._.map(arrQCellCols, function(objQCellCol){return objQCellCol.attr('width');}), 'array');
		
		//colkeys, 컬럼 이동/추가/삭제 시 동기화 필요
		this.attr('colkeys', QBOX._.map(arrQCellCols, function(objQCellCol){return objQCellCol.attr('key');}), 'array');
		
		//colids, 컬럼 이동/추가/삭제 시 동기화 필요
		this.attr('colids', QBOX._.map(arrQCellCols, function(objQCellCol){return objQCellCol.attr('id');}), 'array');
		
		//colkeysinfo, 컬럼 이동/추가/삭제 시 동기화 필요
		QBOX._.each(this.attr('colkeys'), function(key, nCol){
			if(htColKeysInfo.containsKey(key) === false){
				htColKeysInfo.put(key, new _QHashSet());
			}
			htColKeysInfo.get(key).add(nCol);
		});
		
		//colidsinfo, 컬럼 이동/추가/삭제 시 동기화 필요
		this.attr('colidsinfo', QBOX._.object(QBOX._.map(arrQCellCols, function(objQCellCol){return objQCellCol.attr('id');}), QBOX._.range(0, nCols)), 'object');
		
		//headertext, 컬럼 이동/추가/삭제 시 동기화 필요
		this.attr('headertext', QBOX._.map(arrQCellCols, function(objQCellCol){return objQCellCol.attr('title');}), 'array');
		
		if(this.attr('hiddencolsprops') !== null){
			var arrHT = [],arrHCol = this.attr('hiddencolsprops');
			
			if(arrHCol !== undefined && arrHCol !== null){
				for(var i=0;i<arrHCol.length ; i++){
					arrHT.push({key:arrHCol[i].key,title:arrHCol[i].title});
				}				
			}
			this.attr('hiddenheadertext', arrHT, 'object');
		}
		
		//percentcolwidth
		if(QBOX._.find(this.attr('colwidths'), function(colwidth){return colwidth.indexOf('%') > -1;}) !== undefined){
			this.attr('percentcolwidth', true, 'boolean');
		}
		
		//가로스크롤바 이동 범위 설정
		//this._setHSRange();
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._initProps', e.message);
		return null;
	}
};

QBOX.QCELL.BasicQCELL.prototype._getSumOfRowHeight = function(nStartRow, nLastRow){
	var nSumOfRowHeight = 0, 
	nHeaderRowHeight = this.attr('rowheight').header,
	nDataRowHeight = this.attr('rowheight').data,
	nHeaderRows = this.attr('headerrows');
	
	for(var i = nStartRow; i <= nLastRow; i++){
		if(i < nHeaderRows){
			nSumOfRowHeight += nHeaderRowHeight;
		} else{
			nSumOfRowHeight += nDataRowHeight;
		}
	}
	
	return nSumOfRowHeight;
};

QBOX.QCELL.BasicQCELL.prototype._getSumOfColWidth = function(nStartCol, nLastCol){
	var nSumOfColWidth = 0, arrColWidthsPerPixel = this.attr('colwidthsperpixel');
	for(var j = nStartCol; j <= nLastCol; j++){
		nSumOfColWidth += arrColWidthsPerPixel[j];
	}
	return nSumOfColWidth;
};

QBOX.QCELL.BasicQCELL.prototype._getSumOfRowHeight = function(nStartRow, nLastRow){
	var htDynamicRowHeight = this.attr('dynamicrowheight'),
	nDataRowHeight = this.attr('rowheight').data,
	nHeaderRows = this.attr('headerrows'), nSumOfRowHeight = 0;
	
	if(nStartRow >= nHeaderRows){
		nSumOfRowHeight = (nLastRow - nStartRow + 1) * nDataRowHeight;
	} else{
		//headerRows 높이 계산
		nSumOfRowHeight = (nHeaderRows - nStartRow) * this.attr('rowheight').header;
		//DataRows 높이 계산
		nSumOfRowHeight += (nLastRow - nHeaderRows + 1) * nDataRowHeight;
	}
	
	if(htDynamicRowHeight.size() > 0){
		var arrDynamicHeightRows = htDynamicRowHeight.keys().sort(QBOX.st.asc);
		for(var i = nStartRow; i <= nLastRow; i++){
			if(QBOX._.indexOf(arrDynamicHeightRows, i, true) > -1){
				nSumOfRowHeight += htDynamicRowHeight.get(i) - nDataRowHeight;
			}
		}
		arrDynamicHeightRows = null;
	}
	
	return nSumOfRowHeight;
};

QBOX.QCELL.BasicQCELL.prototype._adjustFrozenCount = function(){
	return this._adjustFrozenColsCount() && this._adjustFrozenRowsCount();
};

QBOX.QCELL.BasicQCELL.prototype._adjustFrozenColsCount = function(){
	try{
		//가로스크롤바가 있는 경우에만 FrozenCols를 사용 할 수 있다.
		if(this.attr('hsinfo').bHScroll === false){
			this.attr('frozencols', 0, 'number');
		} else{
			var objProperties = this.getProperties();
			
			this.attr('frozencols', objProperties.frozencols, 'number');
		}
		this._setHSRange();
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._adjustFrozenColsCount', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._adjustFrozenRowsCount = function(){
	try{
		//세로스크롤바가 있는 경우에만 FrozenRows, FrozenBottomRows를 사용 할 수 있다.
		if(this.attr('vsinfo').bVScroll === false){
			this.attr('frozenrows', 0, 'number');
			if(this._isPanel() !== true)
				this.attr('frozenbottomrows', 0, 'number');
		} else{
			var objProperties = this.getProperties();
			
			this.attr('frozenrows', objProperties.frozenrows, 'number');
			this.attr('frozenbottomrows', objProperties.frozenbottomrows, 'number');
		}
		this._setVSRange();
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._adjustFrozenRowsCount', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._updateIdx = function(/*cursor|drag|click|focus*/strType, nRow, nCol){
	var nPrevRow = this._idx('row', strType, 'current'), nPrevCol = this._idx('col', strType, 'current');
	
	if(nRow !== nPrevRow || nCol !== nPrevCol){
		this._idx('row', strType, 'previous', nPrevRow);
		this._idx('col', strType, 'previous', nPrevCol);
		this._idx('row', strType, 'current', nRow);
		this._idx('col', strType, 'current', nCol);
		
		if(strType === 'click' && nRow !== -1 && nCol !== -1){
			this._trigger('dataclicked');
		}
		return true;
	}
	return false;
};

//QBOX.QCELL.BasicQCELL.prototype._getTotalFrozenColWidth = function(){
//	return _.reduce(_.clone(this.attr('colwidthsperpixel')).splice(this.attr('headercols'), this.attr('frozencols')), function(nTotalColWidth, nColWidth){
//		return nTotalColWidth + nColWidth;
//	}, 0);
//};

//QBOX.QCELL.BasicQCELL.prototype._getTotalColWidth = function(){
//	return _.reduce(this.attr('colwidthsperpixel'), function(nTotalColWidth, nColWidth){
//		return nTotalColWidth + nColWidth;
//	}, 0);
//};

QBOX.QCELL.BasicQCELL.prototype._getTotalColWidth = function(){
	var arrColWidths = this.attr('colwidths'),
	nHeaderCols = this.attr('headercols'),
	nContainerClientWidth = this.attr('layoutsize').container.clientWidth,
	nEdgeHeaderWidth = this.attr('headercolwidth') * nHeaderCols;
	
	if(this.attr('percentcolwidth')){
		//headercols는 빼고 나머지 컬럼들의 %값을 모두 더해서 계산
		var nHeaderColsWidth = QBOX._.reduce(arrColWidths.slice(0, nHeaderCols), function(nTotalWidth, strColWidth){
			return nTotalWidth + parseFloat(strColWidth);
		}, 0);
		var nTotalPercent = QBOX._.reduce(arrColWidths.slice(nHeaderCols, arrColWidths.length), function(nTotalPercent, strColWidthPercent){
			return nTotalPercent + parseFloat(strColWidthPercent);
		}, 0);
		
		return nHeaderColsWidth + ((nContainerClientWidth - nEdgeHeaderWidth - (this.attr('vsinfo').bVScroll ? this.attr('scrollbarwidth') : 0)) * nTotalPercent / 100);
	} else{
		return QBOX._.reduce(arrColWidths, function(nTotalColWidth, strColWidth){
			return nTotalColWidth + parseFloat(strColWidth);
		}, 0);
	}
};

QBOX.QCELL.BasicQCELL.prototype._calculateRealColWidth = function(){
	//ViewPort의 width가 결정되고 나면 컬럼의 width를 fix해야 한다.
	
	var objLayoutSize = this.attr('layoutsize'), nHeaderCols = this.attr('headercols');
	
	if(this.attr('percentcolwidth')){
		var nTotalPercent = 0,
		nSumOfColWidths = 0;
		
		this.attr('colwidthsperpixel', QBOX._.map(this.attr('colwidths'), function(strColWidth, nCol){
			if(nCol < nHeaderCols){
				return parseFloat(strColWidth);
			} else{
				var nViewPortOffsetWidth = objLayoutSize.viewport.offsetWidth,
				nColWidthPerPercent = parseFloat(strColWidth),
				nColWidthPerPixel = Math.ceil(nViewPortOffsetWidth * parseFloat(strColWidth) / 100);//올림으로 처리해야 100.001%가 100%보다 적어지는 경우를 방지할 수 있다.
				
				nTotalPercent += nColWidthPerPercent;
				
				if(nTotalPercent === 100){//현재 컬럼의 width까지의 합이 100%인 경우 ViewPort의 width와 정확히 맞아떨어지도록 설정 
					nColWidthPerPixel = nViewPortOffsetWidth - nSumOfColWidths;
				}
				
				nSumOfColWidths += nColWidthPerPixel;
				
				return nColWidthPerPixel;
			}
		}), 'array');
	} else{
		this.attr('colwidthsperpixel', QBOX._.map(this.attr('colwidths'), function(colwidth){return parseFloat(colwidth);}), 'array');
	}
};

//QBOX.QCELL.BasicQCELL.prototype._calculateDynamicCols = function(){
//	//생성해야 할 컬럼 div의 수 계산
//	//모든 스크롤바 위치에서 가장 많은 컬럼이 표시되는 경우를 찾아 컬럼 div의 수를 결정한다.
//	/*
//	 * 생성해야 할 컬럼 div의 수는 어떻게 계산할까?
//	 * frozencols까지는 무조건 정적으로 만들어야 한다.
//	 * 최악의 경우에 해당하는 열 div수를 계산해야 한다.
//	 * headercols가 2개이고, viewport의 clientwidth가 500일 때
//	 * colwidths가 [30, 30, 100, 100, 200, 400, 100, 80, 150]이고, headercols가 2, frozencols가 2일 때
//	 * headercols들을 제외하고 4개 컬럼까지 width의 합이 500보다 크거나 같아지므로 생성해야 할 컬럼 div 수는 4개이다.(100 + 100 + 200 + 400 >= 500)
//	 * (100 + 100) + 400 >= 500이므로 생성해야 할 컬럼 div 수는 3개이다.
//	 * (100 + 100) + 100 + 80 + 150 >= 500이므로 생성해야 할 컬럼 div 수는 5개이다.
//	 * (100 + 100) + 80 + 150 < 500이지만 마지막 컬럼까지 더했으므로 생성해야 할 컬럼 div 수는 4개이다.
//	 * 이 중 세번째 경우가 가장 많은 컬럼 div를 생성하는 경우이고, 이를 기준으로 삼는다.
//	 */
//	var i, j, nDynamicCols = 0,
//	nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
//	nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth,
//	nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
//	nTotalViewPortNormalColWidth,
//	nDivCount,
//	arrColWidthsPerPixel = this.attr('colwidthsperpixel'),
//	arrViewPortNormalColWidths = arrColWidthsPerPixel.slice(this.attr('headercols') + nFrozenCols),
//	objHSInfo = this.attr('hsinfo');
//	
//	//console.log(arrColWidthsPerPixel);
//	//console.log(arrViewPortNormalColWidths);
//	//console.log('nViewPortOffsetWidth:', nViewPortOffsetWidth);
//	
//	//nFrozenColsWidth + 일반컬럼의 width합이 viewport의 width보다 크거나 같아지는 경우 중에서 가장 큰 경우를 찾는다.
//	for(i = 0, nLength = arrViewPortNormalColWidths.length; i < nLength; i++){
//		nTotalViewPortNormalColWidth = nFrozenColsWidth;
//		nDivCount = nFrozenCols;
//		//var strLog = '[';
//		for(j = i; j < nLength; j++){
//			//console.log('비교', nTotalViewPortNormalColWidth, ',', nViewPortOffsetWidth)
//			if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
//				break;
//			} else{
//				nTotalViewPortNormalColWidth += arrViewPortNormalColWidths[j];
//				nDivCount += 1;
//				//strLog += j + ':' + arrViewPortNormalColWidths[j] + ',';
//			}
//		}
//		
//		//strLog + ']';
//		//console.log(strLog);
//		//console.log('result:' + (nDivCount));
//		
//		if(nDivCount > nDynamicCols){
//			nDynamicCols = nDivCount;
//		}
//	}
//	
//	//가로스크롤바가 오른쪽 끝에서 왼쪽으로 움직이는 경우도 고려해야 한다.
//	arrViewPortNormalColWidths.reverse();
//	for(i = 0, nLength = arrViewPortNormalColWidths.length; i < nLength; i++){
//		nTotalViewPortNormalColWidth = nFrozenColsWidth;
//		nDivCount = nFrozenCols;
//		for(j = i; j < nLength; j++){
//			if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
//				break;
//			} else{
//				nTotalViewPortNormalColWidth += arrViewPortNormalColWidths[j];
//				nDivCount += 1;
//			}
//		}
//		
//		if(nDivCount > nDynamicCols){
//			nDynamicCols = nDivCount;
//		}
//	}
//	
//	objHSInfo.nDynamicCols = nDynamicCols;
//	//objHSInfo.nRightCol = nHeaderCols + nDynamicCols - 1;
//	
//	//QCELL.log('log', 'BasicQCELL._calculateDynamicCols', 'colWidths per "pixel": ' + JSON.stringify(arrColWidthsPerPixel));
//	//QCELL.log('log', 'BasicQCELL._calculateDynamicCols', 'viewport\'s offsetWidth: ' + nViewPortOffsetWidth + 'px');
//	//QCELL.log('log', 'BasicQCELL._calculateDynamicCols', 'total FrozenCols\'s width: ' + nFrozenColsWidth + 'px');
//	//QCELL.log('log', 'BasicQCELL._calculateDynamicCols', 'nDynamicCols: ' + nDynamicCols);
//};

QBOX.QCELL.BasicQCELL.prototype._calculateDynamicCols = function(){
	try{
		var objHSInfo = this.attr('hsinfo'),
		nHeaderCols = this.attr('headercols'), nCols = this.attr('cols'),
		nDynamicCols = 0;
		
		if(this.attr('useall') || this.attr('usetreeall')){
			nDynamicCols = nCols - nHeaderCols;
		}else	if(nCols - nHeaderCols > 0){
			//생성해야 할 컬럼 div의 수 계산
			//모든 스크롤바 위치에서 가장 많은 컬럼이 표시되는 경우를 찾아 컬럼 div의 수를 결정한다.
			/*
			 * 생성해야 할 컬럼 div의 수는 어떻게 계산할까?
			 * frozencols까지는 무조건 정적으로 만들어야 한다.
			 * 최악의 경우에 해당하는 열 div수를 계산해야 한다.
			 * headercols가 2개이고, viewport의 clientwidth가 500일 때
			 * colwidths가 [30, 30, 100, 100, 200, 400, 100, 80, 150]이고, headercols가 2, frozencols가 2일 때
			 * headercols들을 제외하고 4개 컬럼까지 width의 합이 500보다 크거나 같아지므로 생성해야 할 컬럼 div 수는 4개이다.(100 + 100 + 200 + 400 >= 500)
			 * (100 + 100) + 400 >= 500이므로 생성해야 할 컬럼 div 수는 3개이다.
			 * (100 + 100) + 100 + 80 + 150 >= 500이므로 생성해야 할 컬럼 div 수는 5개이다.
			 * (100 + 100) + 80 + 150 < 500이지만 마지막 컬럼까지 더했으므로 생성해야 할 컬럼 div 수는 4개이다.
			 * 이 중 세번째 경우가 가장 많은 컬럼 div를 생성하는 경우이고, 이를 기준으로 삼는다.
			 */
			var i, j, nLength,
			nFrozenCols = this.attr('frozencols'),
			nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth,
			nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
			nTotalViewPortNormalColWidth,
			nDivCount,
			nColWidth;
			
			//console.log('nCols:' + nCols);
			//console.log('nHeaderCols:' + nHeaderCols);
			//console.log('nFrozenCols:' + nFrozenCols);
			//console.log('nFrozenColsWidth:' + nFrozenColsWidth);
			//console.log('colwidthsperpixel:' + this.attr('colwidthsperpixel'));
			
			//nFrozenColsWidth + 일반컬럼의 width합이 viewport의 width보다 크거나 같아지는 경우 중에서 가장 큰 경우를 찾는다.
			for(/*시작인덱스는 frozenCols 다음의 첫번째 normalCol의 인덱스*/i = nHeaderCols + nFrozenCols, nLength = nCols; /*마지막인덱스는 마지막 normalCol의 인덱스*/i < nLength; i++){
				nTotalViewPortNormalColWidth = nFrozenColsWidth;
				nDivCount = nFrozenCols;
				//var strLog = '[';
				for(j = i; j < nLength; j++){
					//console.log('비교', nTotalViewPortNormalColWidth, ',', nViewPortOffsetWidth);
					if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
						break;
					} else{
						nColWidth = this._getColWidth(j);
						nTotalViewPortNormalColWidth += nColWidth;
						nDivCount += 1;
						//strLog += j + ':' + nColWidth + ',';
					}
				}
				
				//strLog += ']';
				//console.log(strLog);
				//console.log('result:' + (nDivCount));
				
				if(nDivCount > nDynamicCols){
					nDynamicCols = nDivCount;
				}
			}
			
			//가로스크롤바가 오른쪽 끝에서 왼쪽으로 움직이는 경우도 고려해야 한다.
			for(i = nCols - 1, nLength = nHeaderCols + nFrozenCols; i >= nLength; i--){
				nTotalViewPortNormalColWidth = nFrozenColsWidth;
				nDivCount = nFrozenCols;
				//var strLog = '[';
				for(j = i; j >= nLength; j--){
					//console.log('비교', nTotalViewPortNormalColWidth, ',', nViewPortOffsetWidth);
					if(nTotalViewPortNormalColWidth >= nViewPortOffsetWidth){
						break;
					} else{
						nColWidth = this._getColWidth(j);
						nTotalViewPortNormalColWidth += nColWidth;
						nDivCount += 1;
						//strLog += j + ':' + nColWidth + ',';
					}
				}
				
				//strLog += ']';
				//console.log(strLog);
				//console.log('result:' + (nDivCount));
				
				if(nDivCount > nDynamicCols){
					nDynamicCols = nDivCount;
				}
			}
			
			//QCELL.log('log', 'BasicQCELL._calculateDynamicCols2', 'viewport\'s offsetWidth: ' + nViewPortOffsetWidth + 'px');
			//QCELL.log('log', 'BasicQCELL._calculateDynamicCols2', 'total FrozenCols\'s width: ' + nFrozenColsWidth + 'px');
			//QCELL.log('log', 'BasicQCELL._calculateDynamicCols2', 'nDynamicCols: ' + nDynamicCols);
		}
		
		objHSInfo.nDynamicCols = nDynamicCols;
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._calculateDynamicCols', e.message);
		return false;
	}
};

//QBOX.QCELL.BasicQCELL.prototype._calculateDynamicRows = function(){
//	var objVSInfo = this.attr('vsinfo'),
//	nDataRowHeight = this.attr('rowheight').data,
//	nViewPortOffsetHeight = this.attr('layoutsize').viewport.offsetHeight,
//	nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'),
//	nDynamicRows;
//	
//	nDynamicRows = parseInt(nViewPortOffsetHeight / nDataRowHeight) + ((nViewPortOffsetHeight % nDataRowHeight) > 0 ? 1 : 0);
//	
//	objVSInfo.nDynamicRows = nDynamicRows;
//};

QBOX.QCELL.BasicQCELL.prototype._calculateDynamicRows = function(){
	try{
		var objVSInfo = this.attr('vsinfo'),
		nHeaderRows = this.attr('headerrows'), nRows = this.attr('rows'),
		nDynamicRows = 0;
		
		if(nRows - nHeaderRows > 0){
			//생성해야 할 행 div의 수 계산
			//모든 스크롤바 위치에서 가장 많은 행이 표시되는 경우를 찾아 행 div의 수를 결정한다.
			/*
			 * 생성해야 할 행 div의 수는 어떻게 계산할까?
			 * frozenrows까지는 무조건 정적으로 만들어야 한다.
			 * 최악의 경우에 해당하는 행 div수를 계산해야 한다.
			 * headerrows가 2개이고, viewport의 clientheight가 500일 때
			 * rowheight가 [30, 30, 100, 100, 200, 400, 100, 80, 150]이고, headerrows가 2, frozenrows가 2일 때, frozenbottomrows가 2일 때,
			 * headerrows들을 제외하고 4개 행까지 height의 합이 500보다 크거나 같아지므로 생성해야 할 행 div 수는 4개이다.(100 + 100 + 200 + 400 >= 500)
			 * (100 + 100) + 400 >= 500이므로 생성해야 할 행 div 수는 3개이다.
			 * (100 + 100) + 100 + 80 + 150 >= 500이므로 생성해야 할 행 div 수는 5개이다.
			 * (100 + 100) + 80 + 150 < 500이지만 마지막 행까지 더했으므로 생성해야 할 컬럼 div 수는 4개이다.
			 * 이 중 세번째 경우가 가장 많은 행 div를 생성하는 경우이고, 이를 기준으로 삼는다.
			 */
			var i, j, nLength,
			nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'),
			nViewPortOffsetHeight = this.attr('layoutsize').viewport.offsetHeight,
			nFrozenRowsHeight = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
			nFrozenBottomRowsHeight = nFrozenBottomRows === 0 ? 0 : (this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1)),
			nTotalViewPortNormalRowHeight,
			nDivCount,
			nRowHeight;
			
			//console.log('nRows:' + nRows);
			//console.log('nFrozenRows:' + nFrozenRows);
			//console.log('nFrozenBottomRows:' + nFrozenBottomRows);
			
			if(true){
				//nFrozenRowsHeight + nFrozenBottomRowsHeight + 일반 행의 height합이 viewport의 height보다 크거나 같아지는 경우 중에서 가장 큰 경우를 찾는다.
				nTotalViewPortNormalRowHeight = nFrozenRowsHeight + nFrozenBottomRowsHeight;
				nDivCount = nFrozenRows + nFrozenBottomRows;
				
				//var strLog = '[';
				/*if(this.attr('useall') || this.attr('usetreeall')){
					for(j = nHeaderRows + nFrozenRows, nLength = nRows - nFrozenBottomRows; j < nLength; j++){
						nRowHeight = this._getRowHeight(j);
						nTotalViewPortNormalRowHeight += nRowHeight;
						nDivCount += 1;
							//strLog += j + ':' + nRowHeight + ',';
					}
				}else*/{
					for(j = nHeaderRows + nFrozenRows, nLength = nRows - nFrozenBottomRows; j < nLength; j++){
						//console.log('비교', nTotalViewPortNormalRowHeight, ',', nViewPortOffsetHeight);
						if(nTotalViewPortNormalRowHeight >= nViewPortOffsetHeight){
							break;
						} else{
							nRowHeight = this._getRowHeight(j);
							nTotalViewPortNormalRowHeight += nRowHeight;
							nDivCount += 1;
							//strLog += j + ':' + nRowHeight + ',';
						}
					}
					
				}
				
				//strLog += ']';
				//console.log(strLog);
				//console.log('result:' + (nDivCount));
				
				nDynamicRows = nDivCount;
			} else{//동적 rowHeight 변경 기능 구현 시 사용 할 것! -> 데이터 수 만큼 for문을 두번 돌아야 해서 시간이 걸린다.
				//nFrozenRowsHeight + nFrozenBottomRowsHeight + 일반 행의 height합이 viewport의 height보다 크거나 같아지는 경우 중에서 가장 큰 경우를 찾는다.
				for(/*시작인덱스는 frozenRows 다음의 첫번째 normalRow의 인덱스*/i = nHeaderRows + nFrozenRows, nLength = nRows - nFrozenBottomRows; /*마지막인덱스는 frozenBottomRows 이전의 마지막 normalRow의 인덱스*/i < nLength; i++){
					nTotalViewPortNormalRowHeight = nFrozenRowsHeight + nFrozenBottomRowsHeight;
					nDivCount = nFrozenRows + nFrozenBottomRows;
					//var strLog = '[';
					for(j = i; j < nLength; j++){
						//console.log('비교', nTotalViewPortNormalRowHeight, ',', nViewPortOffsetHeight);
						if(nTotalViewPortNormalRowHeight >= nViewPortOffsetHeight){
							break;
						} else{
							nRowHeight = this._getRowHeight(j);
							nTotalViewPortNormalRowHeight += nRowHeight;
							nDivCount += 1;
							//strLog += j + ':' + nRowHeight + ',';
						}
					}
					
					//strLog += ']';
					//console.log(strLog);
					//console.log('result:' + (nDivCount));
					
					if(nDivCount > nDynamicRows){
						nDynamicRows = nDivCount;
					}
				}
				
				//세로스크롤바가 최상단에서 최하단으로 움직이는 경우도 고려해야 한다.
				for(i = nRows - nFrozenBottomRows - 1; i >= nHeaderRows + nFrozenRows; i--){
					nTotalViewPortNormalRowHeight = nFrozenRowsHeight + nFrozenBottomRowsHeight;
					nDivCount = nFrozenRows + nFrozenBottomRows;
					//var strLog = '[';
					for(j = i; j >= nHeaderRows + nFrozenRows; j--){
						if(nTotalViewPortNormalRowHeight >= nViewPortOffsetHeight){
							break;
						} else{
							nRowHeight = this._getRowHeight(j);
							nTotalViewPortNormalRowHeight += nRowHeight;
							nDivCount += 1;
							//strLog += j + ':' + nRowHeight + ',';
						}
					}
					
					//strLog += ']';
					//console.log(strLog);
					//console.log('result:' + (nDivCount));
					
					if(nDivCount > nDynamicRows){
						nDynamicRows = nDivCount;
					}
				}
			}
			
			objVSInfo.nDynamicRows = nDynamicRows;
			
			//QCELL.log('log', 'BasicQCELL._calculateDynamicRows2', 'viewport\'s offsetHeight: ' + nViewPortOffsetHeight + 'px');
			//QCELL.log('log', 'BasicQCELL._calculateDynamicRows2', 'total FrozenRows\'s height: ' + nFrozenRowsHeight + 'px');
			//QCELL.log('log', 'BasicQCELL._calculateDynamicRows2', 'total FrozenBottomRows\'s height: ' + nFrozenBottomRowsHeight + 'px');
			//QCELL.log('log', 'BasicQCELL._calculateDynamicRows2', 'nDynamicRows: ' + nDynamicRows);
		}
		
		objVSInfo.nDynamicRows = nDynamicRows;
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._calculateDynamicRows', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._initLayoutSize = function(){
	try{
		var objLayoutSize = this.attr('layoutsize'),
		objVSInfo = this.attr('vsinfo'),
		objHSInfo = this.attr('hsinfo'),
		objRowHeight = this.attr('rowheight'),
		objContainerOffset,
		objPaginationInfo = this.attr('paginationinfo'),
		htElementPool = this.attr('elementpool'),
		heRoot = htElementPool.get('root'), hePanel = htElementPool.get('panel'), heContainer = htElementPool.get('container'), hePaginationPanel = htElementPool.get('paginationpanel'), heSheetPanel = htElementPool.get('sheetpanel'), 
		heViewPort = htElementPool.get('viewport'), heFooterRowHeader = htElementPool.get('footerrowheader'), heFooter = htElementPool.get('footer'), heEdgeHeader = htElementPool.get('edgeheader'), heRowHeader = htElementPool.get('rowheader'), heColHeader = htElementPool.get('colheader'), heHScrollbar = htElementPool.get('hscrollbar'), heVScrollbar = htElementPool.get('vscrollbar'),
		nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'), nFooterRows = this.attr('footerrows'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nHeaderRowHeight = objRowHeight.header, nDataRowHeight = objRowHeight.data, nFooterRowHeight = objRowHeight.footer,
		nFooterRowsHeight = nFooterRowHeight * nFooterRows,
		nScrollBarWidth = this.attr('scrollbarwidth'),
		$parent = QBOX.$(this.attr('parent')),
		$parentWidth = $parent.width();
		
		//1. root size 설정
		heRoot.style.width = this.attr('width');
		heRoot.style.height = this.attr('height');
		objLayoutSize.root = {
			offsetLeft		: heRoot.offsetLeft,
			offsetTop		: heRoot.offsetTop,
			offsetWidth		: heRoot.offsetWidth > $parent.width() ? $parent.width() : heRoot.offsetWidth,
			offsetHeight	: heRoot.offsetHeight,
			clientWidth		: heRoot.clientWidth > $parent.width() ? $parent.width() : heRoot.clientWidth,
			clientHeight	: heRoot.clientHeight
		};
		
		//2. panel size 설정
		
		//console.log(QBOX.QCELL.module);
		//console.log(this.attrList());
		//console.log(this.attr('useGroupUI'));
		//hePanel.style.backgroundColor = "yellow";
		hePanel.style.width = objLayoutSize.root.clientWidth + 'px';
		hePanel.style.height = '0px';
		hePanel.style.display = 'none';
		objLayoutSize.panel = {
			offsetTop		: 0,
			offsetWidth		: 0,
			offsetHeight	: 0,
			clientWidth		: 0,
			clientHeight	: 0
		};
		
		if(this.attr('useGroupUI')){
			//hePanel.style.backgroundColor = "silver";
			hePanel.style.width = objLayoutSize.root.clientWidth + 'px';
			hePanel.style.height = '40px';
			hePanel.style.display = 'block';
			objLayoutSize.panel = {
				offsetTop		: hePanel.offsetTop,
				offsetWidth		: hePanel.offsetWidth,
				offsetHeight	: hePanel.offsetHeight,
				clientWidth		: hePanel.clientWidth,
				clientHeight	: hePanel.clientHeight
			};
		}
		
//		objLayoutSize.panel = {
//			offsetTop		: hePanel.offsetTop,
//			offsetWidth		: hePanel.offsetWidth,
//			offsetHeight	: hePanel.offsetHeight,
//			clientWidth		: hePanel.clientWidth,
//			clientHeight	: hePanel.clientHeight
//		};
//		hePanel.style.display = objLayoutSize.panel.clientHeight > 0 ? '' : 'none';
		
		//3. SheetPanel size, position 설정
		heSheetPanel.style.width = hePanel.style.width;
		heSheetPanel.style.height = this.attr('bottompanelheight')+'px';
		heSheetPanel.style.left = objLayoutSize.container.clientX+'px';
		heSheetPanel.style.top = (objLayoutSize.root.offsetTop + (objLayoutSize.root.offsetHeight - parseFloat(heSheetPanel.style.height))) + 'px';
		heSheetPanel.style.display = 'none';
		objLayoutSize.sheetpanel = {
			offsetTop		: 0,
			offsetWidth		: 0,
			offsetHeight	: 0,
			clientWidth		: 0,
			clientHeight	: 0
		};
		//console.log(this.attr('bottompanel'));
		if(this.attr('bottompanel')){
			//heSheetPanel.style.backgroundColor = "#202534";
			
			//console.log(objLayoutSize);
			//console.log(this.attr('bottompanelheight'));
			
			/*
			heSheetPanel.style.width = hePanel.style.width;
			heSheetPanel.style.height = this.attr('bottompanelheight')+'px';
			heSheetPanel.style.left = objLayoutSize.container.clientX+'px';
			heSheetPanel.style.top = (objLayoutSize.root.offsetTop + (objLayoutSize.root.offsetHeight - parseFloat(heSheetPanel.style.height))) + 'px';
			*/
			heSheetPanel.style.display = 'block';
			
			objLayoutSize.sheetpanel = {
				offsetTop		: heSheetPanel.offsetTop,
				offsetWidth		: heSheetPanel.offsetWidth,
				offsetHeight	: heSheetPanel.offsetHeight,
				clientWidth		: heSheetPanel.clientWidth,
				clientHeight	: heSheetPanel.clientHeight
			};
		}
//		heSheetPanel.style.display = objLayoutSize.sheetpanel.clientHeight > 0 ? '' : 'none';
		
		// pagination size, position 설정
		hePaginationPanel.style.width = hePanel.style.width;
		hePaginationPanel.style.height = QBOX._.isEmpty(objPaginationInfo) === false ? '30px' : '0px';
		hePaginationPanel.style.top = (objLayoutSize.root.offsetTop + (objLayoutSize.root.offsetHeight - parseFloat(hePaginationPanel.style.height)) - objLayoutSize.sheetpanel.offsetHeight ) + 'px';
		objLayoutSize.paginationpanel =
			QBOX._.isEmpty(objPaginationInfo) === false ?
		{
			offsetTop		: hePaginationPanel.offsetTop,
			offsetWidth		: hePaginationPanel.offsetWidth,
			offsetHeight	: hePaginationPanel.offsetHeight,
			clientWidth		: hePaginationPanel.clientWidth,
			clientHeight	: hePaginationPanel.clientHeight
		} :
		{
			offsetTop		: 0,
			offsetWidth		: 0,
			offsetHeight	: 0,
			clientWidth		: 0,
			clientHeight	: 0
		};
		hePaginationPanel.style.display = QBOX._.isEmpty(objPaginationInfo) === false ? objLayoutSize.paginationpanel.clientHeight > 0 ? '' : 'none' : 'none';
		
		//4. container size, position 설정
		if(hePanel.style.display === 'none'){
			heContainer.style.top = '';
		} else{
			heContainer.style.top = (objLayoutSize.panel.offsetTop + objLayoutSize.panel.offsetHeight) + 'px'; //향 후 panel영역에 border가 들어갈 가능성이 있으므로 clientHeight가 아닌  offsetHeight로 top을 설정해야 한다.
		}
		heContainer.style.width = hePanel.style.width;
		heContainer.style.height = (objLayoutSize.root.clientHeight - objLayoutSize.panel.offsetHeight - objLayoutSize.sheetpanel.offsetHeight - objLayoutSize.paginationpanel.offsetHeight) + 'px';
		objContainerOffset = htElementPool.get('$container').offset();
		objLayoutSize.container = {
			clientX			: parseInt(objContainerOffset.left),	//브라우저 기준 절대위치
			clientY			: parseInt(objContainerOffset.top),		//브라우저 기준 절대위치
			offsetTop		: heContainer.offsetTop,
			offsetWidth		: heContainer.offsetWidth,
			offsetHeight	: heContainer.offsetHeight,
			clientWidth		: heContainer.clientWidth,
			clientHeight	: heContainer.clientHeight
		};
		
		//6. edgeheader size 설정
		heEdgeHeader.style.width = (nHeaderCols * this.attr('headercolwidth')) + 'px';
		heEdgeHeader.style.height = (nHeaderRows * nHeaderRowHeight) + 'px';
		objLayoutSize.edgeheader = {
			offsetWidth		: heEdgeHeader.offsetWidth,
			offsetHeight	: heEdgeHeader.offsetHeight,
			clientWidth		: heEdgeHeader.clientWidth,
			clientHeight	: heEdgeHeader.clientHeight
		};
		
		//7. vscrollbar 표시여부 확인
		objVSInfo.bVScroll = (this.attr('currentdata').length * nDataRowHeight > objLayoutSize.container.offsetHeight - objLayoutSize.edgeheader.offsetHeight - nFooterRowsHeight) ? true : false;
		//objVSInfo.bVScroll = true;
		//if(objVSInfo.bVScroll){console.log('vscrollbar 생성');}
		
		//8. colheader의 width 설정
		heColHeader.style.width = (objLayoutSize.container.offsetWidth - objLayoutSize.edgeheader.offsetWidth - (objVSInfo.bVScroll ? nScrollBarWidth : 0)) + 'px';
		if(objLayoutSize.colheader === undefined){
			objLayoutSize.colheader = {};
		}
		objLayoutSize.colheader = {
			offsetWidth		: (objLayoutSize.container.offsetWidth - objLayoutSize.edgeheader.offsetWidth - (objVSInfo.bVScroll ? nScrollBarWidth : 0)),
			offsetHeight	: 0,
			clientWidth		: 0,
			clientHeight	: 0
		};
		
		//9. hscrollbar 표시 여부 확인
		objHSInfo.bHScroll = (/*전체 사용자 컬럼 width의 합*/(this._getTotalColWidth())/*.toFixed(2)*/ > objLayoutSize.edgeheader.offsetWidth + objLayoutSize.colheader.offsetWidth) ? true : false;
		//if(objHSInfo.bHScroll){console.log('hscrollbar 생성');}
		
		//10. viewport의 height 설정
		heViewPort.style.height = (objLayoutSize.container.offsetHeight - objLayoutSize.edgeheader.offsetHeight - nFooterRowsHeight - (objHSInfo.bHScroll ? nScrollBarWidth : 0)) + 'px';
		objLayoutSize.viewport = {
			offsetWidth		: 0,
			offsetHeight	: heViewPort.offsetHeight,
			clientWidth		: 0,
			clientHeight	: 0
		};
		
		//10. vscrollbar 표시여부 재확인
		if(objVSInfo.bVScroll === false){
			if(objHSInfo.bHScroll){
				//가로스크롤바가 생성되어 계산해야 되는 height가 줄어들었으므로 세로스크롤바 생성여부를 재계산한다.
				objVSInfo.bVScroll = (this.attr('currentdata').length * nDataRowHeight > objLayoutSize.viewport.offsetHeight) ? true : false;
				
				if(objVSInfo.bVScroll){
					//세로스크롤바가 생성되어 계산해야 되는 width가 줄어들었으므로 colheader의 width를 재계산한다.
					heColHeader.style.width = (objLayoutSize.container.offsetWidth - objLayoutSize.edgeheader.offsetWidth - nScrollBarWidth) + 'px';
				}
			}
		}
		
		//11. colheader size, position 설정
		heColHeader.style.height = heEdgeHeader.style.height;
		heColHeader.style.left = (objLayoutSize.edgeheader.offsetWidth + heEdgeHeader.offsetLeft)  + 'px';
		objLayoutSize.colheader.offsetLeft = heColHeader.offsetLeft;
		objLayoutSize.colheader.offsetTop = heColHeader.offsetTop;
		objLayoutSize.colheader.offsetWidth = heColHeader.offsetWidth;
		objLayoutSize.colheader.offsetHeight = heColHeader.offsetHeight;
		objLayoutSize.colheader.clientWidth = heColHeader.clientWidth;
		objLayoutSize.colheader.clientHeight = heColHeader.clientHeight;
		
		//12. viewport size, position 설정
		heViewPort.style.width = heColHeader.style.width;
		heViewPort.style.left = heColHeader.style.left;
		heViewPort.style.top = (objLayoutSize.edgeheader.offsetHeight + heEdgeHeader.offsetTop) + 'px';
		objLayoutSize.viewport.offsetLeft = heViewPort.offsetLeft;
		objLayoutSize.viewport.offsetTop = heViewPort.offsetTop;
		objLayoutSize.viewport.offsetWidth = heViewPort.offsetWidth;
		objLayoutSize.viewport.clientWidth = heViewPort.clientWidth;
		objLayoutSize.viewport.clientHeight = heViewPort.clientHeight;
		
		//13. rowheader size, position 설정
		heRowHeader.style.width = heEdgeHeader.style.width;
		heRowHeader.style.height = heViewPort.style.height;
		heRowHeader.style.top = heViewPort.style.top;
		objLayoutSize.rowheader = {
			offsetWidth		: heRowHeader.offsetWidth,
			offsetHeight	: heRowHeader.offsetHeight,
			clientWidth		: heRowHeader.clientWidth,
			clientHeight	: heRowHeader.clientHeight
		};
		
		//14. heFooterRowHeader의 size, position 설정
		heFooterRowHeader.style.width = heRowHeader.style.width;
		heFooterRowHeader.style.height = nFooterRowsHeight + 'px';
		heFooterRowHeader.style.top = (objLayoutSize.viewport.offsetHeight + heViewPort.offsetTop) + 'px';
		if(objLayoutSize.footerrowheader === undefined){
			objLayoutSize.footerrowheader = {};
		}
		if(nFooterRowsHeight === 0){
			objLayoutSize.footerrowheader = {
				offsetWidth		: 0,
				offsetHeight	: 0,
				clientWidth		: 0,
				clientHeight	: 0
			};
			heFooterRowHeader.style.display = 'none';
		} else{
			objLayoutSize.footerrowheader = {
				offsetWidth		: heFooterRowHeader.offsetWidth,
				offsetHeight	: heFooterRowHeader.offsetHeight,
				clientWidth		: heFooterRowHeader.clientWidth,
				clientHeight	: heFooterRowHeader.clientHeight
			};
			heFooterRowHeader.style.display = '';
		}

		//15. heFooter의 size, position 설정
		heFooter.style.width = heColHeader.style.width;
		heFooter.style.height = heFooterRowHeader.style.height;
		heFooter.style.left = heColHeader.style.left;
		heFooter.style.top = heFooterRowHeader.style.top;
		if(objLayoutSize.footer === undefined){
			objLayoutSize.footer = {};
		}
		if(nFooterRowsHeight === 0){
			objLayoutSize.footer = {
				offsetTop		: objLayoutSize.viewport.offsetTop + objLayoutSize.viewport.offsetHeight,
				offsetWidth		: 0,
				offsetHeight	: 0,
				clientWidth		: 0,
				clientHeight	: 0
			};
			heFooter.style.display = 'none';
		} else{
			objLayoutSize.footer = {
				offsetTop		: heFooter.offsetTop,
				offsetWidth		: heFooter.offsetWidth,
				offsetHeight	: heFooter.offsetHeight,
				clientWidth		: heFooter.clientWidth,
				clientHeight	: heFooter.clientHeight
			};
			heFooter.style.display = '';
		}
		//heFooter.style.display = nFooterRows > 0 ? '' : 'none';
		
		//16. 실제 colwidth 계산(세로 스크롤바 생성 여부에 따라 viewport의 크기가 달라지므로 viewport의 크기가 결정되고 나서 컬럼의 width를 계산해야 한다.)
		this._calculateRealColWidth();
		
		//17. hscrollbar size, position 설정
		if(objLayoutSize.hscrollbar === undefined){
			objLayoutSize.hscrollbar = {};
		}
		if(objHSInfo.bHScroll){
			heHScrollbar.style.display = '';
			heHScrollbar.style.width = (objLayoutSize.rowheader.offsetWidth + objLayoutSize.viewport.offsetWidth + 1) + 'px';//+1을 해주는 이유는 vscrollbar 영역의 right border와 맞추기 위해서이다. 
			heHScrollbar.style.height = (nScrollBarWidth + 1) + 'px';//스크롤바플러그인으로 가로스크롤바 사용시 아래도 UI가 아래로 붙어버려 보정이 필요함.
			heHScrollbar.style.top = (objLayoutSize.footer.offsetTop + objLayoutSize.footer.offsetHeight) + 'px';
			objLayoutSize.hscrollbar = {
				offsetWidth		: heHScrollbar.offsetWidth,
				offsetHeight	: heHScrollbar.offsetHeight,
				clientWidth		: heHScrollbar.clientWidth,
				clientHeight	: heHScrollbar.clientHeight
			};
		} else{
			heHScrollbar.style.display = 'none';
			objLayoutSize.hscrollbar = {
				offsetWidth		: 0,
				offsetHeight	: 0,
				clientWidth		: 0,
				clientHeight	: 0
			};
		}
		
		//18. vscrollbar size, position 설정
		if(objLayoutSize.vscrollbar === undefined){
			objLayoutSize.vscrollbar = {};
		}
		if(objVSInfo.bVScroll){
			heVScrollbar.style.display = '';
			heVScrollbar.style.width = nScrollBarWidth + 'px';
			//heVScrollbar.style.height = (objLayoutSize.colheader.offsetHeight + objLayoutSize.rowheader.offsetHeight + 1) + 'px';//+1을 해주는 이유는 hscrollbar 영역의 top border와 맞추기 위해서이다.
			heVScrollbar.style.height = (objLayoutSize.container.offsetHeight - objLayoutSize.hscrollbar.offsetHeight + 2) + 'px';//+2을 해주는 이유는 hscrollbar 영역의 top border와 맞추기 위해서이다.
			heVScrollbar.style.left = (objLayoutSize.colheader.offsetLeft + objLayoutSize.colheader.offsetWidth) + 'px';
			//heVScrollbar.style.top = (objLayoutSize.colheader.offsetTop + objLayoutSize.colheader.offsetHeight) + 'px';
			
			objLayoutSize.vscrollbar = {
				offsetWidth		: heVScrollbar.offsetWidth,
				offsetHeight	: heVScrollbar.offsetHeight,
				clientWidth		: heVScrollbar.clientWidth,
				clientHeight	: heVScrollbar.clientHeight
			};
		} else{
			heVScrollbar.style.display = 'none';
			objLayoutSize.vscrollbar = {
				offsetWidth		: 0,
				offsetHeight	: 0,
				clientWidth		: 0,
				clientHeight	: 0
			};
		}
		
		// tooltip의 생성 초기화
		this.attr('tooltipvisible', false, 'boolean');
		
		var THAT = this;
		setTimeout(function(){
			if($parentWidth > $parent.width()){
				THAT._initLayoutSize();
			}
		}, 0);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._initLayoutSize', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._getRowHeight = function(nRow){
	var htDynamicRowHeight = this.attr('dynamicrowheight'), objRowHeight = this.attr('rowheight'),
	nHeaderRows = this.attr('headerrows'), nHeaderRowHeight = objRowHeight.header, nDataRowHeight = objRowHeight.data;
	return nRow < nHeaderRows ? nHeaderRowHeight : (htDynamicRowHeight.containsKey(nRow) ? htDynamicRowHeight.get(nRow) : nDataRowHeight);
};

// rowheader data 초기 셋팅
QBOX.QCELL.BasicQCELL.prototype._initRowheaderData = function() {
	var arrRowHeaders = this.attr('rowheaders'),
	arrHeaderRows = this.attr('headerrows'),
	nCurrentdataLength = this.attr('currentdata').length,
	arrRowheaderdata = [],
	arrRowheaderCheckboxClick = [],
	i = 0, j = 0;
	
	for(i = 0; i < arrHeaderRows; i++){
		var arrHeaderRowCheckbox = [];
		for(j = 0; j < arrRowHeaders.length; j++) {
			if(arrRowHeaders[j] === 'checkbox') {
				arrHeaderRowCheckbox.push(true);
			} else {
				arrHeaderRowCheckbox.push(false);
			}
		}
		arrRowheaderCheckboxClick.push(arrHeaderRowCheckbox);
	}
	
	for(i = 0; i < nCurrentdataLength; i++) {
		var arrRowdata = [], arrRowCheckbox = [];
		for(j = 0; j < arrRowHeaders.length; j++) {
			if(arrRowHeaders[j] === 'sequence') {
				arrRowdata.push(i+1);
				arrRowCheckbox.push(false);
			} else if(arrRowHeaders[j] === 'reverse') {
				arrRowdata.push((nCurrentdataLength-(i)));
				arrRowCheckbox.push(false);
			} else if(arrRowHeaders[j] === 'checkbox' || arrRowHeaders[j] === 'radio') { // rowheader의 type이 checkbox일 때 초기값은 false
				arrRowdata.push(false);
				arrRowCheckbox.push(true);
			} else if(arrRowHeaders[j] === 'state') {
				arrRowdata.push('n');
				arrRowCheckbox.push(false);
			}else if(arrRowHeaders[j] === 'custom') {
				arrRowdata.push('');
				arrRowCheckbox.push(false);
			}
		}
		arrRowheaderdata.push(arrRowdata);
		arrRowheaderCheckboxClick.push(arrRowCheckbox);
	}
	
	this.attr('rowheaderdata', arrRowheaderdata, 'array');
	this.attr('rowheadercheckboxclick', arrRowheaderCheckboxClick, 'array');
	
	return true;
};

// addrow, removerow와 같은 row정보 변경시 rowheader 정보 동기화
QBOX.QCELL.BasicQCELL.prototype._updateRowheaderData = function(arrRowheaderData, arrRowHeadersCheckbox) {
	var arrRowHeaders = this.attr('rowheaders'),
	arrHeaderRows = this.attr('headerrows'),
	nCurrentdataLength = this.attr('currentdata').length,
	arrRowheaderdata = [],
	arrRowheaderCheckboxClick = [],
	i = 0, j = 0;
	
	for(i = 0; i < arrHeaderRows; i++){
		var arrHeaderRowCheckbox = [];
		for(j = 0; j < arrRowHeaders.length; j++) {
			if(arrRowHeaders[j] === 'checkbox') {
				arrHeaderRowCheckbox.push(true);
			} else {
				arrHeaderRowCheckbox.push(false);
			}
		}
		arrRowheaderCheckboxClick.push(arrHeaderRowCheckbox);
	}
	
	for(i = 0; i < nCurrentdataLength; i++) {
		var arrRowdata = [], arrRowCheckbox = [];
		for(j = 0; j < arrRowHeaders.length; j++) {
			if(arrRowHeaders[j] === 'sequence') {
				arrRowdata.push(i+1);
				arrRowCheckbox.push(false);
			} else if(arrRowHeaders[j] === 'reverse') {
				arrRowdata.push((nCurrentdataLength-(i)));
				arrRowCheckbox.push(false);
			} else if(arrRowHeaders[j] === 'checkbox') {
				var bChk = false; // checkbox의 초기값은 false
				var bRowChk = true; // 초기값 true
				
				if(QBOX._.isUndefined(arrRowheaderData[i]) === false) { // 데이터가 존재하지 않는 지 확인
					bChk = QBOX._.isUndefined(arrRowheaderData[i][j]) ? false : arrRowheaderData[i][j];
				}
				if(QBOX._.isUndefined(arrRowHeadersCheckbox[i]) === false) { // 데이터가 존재하지 않는 지 확인
					bRowChk = QBOX._.isUndefined(arrRowHeadersCheckbox[i][j]) ? true : arrRowHeadersCheckbox[i][j];
				}
				
				arrRowdata.push(bChk);
				arrRowCheckbox.push(bRowChk);
			} else if (arrRowHeaders[j] === 'state') {
				arrRowdata.push(this._getRowState(i+1));
				arrRowCheckbox.push(false);
			} else {
				arrRowdata.push('');
				arrRowCheckbox.push(false);
			}
		}
		arrRowheaderdata.push(arrRowdata);
		arrRowheaderCheckboxClick.push(arrRowCheckbox);
	}
	
	this.attr('rowheaderdata', arrRowheaderdata, 'array');
	this.attr('rowheadercheckboxclick', arrRowheaderCheckboxClick, 'array');
	
	return true;
};

// rowheaderdata 정보 가져오기
QBOX.QCELL.BasicQCELL.prototype._getRowheaderData = function(nRow, nCol) {
	nRow = nRow - this.attr('headerrows');
	
	if(this.attr('rowheaderdata')[nRow] === undefined){
		return false;
	}
		
	
	return this.attr('rowheaderdata')[nRow][nCol];
};

// rowheader 정보 설정
QBOX.QCELL.BasicQCELL.prototype._setRowheaderData = function(nRow, nCol, val) {
	var arrRowHeaders = this.attr('rowheaders'),
	bResult = true;
	
	// 내부 배열에서 row의 주소값이 0부터 시작하기 때문에 headerrows의 값을 제거한 값이 시작 row값이 된다.
	nRow = nRow - this.attr('headerrows');
	
	if(nRow >= this.attr('rowheaderdata').length){
		return false;
	}
	
	if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
		if(QBOX._.isNumber(val) === false) {
			bResult = false;
		}
	} else if(arrRowHeaders[nCol] === 'checkbox') {
		if(QBOX._.isBoolean(val) === false) {
			bResult = false;
		}
	}else if(arrRowHeaders[nCol] === 'radio') {
		for(var i=0;i<this.attr('rowheaderdata').length;i++){
			if(i === nRow)
				this.attr('rowheaderdata')[nRow][nCol] = val;
			else
				this.attr('rowheaderdata')[i][nCol] = false;
		}
		return false;
	}else {	
		bResult = false;
	}
	
	if(bResult) {
		this.attr('rowheaderdata')[nRow][nCol] = val;
	}
	
	return bResult;
};

// rowheader checkbox click 시 동작 설정
QBOX.QCELL.BasicQCELL.prototype._rowheaderCheckboxClick = function(nRow, nCol, bState) {
	var heParentElement = this._getCellDOM(nRow, nCol),
	heTargetElement = heParentElement.childNodes[0],
	strTargetName = heTargetElement.name,
	targetCell,
	tRow = -1, tCol = -1,
	bInvisible = false, bDisable = false;
	
	this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
	
	if(strTargetName.indexOf('_all') > -1){ // 전체 선택 rowheader checkbox click
		
		var strName = strTargetName.replace('_all', ''),
		arrCheckboxs = document.getElementsByName(strName);
		
		heTargetElement.checked = bState;
		
		for(var i = 0; i < arrCheckboxs.length; i++) { // 화면에 보이는 checkbox 처리
			targetCell = arrCheckboxs[i].parentNode;
			tRow = targetCell.getAttribute('data-row');
			tCol = targetCell.getAttribute('data-col');
			
			bInvisible = this._getQCellCol(tCol).attr('cellinvisible')[tRow];
			bDisable = this._getQCellCol(tCol).attr('celldisabled')[tRow];
			
			if(!bInvisible && !bDisable){
				arrCheckboxs[i].checked = bState;
			}
		}
		
		for(var k = this.attr('headerrows'); k < this.attr('rows'); k++) { // 전체 데이터의 checkbox 처리
			//console.log('invisible', nCol, k, this._getQCellCol(nCol).attr('cellinvisible')[k]);
			//console.log('disabled', nCol, k, this._getQCellCol(nCol).attr('celldisabled')[k]);
			
			bInvisible = this._getQCellCol(nCol).attr('cellinvisible')[k];
			bDisable = this._getQCellCol(nCol).attr('celldisabled')[k];
			
			if(!bInvisible && !bDisable){
				this._setRowheaderData(k, nCol, bState);
			}
		}
	} else { // 전체 선택 외 rowheader checkbox click
		
		// 전체 선택 rowheader checkbox의 DOM 주소 및 checkbox 정보 획득
		var heheaderCell = this._getCellDOM(0, nCol), // edge는 항상 병합되어 있기 때문에 Row index는 0
		headerCheckbox = heheaderCell.childNodes[0];
		
		// click 한 rowheader의 정보 설정
		this._setRowheaderData(nRow, nCol, bState);
		
		heTargetElement.checked = bState;
		
		if(bState) {
			// 모든 rowheader checbox가 check 되어 있으면 header 영역에 전체 선택 checkbox check 설정
			var checklength = 0;
			for(var j = this.attr('headerrows'), j_len = this.attr('rows'); j < j_len; j++) { // 전체 데이터 확인
				if(this._getRowheaderData(j, nCol) === true){ // check가 되어 있으면 checklength 1씩증가
					checklength++;
				}
			}
			
			if(checklength === this.attr('rowheaderdata').length){ // 현재 화면의 데이터와 checklength 값이 동일하면
				headerCheckbox.checked = true; // headercheckbox check 처리
			}
		} else {
			// check 해지 되었을 때 전체 선택 checkbox에 check가 되어 있을 시 동작
			if(headerCheckbox.checked === true){
				headerCheckbox.checked = false;
			}
		}
	}
};
QBOX.QCELL.BasicQCELL.prototype._setRowheaderState = function(heCell, nRow) {
	var jqCell = QBOX.$(heCell), strState = this._getRowState(nRow), css = QBOX.QCELL.def.css;
	
	if(strState === 'n' && jqCell.hasClass(css.ROWHEADER_STATE_INIT))
		return;
	
	jqCell.removeClass(css.ROWHEADER_STATE_INSERT);
	jqCell.removeClass(css.ROWHEADER_STATE_UPDATE);
	jqCell.removeClass(css.ROWHEADER_STATE_DELETE);
	jqCell.removeClass(css.ROWHEADER_STATE_INIT);	
	
	switch(strState){
		case 'n' : jqCell.addClass(css.ROWHEADER_STATE_INIT);break;
		case 'i' : jqCell.addClass(css.ROWHEADER_STATE_INSERT);break;
		case 'u' : jqCell.addClass(css.ROWHEADER_STATE_UPDATE);break;
		case 'd' : jqCell.addClass(css.ROWHEADER_STATE_DELETE);break;		
	}
};
QBOX.QCELL.BasicQCELL.prototype._setRowheaderCustom = function(heCell, nRow, nCol) {
	var nHeaderRows = this.attr('headerrows'), arrOptions = this.attr('rowheaderoptions'),objOption,strHtml;
	if(arrOptions === null || arrOptions === undefined)
		return;
	
	for(var i=0;i<arrOptions.length;i++){
		objOption = arrOptions[i];
		if(objOption.col !== undefined && objOption.col === nCol){
			if(nRow < nHeaderRows){
				if(objOption.header !== undefined && QBOX._.isFunction(objOption.header)){
					strHtml = objOption.header(this,nRow,nCol);
					heCell.innerHTML = strHtml;
				}
			}else{
				if(objOption.data !== undefined && QBOX._.isFunction(objOption.data)){
					strHtml = objOption.data(this,nRow,nCol);
					heCell.innerHTML = strHtml;
				}				
			}
		}
	}
};


QBOX.$(function(){
	
	/* 
	----------------------------------------
	PLUGIN NAMESPACE, PREFIX, DEFAULT SELECTOR(S) 
	----------------------------------------
	*/
	
	/* 
	----------------------------------------
	PLUGIN NAMESPACE, PREFIX, DEFAULT SELECTOR(S) 
	----------------------------------------
	*/
	
	var pluginNS="rt_qc_mCSbar",
		pluginPfx="rt_qc_mCS",
		defaultSelector=".rt_qc_mCSbar",
	
	
		
	
	
	/* 
	----------------------------------------
	DEFAULT OPTIONS 
	----------------------------------------
	*/
	
		defaults={
			/*
			set element/content width/height programmatically 
			values: boolean, pixels, percentage 
				option						default
				-------------------------------------
				setWidth					false
				setHeight					false
			*/
			/*
			set the initial css top property of content  
			values: string (e.g. "-100px", "10%" etc.)
			*/
			setTop:0,
			/*
			set the initial css left property of content  
			values: string (e.g. "-100px", "10%" etc.)
			*/
			setLeft:0,
			/* 
			scrollbar axis (vertical and/or horizontal scrollbars) 
			values (string): "y", "x", "yx"
			*/
			axis:"y",
			/*
			position of scrollbar relative to content  
			values (string): "inside", "outside" ("outside" requires elements with position:relative)
			*/
			scrollbarPosition:"inside",
			/*
			scrolling inertia
			values: integer (milliseconds)
			*/
			scrollInertia:950,
			/* 
			auto-adjust scrollbar dragger length
			values: boolean
			*/
			autoDraggerLength:true,
			/*
			auto-hide scrollbar when idle 
			values: boolean
				option						default
				-------------------------------------
				autoHideScrollbar			false
			*/
			/*
			auto-expands scrollbar on mouse-over and dragging
			values: boolean
				option						default
				-------------------------------------
				autoExpandScrollbar			false
			*/
			/*
			always show scrollbar, even when there's nothing to scroll 
			values: integer (0=disable, 1=always show dragger rail and buttons, 2=always show dragger rail, dragger and buttons), boolean
			*/
			alwaysShowScrollbar:0,
			/*
			scrolling always snaps to a multiple of this number in pixels
			values: integer, array ([y,x])
				option						default
				-------------------------------------
				snapAmount					null
			*/
			/*
			when snapping, snap with this number in pixels as an offset 
			values: integer
			*/
			snapOffset:0,
			/* 
			mouse-wheel scrolling
			*/
			mouseWheel:{
				/* 
				enable mouse-wheel scrolling
				values: boolean
				*/
				enable:true,
				/* 
				scrolling amount in pixels
				values: "auto", integer 
				*/
				scrollAmount:"auto",
				/* 
				mouse-wheel scrolling axis 
				the default scrolling direction when both vertical and horizontal scrollbars are present 
				values (string): "y", "x" 
				*/
				axis:"y",
				/* 
				prevent the default behaviour which automatically scrolls the parent element(s) when end of scrolling is reached 
				values: boolean
					option						default
					-------------------------------------
					preventDefault				null
				*/
				/*
				the reported mouse-wheel delta value. The number of lines (translated to pixels) one wheel notch scrolls.  
				values: "auto", integer 
				"auto" uses the default OS/browser value 
				*/
				deltaFactor:"auto",
				/*
				normalize mouse-wheel delta to -1 or 1 (disables mouse-wheel acceleration) 
				values: boolean
					option						default
					-------------------------------------
					normalizeDelta				null
				*/
				/*
				invert mouse-wheel scrolling direction 
				values: boolean
					option						default
					-------------------------------------
					invert						null
				*/
				/*
				the tags that disable mouse-wheel when cursor is over them
				*/
				disableOver:["select","option","keygen","datalist","textarea"]
			},
			/* 
			scrollbar buttons
			*/
			scrollButtons:{ 
				/*
				enable scrollbar buttons
				values: boolean
					option						default
					-------------------------------------
					enable						null
				*/
				/*
				scrollbar buttons scrolling type 
				values (string): "stepless", "stepped"
				*/
				scrollType:"stepless",
				/*
				scrolling amount in pixels
				values: "auto", integer 
				*/
				scrollAmount:"auto"
				/*
				tabindex of the scrollbar buttons
				values: false, integer
					option						default
					-------------------------------------
					tabindex					null
				*/
			},
			/* 
			keyboard scrolling
			*/
			keyboard:{ 
				/*
				enable scrolling via keyboard
				values: boolean
				*/
				enable:true,
				/*
				keyboard scrolling type 
				values (string): "stepless", "stepped"
				*/
				scrollType:"stepless",
				/*
				scrolling amount in pixels
				values: "auto", integer 
				*/
				scrollAmount:"auto"
			},
			/*
			enable content touch-swipe scrolling 
			values: boolean, integer, string (number)
			integer values define the axis-specific minimum amount required for scrolling momentum
			*/
			contentTouchScroll:25,
			/*
			enable/disable document (default) touch-swipe scrolling 
			*/
			documentTouchScroll:true,
			/*
			advanced option parameters
			*/
			advanced:{
				/*
				auto-expand content horizontally (for "x" or "yx" axis) 
				values: boolean, integer (the value 2 forces the non scrollHeight/scrollWidth method, the value 3 forces the scrollHeight/scrollWidth method)
					option						default
					-------------------------------------
					autoExpandHorizontalScroll	null
				*/
				/*
				auto-scroll to elements with focus
				*/
				autoScrollOnFocus:"input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
				/*
				auto-update scrollbars on content, element or viewport resize 
				should be true for fluid layouts/elements, adding/removing content dynamically, hiding/showing elements, content with images etc. 
				values: boolean
				*/
				updateOnContentResize:true,
				/*
				auto-update scrollbars each time each image inside the element is fully loaded 
				values: "auto", boolean
				*/
				updateOnImageLoad:"auto",
				/*
				auto-update scrollbars based on the amount and size changes of specific selectors 
				useful when you need to update the scrollbar(s) automatically, each time a type of element is added, removed or changes its size 
				values: boolean, string (e.g. "ul li" will auto-update scrollbars each time list-items inside the element are changed) 
				a value of true (boolean) will auto-update scrollbars each time any element is changed
					option						default
					-------------------------------------
					updateOnSelectorChange		null
				*/
				/*
				extra selectors that'll allow scrollbar dragging upon mousemove/up, pointermove/up, touchend etc. (e.g. "selector-1, selector-2")
					option						default
					-------------------------------------
					extraDraggableSelectors		null
				*/
				/*
				extra selectors that'll release scrollbar dragging upon mouseup, pointerup, touchend etc. (e.g. "selector-1, selector-2")
					option						default
					-------------------------------------
					releaseDraggableSelectors	null
				*/
				/*
				auto-update timeout 
				values: integer (milliseconds)
				*/
				autoUpdateTimeout:60
			},
			/* 
			scrollbar theme 
			values: string (see CSS/plugin URI for a list of ready-to-use themes)
			*/
			theme:"light",
			/*
			user defined callback functions
			*/
			callbacks:{
				/*
				Available callbacks: 
					callback					default
					-------------------------------------
					onCreate					null
					onInit						null
					onScrollStart				null
					onScroll					null
					onTotalScroll				null
					onTotalScrollBack			null
					whileScrolling				null
					onOverflowY					null
					onOverflowX					null
					onOverflowYNone				null
					onOverflowXNone				null
					onImageLoad					null
					onSelectorChange			null
					onBeforeUpdate				null
					onUpdate					null
				*/
				onTotalScrollOffset:0,
				onTotalScrollBackOffset:0,
				alwaysTriggerOffsets:true
			},
			
			target:null
			/*
			add scrollbar(s) on all elements matching the current selector, now and in the future 
			values: boolean, string 
			string values: "on" (enable), "once" (disable after first invocation), "off" (disable)
			liveSelector values: string (selector)
				option						default
				-------------------------------------
				live						false
				liveSelector				null
			*/
		},
	
	
	
	
	
	/* 
	----------------------------------------
	VARS, CONSTANTS 
	----------------------------------------
	*/
	
		totalInstances=0, /* plugin instances amount */
		liveTimers={}, /* live option timers */
		oldIE=(window.attachEvent && !window.addEventListener) ? 1 : 0, /* detect IE < 9 */
		touchActive=false,touchable, /* global touch vars (for touch and pointer events) */
		/* general plugin classes */
		classes=[
			"rt_qc_mCSB_dragger_onDrag","rt_qc_mCSB_scrollTools_onDrag","rt_qc_mCS_img_loaded","rt_qc_mCS_disabled","rt_qc_","rt_qc_mCS_no_scrollbar",
			"rt_qc_mCS-autoHide","rt_qc_mCS-dir-rtl","rt_qc_mCS_no_scrollbar_y","rt_qc_mCS_no_scrollbar_x","rt_qc_mCS_y_hidden","rt_qc_mCS_x_hidden","rt_qc_mCSB_draggerContainer",
			"rt_qc_mCSB_buttonUp","rt_qc_mCSB_buttonDown","rt_qc_mCSB_buttonLeft","rt_qc_mCSB_buttonRight"
		],
		
	
	
	
	
	/* 
	----------------------------------------
	METHODS 
	----------------------------------------
	*/
	
		methods={
			
			/* 
			plugin initialization method 
			creates the scrollbar(s), plugin data object and options
			----------------------------------------
			*/
			
			init:function(options){
				
				options=QBOX.$.extend(true,{},defaults,options);
				var selector=_selector.call(this); /* validate selector */
				var liveSelector;
				
				/* 
				if live option is enabled, monitor for elements matching the current selector and 
				apply scrollbar(s) when found (now and in the future) 
				*/
				if(options.live){
					    liveSelector=options.liveSelector || this.selector || defaultSelector; /* live selector(s) */
						var $liveSelector=QBOX.$(liveSelector); /* live selector(s) as jquery object */
					if(options.live==="off"){
						/* 
						disable live if requested 
						usage: $(selector).rt_qc_mCSBar({live:"off"}); 
						*/
						removeLiveTimers(liveSelector);
						return;
					}
					liveTimers[liveSelector]=setTimeout(function(){
						/* call mCustomScrollbar fn on live selector(s) every half-second */
						$liveSelector.rt_qc_mCSbar(options);
						if(options.live==="once" && $liveSelector.length){
							/* disable live after first invocation */
							removeLiveTimers(liveSelector);
						}
					},500);
				}else{
					removeLiveTimers(liveSelector);
				}
				
				/* options backward compatibility (for versions < 3.0.0) and normalization */
				options.setWidth=(options.set_width) ? options.set_width : options.setWidth;
				options.setHeight=(options.set_height) ? options.set_height : options.setHeight;
				options.axis=(options.horizontalScroll) ? "x" : _findAxis(options.axis);
				options.scrollInertia=options.scrollInertia>0 && options.scrollInertia<17 ? 17 : options.scrollInertia;
				if(typeof options.mouseWheel!=="object" &&  options.mouseWheel===true){ /* old school mouseWheel option (non-object) */
					options.mouseWheel={enable:true,scrollAmount:"auto",axis:"y",preventDefault:false,deltaFactor:"auto",normalizeDelta:false,invert:false};
				}
				options.mouseWheel.scrollAmount=!options.mouseWheelPixels ? options.mouseWheel.scrollAmount : options.mouseWheelPixels;
				options.mouseWheel.normalizeDelta=!options.advanced.normalizeMouseWheelDelta ? options.mouseWheel.normalizeDelta : options.advanced.normalizeMouseWheelDelta;
				options.scrollButtons.scrollType=_findScrollButtonsType(options.scrollButtons.scrollType); 
				
				_theme(options); /* theme-specific options */
				
				/* plugin constructor */
				return QBOX.$(selector).each(function(){
					
					var $this=QBOX.$(this);
					
					if(!$this.data(pluginPfx)){ /* prevent multiple instantiations */
					
						/* store options and create objects in jquery data */
						$this.data(pluginPfx,{
							idx:++totalInstances, /* instance index */
							opt:options, /* options */
							scrollRatio:{y:null,x:null}, /* scrollbar to content ratio */
							overflowed:null, /* overflowed axis */
							contentReset:{y:null,x:null}, /* object to check when content resets */
							bindEvents:false, /* object to check if events are bound */
							tweenRunning:false, /* object to check if tween is running */
							sequential:{}, /* sequential scrolling object */
							langDir:$this.css("direction"), /* detect/store direction (ltr or rtl) */
							cbOffsets:null, /* object to check whether callback offsets always trigger */
							/* 
							object to check how scrolling events where last triggered 
							"internal" (default - triggered by this script), "external" (triggered by other scripts, e.g. via scrollTo method) 
							usage: object.data("mCS").trigger
							*/
							trigger:null,
							/* 
							object to check for changes in elements in order to call the update method automatically 
							*/
							poll:{size:{o:0,n:0},img:{o:0,n:0},change:{o:0,n:0}}
						});
						
						var d=$this.data(pluginPfx),o=d.opt,
							/* HTML data attributes */
							htmlDataAxis=$this.data("mcs-axis"),htmlDataSbPos=$this.data("mcs-scrollbar-position"),htmlDataTheme=$this.data("mcs-theme");
						 
						if(htmlDataAxis){o.axis=htmlDataAxis;} /* usage example: data-mcs-axis="y" */
						if(htmlDataSbPos){o.scrollbarPosition=htmlDataSbPos;} /* usage example: data-mcs-scrollbar-position="outside" */
						if(htmlDataTheme){ /* usage example: data-mcs-theme="minimal" */
							o.theme=htmlDataTheme;
							_theme(o); /* theme-specific options */
						}
						
						_pluginMarkup.call(this); /* add plugin markup */
						
						if(d && o.callbacks.onCreate && typeof o.callbacks.onCreate==="function"){o.callbacks.onCreate.call(this);} /* callbacks: onCreate */
						
						QBOX.$("#rt_qc_mCSB_"+d.idx+"_container img:not(."+classes[2]+")").addClass(classes[2]); /* flag loaded images */
						
						methods.update.call(null,$this); /* call the update method */
					
					}
					
				});
				
			},
			/* ---------------------------------------- */
			
			
			
			/* 
			plugin update method 
			updates content and scrollbar(s) values, events and status 
			----------------------------------------
			usage: $(selector).rt_qc_mCSBar("update");
			*/
			
			update:function(el,cb){
				
				var selector=el || _selector.call(this); /* validate selector */
				
				return QBOX.$(selector).each(function(){
					
					var $this=QBOX.$(this);
					
					if($this.data(pluginPfx)){ /* check if plugin has initialized */
						
						var d=$this.data(pluginPfx),o=d.opt,
							mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
							mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
							mCSB_dragger=[QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_vertical"),QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_horizontal")];
						
						if(!mCSB_container.length){return;}
						
						if(d.tweenRunning){_stop($this);} /* stop any running tweens while updating */
						
						if(cb && d && o.callbacks.onBeforeUpdate && typeof o.callbacks.onBeforeUpdate==="function"){o.callbacks.onBeforeUpdate.call(this);} /* callbacks: onBeforeUpdate */
						
						/* if element was disabled or destroyed, remove class(es) */
						if($this.hasClass(classes[3])){$this.removeClass(classes[3]);}
						if($this.hasClass(classes[4])){$this.removeClass(classes[4]);}
						
						/* css flexbox fix, detect/set max-height */
						mCustomScrollBox.css("max-height","none");
						if(mCustomScrollBox.height()!==$this.height()){mCustomScrollBox.css("max-height",$this.height());}
						
						_expandContentHorizontally.call(this); /* expand content horizontally */
						
						if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
							mCSB_container.css("width",_contentWidth(mCSB_container));
						}
						
						d.overflowed=_overflowed.call(this); /* determine if scrolling is required */
						
						_scrollbarVisibility.call(this); /* show/hide scrollbar(s) */
						
						/* auto-adjust scrollbar dragger length analogous to content */
						if(o.autoDraggerLength){_setDraggerLength.call(this);}
						
						_scrollRatio.call(this); /* calculate and store scrollbar to content ratio */
						
						_bindEvents.call(this); /* bind scrollbar events */
						
						/* reset scrolling position and/or events */
						var to=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)];
						if(o.axis!=="x"){ /* y/yx axis */
							if(!d.overflowed[0]){ /* y scrolling is not required */
								_resetContentPosition.call(this); /* reset content position */
								if(o.axis==="y"){
									_unbindEvents.call(this);
								}else if(o.axis==="yx" && d.overflowed[1]){
									_scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
								}
							}else if(mCSB_dragger[0].height()>mCSB_dragger[0].parent().height()){
								_resetContentPosition.call(this); /* reset content position */
							}else{ /* y scrolling is required */
								_scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
								d.contentReset.y=null;
							}
						}
						if(o.axis!=="y"){ /* x/yx axis */
							if(!d.overflowed[1]){ /* x scrolling is not required */
								_resetContentPosition.call(this); /* reset content position */
								if(o.axis==="x"){
									_unbindEvents.call(this);
								}else if(o.axis==="yx" && d.overflowed[0]){
									_scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
								}
							}else if(mCSB_dragger[1].width()>mCSB_dragger[1].parent().width()){
								_resetContentPosition.call(this); /* reset content position */
							}else{ /* x scrolling is required */
								_scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
								d.contentReset.x=null;
							}
						}
						
						/* callbacks: onImageLoad, onSelectorChange, onUpdate */
						if(cb && d){
							if(cb===2 && o.callbacks.onImageLoad && typeof o.callbacks.onImageLoad==="function"){
								o.callbacks.onImageLoad.call(this);
							}else if(cb===3 && o.callbacks.onSelectorChange && typeof o.callbacks.onSelectorChange==="function"){
								o.callbacks.onSelectorChange.call(this);
							}else if(o.callbacks.onUpdate && typeof o.callbacks.onUpdate==="function"){
								o.callbacks.onUpdate.call(this);
							}
						}
						
						_autoUpdate.call(this); /* initialize automatic updating (for dynamic content, fluid layouts etc.) */
						
					}
					
				});
				
			},
			/* ---------------------------------------- */
			
			
			
			/* 
			plugin scrollTo method 
			triggers a scrolling event to a specific value
			----------------------------------------
			usage: $(selector).rt_qc_mCSBar("scrollTo",value,options);
			*/
		
			scrollTo:function(val,options,params){
				
				/* prevent silly things like $(selector).rt_qc_mCSBar("scrollTo",undefined); */
				if(typeof val=="undefined" || val===null){return;}
				
				var selector=_selector.call(this); /* validate selector */
				
				return QBOX.$(selector).each(function(){
					
					var $this=QBOX.$(this);
					
					if($this.data(pluginPfx)){ /* check if plugin has initialized */
					
						var d=$this.data(pluginPfx),o=d.opt,
							/* method default options */
							methodDefaults={
								trigger:"external", /* method is by default triggered externally (e.g. from other scripts) */
								scrollInertia:o.scrollInertia, /* scrolling inertia (animation duration) */
								scrollEasing:"mcsEaseInOut", /* animation easing */
								moveDragger:false, /* move dragger instead of content */
								timeout:60, /* scroll-to delay */
								callbacks:true, /* enable/disable callbacks */
								onStart:true,
								onUpdate:true,
								onComplete:true
							},
							methodOptions=QBOX.$.extend(true,{},methodDefaults,options),
							to=_arr.call(this,val),dur=methodOptions.scrollInertia>0 && methodOptions.scrollInertia<17 ? 17 : methodOptions.scrollInertia;
						
						/* translate yx values to actual scroll-to positions */
						to[0]=_to.call(this,to[0],"y");
						to[1]=_to.call(this,to[1],"x");
						
						/* 
						check if scroll-to value moves the dragger instead of content. 
						Only pixel values apply on dragger (e.g. 100, "100px", "-=100" etc.) 
						*/
						if(methodOptions.moveDragger){
							to[0]*=d.scrollRatio.y;
							to[1]*=d.scrollRatio.x;
						}
						
						methodOptions.dur=_isTabHidden() ? 0 : dur; //skip animations if browser tab is hidden
						
						setTimeout(function(){ 
							/* do the scrolling */
							if(to[0]!==null && typeof to[0]!=="undefined" && o.axis!=="x" && d.overflowed[0]){ /* scroll y */
								methodOptions.dir="y";
								methodOptions.overwrite="all";
								_scrollTo($this,to[0].toString(),methodOptions,params);
							}
							if(to[1]!==null && typeof to[1]!=="undefined" && o.axis!=="y" && d.overflowed[1]){ /* scroll x */
								methodOptions.dir="x";
								methodOptions.overwrite="none";
								_scrollTo($this,to[1].toString(),methodOptions,params);
							}
						},methodOptions.timeout);
						
					}
					
				});
				
			},
			/* ---------------------------------------- */
			
			
			
			/*
			plugin stop method 
			stops scrolling animation
			----------------------------------------
			usage: $(selector).rt_qc_mCSBar("stop");
			*/
			stop:function(){
				
				var selector=_selector.call(this); /* validate selector */
				
				return QBOX.$(selector).each(function(){
					
					var $this=QBOX.$(this);
					
					if($this.data(pluginPfx)){ /* check if plugin has initialized */
										
						_stop($this);
					
					}
					
				});
				
			},
			/* ---------------------------------------- */
			
			
			
			/*
			plugin disable method 
			temporarily disables the scrollbar(s) 
			----------------------------------------
			usage: $(selector).rt_qc_mCSBar("disable",reset); 
			reset (boolean): resets content position to 0 
			*/
			disable:function(r){
				
				var selector=_selector.call(this); /* validate selector */
				
				return QBOX.$(selector).each(function(){
					
					var $this=QBOX.$(this);
					
					if($this.data(pluginPfx)){ /* check if plugin has initialized */
						
						var d=$this.data(pluginPfx);
						
						_autoUpdate.call(this,"remove"); /* remove automatic updating */
						
						_unbindEvents.call(this); /* unbind events */
						
						if(r){_resetContentPosition.call(this);} /* reset content position */
						
						_scrollbarVisibility.call(this,true); /* show/hide scrollbar(s) */
						
						$this.addClass(classes[3]); /* add disable class */
					
					}
					
				});
				
			},
			/* ---------------------------------------- */
			
			
			
			/*
			plugin destroy method 
			completely removes the scrollbar(s) and returns the element to its original state
			----------------------------------------
			usage: $(selector).rt_qc_mCSBar("destroy"); 
			*/
			destroy:function(){
				
				var selector=_selector.call(this); /* validate selector */
				
				return QBOX.$(selector).each(function(){
					
					var $this=QBOX.$(this);
					
					if($this.data(pluginPfx)){ /* check if plugin has initialized */
					
						var d=$this.data(pluginPfx),o=d.opt,
							mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
							mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
							scrollbar=QBOX.$(".rt_qc_mCSB_"+d.idx+"_scrollbar");
					
						if(o.live){removeLiveTimers(o.liveSelector || QBOX.$(selector).selector);} /* remove live timers */
						
						_autoUpdate.call(this,"remove"); /* remove automatic updating */
						
						_unbindEvents.call(this); /* unbind events */
						
						_resetContentPosition.call(this); /* reset content position */
						
						$this.removeData(pluginPfx); /* remove plugin data object */
						
						_delete(this,"mcs"); /* delete callbacks object */
						
						/* remove plugin markup */
						scrollbar.remove(); /* remove scrollbar(s) first (those can be either inside or outside plugin's inner wrapper) */
						mCSB_container.find("img."+classes[2]).removeClass(classes[2]); /* remove loaded images flag */
						mCustomScrollBox.replaceWith(mCSB_container.contents()); /* replace plugin's inner wrapper with the original content */
						/* remove plugin classes from the element and add destroy class */
						$this.removeClass(pluginNS+" _"+pluginPfx+"_"+d.idx+" "+classes[6]+" "+classes[7]+" "+classes[5]+" "+classes[3]).addClass(classes[4]);
					
					}
					
				});
				
			}
			/* ---------------------------------------- */
			
		},
	
	
	
	
		
	/* 
	----------------------------------------
	FUNCTIONS
	----------------------------------------
	*/
	
		/* validates selector (if selector is invalid or undefined uses the default one) */
		_selector=function(){
			return (typeof QBOX.$(this)!=="object" || QBOX.$(this).length<1) ? defaultSelector : this;
		},
		/* -------------------- */
		
		
		/* changes options according to theme */
		_theme=function(obj){
			var fixedSizeScrollbarThemes=["rounded","rounded-dark","rounded-dots","rounded-dots-dark"],
				nonExpandedScrollbarThemes=["rounded-dots","rounded-dots-dark","3d","3d-dark","3d-thick","3d-thick-dark","inset","inset-dark","inset-2","inset-2-dark","inset-3","inset-3-dark"],
				disabledScrollButtonsThemes=["minimal","minimal-dark"],
				enabledAutoHideScrollbarThemes=["minimal","minimal-dark"],
				scrollbarPositionOutsideThemes=["minimal","minimal-dark"];
			obj.autoDraggerLength=QBOX.$.inArray(obj.theme,fixedSizeScrollbarThemes) > -1 ? false : obj.autoDraggerLength;
			obj.autoExpandScrollbar=QBOX.$.inArray(obj.theme,nonExpandedScrollbarThemes) > -1 ? false : obj.autoExpandScrollbar;
			obj.scrollButtons.enable=QBOX.$.inArray(obj.theme,disabledScrollButtonsThemes) > -1 ? false : obj.scrollButtons.enable;
			obj.autoHideScrollbar=QBOX.$.inArray(obj.theme,enabledAutoHideScrollbarThemes) > -1 ? true : obj.autoHideScrollbar;
			obj.scrollbarPosition=QBOX.$.inArray(obj.theme,scrollbarPositionOutsideThemes) > -1 ? "outside" : obj.scrollbarPosition;
		},
		/* -------------------- */
		
		
		/* live option timers removal */
		removeLiveTimers=function(selector){
			if(liveTimers[selector]){
				clearTimeout(liveTimers[selector]);
				_delete(liveTimers,selector);
			}
		},
		/* -------------------- */
		
		
		/* normalizes axis option to valid values: "y", "x", "yx" */
		_findAxis=function(val){
			return (val==="yx" || val==="xy" || val==="auto") ? "yx" : (val==="x" || val==="horizontal") ? "x" : "y";
		},
		/* -------------------- */
		
		
		/* normalizes scrollButtons.scrollType option to valid values: "stepless", "stepped" */
		_findScrollButtonsType=function(val){
			return (val==="stepped" || val==="pixels" || val==="step" || val==="click") ? "stepped" : "stepless";
		},
		/* -------------------- */
		
		
		/* generates plugin markup */
		_pluginMarkup=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				expandClass=o.autoExpandScrollbar ? " "+classes[1]+"_expand" : "",
				scrollbar=["<div id='rt_qc_mCSB_"+d.idx+"_scrollbar_vertical' class='rt_qc_mCSB_scrollTools rt_qc_mCSB_"+d.idx+"_scrollbar rt_qc_mCS-"+o.theme+" rt_qc_mCSB_scrollTools_vertical"+expandClass+"'><div class='"+classes[12]+"'><div id='rt_qc_mCSB_"+d.idx+"_dragger_vertical' class='rt_qc_mCSB_dragger' style='position:absolute;'><div class='rt_qc_mCSB_dragger_bar' /></div><div class='rt_qc_mCSB_draggerRail' /></div></div>","<div id='rt_qc_mCSB_"+d.idx+"_scrollbar_horizontal' class='rt_qc_mCSB_scrollTools rt_qc_mCSB_"+d.idx+"_scrollbar rt_qc_mCS-"+o.theme+" rt_qc_mCSB_scrollTools_horizontal"+expandClass+"'><div class='"+classes[12]+"'><div id='rt_qc_mCSB_"+d.idx+"_dragger_horizontal' class='rt_qc_mCSB_dragger' style='position:absolute;'><div class='rt_qc_mCSB_dragger_bar' /></div><div class='rt_qc_mCSB_draggerRail' /></div></div>"],
				wrapperClass=o.axis==="yx" ? "rt_qc_mCSB_vertical_horizontal" : o.axis==="x" ? "rt_qc_mCSB_horizontal" : "rt_qc_mCSB_vertical",
				scrollbars=o.axis==="yx" ? scrollbar[0]+scrollbar[1] : o.axis==="x" ? scrollbar[1] : scrollbar[0],
				contentWrapper=o.axis==="yx" ? "<div id='rt_qc_mCSB_"+d.idx+"_container_wrapper' class='rt_qc_mCSB_container_wrapper' />" : "",
				autoHideClass=o.autoHideScrollbar ? " "+classes[6] : "",
				scrollbarDirClass=(o.axis!=="x" && d.langDir==="rtl") ? " "+classes[7] : "";
			if(o.setWidth){$this.css("width",o.setWidth);} /* set element width */
			if(o.setHeight){$this.css("height",o.setHeight);} /* set element height */
			o.setLeft=(o.axis!=="y" && d.langDir==="rtl") ? "989999px" : o.setLeft; /* adjust left position for rtl direction */
			$this.addClass(pluginNS+" _"+pluginPfx+"_"+d.idx+autoHideClass+scrollbarDirClass).wrapInner("<div id='rt_qc_mCSB_"+d.idx+"' class='rt_qc_mCSBox rt_qc_mCS-"+o.theme+" "+wrapperClass+"'><div id='rt_qc_mCSB_"+d.idx+"_container' class='rt_qc_mCSB_container' style='position:relative; top:"+o.setTop+"; left:"+o.setLeft+";' dir='"+d.langDir+"' /></div>");
			var mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container");
			if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
				mCSB_container.css("width",_contentWidth(mCSB_container));
			}
			if(o.scrollbarPosition==="outside"){
				if($this.css("position")==="static"){ /* requires elements with non-static position */
					$this.css("position","relative");
				}
				$this.css("overflow","visible");
				mCustomScrollBox.addClass("rt_qc_mCSB_outside").after(scrollbars);
			}else{
				mCustomScrollBox.addClass("rt_qc_mCSB_inside").append(scrollbars);
				mCSB_container.wrap(contentWrapper);
			}
			_scrollButtons.call(this); /* add scrollbar buttons */
			/* minimum dragger length */
			var mCSB_dragger=[QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_vertical"),QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_horizontal")];
			mCSB_dragger[0].css("min-height",mCSB_dragger[0].height());
			mCSB_dragger[1].css("min-width",mCSB_dragger[1].width());
		},
		/* -------------------- */
		
		
		/* calculates content width */
		_contentWidth=function(el){
			var val=[el[0].scrollWidth,Math.max.apply(Math,el.children().map(function(){return QBOX.$(this).outerWidth(true);}).get())],w=el.parent().width();
			return val[0]>w ? val[0] : val[1]>w ? val[1] : "100%";
		},
		/* -------------------- */
		
		
		/* expands content horizontally */
		_expandContentHorizontally=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container");
			if(o.advanced.autoExpandHorizontalScroll && o.axis!=="y"){
				/* calculate scrollWidth */
				mCSB_container.css({"width":"auto","min-width":0,"overflow-x":"scroll"});
				var w=Math.ceil(mCSB_container[0].scrollWidth);
				if(o.advanced.autoExpandHorizontalScroll===3 || (o.advanced.autoExpandHorizontalScroll!==2 && w>mCSB_container.parent().width())){
					mCSB_container.css({"width":w,"min-width":"100%","overflow-x":"inherit"});
				}else{
					/* 
					wrap content with an infinite width div and set its position to absolute and width to auto. 
					Setting width to auto before calculating the actual width is important! 
					We must let the browser set the width as browser zoom values are impossible to calculate.
					*/
					mCSB_container.css({"overflow-x":"inherit","position":"absolute"})
						.wrap("<div class='rt_qc_mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />")
						.css({ /* set actual width, original position and un-wrap */
							/* 
							get the exact width (with decimals) and then round-up. 
							Using jquery outerWidth() will round the width value which will mess up with inner elements that have non-integer width
							*/
							"width":(Math.ceil(mCSB_container[0].getBoundingClientRect().right+0.4)-Math.floor(mCSB_container[0].getBoundingClientRect().left)),
							"min-width":"100%",
							"position":"relative"
						}).unwrap();
				}
			}
		},
		/* -------------------- */
		
		
		/* adds scrollbar buttons */
		_scrollButtons=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				mCSB_scrollTools=QBOX.$(".rt_qc_mCSB_"+d.idx+"_scrollbar:first"),
				tabindex=!_isNumeric(o.scrollButtons.tabindex) ? "" : "tabindex='"+o.scrollButtons.tabindex+"'",
				btnHTML=[
					"<a title='QCell scroll up' href='#' class='"+classes[13]+"' "+tabindex+" />",
					"<a title='QCell scroll down' href='#' class='"+classes[14]+"' "+tabindex+" />",
					"<a title='QCell scroll left' href='#' class='"+classes[15]+"' "+tabindex+" />",
					"<a title='QCell scroll right' href='#' class='"+classes[16]+"' "+tabindex+" />"
				],
				btn=[(o.axis==="x" ? btnHTML[2] : btnHTML[0]),(o.axis==="x" ? btnHTML[3] : btnHTML[1]),btnHTML[2],btnHTML[3]];
			if(o.scrollButtons.enable){
				mCSB_scrollTools.prepend(btn[0]).append(btn[1]).next(".rt_qc_mCSB_scrollTools").prepend(btn[2]).append(btn[3]);
			}
		},
		/* -------------------- */
		
		
		/* auto-adjusts scrollbar dragger length */
		_setDraggerLength=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),
				mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				mCSB_dragger=[QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_vertical"),QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_horizontal")],
				ratio=[mCustomScrollBox.height()/mCSB_container.outerHeight(false),mCustomScrollBox.width()/mCSB_container.outerWidth(false)],
				l=[
					parseInt(mCSB_dragger[0].css("min-height")),Math.round(ratio[0]*mCSB_dragger[0].parent().height()),
					parseInt(mCSB_dragger[1].css("min-width")),Math.round(ratio[1]*mCSB_dragger[1].parent().width())
				],
				h=oldIE && (l[1]<l[0]) ? l[0] : l[1],w=oldIE && (l[3]<l[2]) ? l[2] : l[3];
			mCSB_dragger[0].css({
				"height":h,"max-height":(mCSB_dragger[0].parent().height()-10)
			}).find(".rt_qc_mCSB_dragger_bar").css({"line-height":l[0]+"px"});
			mCSB_dragger[1].css({
				"width":w,"max-width":(mCSB_dragger[1].parent().width()-10)
			});
		},
		/* -------------------- */
		
		
		/* calculates scrollbar to content ratio */
		_scrollRatio=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),
				mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				mCSB_dragger=[QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_vertical"),QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_horizontal")],
				scrollAmount=[mCSB_container.outerHeight(false)-mCustomScrollBox.height(),mCSB_container.outerWidth(false)-mCustomScrollBox.width()],
				ratio=[
					scrollAmount[0]/(mCSB_dragger[0].parent().height()-mCSB_dragger[0].height()),
					scrollAmount[1]/(mCSB_dragger[1].parent().width()-mCSB_dragger[1].width())
				];
			d.scrollRatio={y:ratio[0],x:ratio[1]};
		},
		/* -------------------- */
		
		
		/* toggles scrolling classes */
		_onDragClasses=function(el,action,xpnd){
			var expandClass=xpnd ? classes[0]+"_expanded" : "",
				scrollbar=el.closest(".rt_qc_mCSB_scrollTools");
			if(action==="active"){
				el.toggleClass(classes[0]+" "+expandClass); scrollbar.toggleClass(classes[1]); 
				el[0]._draggable=el[0]._draggable ? 0 : 1;
			}else{
				if(!el[0]._draggable){
					if(action==="hide"){
						el.removeClass(classes[0]); scrollbar.removeClass(classes[1]);
					}else{
						el.addClass(classes[0]); scrollbar.addClass(classes[1]);
					}
				}
			}
		},
		/* -------------------- */
		
		
		/* checks if content overflows its container to determine if scrolling is required */
		_overflowed=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),
				mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				contentHeight=d.overflowed===null ? mCSB_container.height() : mCSB_container.outerHeight(false),
				contentWidth=d.overflowed===null ? mCSB_container.width() : mCSB_container.outerWidth(false),
				h=mCSB_container[0].scrollHeight,w=mCSB_container[0].scrollWidth;
			if(h>contentHeight){contentHeight=h;}
			if(w>contentWidth){contentWidth=w;}
			return [contentHeight>mCustomScrollBox.height(),contentWidth>mCustomScrollBox.width()];
		},
		/* -------------------- */
		
		
		/* resets content position to 0 */
		_resetContentPosition=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				mCSB_dragger=[QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_vertical"),QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_horizontal")];
			_stop($this); /* stop any current scrolling before resetting */
			if((o.axis!=="x" && !d.overflowed[0]) || (o.axis==="y" && d.overflowed[0])){ /* reset y */
				mCSB_dragger[0].add(mCSB_container).css("top",0);
				_scrollTo($this,"_resetY");
			}
			if((o.axis!=="y" && !d.overflowed[1]) || (o.axis==="x" && d.overflowed[1])){ /* reset x */
				var cx=0,dx=0;
				if(d.langDir==="rtl"){ /* adjust left position for rtl direction */
					cx=mCustomScrollBox.width()-mCSB_container.outerWidth(false);
					dx=Math.abs(cx/d.scrollRatio.x);
				}
				mCSB_container.css("left",cx);
				mCSB_dragger[1].css("left",dx);
				_scrollTo($this,"_resetX");
			}
		},
		/* -------------------- */
		
		/* binds scrollbar events */
		_bindEvents=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt;
			if(!d.bindEvents){ /* check if events are already bound */
				_draggable.call(this);
				if(o.contentTouchScroll){_contentDraggable.call(this);}
				_selectable.call(this);
				if(o.mouseWheel.enable){ /* bind mousewheel fn when plugin is available */
					var mousewheelTimeout;
					_mwt($this);
				}
				_draggerRail.call(this);
				_wrapperScroll.call(this);
				if(o.advanced.autoScrollOnFocus){_focus.call(this);}
				if(o.scrollButtons.enable){_buttons.call(this);}
				if(o.keyboard.enable){_keyboard.call(this);}
				d.bindEvents=true;
			}
		},
		_mwt=function($this){
			var mousewheelTimeout=setTimeout(function(){
				if(!QBOX.$.event.special.mousewheel){
					_mwt($this);
				}else{
					clearTimeout(mousewheelTimeout);
					_mousewheel.call($this[0]);
				}
			},100);
		},
		/* -------------------- */
		
		
		/* unbinds scrollbar events */
		_unbindEvents=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				namespace=pluginPfx+"_"+d.idx,
				sb=".rt_qc_mCSB_"+d.idx+"_scrollbar",
				sel=QBOX.$("#rt_qc_mCSB_"+d.idx+",#rt_qc_mCSB_"+d.idx+"_container,#rt_qc_mCSB_"+d.idx+"_container_wrapper,"+sb+" ."+classes[12]+",#rt_qc_mCSB_"+d.idx+"_dragger_vertical,#rt_qc_mCSB_"+d.idx+"_dragger_horizontal,"+sb+">a"),
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container");
			if(o.advanced.releaseDraggableSelectors){sel.add(QBOX.$(o.advanced.releaseDraggableSelectors));}
			if(o.advanced.extraDraggableSelectors){sel.add(QBOX.$(o.advanced.extraDraggableSelectors));}
			if(d.bindEvents){ /* check if events are bound */
				/* unbind namespaced events from document/selectors */
				QBOX.$(document).add(QBOX.$(!_canAccessIFrame() || top.document)).unbind("."+namespace);
				sel.each(function(){
					QBOX.$(this).unbind("."+namespace);
				});
				/* clear and delete timeouts/objects */
				clearTimeout($this[0]._focusTimeout); _delete($this[0],"_focusTimeout");
				clearTimeout(d.sequential.step); _delete(d.sequential,"step");
				clearTimeout(mCSB_container[0].onCompleteTimeout); _delete(mCSB_container[0],"onCompleteTimeout");
				d.bindEvents=false;
			}
		},
		/* -------------------- */
		
		
		/* toggles scrollbar visibility */
		_scrollbarVisibility=function(disabled){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				contentWrapper=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container_wrapper"),
				content=contentWrapper.length ? contentWrapper : QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				scrollbar=[QBOX.$("#rt_qc_mCSB_"+d.idx+"_scrollbar_vertical"),QBOX.$("#rt_qc_mCSB_"+d.idx+"_scrollbar_horizontal")],
				mCSB_dragger=[scrollbar[0].find(".rt_qc_mCSB_dragger"),scrollbar[1].find(".rt_qc_mCSB_dragger")];
			if(o.axis!=="x"){
				if(d.overflowed[0] && !disabled){
					scrollbar[0].add(mCSB_dragger[0]).add(scrollbar[0].children("a")).css("display","block");
					content.removeClass(classes[8]+" "+classes[10]);
				}else{
					if(o.alwaysShowScrollbar){
						if(o.alwaysShowScrollbar!==2){mCSB_dragger[0].css("display","none");}
						content.removeClass(classes[10]);
					}else{
						scrollbar[0].css("display","none");
						content.addClass(classes[10]);
					}
					content.addClass(classes[8]);
				}
			}
			if(o.axis!=="y"){
				if(d.overflowed[1] && !disabled){
					scrollbar[1].add(mCSB_dragger[1]).add(scrollbar[1].children("a")).css("display","block");
					content.removeClass(classes[9]+" "+classes[11]);
				}else{
					if(o.alwaysShowScrollbar){
						if(o.alwaysShowScrollbar!==2){mCSB_dragger[1].css("display","none");}
						content.removeClass(classes[11]);
					}else{
						scrollbar[1].css("display","none");
						content.addClass(classes[11]);
					}
					content.addClass(classes[9]);
				}
			}
			if(!d.overflowed[0] && !d.overflowed[1]){
				$this.addClass(classes[5]);
			}else{
				$this.removeClass(classes[5]);
			}
		},
		/* -------------------- */
		
		
		/* returns input coordinates of pointer, touch and mouse events (relative to document) */
		_coordinates=function(e){
			var t=e.type,o=e.target.ownerDocument!==document && frameElement!==null ? [QBOX.$(frameElement).offset().top,QBOX.$(frameElement).offset().left] : null,
				io=_canAccessIFrame() && e.target.ownerDocument!==top.document && frameElement!==null ? [QBOX.$(e.view.frameElement).offset().top,QBOX.$(e.view.frameElement).offset().left] : [0,0],
				res;
			switch(t){
				case "pointerdown": case "MSPointerDown": case "pointermove": case "MSPointerMove": case "pointerup": case "MSPointerUp":
					res = o ? [e.originalEvent.pageY-o[0]+io[0],e.originalEvent.pageX-o[1]+io[1],false] : [e.originalEvent.pageY,e.originalEvent.pageX,false];
					break;
				case "touchstart": case "touchmove": case "touchend":
					var touch=e.originalEvent.touches[0] || e.originalEvent.changedTouches[0],
						touches=e.originalEvent.touches.length || e.originalEvent.changedTouches.length;
					res = e.target.ownerDocument!==document ? [touch.screenY,touch.screenX,touches>1] : [touch.pageY,touch.pageX,touches>1];
					break;
				default:
					res = o ? [e.pageY-o[0]+io[0],e.pageX-o[1]+io[1],false] : [e.pageY,e.pageX,false];
					break;
			}
			return res;
		},
		/* -------------------- */
		
		
		/* 
		SCROLLBAR DRAG EVENTS
		scrolls content via scrollbar dragging 
		*/
		_draggable=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				namespace=pluginPfx+"_"+d.idx,
				draggerId=["rt_qc_mCSB_"+d.idx+"_dragger_vertical","rt_qc_mCSB_"+d.idx+"_dragger_horizontal"],
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				mCSB_dragger=QBOX.$("#"+draggerId[0]+",#"+draggerId[1]),
				draggable,dragY,dragX,
				rds=o.advanced.releaseDraggableSelectors ? mCSB_dragger.add(QBOX.$(o.advanced.releaseDraggableSelectors)) : mCSB_dragger,
				eds=o.advanced.extraDraggableSelectors ? QBOX.$(!_canAccessIFrame() || top.document).add(QBOX.$(o.advanced.extraDraggableSelectors)) : QBOX.$(!_canAccessIFrame() || top.document);
			mCSB_dragger.bind("contextmenu."+namespace,function(e){
				e.preventDefault(); //prevent right click
			}).bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
				e.stopImmediatePropagation();
				e.preventDefault();
				if(!_mouseBtnLeft(e)){return;} /* left mouse button only */
				touchActive=true;
				if(oldIE){document.onselectstart=function(){return false;};} /* disable text selection for IE < 9 */
				_iframe.call(mCSB_container,false); /* enable scrollbar dragging over iframes by disabling their events */
				_stop($this);
				draggable=QBOX.$(this);
				var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
					h=draggable.height()+offset.top,w=draggable.width()+offset.left;
				if(y<h && y>0 && x<w && x>0){
					dragY=y; 
					dragX=x;
				}
				_onDragClasses(draggable,"active",o.autoExpandScrollbar); 
			}).bind("touchmove."+namespace,function(e){
				e.stopImmediatePropagation();
				e.preventDefault();
				var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
				_drag(dragY,dragX,y,x);
			});
			QBOX.$(document).add(eds).bind("mousemove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace,function(e){
				if(draggable){
					var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
					if(dragY===y && dragX===x){return;} /* has it really moved? */
					_drag(dragY,dragX,y,x);
				}
			}).add(rds).bind("mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
				if(draggable){
					_onDragClasses(draggable,"active",o.autoExpandScrollbar); 
					draggable=null;
				}
				touchActive=false;
				if(oldIE){document.onselectstart=null;} /* enable text selection for IE < 9 */
				_iframe.call(mCSB_container,true); /* enable iframes events */
			});
			function _drag(dragY,dragX,y,x){
				var dir;
				mCSB_container[0].idleTimer=o.scrollInertia<233 ? 250 : 0;
				if(draggable.attr("id")===draggerId[1]){
					dir="x";
					to=((draggable[0].offsetLeft-dragX)+x)*d.scrollRatio[dir];
				}else{
					dir="y";
					to=((draggable[0].offsetTop-dragY)+y)*d.scrollRatio[dir];
				}
				_scrollTo($this,to.toString(),{dir:dir,drag:true});
			}
		},
		/* -------------------- */
		
		
		/* 
		TOUCH SWIPE EVENTS
		scrolls content via touch swipe 
		Emulates the native touch-swipe scrolling with momentum found in iOS, Android and WP devices 
		*/
		_contentDraggable=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				namespace=pluginPfx+"_"+d.idx,
				mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				mCSB_dragger=[QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_vertical"),QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_horizontal")],
				draggable,dragY,dragX,touchStartY,touchStartX,touchMoveY=[],touchMoveX=[],startTime,runningTime,endTime,distance,speed,amount,
				durA=0,durB,overwrite=o.axis==="yx" ? "none" : "all",touchIntent=[],touchDrag,docDrag,
				iframe=mCSB_container.find("iframe"),
				events=[
					"touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace, //start
					"touchmove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace, //move
					"touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace //end
				],
				touchAction=document.body.style.touchAction!==undefined && document.body.style.touchAction!=="";
			mCSB_container.bind(events[0],function(e){
				_onTouchstart(e);
			}).bind(events[1],function(e){
				_onTouchmove(e);
			});
			mCustomScrollBox.bind(events[0],function(e){
				_onTouchstart2(e);
			}).bind(events[2],function(e){
				_onTouchend(e);
			});
			if(iframe.length){
				iframe.each(function(){
					QBOX.$(this).bind("load",function(){
						/* bind events on accessible iframes */
						if(_canAccessIFrame(this)){
							QBOX.$(this.contentDocument || this.contentWindow.document).bind(events[0],function(e){
								_onTouchstart(e);
								_onTouchstart2(e);
							}).bind(events[1],function(e){
								_onTouchmove(e);
							}).bind(events[2],function(e){
								_onTouchend(e);
							});
						}
					});
				});
			}
			function _onTouchstart(e){
				if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){touchable=0; return;}
				touchable=1; touchDrag=0; docDrag=0; draggable=1;
				$this.removeClass("rt_qc_mCS_touch_action");
				var offset=mCSB_container.offset();
				dragY=_coordinates(e)[0]-offset.top;
				dragX=_coordinates(e)[1]-offset.left;
				touchIntent=[_coordinates(e)[0],_coordinates(e)[1]];
			}
			function _onTouchmove(e){
				if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
				if(!o.documentTouchScroll){e.preventDefault();} 
				e.stopImmediatePropagation();
				if(docDrag && !touchDrag){return;}
				if(draggable){
					runningTime=_getTime();
					var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
						easing="mcsLinearOut",prevent,preventX;
					touchMoveY.push(y);
					touchMoveX.push(x);
					touchIntent[2]=Math.abs(_coordinates(e)[0]-touchIntent[0]); touchIntent[3]=Math.abs(_coordinates(e)[1]-touchIntent[1]);
					if(d.overflowed[0]){
						var limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height();
						prevent=((dragY-y)>0 && (y-dragY)>-(limit*d.scrollRatio.y) && (touchIntent[3]*2<touchIntent[2] || o.axis==="yx"));
					}
					if(d.overflowed[1]){
						var limitX=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width();
						preventX=((dragX-x)>0 && (x-dragX)>-(limitX*d.scrollRatio.x) && (touchIntent[2]*2<touchIntent[3] || o.axis==="yx"));
					}
					if(prevent || preventX){ /* prevent native document scrolling */
						if(!touchAction){e.preventDefault();} 
						touchDrag=1;
					}else{
						docDrag=1;
						$this.addClass("rt_qc_mCS_touch_action");
					}
					if(touchAction){e.preventDefault();} 
					amount=o.axis==="yx" ? [(dragY-y),(dragX-x)] : o.axis==="x" ? [null,(dragX-x)] : [(dragY-y),null];
					mCSB_container[0].idleTimer=250;
					if(d.overflowed[0]){_drag(amount[0],durA,easing,"y","all",true);}
					if(d.overflowed[1]){_drag(amount[1],durA,easing,"x",overwrite,true);}
				}
			}
			function _onTouchstart2(e){
				if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){touchable=0; return;}
				touchable=1;
				e.stopImmediatePropagation();
				_stop($this);
				startTime=_getTime();
				var offset=mCustomScrollBox.offset();
				touchStartY=_coordinates(e)[0]-offset.top;
				touchStartX=_coordinates(e)[1]-offset.left;
				touchMoveY=[]; touchMoveX=[];
			}
			function _onTouchend(e){
				if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
				draggable=0;
				e.stopImmediatePropagation();
				touchDrag=0; docDrag=0;
				endTime=_getTime();
				var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
				if((endTime-runningTime)>30){return;}
				speed=1000/(endTime-startTime);
				var easing="mcsEaseOut",slow=speed<2.5,
					diff=slow ? [touchMoveY[touchMoveY.length-2],touchMoveX[touchMoveX.length-2]] : [0,0];
				distance=slow ? [(y-diff[0]),(x-diff[1])] : [y-touchStartY,x-touchStartX];
				var absDistance=[Math.abs(distance[0]),Math.abs(distance[1])];
				speed=slow ? [Math.abs(distance[0]/4),Math.abs(distance[1]/4)] : [speed,speed];
				var a=[
					Math.abs(mCSB_container[0].offsetTop)-(distance[0]*_m((absDistance[0]/speed[0]),speed[0])),
					Math.abs(mCSB_container[0].offsetLeft)-(distance[1]*_m((absDistance[1]/speed[1]),speed[1]))
				];
				amount=o.axis==="yx" ? [a[0],a[1]] : o.axis==="x" ? [null,a[1]] : [a[0],null];
				durB=[(absDistance[0]*4)+o.scrollInertia,(absDistance[1]*4)+o.scrollInertia];
				var md=parseInt(o.contentTouchScroll) || 0; /* absolute minimum distance required */
				amount[0]=absDistance[0]>md ? amount[0] : 0;
				amount[1]=absDistance[1]>md ? amount[1] : 0;
				if(d.overflowed[0]){_drag(amount[0],durB[0],easing,"y",overwrite,false);}
				if(d.overflowed[1]){_drag(amount[1],durB[1],easing,"x",overwrite,false);}
			}
			function _m(ds,s){
				var r=[s*1.5,s*2,s/1.5,s/2];
				if(ds>90){
					return s>4 ? r[0] : r[3];
				}else if(ds>60){
					return s>3 ? r[3] : r[2];
				}else if(ds>30){
					return s>8 ? r[1] : s>6 ? r[0] : s>4 ? s : r[2];
				}else{
					return s>8 ? s : r[3];
				}
			}
			function _drag(amount,dur,easing,dir,overwrite,drag){
				if(!amount){return;}
				_scrollTo($this,amount.toString(),{dur:dur,scrollEasing:easing,dir:dir,overwrite:overwrite,drag:drag});
			}
		},
		/* -------------------- */
		
		
		/* 
		SELECT TEXT EVENTS 
		scrolls content when text is selected 
		*/
		_selectable=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
				namespace=pluginPfx+"_"+d.idx,
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				wrapper=mCSB_container.parent(),
				action;
			mCSB_container.bind("mousedown."+namespace,function(e){
				if(touchable){return;}
				if(!action){action=1; touchActive=true;}
			}).add(document).bind("mousemove."+namespace,function(e){
				if(!touchable && action && _sel()){
					var offset=mCSB_container.offset(),
						y=_coordinates(e)[0]-offset.top+mCSB_container[0].offsetTop,x=_coordinates(e)[1]-offset.left+mCSB_container[0].offsetLeft;
					if(y>0 && y<wrapper.height() && x>0 && x<wrapper.width()){
						if(seq.step){_seq("off",null,"stepped");}
					}else{
						if(o.axis!=="x" && d.overflowed[0]){
							if(y<0){
								_seq("on",38);
							}else if(y>wrapper.height()){
								_seq("on",40);
							}
						}
						if(o.axis!=="y" && d.overflowed[1]){
							if(x<0){
								_seq("on",37);
							}else if(x>wrapper.width()){
								_seq("on",39);
							}
						}
					}
				}
			}).bind("mouseup."+namespace+" dragend."+namespace,function(e){
				if(touchable){return;}
				if(action){action=0; _seq("off",null);}
				touchActive=false;
			});
			function _sel(){
				return 	window.getSelection ? window.getSelection().toString() : 
						document.selection && document.selection.type!="Control" ? document.selection.createRange().text : 0;
			}
			function _seq(a,c,s){
				seq.type=s && action ? "stepped" : "stepless";
				seq.scrollAmount=10;
				_sequentialScroll($this,a,c,"mcsLinearOut",s ? 60 : null);
			}
		},
		/* -------------------- */
		
		
		/* 
		MOUSE WHEEL EVENT
		scrolls content via mouse-wheel 
		via mouse-wheel plugin (https://github.com/brandonaaron/jquery-mousewheel)
		*/
		_mousewheel=function(){
			if(!QBOX.$(this).data(pluginPfx)){return;} /* Check if the scrollbar is ready to use mousewheel events (issue: #185) */
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				namespace=pluginPfx+"_"+d.idx,
				mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
				mCSB_dragger=[QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_vertical"),QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_horizontal")],
				iframe=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container").find("iframe");
			if(iframe.length){
				iframe.each(function(){
					QBOX.$(this).bind("load",function(){
						/* bind events on accessible iframes */
						if(_canAccessIFrame(this)){
							QBOX.$(this.contentDocument || this.contentWindow.document).bind("mousewheel."+namespace,function(e,delta){
								_onMousewheel(e,delta);
							});
						}
					});
				});
			}
			mCustomScrollBox.bind("mousewheel."+namespace,function(e,delta){
				_onMousewheel(e,delta);
			});
			function _onMousewheel(e,delta){
				_stop($this);
				if(_disableMousewheel($this,e.target)){return;} /* disables mouse-wheel when hovering specific elements */
				var deltaFactor=o.mouseWheel.deltaFactor!=="auto" ? parseInt(o.mouseWheel.deltaFactor) : (oldIE && e.deltaFactor<100) ? 100 : e.deltaFactor || 100,
					dur=o.scrollInertia,dir,px,amount,contentPos,draggerPos,limit,dlt;
				if(o.axis==="x" || o.mouseWheel.axis==="x"){
					dir="x";
					px=[Math.round(deltaFactor*d.scrollRatio.x),parseInt(o.mouseWheel.scrollAmount)];
					amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.width() ? mCustomScrollBox.width()*0.9 : px[0];
					contentPos=Math.abs(QBOX.$("#rt_qc_mCSB_"+d.idx+"_container")[0].offsetLeft);
					draggerPos=mCSB_dragger[1][0].offsetLeft;
					limit=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width();
					dlt=o.mouseWheel.axis==="y" ? (e.deltaY || delta) : e.deltaX;
				}else{
					dir="y";
					px=[Math.round(deltaFactor*d.scrollRatio.y),parseInt(o.mouseWheel.scrollAmount)];
					amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.height() ? mCustomScrollBox.height()*0.9 : px[0];
					contentPos=Math.abs(QBOX.$("#rt_qc_mCSB_"+d.idx+"_container")[0].offsetTop);
					draggerPos=mCSB_dragger[0][0].offsetTop;
					limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height();
					dlt=e.deltaY || delta;
				}
				if((dir==="y" && !d.overflowed[0]) || (dir==="x" && !d.overflowed[1])){return;}
				if(o.mouseWheel.invert || e.webkitDirectionInvertedFromDevice){dlt=-dlt;}
				if(o.mouseWheel.normalizeDelta){dlt=dlt<0 ? -1 : 1;}
				if((dlt>0 && draggerPos!==0) || (dlt<0 && draggerPos!==limit) || o.mouseWheel.preventDefault){
					e.stopImmediatePropagation();
					e.preventDefault();
				}
				if(e.deltaFactor<5 && !o.mouseWheel.normalizeDelta){
					//very low deltaFactor values mean some kind of delta acceleration (e.g. osx trackpad), so adjusting scrolling accordingly
					amount=e.deltaFactor; dur=17;
				}
				_scrollTo($this,(contentPos-(dlt*amount)).toString(),{dir:dir,dur:dur});
			}
		},
		/* -------------------- */
		
		
		/* checks if iframe can be accessed */
		_canAccessIFrameCache={},
		_canAccessIFrame=function(iframe){
		    var result=false,cacheKey=false,html=null,doc;
		    if(iframe===undefined){
				cacheKey="#empty";
		    }else if(QBOX.$(iframe).attr("id")!==undefined){
				cacheKey=QBOX.$(iframe).attr("id");
		    }
			if(cacheKey!==false && _canAccessIFrameCache[cacheKey]!==undefined){
				return _canAccessIFrameCache[cacheKey];
			}
			if(!iframe){
				try{
					doc=top.document;
					html=doc.body.innerHTML;
				}catch(err){QCELL.log('err', 'QCELL.Scroll', err.message);}
				result=(html!==null);
			}else{
				try{
					doc=iframe.contentDocument || iframe.contentWindow.document;
					html=doc.body.innerHTML;
				}catch(err){QCELL.log('err', 'QCELL.Scroll', err.message);}
				result=(html!==null);
			}
			if(cacheKey!==false){_canAccessIFrameCache[cacheKey]=result;}
			return result;
		},
		/* -------------------- */
		
		
		/* switches iframe's pointer-events property (drag, mousewheel etc. over cross-domain iframes) */
		_iframe=function(evt){
			var el=this.find("iframe");
			if(!el.length){return;} /* check if content contains iframes */
			var val=!evt ? "none" : "auto";
			el.css("pointer-events",val); /* for IE11, iframe's display property should not be "block" */
		},
		/* -------------------- */
		
		
		/* disables mouse-wheel when hovering specific elements like select, datalist etc. */
		_disableMousewheel=function(el,target){
			var tag=target.nodeName.toLowerCase(),
				tags=el.data(pluginPfx).opt.mouseWheel.disableOver,
				/* elements that require focus */
				focusTags=["select","textarea"];
			return QBOX.$.inArray(tag,tags) > -1 && !(QBOX.$.inArray(tag,focusTags) > -1 && !QBOX.$(target).is(":focus"));
		},
		/* -------------------- */
		
		
		/* 
		DRAGGER RAIL CLICK EVENT
		scrolls content via dragger rail 
		*/
		_draggerRail=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),
				namespace=pluginPfx+"_"+d.idx,
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				wrapper=mCSB_container.parent(),
				mCSB_draggerContainer=QBOX.$(".rt_qc_mCSB_"+d.idx+"_scrollbar ."+classes[12]),
				clickable;
			mCSB_draggerContainer.bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
				touchActive=true;
				if(!QBOX.$(e.target).hasClass("rt_qc_mCSB_dragger")){clickable=1;}
			}).bind("touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
				touchActive=false;
			}).bind("click."+namespace,function(e){
				if(!clickable){return;}
				clickable=0;
				if(QBOX.$(e.target).hasClass(classes[12]) || QBOX.$(e.target).hasClass("rt_qc_mCSB_draggerRail")){
					_stop($this);
					var el=QBOX.$(this),mCSB_dragger=el.find(".rt_qc_mCSB_dragger"),dir,clickDir,to;
					if(el.parent(".rt_qc_mCSB_scrollTools_horizontal").length>0){
						if(!d.overflowed[1]){return;}
						dir="x";
						clickDir=e.pageX>mCSB_dragger.offset().left ? -1 : 1;
						to=Math.abs(mCSB_container[0].offsetLeft)-(clickDir*(wrapper.width()*0.9));
					}else{
						if(!d.overflowed[0]){return;}
						dir="y";
						clickDir=e.pageY>mCSB_dragger.offset().top ? -1 : 1;
						to=Math.abs(mCSB_container[0].offsetTop)-(clickDir*(wrapper.height()*0.9));
					}
					_scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
				}
			});
		},
		/* -------------------- */
		
		
		/* 
		FOCUS EVENT
		scrolls content via element focus (e.g. clicking an input, pressing TAB key etc.)
		*/
		_focus=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				namespace=pluginPfx+"_"+d.idx,
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				wrapper=mCSB_container.parent();
			mCSB_container.bind("focusin."+namespace,function(e){
				var el=QBOX.$(document.activeElement),
					nested=mCSB_container.find(".mCustomScrollBox").length,
					dur=0;
				if(!el.is(o.advanced.autoScrollOnFocus)){return;}
				_stop($this);
				clearTimeout($this[0]._focusTimeout);
				$this[0]._focusTimer=nested ? (dur+17)*nested : 0;
				$this[0]._focusTimeout=setTimeout(function(){
					var	to=[_childPos(el)[0],_childPos(el)[1]],
						contentPos=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft],
						isVisible=[
							(contentPos[0]+to[0]>=0 && contentPos[0]+to[0]<wrapper.height()-el.outerHeight(false)),
							(contentPos[1]+to[1]>=0 && contentPos[0]+to[1]<wrapper.width()-el.outerWidth(false))
						],
						overwrite=(o.axis==="yx" && !isVisible[0] && !isVisible[1]) ? "none" : "all";
					if(o.axis!=="x" && !isVisible[0]){
						_scrollTo($this,to[0].toString(),{dir:"y",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
					}
					if(o.axis!=="y" && !isVisible[1]){
						_scrollTo($this,to[1].toString(),{dir:"x",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
					}
				},$this[0]._focusTimer);
			});
		},
		/* -------------------- */
		
		
		/* sets content wrapper scrollTop/scrollLeft always to 0 */
		_wrapperScroll=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),
				namespace=pluginPfx+"_"+d.idx,
				wrapper=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container").parent();
			wrapper.bind("scroll."+namespace,function(e){
				if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){
					QBOX.$(".rt_qc_mCSB_"+d.idx+"_scrollbar").css("visibility","hidden"); /* hide scrollbar(s) */
				}
			});
		},
		/* -------------------- */
		
		
		/* 
		BUTTONS EVENTS
		scrolls content via up, down, left and right buttons 
		*/
		_buttons=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
				namespace=pluginPfx+"_"+d.idx,
				sel=".rt_qc_mCSB_"+d.idx+"_scrollbar",
				btn=QBOX.$(sel+">a");
			btn.bind("contextmenu."+namespace,function(e){
				e.preventDefault(); //prevent right click
			}).bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace+" mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace+" mouseout."+namespace+" pointerout."+namespace+" MSPointerOut."+namespace+" click."+namespace,function(e){
				e.preventDefault();
				if(!_mouseBtnLeft(e)){return;} /* left mouse button only */
				var btnClass=QBOX.$(this).attr("class");
				seq.type=o.scrollButtons.scrollType;
				switch(e.type){
					case "mousedown": case "touchstart": case "pointerdown": case "MSPointerDown":
						if(seq.type==="stepped"){return;}
						touchActive=true;
						d.tweenRunning=false;
						_seq("on",btnClass);
						break;
					case "mouseup": case "touchend": case "pointerup": case "MSPointerUp":
					case "mouseout": case "pointerout": case "MSPointerOut":
						if(seq.type==="stepped"){return;}
						touchActive=false;
						if(seq.dir){_seq("off",btnClass);}
						break;
					case "click":
						if(seq.type!=="stepped" || d.tweenRunning){return;}
						_seq("on",btnClass);
						break;
				}
				function _seq(a,c){
					seq.scrollAmount=o.scrollButtons.scrollAmount;
					_sequentialScroll($this,a,c);
				}
			});
		},
		/* -------------------- */
		
		
		/* 
		KEYBOARD EVENTS
		scrolls content via keyboard 
		Keys: up arrow, down arrow, left arrow, right arrow, PgUp, PgDn, Home, End
		*/
		_keyboard=function(){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
				namespace=pluginPfx+"_"+d.idx,
				mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				wrapper=mCSB_container.parent(),
				editables="input,textarea,select,datalist,keygen,[contenteditable='true']",
				iframe=mCSB_container.find("iframe"),
				events=["blur."+namespace+" keydown."+namespace+" keyup."+namespace];
			if(iframe.length){
				iframe.each(function(){
					QBOX.$(this).bind("load",function(){
						/* bind events on accessible iframes */
						if(_canAccessIFrame(this)){
							QBOX.$(this.contentDocument || this.contentWindow.document).bind(events[0],function(e){
								_onKeyboard(e);
							});
						}
					});
				});
			}
			mCustomScrollBox.attr("tabindex","0").bind(events[0],function(e){
				_onKeyboard(e);
			});
			function _onKeyboard(e){
				var dir,to;
				switch(e.type){
					case "blur":
						if(d.tweenRunning && seq.dir){_seq("off",null);}
						break;
					case "keydown": case "keyup":
						var code=e.keyCode ? e.keyCode : e.which,action="on";
						if((o.axis!=="x" && (code===38 || code===40)) || (o.axis!=="y" && (code===37 || code===39))){
							/* up (38), down (40), left (37), right (39) arrows */
							if(((code===38 || code===40) && !d.overflowed[0]) || ((code===37 || code===39) && !d.overflowed[1])){return;}
							if(e.type==="keyup"){action="off";}
							if(!QBOX.$(document.activeElement).is(editables)){
								e.preventDefault();
								e.stopImmediatePropagation();
								_seq(action,code);
							}
						}else if(code===33 || code===34){
							/* PgUp (33), PgDn (34) */
							if(d.overflowed[0] || d.overflowed[1]){
								e.preventDefault();
								e.stopImmediatePropagation();
							}
							if(e.type==="keyup"){
								_stop($this);
								var keyboardDir=code===34 ? -1 : 1;
								if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
									dir="x";
									to=Math.abs(mCSB_container[0].offsetLeft)-(keyboardDir*(wrapper.width()*0.9));
								}else{
									dir="y";
									to=Math.abs(mCSB_container[0].offsetTop)-(keyboardDir*(wrapper.height()*0.9));
								}
								_scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
							}
						}else if(code===35 || code===36){
							/* End (35), Home (36) */
							if(!QBOX.$(document.activeElement).is(editables)){
								if(d.overflowed[0] || d.overflowed[1]){
									e.preventDefault();
									e.stopImmediatePropagation();
								}
								if(e.type==="keyup"){
									if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
										dir="x";
										to=code===35 ? Math.abs(wrapper.width()-mCSB_container.outerWidth(false)) : 0;
									}else{
										dir="y";
										to=code===35 ? Math.abs(wrapper.height()-mCSB_container.outerHeight(false)) : 0;
									}
									_scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
								}
							}
						}
						break;
				}
				function _seq(a,c){
					seq.type=o.keyboard.scrollType;
					seq.scrollAmount=o.keyboard.scrollAmount;
					if(seq.type==="stepped" && d.tweenRunning){return;}
					_sequentialScroll($this,a,c);
				}
			}
		},
		/* -------------------- */
		
		
		/* scrolls content sequentially (used when scrolling via buttons, keyboard arrows etc.) */
		_sequentialScroll=function(el,action,trigger,e,s){
			var d=el.data(pluginPfx),o=d.opt,seq=d.sequential,
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				once=seq.type==="stepped" ? true : false,
				steplessSpeed=o.scrollInertia < 26 ? 26 : o.scrollInertia, /* 26/1.5=17 */
				steppedSpeed=o.scrollInertia < 1 ? 17 : o.scrollInertia;
			switch(action){
				case "on":
					seq.dir=[
						(trigger===classes[16] || trigger===classes[15] || trigger===39 || trigger===37 ? "x" : "y"),
						(trigger===classes[13] || trigger===classes[15] || trigger===38 || trigger===37 ? -1 : 1)
					];
					_stop(el);
					if(_isNumeric(trigger) && seq.type==="stepped"){return;}
					_on(once);
					break;
				case "off":
					_off();
					if(once || (d.tweenRunning && seq.dir)){
						_on(true);
					}
					break;
			}
			
			/* starts sequence */
			function _on(once){
				if(o.snapAmount){seq.scrollAmount=!(o.snapAmount instanceof Array) ? o.snapAmount : seq.dir[0]==="x" ? o.snapAmount[1] : o.snapAmount[0];} /* scrolling snapping */
				var c=seq.type!=="stepped", /* continuous scrolling */
					t=s ? s : !once ? 1000/60 : c ? steplessSpeed/1.5 : steppedSpeed, /* timer */
					m=!once ? 2.5 : c ? 7.5 : 40, /* multiplier */
					contentPos=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)],
					ratio=[d.scrollRatio.y>10 ? 10 : d.scrollRatio.y,d.scrollRatio.x>10 ? 10 : d.scrollRatio.x],
					amount=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*(ratio[1]*m)) : contentPos[0]+(seq.dir[1]*(ratio[0]*m)),
					px=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*parseInt(seq.scrollAmount)) : contentPos[0]+(seq.dir[1]*parseInt(seq.scrollAmount)),
					to=seq.scrollAmount!=="auto" ? px : amount,
					easing=e ? e : !once ? "mcsLinear" : c ? "mcsLinearOut" : "mcsEaseInOut",
					onComplete=!once ? false : true;
				if(once && t<17){
					to=seq.dir[0]==="x" ? contentPos[1] : contentPos[0];
				}
				_scrollTo(el,to.toString(),{dir:seq.dir[0],scrollEasing:easing,dur:t,onComplete:onComplete});
				if(once){
					seq.dir=false;
					return;
				}
				clearTimeout(seq.step);
				seq.step=setTimeout(function(){
					_on();
				},t);
			}
			/* stops sequence */
			function _off(){
				clearTimeout(seq.step);
				_delete(seq,"step");
				_stop(el);
			}
		},
		/* -------------------- */
		
		
		/* returns a yx array from value */
		_arr=function(val){
			var o=QBOX.$(this).data(pluginPfx).opt,vals=[];
			if(typeof val==="function"){val=val();} /* check if the value is a single anonymous function */
			/* check if value is object or array, its length and create an array with yx values */
			if(!(val instanceof Array)){ /* object value (e.g. {y:"100",x:"100"}, 100 etc.) */
				vals[0]=val.y ? val.y : val.x || o.axis==="x" ? null : val;
				vals[1]=val.x ? val.x : val.y || o.axis==="y" ? null : val;
			}else{ /* array value (e.g. [100,100]) */
				vals=val.length>1 ? [val[0],val[1]] : o.axis==="x" ? [null,val[0]] : [val[0],null];
			}
			/* check if array values are anonymous functions */
			if(typeof vals[0]==="function"){vals[0]=vals[0]();}
			if(typeof vals[1]==="function"){vals[1]=vals[1]();}
			return vals;
		},
		/* -------------------- */
		
		
		/* translates values (e.g. "top", 100, "100px", "#id") to actual scroll-to positions */
		_to=function(val,dir){
			if(val===null || typeof val=="undefined"){return;}
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				wrapper=mCSB_container.parent(),
				t=typeof val,
				obj;
			if(!dir){dir=o.axis==="x" ? "x" : "y";}
			var contentLength=dir==="x" ? mCSB_container.outerWidth(false)-wrapper.width() : mCSB_container.outerHeight(false)-wrapper.height(),
				contentPos=dir==="x" ? mCSB_container[0].offsetLeft : mCSB_container[0].offsetTop,
				cssProp=dir==="x" ? "left" : "top";
			switch(t){
				case "function": /* this currently is not used. Consider removing it */
					return val();
				case "object": /* js/jquery object */
					obj=val.jquery ? val : QBOX.$(val);
					if(!obj.length){return;}
					return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
				case "string": case "number":
					if(_isNumeric(val)){ /* numeric value */
						return Math.abs(val);
					}else if(val.indexOf("%")!==-1){ /* percentage value */
						return Math.abs(contentLength*parseInt(val)/100);
					}else if(val.indexOf("-=")!==-1){ /* decrease value */
						return Math.abs(contentPos-parseInt(val.split("-=")[1]));
					}else if(val.indexOf("+=")!==-1){ /* inrease value */
						var p=(contentPos+parseInt(val.split("+=")[1]));
						return p>=0 ? 0 : Math.abs(p);
					}else if(val.indexOf("px")!==-1 && _isNumeric(val.split("px")[0])){ /* pixels string value (e.g. "100px") */
						return Math.abs(val.split("px")[0]);
					}else{
						if(val==="top" || val==="left"){ /* special strings */
							return 0;
						}else if(val==="bottom"){
							return Math.abs(wrapper.height()-mCSB_container.outerHeight(false));
						}else if(val==="right"){
							return Math.abs(wrapper.width()-mCSB_container.outerWidth(false));
						}else if(val==="first" || val==="last"){
							obj=mCSB_container.find(":"+val);
							return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
						}else{
							if(QBOX.$(val).length){ /* jquery selector */
								return dir==="x" ? _childPos(QBOX.$(val))[1] : _childPos(QBOX.$(val))[0];
							}else{ /* other values (e.g. "100em") */
								mCSB_container.css(cssProp,val);
								methods.update.call(null,$this[0]);
								return;
							}
						}
					}
					break;
			}
		},
		/* -------------------- */
		
		
		/* calls the update method automatically */
		_autoUpdate=function(rem){
			var $this=QBOX.$(this),d=$this.data(pluginPfx),o=d.opt,
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container");
			if(rem){
				/* 
				removes autoUpdate timer 
				usage: _autoUpdate.call(this,"remove");
				*/
				clearTimeout(mCSB_container[0].autoUpdate);
				_delete(mCSB_container[0],"autoUpdate");
				return;
			}
			upd();
			function upd(){
				clearTimeout(mCSB_container[0].autoUpdate);
				if($this.parents("html").length===0){
					/* check element in dom tree */
					$this=null;
					return;
				}
				mCSB_container[0].autoUpdate=setTimeout(function(){
					/* update on specific selector(s) length and size change */
					if(o.advanced.updateOnSelectorChange){
						d.poll.change.n=sizesSum();
						if(d.poll.change.n!==d.poll.change.o){
							d.poll.change.o=d.poll.change.n;
							doUpd(3);
							return;
						}
					}
					/* update on main element and scrollbar size changes */
					if(o.advanced.updateOnContentResize){
						d.poll.size.n=$this[0].scrollHeight+$this[0].scrollWidth+mCSB_container[0].offsetHeight+$this[0].offsetHeight+$this[0].offsetWidth;
						if(d.poll.size.n!==d.poll.size.o){
							d.poll.size.o=d.poll.size.n;
							doUpd(1);
							return;
						}
					}
					/* update on image load */
					if(o.advanced.updateOnImageLoad){
						if(!(o.advanced.updateOnImageLoad==="auto" && o.axis==="y")){ //by default, it doesn't run on vertical content
							d.poll.img.n=mCSB_container.find("img").length;
							if(d.poll.img.n!==d.poll.img.o){
								d.poll.img.o=d.poll.img.n;
								mCSB_container.find("img").each(function(){
									imgLoader(this);
								});
								return;
							}
						}
					}
					if(o.advanced.updateOnSelectorChange || o.advanced.updateOnContentResize || o.advanced.updateOnImageLoad){upd();}
				},o.advanced.autoUpdateTimeout);
			}
			/* a tiny image loader */
			function imgLoader(el){
				if(QBOX.$(el).hasClass(classes[2])){doUpd(); return;}
				var img=new Image();
				function createDelegate(contextObject,delegateMethod){
					return function(){return delegateMethod.apply(contextObject,arguments);};
				}
				function imgOnLoad(){
					this.onload=null;
					QBOX.$(el).addClass(classes[2]);
					doUpd(2);
				}
				img.onload=createDelegate(img,imgOnLoad);
				img.src=el.src;
			}
			/* returns the total height and width sum of all elements matching the selector */
			function sizesSum(){
				if(o.advanced.updateOnSelectorChange===true){o.advanced.updateOnSelectorChange="*";}
				var total=0,sel=mCSB_container.find(o.advanced.updateOnSelectorChange);
				if(o.advanced.updateOnSelectorChange && sel.length>0){sel.each(function(){total+=this.offsetHeight+this.offsetWidth;});}
				return total;
			}
			/* calls the update method */
			function doUpd(cb){
				clearTimeout(mCSB_container[0].autoUpdate);
				methods.update.call(null,$this[0],cb);
			}
		},
		/* -------------------- */
		
		
		/* snaps scrolling to a multiple of a pixels number */
		_snapAmount=function(to,amount,offset){
			return (Math.round(to/amount)*amount-offset); 
		},
		/* -------------------- */
		
		
		/* stops content and scrollbar animations */
		_stop=function(el){
			var d=el.data(pluginPfx),
				sel=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container,#rt_qc_mCSB_"+d.idx+"_container_wrapper,#rt_qc_mCSB_"+d.idx+"_dragger_vertical,#rt_qc_mCSB_"+d.idx+"_dragger_horizontal");
			sel.each(function(){
				_stopTween.call(this);
			});
		},
		/* -------------------- */
		
		
		/* 
		ANIMATES CONTENT 
		This is where the actual scrolling happens
		*/
		_scrollTo=function(el,to,opt,params){
			var d=el.data(pluginPfx);
			if(d === undefined)
				return;
			
			var o=d.opt,
				defaults={
					trigger:"internal",
					dir:"y",
					scrollEasing:"mcsEaseOut",
					drag:false,
					dur:o.scrollInertia,
					overwrite:"all",
					callbacks:true,
					onStart:true,
					onUpdate:true,
					onComplete:true
				},
				options=QBOX.$.extend(defaults,opt),
				dur=[options.dur,(options.drag ? 0 : options.dur)],
				mCustomScrollBox=QBOX.$("#rt_qc_mCSB_"+d.idx),
				mCSB_container=QBOX.$("#rt_qc_mCSB_"+d.idx+"_container"),
				wrapper=mCSB_container.parent(),
				totalScrollOffsets=o.callbacks.onTotalScrollOffset ? _arr.call(el,o.callbacks.onTotalScrollOffset) : [0,0],
				totalScrollBackOffsets=o.callbacks.onTotalScrollBackOffset ? _arr.call(el,o.callbacks.onTotalScrollBackOffset) : [0,0];
			d.trigger=options.trigger;
			if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){ /* always reset scrollTop/Left */
				QBOX.$(".rt_qc_mCSB_"+d.idx+"_scrollbar").css("visibility","visible");
				wrapper.scrollTop(0).scrollLeft(0);
			}
			if(to==="_resetY" && !d.contentReset.y){
				/* callbacks: onOverflowYNone */
				if(_cb("onOverflowYNone")){o.callbacks.onOverflowYNone.call(el[0]);}
				d.contentReset.y=1;
			}
			if(to==="_resetX" && !d.contentReset.x){
				/* callbacks: onOverflowXNone */
				if(_cb("onOverflowXNone")){o.callbacks.onOverflowXNone.call(el[0]);}
				d.contentReset.x=1;
			}
			if(to==="_resetY" || to==="_resetX"){return;}
			if((d.contentReset.y || !el[0].mcs) && d.overflowed[0]){
				/* callbacks: onOverflowY */
				if(_cb("onOverflowY")){o.callbacks.onOverflowY.call(el[0]);}
				d.contentReset.x=null;
			}
			if((d.contentReset.x || !el[0].mcs) && d.overflowed[1]){
				/* callbacks: onOverflowX */
				if(_cb("onOverflowX")){o.callbacks.onOverflowX.call(el[0]);}
				d.contentReset.x=null;
			}
			if(o.snapAmount){ /* scrolling snapping */
				var snapAmount=!(o.snapAmount instanceof Array) ? o.snapAmount : options.dir==="x" ? o.snapAmount[1] : o.snapAmount[0];
				to=_snapAmount(to,snapAmount,o.snapOffset);
			}
			var mCSB_dragger,property,contentPos,limit,scrollTo,tso,tsbo,totalScrollOffset,totalScrollBackOffset;
			switch(options.dir){
				case "x":
					mCSB_dragger=QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_horizontal");
					property="left";
					contentPos=mCSB_container[0].offsetLeft;
					limit=[
						mCustomScrollBox.width()-mCSB_container.outerWidth(false),
						mCSB_dragger.parent().width()-mCSB_dragger.width()
					];
					scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.x)];
					tso=totalScrollOffsets[1];
					tsbo=totalScrollBackOffsets[1];
					totalScrollOffset=tso>0 ? tso/d.scrollRatio.x : 0;
					totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.x : 0;
					break;
				case "y":
					mCSB_dragger=QBOX.$("#rt_qc_mCSB_"+d.idx+"_dragger_vertical");
					property="top";
					contentPos=mCSB_container[0].offsetTop;
					limit=[
						mCustomScrollBox.height()-mCSB_container.outerHeight(false),
						mCSB_dragger.parent().height()-mCSB_dragger.height()
					];
					scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.y)];
					tso=totalScrollOffsets[0];
					tsbo=totalScrollBackOffsets[0];
					totalScrollOffset=tso>0 ? tso/d.scrollRatio.y : 0;
					totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.y : 0;
					break;
			}
			if(scrollTo[1]<0 || (scrollTo[0]===0 && scrollTo[1]===0)){
				scrollTo=[0,0];
			}else if(scrollTo[1]>=limit[1]){
				scrollTo=[limit[0],limit[1]];
			}else{
				scrollTo[0]=-scrollTo[0];
			}
			if(!el[0].mcs){
				_mcs(o);  /* init mcs object (once) to make it available before callbacks */
				if(_cb("onInit")){o.callbacks.onInit.call(el[0],params);} /* callbacks: onInit */
			}
			clearTimeout(mCSB_container[0].onCompleteTimeout);
			_tweenTo(mCSB_dragger[0],property,Math.round(scrollTo[1]),dur[1],options.scrollEasing);
			if(!d.tweenRunning && ((contentPos===0 && scrollTo[0]>=0) || (contentPos===limit[0] && scrollTo[0]<=limit[0]))){return;}
			_tweenTo(mCSB_container[0],property,Math.round(scrollTo[0]),dur[0],options.scrollEasing,options.overwrite,{
				onStart:function(){
					if(options.callbacks && options.onStart && !d.tweenRunning){
						/* callbacks: onScrollStart */
						if(_cb("onScrollStart")){_mcs(o); o.callbacks.onScrollStart.call(el[0],params);}
						d.tweenRunning=true;
						_onDragClasses(mCSB_dragger);
						d.cbOffsets=_cbOffsets();
					}
				},onUpdate:function(){
					if(options.callbacks && options.onUpdate){
						/* callbacks: whileScrolling */
						if(_cb("whileScrolling")){_mcs(o); o.callbacks.whileScrolling.call(el[0],params);}
					}
				},onComplete:function(){
					if(options.callbacks && options.onComplete){
						if(o.axis==="yx"){clearTimeout(mCSB_container[0].onCompleteTimeout);}
						var t=mCSB_container[0].idleTimer || 0;
						mCSB_container[0].onCompleteTimeout=setTimeout(function(){
							/* callbacks: onScroll, onTotalScroll, onTotalScrollBack */
							if(_cb("onScroll")){_mcs(o); o.callbacks.onScroll.call(el[0],params);}
							if(_cb("onTotalScroll") && scrollTo[1]>=limit[1]-totalScrollOffset && d.cbOffsets[0]){_mcs(o); o.callbacks.onTotalScroll.call(el[0],params);}
							if(_cb("onTotalScrollBack") && scrollTo[1]<=totalScrollBackOffset && d.cbOffsets[1]){_mcs(o); o.callbacks.onTotalScrollBack.call(el[0],params);}
							d.tweenRunning=false;
							mCSB_container[0].idleTimer=0;
							_onDragClasses(mCSB_dragger,"hide");
						},t);
					}
				}
			});
			/* checks if callback function exists */
			function _cb(cb){
				return d && o.callbacks[cb] && typeof o.callbacks[cb]==="function";
			}
			/* checks whether callback offsets always trigger */
			function _cbOffsets(){
				return [o.callbacks.alwaysTriggerOffsets || contentPos>=limit[0]+tso,o.callbacks.alwaysTriggerOffsets || contentPos<=-tsbo];
			}
			/* 
			populates object with useful values for the user 
			values: 
				content: this.mcs.content
				content top position: this.mcs.top 
				content left position: this.mcs.left 
				dragger top position: this.mcs.draggerTop 
				dragger left position: this.mcs.draggerLeft 
				scrolling y percentage: this.mcs.topPct 
				scrolling x percentage: this.mcs.leftPct 
				scrolling direction: this.mcs.direction
			*/
			function _mcs(o){
				var cp=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft], /* content position */
					dp=[mCSB_dragger[0].offsetTop,mCSB_dragger[0].offsetLeft], /* dragger position */
					cl=[mCSB_container.outerHeight(false),mCSB_container.outerWidth(false)], /* content length */
					pl=[mCustomScrollBox.height(),mCustomScrollBox.width()]; /* content parent length */
				el[0].mcs={
					content:mCSB_container, /* original content wrapper as jquery object */
					top:cp[0],left:cp[1],draggerTop:dp[0],draggerLeft:dp[1],
					topPct:Math.round((100*Math.abs(cp[0]))/(Math.abs(cl[0])-pl[0])),leftPct:Math.round((100*Math.abs(cp[1]))/(Math.abs(cl[1])-pl[1])),
					direction:options.dir,
					target:(o.target === null ? null : o.target)
				};
				/* 
				this refers to the original element containing the scrollbar(s)
				usage: this.mcs.top, this.mcs.leftPct etc. 
				*/
			}
		},
		/* -------------------- */
		
		
		/* 
		CUSTOM JAVASCRIPT ANIMATION TWEEN 
		Lighter and faster than jquery animate() and css transitions 
		Animates top/left properties and includes easings 
		*/
		_tweenTo=function(el,prop,to,duration,easing,overwrite,cbs){
			if(!el._mTween){el._mTween={top:{},left:{}};}
			var callbacks=cbs || {},
				onStart=callbacks.onStart || function(){},onUpdate=callbacks.onUpdate || function(){},onComplete=callbacks.onComplete || function(){},
				startTime=_getTime(),_delay,progress=0,from=el.offsetTop,elStyle=el.style,_request,tobj=el._mTween[prop];
			if(prop==="left"){from=el.offsetLeft;}
			var diff=to-from;
			tobj.stop=0;
			if(overwrite!=="none"){_cancelTween();}
			_startTween();
			function _step(){
				if(tobj.stop){return;}
				if(!progress){onStart.call();}
				progress=_getTime()-startTime;
				_tween();
				if(progress>=tobj.time){
					tobj.time=(progress>tobj.time) ? progress+_delay-(progress-tobj.time) : progress+_delay-1;
					if(tobj.time<progress+1){tobj.time=progress+1;}
				}
				if(tobj.time<duration){tobj.id=_request(_step);}else{onComplete.call();}
			}
			function _tween(){
				if(duration>0){
					tobj.currVal=_ease(tobj.time,from,diff,duration,easing);
					elStyle[prop]=Math.round(tobj.currVal)+"px";
				}else{
					elStyle[prop]=to+"px";
				}
				onUpdate.call();
			}
			function _startTween(){
				_delay=1000/60;
				tobj.time=progress+_delay;
				_request=(!window.requestAnimationFrame) ? function(f){_tween(); return setTimeout(f,0.01);} : window.requestAnimationFrame;
				tobj.id=_request(_step);
			}
			function _cancelTween(){
				if(tobj.id===null){return;}
				if(!window.requestAnimationFrame){clearTimeout(tobj.id);
				}else{window.cancelAnimationFrame(tobj.id);}
				tobj.id=null;
			}
			function _ease(t,b,c,d,type){
				var ts,tc;
				switch(type){
					case "linear": case "mcsLinear":
						return c*t/d + b;						
					case "mcsLinearOut":
						t/=d; t--; return c * Math.sqrt(1 - t*t) + b;						
					case "easeInOutSmooth":
						t/=d/2;
						if(t<1) return c/2*t*t + b;
						t--;
						return -c/2 * (t*(t-2) - 1) + b;
					case "easeInOutStrong":
						t/=d/2;
						if(t<1) return c/2 * Math.pow( 2, 10 * (t - 1) ) + b;
						t--;
						return c/2 * ( -Math.pow( 2, -10 * t) + 2 ) + b;
					case "easeInOut": case "mcsEaseInOut":
						t/=d/2;
						if(t<1) return c/2*t*t*t + b;
						t-=2;
						return c/2*(t*t*t + 2) + b;
					case "easeOutSmooth":
						t/=d; t--;
						return -c * (t*t*t*t - 1) + b;
					case "easeOutStrong":
						return c * ( -Math.pow( 2, -10 * t/d ) + 1 ) + b;
					case "easeOut": case "mcsEaseOut": 
						ts=(t/=d)*t;
						tc=ts*t;
						return b+c*(0.499999999999997*tc*ts + -2.5*ts*ts + 5.5*tc + -6.5*ts + 4*t);
					default:
						ts=(t/=d)*t;
						tc=ts*t;
						return b+c*(0.499999999999997*tc*ts + -2.5*ts*ts + 5.5*tc + -6.5*ts + 4*t);
				}
			}
		},
		/* -------------------- */
		
		
		/* returns current time */
		_getTime=function(){
			if(window.performance && window.performance.now){
				return window.performance.now();
			}else{
				if(window.performance && window.performance.webkitNow){
					return window.performance.webkitNow();
				}else{
					if(Date.now){return Date.now();}else{return new Date().getTime();}
				}
			}
		},
		/* -------------------- */
		
		
		/* stops a tween */
		_stopTween=function(){
			var el=this;
			if(!el._mTween){el._mTween={top:{},left:{}};}
			var props=["top","left"];
			for(var i=0; i<props.length; i++){
				var prop=props[i];
				if(el._mTween[prop].id){
					if(!window.requestAnimationFrame){clearTimeout(el._mTween[prop].id);
					}else{window.cancelAnimationFrame(el._mTween[prop].id);}
					el._mTween[prop].id=null;
					el._mTween[prop].stop=1;
				}
			}
		},
		/* -------------------- */
		
		
		/* deletes a property (avoiding the exception thrown by IE) */
		_delete=function(c,m){
			try{delete c[m];}catch(e){c[m]=null;}
		},
		/* -------------------- */
		
		
		/* detects left mouse button */
		_mouseBtnLeft=function(e){
			return !(e.which && e.which!==1);
		},
		/* -------------------- */
		
		
		/* detects if pointer type event is touch */
		_pointerTouch=function(e){
			var t=e.originalEvent.pointerType;
			return !(t && t!=="touch" && t!==2);
		},
		/* -------------------- */
		
		
		/* checks if value is numeric */
		_isNumeric=function(val){
			return !isNaN(parseFloat(val)) && isFinite(val);
		},
		/* -------------------- */
		
		
		/* returns element position according to content */
		_childPos=function(el){
			var p=el.parents(".rt_qc_mCSB_container");
			return [el.offset().top-p.offset().top,el.offset().left-p.offset().left];
		},
		/* -------------------- */
		
		
		/* checks if browser tab is hidden/inactive via Page Visibility API */
		_isTabHidden=function(){
			var prop=_getHiddenProp();
			if(!prop) return false;
			return document[prop];
			function _getHiddenProp(){
				var pfx=["webkit","moz","ms","o"];
				if("hidden" in document) return "hidden"; //natively supported
				for(var i=0; i<pfx.length; i++){ //prefixed
				    if((pfx[i]+"Hidden") in document) 
				        return pfx[i]+"Hidden";
				}
				return null; //not supported
			}
		};
		/* -------------------- */
		
	
	
	
	
	/* 
	----------------------------------------
	PLUGIN SETUP 
	----------------------------------------
	*/
	
	/* plugin constructor functions */
	QBOX.$.fn[pluginNS]=function(method){ /* usage: $(selector).rt_qc_mCSBar(); */
		if(methods[method]){
			return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
		}else if(typeof method==="object" || !method){
			return methods.init.apply(this,arguments);
		}else{
			QBOX.$.error("Method "+method+" does not exist");
		}
	};
	QBOX.$[pluginNS]=function(method){ /* usage: $.rt_qc_mCSBar(); */
		if(methods[method]){
			return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
		}else if(typeof method==="object" || !method){
			return methods.init.apply(this,arguments);
		}else{
			QBOX.$.error("Method "+method+" does not exist");
		}
	};
	
	/* 
	allow setting plugin default options. 
	usage: $.rt_qc_mCSBar.defaults.scrollInertia=500; 
	to apply any changed default options on default selectors (below), use inside document ready fn 
	e.g.: $(document).ready(function(){ $.rt_qc_mCSBar.defaults.scrollInertia=500; });
	*/
	QBOX.$[pluginNS].defaults=defaults;
	
	/* 
	add window object (window.rt_qc_mCSBar) 
	usage: if(window.rt_qc_mCSBar){console.log("custom scrollbar plugin loaded");}
	*/
	window[pluginNS]=true;
	
	QBOX.$(window).bind("load",function(){
		
		QBOX.$(defaultSelector)[pluginNS](); /* add scrollbars automatically on default selector */
		
		/* extend jQuery expressions */
		QBOX.$.extend(QBOX.$.expr[":"],{
			/* checks if element is within scrollable viewport */
			mcsInView:QBOX.$.expr[":"].mcsInView || function(el){
				var $el=QBOX.$(el),content=$el.parents(".rt_qc_mCSB_container"),wrapper,cPos;
				if(!content.length){return;}
				wrapper=content.parent();
				cPos=[content[0].offsetTop,content[0].offsetLeft];
				return 	cPos[0]+_childPos($el)[0]>=0 && cPos[0]+_childPos($el)[0]<wrapper.height()-$el.outerHeight(false) && 
						cPos[1]+_childPos($el)[1]>=0 && cPos[1]+_childPos($el)[1]<wrapper.width()-$el.outerWidth(false);
			},
			/* checks if element or part of element is in view of scrollable viewport */
			mcsInSight:QBOX.$.expr[":"].mcsInSight || function(el,i,m){
				var $el=QBOX.$(el),elD,content=$el.parents(".rt_qc_mCSB_container"),wrapperView,pos,wrapperViewPct,
					pctVals=m[3]==="exact" ? [[1,0],[1,0]] : [[0.9,0.1],[0.6,0.4]];
				if(!content.length){return;}
				elD=[$el.outerHeight(false),$el.outerWidth(false)];
				pos=[content[0].offsetTop+_childPos($el)[0],content[0].offsetLeft+_childPos($el)[1]];
				wrapperView=[content.parent()[0].offsetHeight,content.parent()[0].offsetWidth];
				wrapperViewPct=[elD[0]<wrapperView[0] ? pctVals[0] : pctVals[1],elD[1]<wrapperView[1] ? pctVals[0] : pctVals[1]];
				return 	pos[0]-(wrapperView[0]*wrapperViewPct[0][0])<0 && pos[0]+elD[0]-(wrapperView[0]*wrapperViewPct[0][1])>=0 && 
						pos[1]-(wrapperView[1]*wrapperViewPct[1][0])<0 && pos[1]+elD[1]-(wrapperView[1]*wrapperViewPct[1][1])>=0;
			},
			/* checks if element is overflowed having visible scrollbar(s) */
			mcsOverflow:QBOX.$.expr[":"].mcsOverflow || function(el){
				var d=QBOX.$(el).data(pluginPfx);
				if(!d){return;}
				return d.overflowed[0] || d.overflowed[1];
			}
		});
	
	});

});
QBOX.QCELL.BasicQCELL.prototype._getColSearchArea = function(){
	if(this.attr('colsearcharea') === null){
		var heDiv = document.createElement('div');
		this.attr('colsearcharea', this._createColSearchArea(heDiv), 'jquery');
	}
	
	return this.attr('colsearcharea').clone(true).get(0);
};
// col search click하면 ui생성
QBOX.QCELL.BasicQCELL.prototype._createColSearchArea = function(heDiv){
	var css = QBOX.QCELL.def.css;
	
	return QBOX.$(heDiv.cloneNode()).addClass(css.COLSEARCH_AREA).on('mousedown', this.attr('eventparam'), function(event){
		var target = event.target,
		objQCell = event.data.target,
		nTargetCol = parseInt(target.parentNode.getAttribute('data-col')),
		$searchUIArea = QBOX.$(heDiv.cloneNode()).addClass(css.COLSEARCH_UI_AREA);
		
		if(objQCell.attr('colsearchuivisible')){ // 출력 상태라면 제거
			objQCell._removeColSearUIArea();
		}
		
		// COLSEARCH_AREA 중 현재 클릭된 element에만 COLSEARCH_AREA_HOVER class 추가
		QBOX.$(this).addClass(css.COLSEARCH_AREA_HOVER);
		
		if(objQCell._getQCellCol(nTargetCol).attr('datatype') === 'string'){ // 문자형일 때 col search ui 생성
			objQCell._createStringColSearchUIArea(nTargetCol, $searchUIArea);
		} else{ // 숫자형일 때 col search ui 생성
			objQCell._createNumberColSearchUIArea(nTargetCol, $searchUIArea);
		}
		
		objQCell._showColSearchUIArea(target, nTargetCol);
	});
};

// col search ui 구조 생성
QBOX.QCELL.BasicQCELL.prototype._createStringColSearchUIArea = function(nCol, $jqColSearchArea){
	var css = QBOX.QCELL.def.css,
	$div = QBOX.$(document.createElement('div')),
	$button = QBOX.$(document.createElement('button')).addClass(css.COLSEARCH_UI_BTN),
	$span = QBOX.$(document.createElement('span')),
	$input = QBOX.$(document.createElement('input')),
	$titleArea, $inputArea, $buttonArea, $messageArea,
	strTitle = this.attr('headertext')[nCol][this.attr('headertext')[nCol].length - 1],
	id = this.attr('id') + '_colsearch_text_' + nCol,
	msg_id = this.attr('id') + '_colsearch_msg_' + nCol,
	nHeaderRows = this.attr('headerrows'),
	objColSearchInfo = this.attr('colsearchinfo'),
	objPaginationInfo = this.attr('paginationinfo'),
	msg_text = '';
	
	// 최초 생성시 col index를 키값으로 하여, 입력값과 배열값 생성
	if(objColSearchInfo[nCol] === undefined){
		objColSearchInfo[nCol] = {};
		objColSearchInfo[nCol].key = '';
		objColSearchInfo[nCol].arrColIdxs = [];
		objColSearchInfo[nCol].move = {};
	}
	
	$jqColSearchArea.css({
		'display'	: 'none',
		'height'	: '120px',
		'width'		: '180px'
	});
	
	/* 상단 제목 영역 start */
	$titleArea = $div.clone().css({
		'margin-bottom': '10px'
	});
	
	$span.clone().text(strTitle).css({
		'font-weight'	: 'bold',
		'font-size'		: '15px'
	}).appendTo($titleArea);
	
	$div.clone().addClass(css.COLSEARCH_UI_CLOSE).on('click', this.attr('eventparam'), function(event){ // X버튼 클릭시 colsearch UI 제거
		var objQCell = event.data.target;
		
		if(objQCell.attr('colsearchuivisible')){
			objQCell._removeColSearUIArea();
		}
		
	}).appendTo($titleArea);
	
	$titleArea.appendTo($jqColSearchArea);
	/* 상단 제목 영역 end */
	
	/* 입력 영역 start */
	$inputArea = $div.clone();
	
	$input.clone()
	.css({
		'width'	: '100%',
		'margin': '0px 5px 5px 0px'
	})
	.attr({'id': id}).on('keydown', this.attr('eventparam'),function(event){
		if(event.keyCode !== QBOX.def.key.ENTER)
			return;
		
		var THAT = this;
		setTimeout(function(){
			THAT.focus();
			},500);
		
		var objQCell = event.data.target,
		idVal = QBOX.$('#'+id).val(),
		nRow = objQCell.getIdx('row', 'focus'),
		arrColIndex = [],
		i;
		
		if(QBOX.$.trim(idVal).length > 0){
			var arrColData = objQCell._getColData(nCol);
			
			// 이전 검색한 검색값과 검색값이 틀릴 경우
			if( objColSearchInfo[nCol].key !== idVal ){
				for(i=0; i<arrColData.length; i++){
					if(arrColData[i] !== undefined && arrColData[i].indexOf(idVal) > -1){
						arrColIndex.push(nHeaderRows+i);
					}
				}
				
				objColSearchInfo[nCol].key = idVal;
				objColSearchInfo[nCol].arrColIdxs = arrColIndex;
				
				msg_text = objQCell._moveNexColSearchRow(nCol, nRow, arrColIndex);
			}
			else { // 동일 colindex에서 동일한 검색값으로 검색할 때
				
				if(QBOX._.isUndefined(objPaginationInfo)){ // pagination 미사용시
					msg_text = objQCell._moveNexColSearchRow(nCol, nRow, objColSearchInfo[nCol].arrColIdxs);
				}
				else{ // pagination 사용시 pageindex정보가 바뀌었는지 확인이 어렵기 때문에 재검색
					for(i=0; i<arrColData.length; i++){
						if(arrColData[i] !== undefined && arrColData[i].indexOf(idVal) > -1){
							arrColIndex.push(nHeaderRows+i);
						}
					}
					
					objColSearchInfo[nCol].key = idVal;
					objColSearchInfo[nCol].arrColIdxs = arrColIndex;
					
					msg_text = objQCell._moveNexColSearchRow(nCol, nRow, arrColIndex);
					

				}
			}
		}
		// 검색값이 존재하지 않을 경우
		else {
			objColSearchInfo[nCol].arrColIdxs = [];
			msg_text = '검색할 값을 입력하여 주십시오.';
		}
		
		QBOX.$('#'+msg_id).text(msg_text);
		
	}).val(objColSearchInfo[nCol].key).appendTo($inputArea);
	
	$inputArea.appendTo($jqColSearchArea);
	/* 입력 영역 end */
	
	/* 하단 버튼 영역 start */
	$buttonArea = $div.clone().css({
		'text-align': 'center',
		'margin-top': '10px'
	});
	
	$span.clone().text(QBOX.QCELL.def.resource.search).appendTo($button.clone().css({'background-color': '#949598', 'border': '1px solid #949598'}).on('click', this.attr('eventparam'), function(event){
		
		var objQCell = event.data.target,
		idVal = QBOX.$('#'+id).val(),
		nRow = objQCell.getIdx('row', 'focus'),
		arrColIndex = [],
		i;
		
		if(QBOX.$.trim(idVal).length > 0){
			var arrColData = objQCell._getColData(nCol);
			
			// 이전 검색한 검색값과 검색값이 틀릴 경우
			if( objColSearchInfo[nCol].key !== idVal ){
				for(i=0; i<arrColData.length; i++){
					if(arrColData[i] !== undefined && arrColData[i].indexOf(idVal) > -1){
						arrColIndex.push(nHeaderRows+i);
					}
				}
				
				objColSearchInfo[nCol].key = idVal;
				objColSearchInfo[nCol].arrColIdxs = arrColIndex;
				
				msg_text = objQCell._moveNexColSearchRow(nCol, nRow, arrColIndex);
			}
			else { // 동일 colindex에서 동일한 검색값으로 검색할 때
				
				if(QBOX._.isUndefined(objPaginationInfo)){ // pagination 미사용시
					msg_text = objQCell._moveNexColSearchRow(nCol, nRow, objColSearchInfo[nCol].arrColIdxs);
				}
				else{ // pagination 사용시 pageindex정보가 바뀌었는지 확인이 어렵기 때문에 재검색
					for(i=0; i<arrColData.length; i++){
						if(arrColData[i] !== undefined && arrColData[i].indexOf(idVal) > -1){
							arrColIndex.push(nHeaderRows+i);
						}
					}
					
					objColSearchInfo[nCol].key = idVal;
					objColSearchInfo[nCol].arrColIdxs = arrColIndex;
					
					msg_text = objQCell._moveNexColSearchRow(nCol, nRow, arrColIndex);
				}
			}
		}
		// 검색값이 존재하지 않을 경우
		else {
			objColSearchInfo[nCol].arrColIdxs = [];
			msg_text = '검색할 값을 입력하여 주십시오.';
		}
		
		QBOX.$('#'+msg_id).text(msg_text);
	}).appendTo($buttonArea));
	
	$span.clone().text(QBOX.QCELL.def.resource.reset).appendTo($button.clone().css({'background-color': '#3b99fc', 'border': '1px solid #3b99fc'}).on('click', this.attr('eventparam'), function(event){
		
		QBOX.$('#'+id).val('');
		
		objColSearchInfo[nCol].key = '';
		objColSearchInfo[nCol].arrColIdxs = [];
		
		QBOX.$('#'+msg_id).text('');
	}).appendTo($buttonArea));
	
	$buttonArea.appendTo($jqColSearchArea);
	/* 하단 버튼 영역 end */
	
	/* 메세지 영역 start */
	$messageArea = $div.clone().css({
		'text-align': 'center',
		'font-size' : '11px',
		'margin-top': '5px'
	});
	
	$span.clone().css({'color': 'red'}).attr('id', msg_id).appendTo($messageArea);
	
	$messageArea.appendTo($jqColSearchArea);
	/* 메세지 영역 end */
	
	QBOX.$($jqColSearchArea).draggable({ // jquery ui의 drag 기능 구현
		drag: function(){ // drag 동작이 끝난 후 현재 위치의 top, left 정보를 저장
			objColSearchInfo[nCol].move.top = parseInt($jqColSearchArea.css('top'));
			objColSearchInfo[nCol].move.left = parseInt($jqColSearchArea.css('left'));
		}
	});
	
	this.attr('colsearchuiarea', $jqColSearchArea, 'jquery');
};

QBOX.QCELL.BasicQCELL.prototype._createNumberColSearchUIArea = function(nCol, $jqColSearchArea){
	var css = QBOX.QCELL.def.css,
	$div = QBOX.$(document.createElement('div')),
	$button = QBOX.$(document.createElement('button')).addClass(css.COLSEARCH_UI_BTN),
	$span = QBOX.$(document.createElement('span')),
	$input = QBOX.$(document.createElement('input')),
	$select = QBOX.$(document.createElement('select')),
	$option = QBOX.$(document.createElement('option')),
	$titleArea, $inputArea, $selectArea, $buttonArea, $messageArea,
	strTitle = this.attr('headertext')[nCol][this.attr('headertext')[nCol].length - 1],
	id = this.attr('id') + '_colsearch_text_' + nCol,
	select_id = this.attr('id') + '_colsearch_select_' + nCol,
	msg_id = this.attr('id') + '_colsearch_msg_' + nCol,
	nHeaderRows = this.attr('headerrows'),
	objColSearchInfo = this.attr('colsearchinfo'),
	objPaginationInfo = this.attr('paginationinfo'),
	msg_text = '';
	
	// 최초 생성시 col index를 키값으로 하여, 입력값과 배열값 생성
	if(objColSearchInfo[nCol] === undefined){
		objColSearchInfo[nCol] = {};
		objColSearchInfo[nCol].key = '';
		objColSearchInfo[nCol].operator = 'gt'; // number형일 경우 operator 키값 추가
		objColSearchInfo[nCol].arrColIdxs = [];
		objColSearchInfo[nCol].move = {};
	}
	
	$jqColSearchArea.css({
		'display'	: 'none',
		'height'	: '140px',
		'width'		: '220px'
	});
	
	/* 상단 제목 영역 start */
	$titleArea = $div.clone().css({
		'margin-bottom': '10px'
	});
	
	$span.clone().text(strTitle).css({
		'font-weight'	: 'bold',
		'font-size'		: '15px'
	}).appendTo($titleArea);
	
	$div.clone().addClass(css.COLSEARCH_UI_CLOSE).on('click', this.attr('eventparam'), function(event){
		var objQCell = event.data.target;
		
		if(objQCell.attr('colsearchuivisible')){
			objQCell._removeColSearUIArea();
		}
		
	}).appendTo($titleArea);
	
	$titleArea.appendTo($jqColSearchArea);
	/* 상단 제목 영역 end */
	
	/* 입력 영역 start */
	$inputArea = $div.clone();
	$selectArea = $div.clone();
	
	$input.clone()
	.css({
		'width'	: '100%',
		'margin': '0px 5px 5px 0px'
	})
	.attr({'id': id}).val(objColSearchInfo[nCol].key).on('keydown', this.attr('eventparam'),function(event){
		if(event.keyCode !== QBOX.def.key.ENTER)
			return;
		
		var THAT = this;
		setTimeout(function(){
			THAT.focus();
			},500);
		
		var objQCell = event.data.target,
		idVal = QBOX.$('#'+id).val(),
		nRow = objQCell.getIdx('row', 'focus'),
		arrColIndex = [],
		i;
		
		if(QBOX._.isNumber(parseFloat(QBOX.$.trim(idVal))) && QBOX._.isNaN(parseFloat(QBOX.$.trim(idVal))) === false){
			var parseData = parseFloat(idVal),
			operator = QBOX.$('#'+select_id).val(),
			arrColData = objQCell._getColData(nCol);
			
			// 이전 검색한 colIndex의 검색값이 틀릴 경우
			if( objColSearchInfo[nCol].key !== parseData || objColSearchInfo[nCol].operator !== operator){
				for(i=0; i<arrColData.length; i++){
					switch(operator){
						case 'gt':{ // greater than
							if(arrColData[i] > parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'ge':{ // greater or equal
							if(arrColData[i] >= parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'lt':{ // less than
							if(arrColData[i] < parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'le':{ // less than or equal
							if(arrColData[i] <= parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'eq':{ // equal
							if(arrColData[i] === parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'ne':{ // not equal
							if(arrColData[i] !== parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						default: break;
					}
				}
				
				objColSearchInfo[nCol].key = parseData;
				objColSearchInfo[nCol].operator = operator;
				objColSearchInfo[nCol].arrColIdxs = arrColIndex;
				
				msg_text = objQCell._moveNexColSearchRow(nCol, nRow, arrColIndex);
			}
			else { // 동일 colindex에서 동일한 검색값으로 검색할 때
				
				if(QBOX._.isUndefined(objPaginationInfo)){ // pagination 미사용시
					msg_text = objQCell._moveNexColSearchRow(nCol, nRow, objColSearchInfo[nCol].arrColIdxs);
				}
				else{ // pagination 사용시 pageindex정보가 바뀌었는지 확인이 어렵기 때문에 재검색
					for(i=0; i<arrColData.length; i++){
						switch(operator){
							case 'gt':{ // greater than
								if(arrColData[i] > parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'ge':{ // greater or equal
								if(arrColData[i] >= parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'lt':{ // less than
								if(arrColData[i] < parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'le':{ // less than or equal
								if(arrColData[i] <= parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'eq':{ // equal
								if(arrColData[i] === parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'ne':{ // not equal
								if(arrColData[i] !== parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							default: break;
						}
					}
					
					objColSearchInfo[nCol].key = parseData;
					objColSearchInfo[nCol].operator = operator;
					objColSearchInfo[nCol].arrColIdxs = arrColIndex;
					
					msg_text = objQCell._moveNexColSearchRow(nCol, nRow, arrColIndex);
				}
			}
		}
		// 검색값이 존재하지 않을 경우
		else {
			objColSearchInfo[nCol].arrColIdxs = [];
			msg_text = '검색할 값이 없거나 숫자가 아닙니다.';
		}
		
		QBOX.$('#'+msg_id).text(msg_text);
		
	}).appendTo($inputArea);
	
	$inputArea.appendTo($jqColSearchArea);
	
	$option.clone().val('gt').text('크다(>)').attr('selected', objColSearchInfo[nCol].operator === 'gt' ? true : false).appendTo($select);
	$option.clone().val('lt').text('작다(<)').attr('selected', objColSearchInfo[nCol].operator === 'lt' ? true : false).appendTo($select);
	$option.clone().val('ge').text('크거나 같다(>=)').attr('selected', objColSearchInfo[nCol].operator === 'ge' ? true : false).appendTo($select);
	$option.clone().val('le').text('작거나 같다(<=)').attr('selected', objColSearchInfo[nCol].operator === 'le' ? true : false).appendTo($select);
	$option.clone().val('eq').text('같다(==)').attr('selected', objColSearchInfo[nCol].operator === 'eq' ? true : false).appendTo($select);
	$option.clone().val('ne').text('같지 않다(!=)').attr('selected', objColSearchInfo[nCol].operator === 'ne' ? true : false).appendTo($select);
	
	$select.css({
		'height': '20px',
		'width'	: '100%',
		'margin': '0'
	})
	.attr({'id': select_id})
	.appendTo($selectArea);
	
	$selectArea.appendTo($jqColSearchArea);
	
	/* 입력 영역 end */
	
	/* 하단 버튼 영역 start */
	$buttonArea = $div.clone().css({
		'text-align': 'center',
		'margin-top': '10px'
	}).attr({'id': id});
	
	$span.clone().text(QBOX.QCELL.def.resource.search).appendTo($button.clone().css({'background-color': '#949598', 'border': '1px solid #949598'}).on('click', this.attr('eventparam'), function(event){
		var objQCell = event.data.target,
		idVal = QBOX.$('#'+id).val(),
		nRow = objQCell.getIdx('row', 'focus'),
		arrColIndex = [],
		i;
		
		if(QBOX._.isNumber(parseFloat(QBOX.$.trim(idVal))) && QBOX._.isNaN(parseFloat(QBOX.$.trim(idVal))) === false){
			var parseData = parseFloat(idVal),
			operator = QBOX.$('#'+select_id).val(),
			arrColData = objQCell._getColData(nCol);
			
			// 이전 검색한 colIndex의 검색값이 틀릴 경우
			if( objColSearchInfo[nCol].key !== parseData || objColSearchInfo[nCol].operator !== operator){
				for(i=0; i<arrColData.length; i++){
					switch(operator){
						case 'gt':{ // greater than
							if(arrColData[i] > parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'ge':{ // greater or equal
							if(arrColData[i] >= parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'lt':{ // less than
							if(arrColData[i] < parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'le':{ // less than or equal
							if(arrColData[i] <= parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'eq':{ // equal
							if(arrColData[i] === parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						case 'ne':{ // not equal
							if(arrColData[i] !== parseData){
								arrColIndex.push(nHeaderRows+i);
							}
							break;
						}
						default: break;
					}
				}
				
				objColSearchInfo[nCol].key = parseData;
				objColSearchInfo[nCol].operator = operator;
				objColSearchInfo[nCol].arrColIdxs = arrColIndex;
				
				msg_text = objQCell._moveNexColSearchRow(nCol, nRow, arrColIndex);
			}
			else { // 동일 colindex에서 동일한 검색값으로 검색할 때
				
				if(QBOX._.isUndefined(objPaginationInfo)){ // pagination 미사용시
					msg_text = objQCell._moveNexColSearchRow(nCol, nRow, objColSearchInfo[nCol].arrColIdxs);
				}
				else{ // pagination 사용시 pageindex정보가 바뀌었는지 확인이 어렵기 때문에 재검색
					for(i=0; i<arrColData.length; i++){
						switch(operator){
							case 'gt':{ // greater than
								if(arrColData[i] > parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'ge':{ // greater or equal
								if(arrColData[i] >= parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'lt':{ // less than
								if(arrColData[i] < parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'le':{ // less than or equal
								if(arrColData[i] <= parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'eq':{ // equal
								if(arrColData[i] === parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							case 'ne':{ // not equal
								if(arrColData[i] !== parseData){
									arrColIndex.push(nHeaderRows+i);
								}
								break;
							}
							default: break;
						}
					}
					
					objColSearchInfo[nCol].key = parseData;
					objColSearchInfo[nCol].operator = operator;
					objColSearchInfo[nCol].arrColIdxs = arrColIndex;
					
					msg_text = objQCell._moveNexColSearchRow(nCol, nRow, arrColIndex);
				}
			}
		}
		// 검색값이 존재하지 않을 경우
		else {
			objColSearchInfo[nCol].arrColIdxs = [];
			msg_text = '검색할 값이 없거나 숫자가 아닙니다.';
		}
		
		QBOX.$('#'+msg_id).text(msg_text);
	}).appendTo($buttonArea));
	
	$span.clone().text(QBOX.QCELL.def.resource.reset).appendTo($button.clone().css({'background-color': '#3b99fc', 'border': '1px solid #3b99fc'}).on('click', this.attr('eventparam'), function(event){
		QBOX.$('#'+id).val('');
		QBOX.$('#'+select_id+' option:eq(0)').prop('selected', true);
		
		objColSearchInfo[nCol].key = '';
		objColSearchInfo[nCol].operator = 'gt';
		objColSearchInfo[nCol].arrColIdxs = [];
		
		QBOX.$('#'+msg_id).text('');
	}).appendTo($buttonArea));
	
	$buttonArea.appendTo($jqColSearchArea);
	/* 하단 버튼 영역 end */
	
	/* 메세지 영역 start */
	$messageArea = $div.clone().css({
		'text-align': 'center',
		'font-size' : '11px',
		'margin-top': '5px'
	});
	
	$span.clone().css({'color': 'red'}).attr('id', msg_id).appendTo($messageArea);
	
	$messageArea.appendTo($jqColSearchArea);
	/* 메세지 영역 end */
	
	QBOX.$($jqColSearchArea).draggable({ // jquery ui의 drag 기능 구현
		drag: function(){ // drag 동작이 끝난 후 현재 위치의 top, left 정보를 저장
			objColSearchInfo[nCol].move.top = parseInt($jqColSearchArea.css('top'));
			objColSearchInfo[nCol].move.left = parseInt($jqColSearchArea.css('left'));
		}
	});
	
	this.attr('colsearchuiarea', $jqColSearchArea, 'jquery');
};

// 검색 버튼 클릭 시 검색 조건과 일치하는 하단의 행으로 이동
QBOX.QCELL.BasicQCELL.prototype._moveNexColSearchRow = function(nCol, nRow, arrColIndex){
	var objQCell = this,
	lastRow = 0,
	msg_text = '';
	
	if(arrColIndex.length > 0){ // 검색 데이터가 있을 경우 다음 검색 데이터로의 스크롤 이동
		for(var i=0; i<arrColIndex.length; i++){
			if(nRow < arrColIndex[i]){
				lastRow = arrColIndex[i];
				break;
			}
			else {
				if(i === arrColIndex.length - 1){ // 마지막 행에 검색 데이터가 없을 경우, 최초의 검색 데이터가 있는 행을 반환
					lastRow = arrColIndex[0];
				}
			}
		}
		objQCell._clickCell(lastRow, nCol);
		objQCell._scrollTop(lastRow);
		
		/*
		new Promise(function(resolve){ // 스크롤 이동 후 focus처리 동기화
			objQCell._scrollTop(lastRow);
			setTimeout(function(){
				resolve(true);
			}, 100);
		}).then(function(){ // 100ms 이후 동작
			// focus처리만 할 경우
			//var heElement = objQCell._getCellDOM(arrColIndex[0], nCol);
			//objQCell._clearFocus();
			//objQCell._addFocusStyleClass(heElement);
			
			objQCell._clickCell(lastRow, nCol);
		});*/
	}
	else{
		msg_text = '검색 데이터가 없습니다.';
	}
	
	return msg_text;
};

// col search ui 추가 (화면 표시)
QBOX.QCELL.BasicQCELL.prototype._showColSearchUIArea = function(heTarget, nCol){
	var css = QBOX.QCELL.def.css,
	$jqColSearchArea = this.attr('colsearchuiarea'),
	nViewportOffsetLeft = this.attr('layoutsize').viewport.offsetLeft,
	nTargetLeft = heTarget.parentNode.offsetLeft + nViewportOffsetLeft,
	nTargetTop = heTarget.parentNode.offsetTop + this.attr('layoutsize').colheader.offsetHeight - (QBOX.$('.'+css.COLSEARCH_AREA).height() / 2),
	rootOffWidth = this.attr('layoutsize').root.offsetWidth,
	nWidth = parseInt($jqColSearchArea.css('width')),
	nTargetColWidth = parseInt(this._getColWidth(nCol)),
	objColSearchInfo = this.attr('colsearchinfo'),
	nSpacing = QBOX.$('.'+css.COLSEARCH_AREA).width(),
	left = 0;
	
	var id = this.attr('id') + '_colsearch_text_' + nCol;
	
	$jqColSearchArea.appendTo(this.attr('elementpool').get('container'));
	
	if($jqColSearchArea.css('display') === 'none'){ // 화면에 미출력일 경우에만 출력처리
		$jqColSearchArea.css('display', 'inline-block');
	}
	
	if((nTargetLeft - nSpacing + (nWidth*2)) < rootOffWidth){ // 전체화면 보다 적을 때만 우측방향에서 생성
		left = (nTargetLeft + nTargetColWidth - nSpacing);
	}
	else { // 전체화면보다 크면 좌측방향에서 생성
		left = (nTargetLeft - nWidth);
	}
	
	if(QBOX._.isEmpty(objColSearchInfo[nCol].move) === false){ // drag정보가 있으면 해당 위치로 조정
		left = objColSearchInfo[nCol].move.left;
		nTargetTop = objColSearchInfo[nCol].move.top;
	}
	
	$jqColSearchArea.css({
		'left': left + 'px',
		'top' : nTargetTop + 'px'
	});
	
	this.attr('colsearchuivisible', true, 'boolean');
	
	setTimeout(function(){
		QBOX.$('#'+id).focus();
	},0);
};

//col search ui 제거
QBOX.QCELL.BasicQCELL.prototype._removeColSearUIArea = function(){
	var css = QBOX.QCELL.def.css;
	
	// COLSEARCH_AREA 중 COLSEARCH_AREA_HOVER class 전체 삭제
	QBOX.$('.'+css.COLSEARCH_AREA).removeClass(css.COLSEARCH_AREA_HOVER);
	
	this.attr('colsearchuiarea').remove();
	this.attr('colsearchuiarea', null, 'jquery');
	this.attr('colsearchuivisible', false, 'boolean');
};
//2018-01-20(sai1515): 마지막으로 선택한 셀의 row index 리턴 함수.
QBOX.QCELL.BasicQCELL.prototype._getSelectedRow = function(){
	var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row');
	return htSelectedIdxInfoOfRow.size() > 0 ? htSelectedIdxInfoOfRow.keys()[0] : -1;
};

//2018-01-20(sai1515): 마지막으로 선택한 셀의 col index 리턴 함수.
QBOX.QCELL.BasicQCELL.prototype._getSelectedCol = function(){
	var htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col');
	return htSelectedIdxInfoOfCol.size() > 0 ? htSelectedIdxInfoOfCol.keys()[0] : -1;
};

QBOX.QCELL.BasicQCELL.prototype._getSelectedRows = function(){
	return this._getIdxInfo('selected', 'row').keys();
};

QBOX.QCELL.BasicQCELL.prototype._getSelectedCols = function(){
	return this._getIdxInfo('selected', 'col').keys();
};

QBOX.QCELL.BasicQCELL.prototype._clearSelection = function(){
	var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row'),
	htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col');
	
	htSelectedIdxInfoOfRow.clear();
	htSelectedIdxInfoOfCol.clear();
	
	this._clearSelectionCSS();
};

QBOX.QCELL.BasicQCELL.prototype._clearSelectionCSS = function(){
	QBOX.util.removeClass(QBOX._.flatten(this.attr('cellmatrix').get('row')), QBOX.QCELL.def.css.CELL_SELECT);
	QBOX.$(QBOX.QCELL.def.css.CELL_SELECT).removeClass(QBOX.QCELL.def.css.CELL_SELECT);
//	QBOX.$(_.flatten(this._getCellGroupDOMs('row', 'frozen')).concat(_.flatten(this._getCellGroupDOMs('row', 'normal'))).concat(_.flatten(this._getCellGroupDOMs('row', 'frozenbottom'))))
//	.filter('.' + css.CELL_SELECT).removeClass(css.CELL_SELECT);
};

QBOX.QCELL.BasicQCELL.prototype._selectRow = function(nRow){
	/* 2018-02-27(sai1515): 병합이 설정되어 있을 경우 mastercell index로 변경해주는 로직 추가 */
	if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
		var objIndex = this._findNextCell(nRow, this._idx('col', 'focus'), 'up');
		nRow = objIndex.row;
	}
	/* end */
	if(nRow >= this.attr('headerrows')){
		switch(this.attr('selectmode')){
			case 'row': case 'rows': {
				var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row');
				
				if(htSelectedIdxInfoOfRow.containsKey(nRow)){
					htSelectedIdxInfoOfRow.remove(nRow);
				} else{//selectmode가 row 또는 rows인 경우 행 인덱스만 저장하면 된다.
					QBOX.util.addClass(this._getRowCellDOMs(nRow), QBOX.QCELL.def.css.CELL_SELECT);
				}
				
				htSelectedIdxInfoOfRow.put(nRow, true);//항상 
				
				break;
			}
			default:break;
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._deselectRow = function(nRow){
	if(nRow >= this.attr('headerrows')){
		switch(this.attr('selectmode')){
			case 'row': case 'rows': {
				var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row');
				
				if(htSelectedIdxInfoOfRow.containsKey(nRow)){
					htSelectedIdxInfoOfRow.remove(nRow);
					
					//QBOX.util.removeClass(this._getRowCellDOMs(nRow).slice(this.attr('headercols')), QBOX.QCELL.def.css.CELL_SELECT);
					QBOX.util.removeClass(this._getRowCellDOMs(nRow), QBOX.QCELL.def.css.CELL_SELECT);
				}
				
				break;
			}
			default:break;
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._selectRows = function(arrSelectedRows){
	/* 2018-02-27(sai1515): 병합이 설정되어 있을 경우 mastercell index로 변경해주는 로직 추가 */
	if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
		if(this.attr('merge').data === 'col' || this.attr('merge').data === 'group'){
			var objIndex = this._findNextCell(arrSelectedRows[arrSelectedRows.length - 1], this._idx('col', 'focus'), 'up');
			
			if(this._idx('row', 'focus') > arrSelectedRows[arrSelectedRows.length - 1]){
				arrSelectedRows = QBOX._.range(objIndex.row, this._idx('row', 'focus') + 1).reverse();
			}
		}
	}
	/* end */
	switch(this.attr('selectmode')){
		case 'rows': {
			var objQCell = this,
			nHeaderRows = this.attr('headerrows'),
			nHeaderCols = this.attr('headercols'),
			htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row'),
			arrSelectedCellDOMs = [];
			
			QBOX._.each(arrSelectedRows, function(nRow){
				if(nRow >= nHeaderRows){
					if(htSelectedIdxInfoOfRow.containsKey(nRow)){
						htSelectedIdxInfoOfRow.remove(nRow);
					} else{//selectmode가 row 또는 rows인 경우 행 인덱스만 저장하면 된다.
						arrSelectedCellDOMs = arrSelectedCellDOMs.concat(objQCell._getRowCellDOMs(nRow));						
						//arrSelectedCellDOMs = arrSelectedCellDOMs.concat(objQCell._getRowCellDOMs(nRow).slice(nHeaderCols));
						QBOX.$(arrSelectedCellDOMs).addClass(QBOX.QCELL.def.css.CELL_SELECT);
					}
					htSelectedIdxInfoOfRow.put(nRow, true);
				}
			});
						
			break;
		}
		default:break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._deselectRows = function(arrDeselectedRows){
	switch(this.attr('selectmode')){
		case 'rows': {
			var css = QBOX.QCELL.def.css,
			objQCell = this,
			nHeaderRows = this.attr('headerrows'),
			nHeaderCols = this.attr('headercols'),
			htSelectedIdxInfoOfRow = objQCell._getIdxInfo('selected', 'row'),
			arrDeselectedCellDOMs = [];
			
			QBOX._.each(arrDeselectedRows, function(nRow){
				if(nRow >= nHeaderRows){
					if(htSelectedIdxInfoOfRow.containsKey(nRow)){//selectmode가 row 또는 rows인 경우 행 인덱스만 저장하면 된다.
						htSelectedIdxInfoOfRow.remove(nRow);
						arrDeselectedCellDOMs = arrDeselectedCellDOMs.concat(objQCell._getRowCellDOMs(nRow));						
						//arrDeselectedCellDOMs = arrDeselectedCellDOMs.concat(objQCell._getRowCellDOMs(nRow).slice(nHeaderCols));
					}
				}
			});
			
			QBOX.$(arrDeselectedCellDOMs).removeClass(css.CELL_SELECT);
			
			break;
		}
		default:break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._selectCol = function(nCol){
	/* 2018-02-27(sai1515): 병합이 설정되어 있을 경우 mastercell index로 변경해주는 로직 추가 */
	if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
		var objIndex = this._findNextCell(this._idx('row', 'focus'), nCol, 'up');
		nCol = objIndex.col;
	}
	/* end */
	switch(this.attr('selectmode')){
		case 'col': case 'cols': {
			var nHeaderRows = this.attr('headerrows'),
			htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col');
			
			if(htSelectedIdxInfoOfCol.containsKey(nCol)){
				htSelectedIdxInfoOfCol.remove(nCol);
			} else{
				//QBOX.$(this._getColCellDOMs(nCol).slice(nHeaderRows)).addClass(QBOX.QCELL.def.css.CELL_SELECT);				
				QBOX.$(this._getColCellDOMs(nCol)).addClass(QBOX.QCELL.def.css.CELL_SELECT);
			}
			htSelectedIdxInfoOfCol.put(nCol, true);
			
			break;
		}
		default:break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._deselectCol = function(nCol){
	switch(this.attr('selectmode')){
		case 'col': case 'cols': {
			var nHeaderRows = this.attr('headerrows'),
			htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col');
			
			if(htSelectedIdxInfoOfCol.containsKey(nCol)){
				htSelectedIdxInfoOfCol.remove(nCol);
				
				//QBOX.$(this._getColCellDOMs(nCol).slice(nHeaderRows)).removeClass(QBOX.QCELL.def.css.CELL_SELECT);
				QBOX.$(this._getColCellDOMs(nCol)).removeClass(QBOX.QCELL.def.css.CELL_SELECT);
			}
			
			break;
		}
		default:break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._selectCols = function(arrSelectedCols){
	/* 2018-02-27(sai1515): 병합이 설정되어 있을 경우 mastercell index로 변경해주는 로직 추가 */
	if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
		if(this.attr('merge').data === 'row'){
			var objIndex = this._findNextCell(this._idx('row', 'focus'), arrSelectedCols[arrSelectedCols.length - 1], 'up');
			
			if(this._idx('col', 'focus') > arrSelectedCols[arrSelectedCols.length - 1]){
				arrSelectedCols = QBOX._.range(objIndex.col, this._idx('col', 'focus') + 1).reverse();
			}
		}
	}
	/* end */
	if(arrSelectedCols.length > 0){
		switch(this.attr('selectmode')){
			case 'cols': {
				var objQCell = this,
				nHeaderRows = this.attr('headerrows'),
				nHeaderCols = this.attr('headercols'),
				htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col'),
				arrSelectedCellDOMs = [];
				
				QBOX._.each(arrSelectedCols, function(nCol){
					if(nCol >= nHeaderCols){
						if(htSelectedIdxInfoOfCol.containsKey(nCol)){
							htSelectedIdxInfoOfCol.remove(nCol);
						} else{
							arrSelectedCellDOMs = arrSelectedCellDOMs.concat(objQCell._getColCellDOMs(nCol));
							//arrSelectedCellDOMs = arrSelectedCellDOMs.concat(objQCell._getColCellDOMs(nCol).slice(nHeaderRows));
						}
						
						htSelectedIdxInfoOfCol.put(nCol, true);
					}
				});
				
				QBOX.$(arrSelectedCellDOMs).addClass(QBOX.QCELL.def.css.CELL_SELECT);
				
				break;
			}
			default:break;
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._deselectCols = function(arrDeselectedCols){
	switch(this.attr('selectmode')){
		case 'cols': {
			var objQCell = this,
			nHeaderRows = this.attr('headerrows'),
			nHeaderCols = this.attr('headercols'),
			htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col'),
			arrDeselectedCellDOMs = [];
			
			QBOX._.each(arrDeselectedCols, function(nCol){
				if(nCol >= nHeaderCols){
					if(htSelectedIdxInfoOfCol.containsKey(nCol)){
						htSelectedIdxInfoOfCol.remove(nCol);
						//arrDeselectedCellDOMs = arrDeselectedCellDOMs.concat(objQCell._getColCellDOMs(nCol).slice(nHeaderRows));
						arrDeselectedCellDOMs = arrDeselectedCellDOMs.concat(objQCell._getColCellDOMs(nCol));
					}
				}
			});
			
			QBOX.$(arrDeselectedCellDOMs).removeClass(QBOX.QCELL.def.css.CELL_SELECT);
			
			break;
		}
		default:break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._selectCell = function(nRow, nCol){
	/* 2018-02-27(sai1515): 병합이 설정되어 있을 경우 mastercell index로 변경해주는 로직 추가 */
	if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
		var objIndex = this._findNextCell(nRow, nCol, 'up');
		nRow = objIndex.row;
		nCol = objIndex.col;
	}
	/* end */
	switch(this.attr('selectmode')){
		case 'cell': case 'cells': {
			var nHeaderRows = this.attr('headerrows'),
			nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'), nCols = this.attr('cols');
			
			if(nRow >= nHeaderRows && nCol >= nHeaderCols && nCol < nCols){
				var objHSInfo = this.attr('hsinfo'),
				htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row'),
				htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col'),
				hsSelectedColIndexOfRow, hsSelectedRowIndexOfCol;
				
				if(htSelectedIdxInfoOfRow.containsKey(nRow)){
					hsSelectedColIndexOfRow = htSelectedIdxInfoOfRow.remove(nRow);
				} else{
					hsSelectedColIndexOfRow = new _QHashSet();
				}
				
				hsSelectedColIndexOfRow.add(nCol);
				htSelectedIdxInfoOfRow.put(nRow, hsSelectedColIndexOfRow);
				
				if(htSelectedIdxInfoOfCol.containsKey(nCol)){
					hsSelectedRowIndexOfCol = htSelectedIdxInfoOfCol.remove(nCol);
				} else{
					hsSelectedRowIndexOfCol = new _QHashSet();
				}
				
				hsSelectedRowIndexOfCol.add(nRow);
				htSelectedIdxInfoOfCol.put(nCol, hsSelectedRowIndexOfCol);
				
				if(nCol < nHeaderCols + nFrozenCols || nCol >= objHSInfo.nLeftCol && nCol <= objHSInfo.nRightCol){
					var heCell = this._getCellDOM(nRow, nCol);
					
					if(QBOX._.isElement(heCell)){
						QBOX.util.addClass(heCell, QBOX.QCELL.def.css.CELL_SELECT);
					}
				}
			}
			
			break;
		}
		
		default:break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._deselectCell = function(nRow, nCol){
	switch(this.attr('selectmode')){
		case 'cell': case 'cells': {
			var nHeaderRows = this.attr('headerrows'),
			nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'), nCols = this.attr('cols');
			
			if(nRow >= nHeaderRows && nCol >= nHeaderCols && nCol < nCols){
				var objHSInfo = this.attr('hsinfo'),
				htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row'),
				htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col'),
				hsSelectedColIndexOfRow, hsSelectedRowIndexOfCol;
				
				if(htSelectedIdxInfoOfRow.containsKey(nRow)){
					hsSelectedColIndexOfRow = htSelectedIdxInfoOfRow.get(nRow);
					hsSelectedColIndexOfRow.remove(nCol);
					
					if(hsSelectedColIndexOfRow.isEmpty()){
						htSelectedIdxInfoOfRow.remove(nRow);
					}
				}
				
				if(htSelectedIdxInfoOfCol.containsKey(nCol)){
					hsSelectedRowIndexOfCol = htSelectedIdxInfoOfCol.get(nCol);
					hsSelectedRowIndexOfCol.remove(nRow);
					
					if(hsSelectedRowIndexOfCol.isEmpty()){
						htSelectedIdxInfoOfCol.remove(nCol);
					}
				}
				
				if(nCol < nHeaderCols + nFrozenCols || nCol >= objHSInfo.nLeftCol && nCol <= objHSInfo.nRightCol){
					var heCell = this._getCellDOM(nRow, nCol);
					
					if(QBOX._.isElement(heCell)){
						QBOX.util.removeClass(heCell, QBOX.QCELL.def.css.CELL_SELECT);
					}
				}
			}
			
			break;
		}
		default:break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._selectCellRange = function(nFirstSelectedRow, nFirstSelectedCol, nLastSelectedRow, nLastSelectedCol){
	/* 2018-02-27(sai1515): 병합이 설정되어 있을 경우 mastercell index로 변경해주는 로직 추가 */
	if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
		var objIndex = this._findNextCell(nLastSelectedRow, nLastSelectedCol, 'up');
		nLastSelectedRow = objIndex.row;
		nLastSelectedCol = objIndex.col;
	}
	/* end */
	switch(this.attr('selectmode')){
		case 'cells': {
			var css = QBOX.QCELL.def.css,
			nHeaderRows = this.attr('headerrows'),
			nHeaderCols = this.attr('headercols'), nCols = this.attr('cols');
			
			if(nFirstSelectedRow >= nHeaderRows && nLastSelectedRow >= nHeaderRows && nLastSelectedCol >= nHeaderCols && nFirstSelectedCol >= nHeaderCols && nFirstSelectedCol < nCols && nLastSelectedCol < nCols){
				var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row'),
				htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col'),
				hsSelectedColIndexOfRow, hsSelectedRowIndexOfCol,
				bRowReverse = nFirstSelectedRow > nLastSelectedRow, bColReverse = nFirstSelectedCol > nLastSelectedCol,
				i, j,
				heCell;
				//console.log('(', nFirstSelectedRow, ', ', nFirstSelectedCol, '), (', nLastSelectedRow, ', ', nLastSelectedCol, ')');
				for(i = nFirstSelectedRow; bRowReverse ? i >= nLastSelectedRow : i <= nLastSelectedRow; bRowReverse ? i-- : i++){
					if(htSelectedIdxInfoOfRow.containsKey(i)){
						hsSelectedColIndexOfRow = htSelectedIdxInfoOfRow.remove(i);
					} else{
						hsSelectedColIndexOfRow = new _QHashSet();
					}
					
					for(j = nFirstSelectedCol; bColReverse ? j >= nLastSelectedCol : j <= nLastSelectedCol; bColReverse ? j-- : j++){
						hsSelectedColIndexOfRow.add(j);
						
						heCell = this._getCellDOM(i, j);
						
						if(QBOX._.isElement(heCell)){
							QBOX.util.addClass(heCell, css.CELL_SELECT);
						}
					}
					htSelectedIdxInfoOfRow.put(i, hsSelectedColIndexOfRow);
				}
				
				for(j = nFirstSelectedCol; bColReverse ? j >= nLastSelectedCol : j <= nLastSelectedCol; bColReverse ? j-- : j++){
					if(htSelectedIdxInfoOfCol.containsKey(j)){
						hsSelectedRowIndexOfCol = htSelectedIdxInfoOfCol.remove(j);
					} else{
						hsSelectedRowIndexOfCol = new _QHashSet();
					}
					
					for(i = nFirstSelectedRow; bRowReverse ? i >= nLastSelectedRow : i <= nLastSelectedRow; bRowReverse ? i-- : i++){
						hsSelectedRowIndexOfCol.add(i);
					}
					htSelectedIdxInfoOfCol.put(j, hsSelectedRowIndexOfCol);
				}
			}
			
			break;
		}
		default:break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._deselectCellRange = function(nFirstDeselectedRow, nFirstDeselectedCol, nLastDeselectedRow, nLastDeselectedCol){
	switch(this.attr('selectmode')){
		case 'cells': {
			var css = QBOX.QCELL.def.css,
			objHSInfo = this.attr('hsinfo'),
			nHeaderRows = this.attr('headerrows'),
			nHeaderCols = this.attr('headercols'), nCols = this.attr('cols');
			
			if(nFirstDeselectedRow >= nHeaderRows && nLastDeselectedRow >= nHeaderRows && nLastDeselectedCol >= nHeaderCols && nFirstDeselectedCol >= nHeaderCols && nFirstDeselectedCol < nCols && nLastDeselectedCol < nCols){
				var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row'),
				htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col'),
				hsSelectedColIndexOfRow, hsSelectedRowIndexOfCol,
				bRowReverse = nFirstDeselectedRow > nLastDeselectedRow, bColReverse = nFirstDeselectedCol > nLastDeselectedCol,
				i, j,
				heCell;
				
				//console.log('(', nFirstDeselectedRow, ', ', nFirstDeselectedCol, '), (', nLastDeselectedRow, ', ', nLastDeselectedCol, ')');
				for(i = nFirstDeselectedRow; bRowReverse ? i >= nLastDeselectedRow : i <= nLastDeselectedRow; bRowReverse ? i-- : i++){
					if(htSelectedIdxInfoOfRow.containsKey(i)){
						hsSelectedColIndexOfRow = htSelectedIdxInfoOfRow.get(i);
						
						for(j = nFirstDeselectedCol; bColReverse ? j >= nLastDeselectedCol : j <= nLastDeselectedCol; bColReverse ? j-- : j++){
							hsSelectedColIndexOfRow.remove(j);
							
							heCell = this._getCellDOM(i, j);
							
							if(QBOX._.isElement(heCell)){
								QBOX.util.removeClass(heCell, css.CELL_SELECT);
							}
						}
						
						if(hsSelectedColIndexOfRow.isEmpty()){
							htSelectedIdxInfoOfRow.remove(i);
						}
					}
				}
				
				for(j = nFirstDeselectedCol; bColReverse ? j >= nLastDeselectedCol : j <= nLastDeselectedCol; bColReverse ? j-- : j++){
					if(htSelectedIdxInfoOfCol.containsKey(j)){
						hsSelectedRowIndexOfCol = htSelectedIdxInfoOfCol.get(j);
						
						for(i = nFirstDeselectedRow; bRowReverse ? i >= nLastDeselectedRow : i <= nLastDeselectedRow; bRowReverse ? i-- : i++){
							hsSelectedRowIndexOfCol.remove(i);
						}
						
						if(hsSelectedRowIndexOfCol.isEmpty()){
							htSelectedIdxInfoOfCol.remove(j);
						}
					}
				}
			}
			
			break;
		}
		default:break;
	}
};

QBOX.QCELL.BasicQCELL.prototype._selectDragArea = function(event){
	try{
		var nFocusRow = this._idx('row', 'focus'),
		nFocusCol = this._idx('col', 'focus'),
		nDragRow = this._idx('row', 'drag'),
		nDragCol = this._idx('col', 'drag');
		
		switch(this.attr('selectmode')){
			case 'rows'	:{
				if(event.ctrlKey === false){
					this._clearSelection();
				}
				
				this._selectRows(nDragRow > nFocusRow ? QBOX._.range(nFocusRow, nDragRow + 1) : QBOX._.range(nDragRow, nFocusRow + 1).reverse());
				break;
			}
			case 'cols'	:{
				if(event.ctrlKey === false){
					this._clearSelection();
				}
				
				this._selectCols(nDragCol > nFocusCol ? QBOX._.range(nFocusCol, nDragCol + 1) : QBOX._.range(nDragCol, nFocusCol + 1).reverse());
				break;
			}
			case 'cells':{
				if(event.ctrlKey === false){
					this._clearSelection();
				}
				
				this._selectCellRange(nFocusRow, nFocusCol, nDragRow, nDragCol);
				break;
			}
			default		:{//row, col, cell
				break;
			}
		}
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._selectDragArea', e.message);
	}
};

QBOX.QCELL.BasicQCELL.prototype._isSelectedRow = function(nRow){
	return this._getIdxInfo('selected', 'row').containsKey(nRow);
};

QBOX.QCELL.BasicQCELL.prototype._isSelectedCol = function(nCol){
	return this._getIdxInfo('selected', 'col').containsKey(nCol);
};

QBOX.QCELL.BasicQCELL.prototype._isSelectedCell = function(nRow, nCol){
	var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row');
	
	if(htSelectedIdxInfoOfRow.containsKey(nRow)){
		return htSelectedIdxInfoOfRow.get(nRow).contains(nCol);
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._selectGroup = function(nRow, nCol){
	/* 2018-02-27(sai1515): 병합이 설정되어 있을 경우 mastercell index로 변경해주는 로직 추가 */
	if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
		if(this.attr('merge').data === 'group'){ //merge 형태가 group일 때
			var mergeInfo = {},
			nFirstMergeRow = 0, nFirstMergeCol = 0,
			nLastMergeRow = 0, nLasMergetCol = 0,
			css = QBOX.QCELL.def.css,
			nHeaderRows = this.attr('headerrows'), nHeaderCols = this.attr('headercols'), 
			nRows = this.attr('rows'), nCols = this.attr('cols'),
			heCell;
			
			if(this._isMergeCell(nRow, nCol)){
				mergeInfo = this._getMergeInfo(nRow, nCol, this.attr('merge_data_info'));
				nFirstMergeRow = mergeInfo.nStartRow;
				nFirstMergeCol = mergeInfo.nStartCol;
				nLastMergeRow = mergeInfo.nEndRow;
				nLasMergetCol = mergeInfo.nEndCol;
			}else{
				nFirstMergeRow = nRow;
				nFirstMergeCol = nCol;
				nLastMergeRow = nRow;
				nLasMergetCol = nCol;
			}
			
			if(nFirstMergeRow >= nHeaderRows && nLastMergeRow < nRows && nFirstMergeCol > nHeaderCols && nLasMergetCol < nCols){
				var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row'),
				htSelectedIdxInfoOfCol = this._getIdxInfo('selected', 'col'),
				hsSelectedColIndexOfRow, hsSelectedRowIndexOfCol,
				sr, sc,
				mergeCells = [];
				
				for(var c = nLasMergetCol; nHeaderCols <= c; c--){
					for(var r = nLastMergeRow; nFirstMergeRow <= r; r--){
						sr = r;
						sc = c;
						if(this._isMergeCell(r, c)){
							var objMergeInfo = this._getMergeInfo(r, c, this.attr('merge_data_info'));
							sr = objMergeInfo.nStartRow;
							sc = objMergeInfo.nStartCol;
						}
						heCell = this._getCellDOM(sr, sc);
						if(QBOX._.isElement(heCell)){
							QBOX.util.addClass(heCell, css.CELL_SELECT);
							mergeCells.push({'sr': sr, 'sc': sc});
						}
					}
				}
				
				//위에서 작성한 병합 정보가 역순으로 되어 있기 때문에 순차적으로 돌림
				mergeCells.reverse();
				for(var l = 0; l < mergeCells.length ; l++) {
					var objMerge = mergeCells[l];
					
					if(htSelectedIdxInfoOfRow.containsKey(objMerge.sr)){
						hsSelectedColIndexOfRow = htSelectedIdxInfoOfRow.remove(objMerge.sr);
					} else{
						hsSelectedColIndexOfRow = new _QHashSet();
					}
					
					if(htSelectedIdxInfoOfCol.containsKey(objMerge.sc)){
						hsSelectedRowIndexOfCol = htSelectedIdxInfoOfCol.remove(objMerge.sc);
					} else{
						hsSelectedRowIndexOfCol = new _QHashSet();
					}
					
					hsSelectedColIndexOfRow.add(objMerge.sc);
					hsSelectedRowIndexOfCol.add(objMerge.sr);
					
					htSelectedIdxInfoOfRow.put(objMerge.sr, hsSelectedColIndexOfRow);
					htSelectedIdxInfoOfCol.put(objMerge.sc, hsSelectedRowIndexOfCol);
				}
			}
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._deselectGroup = function(nRow, nCol){
	//console.log('_deselectGroup');
};

/* 2018-02-27(sai1515): 병합이 설정되어 있을 경우 mastercell index로 변경해주는 로직 추가 */
/*
QBOX.QCELL.BasicQCELL.prototype._selectRow = function(nRow){
	if(QBOX._.isUndefined(this.attr('merge').data) === false && this.attr('merge').data !== 'none'){
		var objIndex = this._findNextCell(nRow, this._idx('col', 'focus'), 'up');
		nRow = objIndex.row;
	}
	
	if(nRow >= this.attr('headerrows')){
		switch(this.attr('selectmode')){
			case 'row': case 'rows': {
				var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row');
				
				if(htSelectedIdxInfoOfRow.containsKey(nRow)){
					htSelectedIdxInfoOfRow.remove(nRow);
				} else{//selectmode가 row 또는 rows인 경우 행 인덱스만 저장하면 된다.
					QBOX.util.addClass(this._getRowCellDOMs(nRow).slice(this.attr('headercols')), QBOX.QCELL.def.css.CELL_SELECT);
				}
				
				htSelectedIdxInfoOfRow.put(nRow, true);//항상 
				
				break;
			}
			default:break;
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._deselectRow = function(nRow){
	if(nRow >= this.attr('headerrows')){
		switch(this.attr('selectmode')){
			case 'row': case 'rows': {
				var htSelectedIdxInfoOfRow = this._getIdxInfo('selected', 'row');
				
				if(htSelectedIdxInfoOfRow.containsKey(nRow)){
					htSelectedIdxInfoOfRow.remove(nRow);
					
					QBOX.util.removeClass(this._getRowCellDOMs(nRow).slice(this.attr('headercols')), QBOX.QCELL.def.css.CELL_SELECT);
				}
				
				break;
			}
			default:break;
		}
	}
};
*/
QBOX.QCELL.BasicQCELL.prototype._getDefaultSortArea = function(nCol){
	if(this.attr('defaultsortarea') === null){
		var heDiv = document.createElement('div');
		this.attr('defaultsortarea', this._createDefaultSortArea(heDiv), 'jquery');
	}
	
	if(this._getQCellCol(nCol).attr('colsortarea') === null){
		this._getQCellCol(nCol).attr('colsortarea', this.attr('defaultsortarea').clone(true), 'jquery');
	}
	
	return this._getQCellCol(nCol).attr('colsortarea').get(0);
};
QBOX.QCELL.BasicQCELL.prototype._createDefaultSortArea = function(heDiv){
	var css = QBOX.QCELL.def.css,
	heSortArea = heDiv.cloneNode(),
	headerRowHeight = this.attr('rowheight').header;
	
	heSortArea.className += css.SORT_AREA;
	heSortArea.style.top = headerRowHeight - (headerRowHeight / 2 + 5) + 'px';
	
	return QBOX.$(heSortArea);
};

QBOX.QCELL.BasicQCELL.prototype._createMultiSortOrder = function(){
	var css = QBOX.QCELL.def.css,
	heSpan = document.createElement('span'),
	headerRowHeight = this.attr('rowheight').header;
	
	heSpan.className += css.MULTI_SORT_ORDER;
	heSpan.style.bottom = -(headerRowHeight - (headerRowHeight / 2 + 7)) + 'px';
	
	return QBOX.$(heSpan);
};

QBOX.QCELL.BasicQCELL.prototype._sort = function(arrSortList){
	if(this.attr('isSorting') === true)
		return false;
	
	var nCol, objQCellCol;
	/*
	 * API를 통한 정렬 동작 구현
	 * 1. arrSortList 정렬조건의 개수에 따라 단일 / 다중 정렬 구분
	 * 2. 정렬 사용 하는 컬럼에서만 동작 되도록 분기처리 (정렬 기능을 사용하지 않는 컬럼이 정렬 조건에 포함되어있을 경우에는 정렬이 수행되지 않음)
	 */
	this.attr('isSorting', true, 'boolean');
	if(arrSortList.length > 1){// 다중정렬
		var bUseSort = true,bKey = true;
		
		for(var i = 0; i < arrSortList.length; i++){
			if(QBOX._.isNumber(arrSortList[i][0] )){
				bKey = false;
				objQCellCol = this._getQCellCol(arrSortList[i][0]);
				
				if(objQCellCol !== undefined){
					if(objQCellCol.attr('sort') === false){
						bUseSort = false;
						
						break;
					}
				} else{
					return false;
				}				
			}
		}
		
		if(bUseSort){			
			if(bKey === false)
				this._updateMultiSortIcon(arrSortList);
			
			this._multiSort(arrSortList);
			
			return true;
		}
	} else{// 단일 정렬
		nCol = arrSortList[0][0];
		
		if(QBOX._.isString(nCol)){
			this._singleSort(nCol, arrSortList[0][1], arrSortList[0][2]);
			return true;
		}
		
		if(QBOX._.isUndefined(nCol) === false){
			objQCellCol = this._getQCellCol(nCol);
			
			if(objQCellCol.attr('sort')){
				this._updateSingleSortIcon(arrSortList);
				
				this._singleSort(nCol, objQCellCol.attr('sortinfoofcol').sorttype, objQCellCol.attr('datatype'));
				
				return true;
			}			
		} else{
			this.attr('sortinfo', [], 'array');
		}
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._makeSingleSortList = function(nCol){
	var arrSortInfo = this.attr('sortinfo'), objQCellCol = this._getQCellCol(nCol),
	arrSortList, i;
	
	if(arrSortInfo.length > 1){// 기존 정렬이 다중 정렬일 경우
		var strSortType = 'asc';
		
		for(i = 0; i < arrSortInfo.length; i++){
			if(arrSortInfo[i][0] === nCol){// 한번 정렬한 컬럼을 다시 정렬할 경우(다른 정렬 타입으로 정렬하고자 할 경우)
				switch(arrSortInfo[i][1]){
					case 'asc': {
						strSortType = 'desc';
						break;
					}

					case 'desc': {
						strSortType = '';
						break;
					}
					default: {
						strSortType = 'asc';
						break;
					}
				}
			}
		}
		
		arrSortList = [[nCol, strSortType, objQCellCol.attr('datatype')]];
	} else if(arrSortInfo.length === 1){// 기존 정렬이 단일 정렬일 경우
		if(arrSortInfo[0][0] === nCol){// 한번 정렬한 컬럼을 다시 정렬할 경우(다른 정렬 타입으로 정렬하고자 할 경우)
			switch(arrSortInfo[0][1]){
				case 'asc': {
					arrSortList = [[arrSortInfo[0][0], 'desc', arrSortInfo[0][2]]];
					break;
				}

				case 'desc': {
					arrSortList = [[arrSortInfo[0][0], '', arrSortInfo[0][2]]];
					break;
				}
				default: {
					arrSortList = [[arrSortInfo[0][0], 'asc', arrSortInfo[0][2]]];
					break;
				}
			}
		} else{// 새로운 컬럼의 정렬인 경우
			arrSortList = [[nCol, 'asc', objQCellCol.attr('datatype')]];
		}
	} else{// 정렬이 되어 있지 않을 경우
		arrSortList = [[nCol, 'asc', objQCellCol.attr('datatype')]];
	}
	
	return arrSortList;
};

QBOX.QCELL.BasicQCELL.prototype._updateSingleSortIcon = function(arrSortList){
	var css = QBOX.QCELL.def.css,
	arrSortInfo = this.attr('sortinfo'), 
	objQCellCol, jqColSortArea,	i,master,sort,cloneSort,obj;
	
	for(i = 0; i < arrSortInfo.length; i++){//기존 정렬 된 UI class 초기화
		objQCellCol = this._getQCellCol(arrSortInfo[i][0]);
		
		if(objQCellCol.attr('colsortarea') === null){// 'colsortarea' 가 없을 경우 기본 정렬 ui로 설정.
			objQCellCol.attr('colsortarea', this.attr('defaultsortarea').clone(true), 'jquery');
		}
		jqColSortArea = objQCellCol.attr('colsortarea');
		
		objQCellCol.setSortInfoOfCol('none', 0);
		
		jqColSortArea.removeClass(css.SORT_ASC).removeClass(css.SORT_DESC);
		jqColSortArea.empty();
		
		if(objQCellCol.attr('cloneSort_master')){
			master = objQCellCol.attr('cloneSort_master');
			sort = objQCellCol.attr('cloneSort_sort');
			cloneSort = jqColSortArea.clone();
			
			obj = sort.position();
			cloneSort.css('top',obj.top);		
			sort.remove();		
			master.append(cloneSort);		
			objQCellCol.attr('cloneSort_sort',cloneSort,'jquery');		
		}		
	}
	var nCol = QBOX._.isString(arrSortList[0][0]) ? this._getColsOfKey(arrSortList[0][0])[0]: arrSortList[0][0];
	
	objQCellCol = this._getQCellCol(nCol);
	
	if(objQCellCol.attr('colsortarea') === null){// 'colsortarea' 가 없을 경우 기본 정렬 ui로 설정.
		objQCellCol.attr('colsortarea', this.attr('defaultsortarea').clone(true), 'jquery');
	}
	jqColSortArea = objQCellCol.attr('colsortarea');
	
	if(arrSortList[0][1] === 'asc'){
		jqColSortArea.addClass(css.SORT_ASC);
		
		objQCellCol.setSortInfoOfCol('asc', objQCellCol.attr('sortinfoofcol').order);
	}
	else if(arrSortList[0][1] === 'desc'){
		jqColSortArea.addClass(css.SORT_DESC);
		
		objQCellCol.setSortInfoOfCol('desc', objQCellCol.attr('sortinfoofcol').order);
	}
	
	objQCellCol.setSortInfoOfCol(objQCellCol.attr('sortinfoofcol').sorttype, 1);
	objQCellCol.attr('colsortarea', jqColSortArea, 'jquery');
	
	if(objQCellCol.attr('cloneSort_master')){
		master = objQCellCol.attr('cloneSort_master');
		sort = objQCellCol.attr('cloneSort_sort');
		cloneSort = jqColSortArea.clone();
		
		obj = sort.position();
		cloneSort.css('top',obj.top);		
		sort.remove();		
		master.append(cloneSort);		
		objQCellCol.attr('cloneSort_sort',cloneSort,'jquery');		
	}
};

QBOX.QCELL.BasicQCELL.prototype._makeMultiSortList = function(nCol){
	var arrTempSortInfo = [], objQCellCol = this._getQCellCol(nCol),
	arrSortList, i;
	// 'sortinfo'는 현재 정렬 상태를 저장한 속성이기 때문에, 변경이 되면 안되도록 clone 처리
	QBOX._.each(this.attr('sortinfo'), function(arrTemp){
		arrTempSortInfo.push(QBOX._.clone(arrTemp));
	});
	
	if(arrTempSortInfo.length > 1){// 기존 정렬이 다중 정렬일 경우
		var bNewSortList = true;
		
		for(i = 0; i < arrTempSortInfo.length; i++){
			if(arrTempSortInfo[i][0] === nCol){
				switch(arrTempSortInfo[i][1]){
					case 'asc': {
						arrTempSortInfo[i][1] = 'desc';
						break;
					} case 'desc': {
						arrTempSortInfo[i][1] = 'asc';
						break;
					}
				}
				
				bNewSortList = false;
				break;
			}
		}
		
		if(bNewSortList){//새로운 정렬순서가 추가될 경우
			arrTempSortInfo.push([nCol, 'asc', objQCellCol.attr('datatype')]);
		}
		
		arrSortList = arrTempSortInfo;
	} else if(arrTempSortInfo.length === 1){// 기존 정렬이 단일 정렬일 경우
		if(arrTempSortInfo[0][0] === nCol){// 한번 정렬한 컬럼을 다시 정렬할 경우(다른 정렬 타입으로 정렬하고자 할 경우)
			switch(arrTempSortInfo[0][1]){
				case 'asc': {
					arrSortList = [[arrTempSortInfo[0][0], 'desc', arrTempSortInfo[0][2]]];
					break;
				} case 'desc': {
					arrSortList = [[arrTempSortInfo[0][0], 'asc', arrTempSortInfo[0][2]]];
					break;
				}
			}
		} else{// 새로운 컬럼의 정렬인 경우
			arrTempSortInfo.push([nCol, 'asc', objQCellCol.attr('datatype')]);
			arrSortList = arrTempSortInfo;
		}
	} else{// 정렬이 되어 있지 않을 경우
		arrSortList = [[nCol, 'asc', objQCellCol.attr('datatype')]];
	}
	
	return arrSortList;
};

QBOX.QCELL.BasicQCELL.prototype._updateMultiSortIcon = function(arrSortList){
	var css = QBOX.QCELL.def.css,
	arrSortInfo = this.attr('sortinfo'),
	objQCellCol, jqColSortArea,	jqMultiSortOrder, i;
	
	for(i = 0; i < arrSortInfo.length; i++){//기존 정렬 된 UI class 초기화
		objQCellCol = this._getQCellCol(arrSortInfo[i][0]);
		
		if(objQCellCol.attr('colsortarea') === null){// 'colsortarea' 가 없을 경우 기본 정렬 ui로 설정.
			objQCellCol.attr('colsortarea', this.attr('defaultsortarea').clone(true), 'jquery');
		}
		jqColSortArea = objQCellCol.attr('colsortarea');
		
		objQCellCol.setSortInfoOfCol('none', 0);
		
		jqColSortArea.removeClass(css.SORT_ASC).removeClass(css.SORT_DESC);
		jqColSortArea.empty();
	}
	
	for(i = 0; i < arrSortList.length; i++){
		objQCellCol = this._getQCellCol(arrSortList[i][0]);
		
		if(objQCellCol.attr('colsortarea') === null){// 'colsortarea' 가 없을 경우 기본 정렬 ui로 설정.
			objQCellCol.attr('colsortarea', this.attr('defaultsortarea').clone(true), 'jquery');
		}
		jqColSortArea = objQCellCol.attr('colsortarea');
		jqMultiSortOrder = this._createMultiSortOrder();
		
		if(arrSortList[i][1] === 'asc'){
			jqColSortArea.addClass(css.SORT_ASC);
			
			objQCellCol.setSortInfoOfCol('asc', objQCellCol.attr('sortinfoofcol').order);
		} else{
			jqColSortArea.addClass(css.SORT_DESC);
			
			objQCellCol.setSortInfoOfCol('desc', objQCellCol.attr('sortinfoofcol').order);
		}
		
		objQCellCol.setSortInfoOfCol(objQCellCol.attr('sortinfoofcol').sorttype, i + 1);
		
		jqMultiSortOrder.text(objQCellCol.attr('sortinfoofcol').order);
		jqColSortArea.get(0).appendChild(jqMultiSortOrder.get(0));
		
		objQCellCol.attr('colsortarea', jqColSortArea, 'jquery');
		
		if(objQCellCol.attr('cloneSort_master')){
			var master = objQCellCol.attr('cloneSort_master');
			var sort = objQCellCol.attr('cloneSort_sort');
			var cloneSort = jqColSortArea.clone();
			
			var obj = sort.position();
			cloneSort.css('top',obj.top);
			
			var childNodes = cloneSort.get(0).childNodes;
			var x = 0;
			for(x=0;x<childNodes.length;x++){
				var child = childNodes[0];
				var masterHeight = objQCellCol.attr('cloneSort_master_height');
				child.style.bottom = -(masterHeight - (masterHeight / 2 + 7)) + 'px';
			}

			sort.remove();		
			master.append(cloneSort);		
			objQCellCol.attr('cloneSort_sort',cloneSort,'jquery');		
		}		
	}
};
/* diet
QBOX.QCELL.BasicQCELL.prototype._singleSort = function(nCol, strSortType, strDataType){
	this._trigger('beforesort');
	
	if(this.attr('paginationinfo').totalsort === true){
		this._movePage(1);
	}
	
	var strColumnKey = QBOX._.isString(nCol) ? nCol :this._getKeyOfCol(nCol),
	nHeaderRows = this.attr('headerrows'), nHeaderCols = this.attr('headercols'), nCols = this.attr('cols'),
	arrCurrentData = this.attr('currentdata'),
	htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row'), htStyleIdxInfoOfCol = this._getIdxInfo('style', 'col'),
	htSyncInfoOfRow = this._getSyncInfo('row'), htSyncInfoOfCol = this._getSyncInfo('col'),
	strStyleIdxInfoKey = 'rt_styleidxinfo', strSyncinfoKey = 'rt_syncinfo', strOriginrowKey = 'rt_originrow',
	hsSyncInfoOfRowIdx = new _QHashSet(),
	i, j, k, nTargetRow;
	
	if(htSyncInfoOfRow.size() > 0){// 1. 동기화 필요한 행 추출
		htSyncInfoOfRow.each(function(nRow, hsSyncInfoOfRow){
			QBOX._.each(hsSyncInfoOfRow.values(), function(strSyncName){
				switch(strSyncName){
					case 'style':{
						hsSyncInfoOfRowIdx.add(nRow);
						break;
					}
					default: break;
				}
			});
		});
	}
	
	if(hsSyncInfoOfRowIdx.values().length > 0){// 동기화 할 행이 있을 경우 
		var objQCell = this;
		
		objQCell._clearDynamicCSS('row', 'data');// 동적 스타일 제거
		
		QBOX._.each(hsSyncInfoOfRowIdx.values(), function(nRow){// 2. 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
			if(QBOX._.indexOf(htStyleIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 2-1. 스타일 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
				arrCurrentData[nRow - nHeaderRows][strStyleIdxInfoKey] = htStyleIdxInfoOfRow.remove(nRow);
			}
			// 2-2. syncinfo 정보 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
			arrCurrentData[nRow - nHeaderRows][strSyncinfoKey] = htSyncInfoOfRow.remove(nRow);
			arrCurrentData[nRow - nHeaderRows][strOriginrowKey] = nRow;
		});
		QBOX.util.RT_sortBy	(arrCurrentData,strColumnKey, strSortType, strDataType);	
		// 3. 데이터 정렬
		//arrCurrentData.RT_sortBy(strColumnKey, strSortType, strDataType);
		
		// 4. 정렬후 행 데이터에 동기화 정보가 있을 경우 동기화 자료구조에 다시 넣어줌
		for(i = 0; i < arrCurrentData.length; i++){
			var htIdxInfo = arrCurrentData[i][strStyleIdxInfoKey],
			hsSyncInfo = arrCurrentData[i][strSyncinfoKey],
			nOriginRow = arrCurrentData[i][strOriginrowKey];
			// 4-1. 데이터에서 동기화 정보 제거
			delete arrCurrentData[i][strStyleIdxInfoKey];
			delete arrCurrentData[i][strSyncinfoKey];
			delete arrCurrentData[i][strOriginrowKey];
			
			if(hsSyncInfo && nOriginRow){
				// 4-2. row index 스타일 정보 동기화
				htStyleIdxInfoOfRow.put(i + nHeaderRows, htIdxInfo);
				
				// 4-3. col index 스타일 정보 동기화
				for(j = 0; j < nCols; j++){
					if(htStyleIdxInfoOfCol.get(j) !== null){
						for(k = 0; k < htStyleIdxInfoOfCol.get(j).keys().length; k++){
							nTargetRow = htStyleIdxInfoOfCol.get(j).keys()[k];
							
							if(nTargetRow === nOriginRow){
								htStyleIdxInfoOfCol.get(j).put(i + nHeaderRows, htStyleIdxInfoOfCol.get(j).remove(nTargetRow));
							}
						}
					}
				}
				
				// 4-4 row syncinfo 정보 동기화
				htSyncInfoOfRow.put(i + nHeaderRows, hsSyncInfo);
			}
		}
	} else{
		// 스타일 동기화 정보가 없을경우 정렬만 수행
		QBOX.util.RT_sortBy	(arrCurrentData,strColumnKey, strSortType, strDataType);
		//arrCurrentData.RT_sortBy(strColumnKey, strSortType, strDataType);

	}
	if(QBOX._.isNumber(nCol)){
		// 4-5 syncinfo.col 에 sort flag 삽입
		if(htSyncInfoOfCol.containsKey(nCol) === false){
			htSyncInfoOfCol.put(nCol, new _QHashSet());
		}
		htSyncInfoOfCol.get(nCol).add('sort');
		
		// 4-6 단일 정렬이기 때문에 현재 정렬하는 컬럼 이외의 컬럼에 sort flag가 있을 경우는 제거
		QBOX._.each(htSyncInfoOfCol.keys(), function(nTargetIdx){
			if(nTargetIdx !== nCol){
				if(htSyncInfoOfCol.get(nTargetIdx).contains('sort')){
					htSyncInfoOfCol.get(nTargetIdx).remove('sort');
					
					if(htSyncInfoOfCol.get(nTargetIdx).isEmpty()){
						htSyncInfoOfCol.remove(nTargetIdx);
					}
				}
			}
		});
		
	}
	
	this.attr('sortinfo', [[nCol, strSortType, strDataType]], 'array');
	
	this._refreshDRs();
	
	this._trigger('aftersort');
};

QBOX.QCELL.BasicQCELL.prototype._multiSort = function(arrSortList){
	this._trigger('beforesort');
	
	if(this.attr('paginationinfo').totalsort === true){
		this._movePage(1);
	}
	
	var strColumnKey, arrTempSortList = [],
	nHeaderRows = this.attr('headerrows'), nHeaderCols = this.attr('headercols'), nCols = this.attr('cols'),
	arrCurrentData = this.attr('currentdata'),
	htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row'), htStyleIdxInfoOfCol = this._getIdxInfo('style', 'col'),
	htSyncInfoOfRow = this._getSyncInfo('row'), htSyncInfoOfCol = this._getSyncInfo('col'),
	strStyleIdxInfoKey = 'rt_styleidxinfo', strSyncinfoKey = 'rt_syncinfo', strOriginrowKey = 'rt_originrow',
	hsSyncInfoOfRowIdx = new _QHashSet(),
	i, j, k, nTargetRow;
	
	if(htSyncInfoOfRow.size() > 0){// 1. 동기화 필요한 행 추출
		htSyncInfoOfRow.each(function(nRow, hsSyncInfoOfRow){
			QBOX._.each(hsSyncInfoOfRow.values(), function(strSyncName){
				switch(strSyncName){
					case 'style':{
						hsSyncInfoOfRowIdx.add(nRow);
						break;
					}
					default: break;
				}
			});
		});
	}
	
	// arrSortList 는 데이터 변경이 되면 안되고 참조용으로만 사용되어야 하기 때문에, clone 처리
	QBOX._.each(arrSortList, function(arrTemp){
		arrTempSortList.push(QBOX._.clone(arrTemp));
	});
	
	// 컬럼 인덱스 -> key 로 변경
	for(i = 0; i < arrTempSortList.length; i++){
		strColumnKey = this._getKeyOfCol(arrTempSortList[i][0]);
		arrTempSortList[i][0] = strColumnKey;
	}
	
	if(hsSyncInfoOfRowIdx.values().length > 0){// 동기화 할 내용이 있을 경우 
		var objQCell = this;
		
		objQCell._clearDynamicCSS('row', 'data');// 동적 스타일 제거
		
		QBOX._.each(hsSyncInfoOfRowIdx.values(), function(nRow){// 2. 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
			if(QBOX._.indexOf(htStyleIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 2-1. 스타일 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
				arrCurrentData[nRow - nHeaderRows][strStyleIdxInfoKey] = htStyleIdxInfoOfRow.remove(nRow);
			}
			// 2-2. syncinfo 정보 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
			arrCurrentData[nRow - nHeaderRows][strSyncinfoKey] = htSyncInfoOfRow.remove(nRow);
			arrCurrentData[nRow - nHeaderRows][strOriginrowKey] = nRow;
		});
		QBOX.util.RT_sortBy	(arrCurrentData,arrTempSortList);
		// 3. 데이터 정렬
		//arrCurrentData.RT_sortBy(arrTempSortList);
		
		// 4. 정렬후 행 데이터에 동기화 정보가 있을 경우 동기화 자료구조에 다시 넣어줌
		for(i = 0; i < arrCurrentData.length; i++){
			var htIdxInfo = arrCurrentData[i][strStyleIdxInfoKey],
			hsSyncInfo = arrCurrentData[i][strSyncinfoKey],
			nOriginRow = arrCurrentData[i][strOriginrowKey];
			// 4-1. 데이터에서 동기화 정보 제거
			delete arrCurrentData[i][strStyleIdxInfoKey];
			delete arrCurrentData[i][strSyncinfoKey];
			delete arrCurrentData[i][strOriginrowKey];
			
			if(hsSyncInfo && nOriginRow){
				// 4-2. row index 스타일 정보 동기화
				htStyleIdxInfoOfRow.put(i + nHeaderRows, htIdxInfo);
				
				// 4-3. col index 스타일 정보 동기화
				for(j = 0; j < nCols; j++){
					if(htStyleIdxInfoOfCol.get(j) !== null){
						for(k = 0; k < htStyleIdxInfoOfCol.get(j).keys().length; k++){
							nTargetRow = htStyleIdxInfoOfCol.get(j).keys()[k];
							
							if(nTargetRow === nOriginRow){
								htStyleIdxInfoOfCol.get(j).put(i + nHeaderRows, htStyleIdxInfoOfCol.get(j).remove(nTargetRow));
							}
						}
					}
				}
				
				// 4-4 row syncinfo 정보 동기화
				htSyncInfoOfRow.put(i + nHeaderRows, hsSyncInfo);
			}
		}
	} else{
		QBOX.util.RT_sortBy	(arrCurrentData,arrTempSortList);
		// 스타일 동기화 정보가 없을경우 정렬만 수행
		//arrCurrentData.RT_sortBy(arrTempSortList);
		
	}
	
	// 4-5 syncinfo.col 에 sort flag 삽입
	QBOX._.each(arrSortList, function(arrSortInfo){
		if(htSyncInfoOfCol.containsKey(arrSortInfo[0]) === false){
			htSyncInfoOfCol.put(arrSortInfo[0], new _QHashSet());
		}
		htSyncInfoOfCol.get(arrSortInfo[0]).add('sort');
	});
	
	this.attr('sortinfo', arrSortList, 'array');
	
	this._refreshDRs();
	
	this._trigger('aftersort');
};
*/
QBOX.QCELL.BasicQCELL.prototype._clearSortUI = function(){
	var arrSortInfo = this.attr('sortinfo');
	
	if(arrSortInfo.length > 0){
		var htSyncInfoOfCol = this._getSyncInfo('col'),
		objQCell = this, objQCellCol;
		
		QBOX._.each(arrSortInfo, function(arrSortInfoTemp){
			objQCellCol = objQCell._getQCellCol(arrSortInfoTemp[0]);
			
			objQCellCol.attr('colsortarea', objQCell.attr('defaultsortarea').clone(true), 'jquery');
			
			objQCellCol.setSortInfoOfCol('none', 0);
			
			//syncinfo.col 에 sort flag 제거
			if(htSyncInfoOfCol.containsKey(arrSortInfoTemp[0]) === true){
				htSyncInfoOfCol.get(arrSortInfoTemp[0]).remove('sort');
				
				if(htSyncInfoOfCol.get(arrSortInfoTemp[0]).isEmpty()){
					htSyncInfoOfCol.remove(arrSortInfoTemp[0]);
				}
			}
		});
		
		this.attr('sortinfo', [], 'array');
		
		this._refreshHRs();
	}
};

//QBOX.QCELL.BasicQCELL.prototype._updateSortInfoAfterMoveCol = function(nBeforeCol, nAfterCol){
//	var arrSortInfo = this.attr('sortinfo'), objQCellCol, nCol;
//	/*
//	 * 컬럼 이동 후 정렬 정보 동기화
//	 * 1. 기존 정렬 정보에서 index 정보만 동기화
//	 * 
//	 */
//	
//	if(arrSortInfo.length > 0){// 정렬 정보가 있을 때만 update 동작 하도록 분기 처리
//		QBOX._.each(arrSortInfo, function(arrTemp){
//			nCol = arrTemp[0];
//			//1. 이동되는 타겟 컬럼이 정렬 되어 있는 경우, 정렬 정보에서 index 동기화
//			if(nCol === nBeforeCol){
//				arrTemp[0] = nAfterCol;
//			}
//			//2. 컬럼 이동으로 인해 index 값에 변동이 생기는 정렬된 컬럼에 대해 컬럼 정보에서 index 동기화
//			if(nBeforeCol < nAfterCol){
//				if(nCol > nBeforeCol && nCol <= nAfterCol){
//					--arrTemp[0];
//				}
//			} else if(nBeforeCol > nAfterCol){
//				if(nCol < nBeforeCol && nCol >= nAfterCol){
//					++arrTemp[0];
//				}
//			}
//		});
//	}
//};
QBOX.QCELL.BasicQCELL.prototype._sortProcess = function(event){
	if(this.attr('isSorting') === true)
		return false;
	this.attr('isSorting', true, 'boolean');
	this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
	/*
	 * 정렬 아이콘 클릭을 통한 정렬 동작 구현
	 * 1. shift 키 누름 여부에 따라서 단일 / 다중 정렬 구분
	 * 2. 정렬 UI 적용할 새로운 sortList 생성 
	 * 3. sortList에 따른 정렬 UI 변경
	 * 4. 정렬 로직 수행
	 */
	
	var nCol = this._idx('col', 'click'); 
	
	if(nCol === -1)
		return;
	
	var objQCellCol = this._getQCellCol(nCol),
	arrSortList;
	
	if(event.shiftKey){// 다중 정렬
		arrSortList = this._makeMultiSortList(nCol);
		
		this._updateMultiSortIcon(arrSortList);
		
		this.attr('sortinfo', arrSortList, 'array');
		
		this._multiSort(arrSortList);
	} else{ //단일 정렬
		arrSortList = this._makeSingleSortList(nCol);	
		if(nCol < this.getCols('header')){			
				
			
			var arrRowheaders = this.attr('rowheaders');			
			if(arrRowheaders[nCol] !== undefined && arrSortList[0][1] !== 'desc' ){
				arrRowheaders[nCol] = 'sequence';
			}else{
				arrRowheaders[nCol] = 'reverse';
			}

			arrSortList[0][2] = 'number';
			this.attr('rowheaders', arrRowheaders, 'array' );
			objQCellCol.attr('datatype' , 'number','string');
		}
		this._updateSingleSortIcon(arrSortList);		
		this.attr('sortinfo', [[nCol, objQCellCol.attr('sortinfoofcol').sorttype, objQCellCol.attr('datatype')]], 'array');					
		if(nCol < this.getCols('header')){	
			this._singleSort('_rt_qc_s_i', objQCellCol.attr('sortinfoofcol').sorttype, objQCellCol.attr('datatype'));		
		}else{
			this._singleSort(nCol, objQCellCol.attr('sortinfoofcol').sorttype, objQCellCol.attr('datatype'));			
		}

	}
	/************************************************************************************/
};
QBOX.QCELL.BasicQCELL.prototype._getColStyleClassName = function(nCol, strGroup){
	try{
		var objCol = this.attr('qcellcols')[nCol];
		
		if(objCol === null || objCol === undefined)
			return '';
		
		return this.attr('qcellcols')[nCol].getStyleClassName(strGroup);
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._getColStyleClassName', e.message);
		return '';
	}
};
QBOX.QCELL.BasicQCELL.prototype._removeColStyleClassName = function(nCol){
	var nHeaderRows = this.attr('headerrows'), nRows = this.attr('rows'),
	i,
	result = false;
	
	var strHeaderStyleName = this._getColStyleClassName(nCol,'header');
	var strDataStyleName = this._getColStyleClassName(nCol,'data'),
	heCell;
	
	if(strHeaderStyleName !== ''){
		for(i = 0; i < nHeaderRows; i++){
			heCell = this._getCellDOM(i,nCol);
			if(heCell !== null)
				QBOX.util.removeClass(heCell,strHeaderStyleName);
		}		
	}

	if(strDataStyleName !== ''){
		for(i = nHeaderRows; i < nRows; i++){
			heCell = this._getCellDOM(i,nCol);
			if(heCell !== null)
				QBOX.util.removeClass(heCell,strDataStyleName);
		}			
	}

	

	
	return true;
};
QBOX.QCELL.BasicQCELL.prototype._setHighlightRepeat = function(nCycle){
	try{
		this.attr('highlightrepeat', nCycle, 'number');
		
		this._clearHighlightRepeatCSS();
		
		this._refreshDRs();
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._setHighlightRepeat', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._clearHighlightRepeatCSS = function(){
	//"HighlightRepeat" 스타일이 적용된 셀들의 CSS를 제거한다.
	QBOX.util.removeClass(QBOX._.flatten(this.attr('cellmatrix').get('row')), QBOX.QCELL.def.css.CELL_HIGHLIGHTREPEAT);
	
	return true;
};

QBOX.QCELL.BasicQCELL.prototype._initColStyles = function(){
	//컬럼 스타일에서 init은 동적으로 변경된 스타일을 제거하고 컬럼의 속성으로 설정된 스타일을 적용시키는 것을 의미한다.
	var result = true;
	
	QBOX.$.each(this.attr('qcellcols'), function(nCol, objQCellCol){
		if(objQCellCol.initStyle() === false){
			result = false;
			
			return false;
		}
	});
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._initColStyle = function(nCol){
	//컬럼 스타일에서 init은 동적으로 변경된 스타일을 제거하고 컬럼의 속성으로 설정된 스타일을 적용시키는 것을 의미한다.
	return this.attr('qcellcols')[nCol].initStyle();
};

QBOX.QCELL.BasicQCELL.prototype._getColStyle = function(nCol, /*header|data*/strType){
	return this.attr('qcellcols')[nCol].getStyle(strType);
};

QBOX.QCELL.BasicQCELL.prototype._setColStyle = function(nCol, objStyle, /*all|header|data*/strType, bUpdate){
	var nHeaderRows = this.attr('headerrows'), nRows = this.attr('rows'),
	i,
	result = false;
	
	this.attr('qcellcols')[nCol].setStyle(objStyle, strType);
	
	if(nHeaderRows > 0 && (strType === 'header' || strType === 'all')){
		for(i = 0; i < nHeaderRows; i++){
			this._setCellStyle(i, nCol, objStyle, bUpdate);
		}
		
		result = true;
	}
	
	if(strType === 'data' || strType === 'all'){
		for(i = nHeaderRows; i < nRows; i++){
			this._setCellStyle(i, nCol, objStyle, bUpdate);
		}
		
		result = true;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._removeColStyle = function(nCol, /*all|header|data*/strType, bUpdate){
	var nHeaderRows = this.attr('headerrows'), nRows = this.attr('rows'),
	i,
	result = false;
	
	this.attr('qcellcols')[nCol].removeStyle(strType);
	
	if(nHeaderRows > 0 && (strType === 'header' || strType === 'all')){
		for(i = 0; i < nHeaderRows; i++){
			this._removeCellStyle(i, nCol, bUpdate);
		}
		
		result = true;
	}
	
	if(strType === 'data' || strType === 'all'){
		for(i = nHeaderRows; i < nRows; i++){
			this._removeCellStyle(i, nCol, bUpdate);
		}
		
		result = true;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._clearColStyles = function(){
	//컬럼 스타일에서 init은 동적으로 변경된 스타일을 제거하고 컬럼의 속성으로 설정된 스타일을 적용시키는 것을 의미한다.
	var result = true;
	
	QBOX.$.each(QBOX._.filter(this.attr('qcellcols'), function(objQCellCol){
		return QBOX._.size(objQCellCol.attr('style').header) > 0 || QBOX._.size(objQCellCol.attr('style').data) > 0;
	}), function(idx, objQCellCol){
		if(objQCellCol.removeStyle('all') === false){
			result = false;
			
			return false;
		}
	});
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._setRowStyle = function(nRow, objStyle, /*all|header|data*/strType, bUpdate){
	var nHeaderCols = this.attr('headercols'), nCols = this.attr('cols'),
	j,
	result = false;
	
	if(nHeaderCols > 0 && (strType === 'header' || strType === 'all')){
		for(j = 0; j < nHeaderCols; j++){
			this._setCellStyle(nRow, j, objStyle, bUpdate);
		}
		
		result = true;
	}
	
	if(strType === 'data' || strType === 'all'){
		for(j = nHeaderCols; j < nCols; j++){
			this._setCellStyle(nRow, j, objStyle, bUpdate);
		}
		
		result = true;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._removeRowStyle = function(nRow, /*all|header|data*/strType, bUpdate){
	var nHeaderCols = this.attr('headercols'), nCols = this.attr('cols'),
	j,
	result = false;
	
	if(nHeaderCols > 0 && (strType === 'header' || strType === 'all')){
		for(j = 0; j < nHeaderCols; j++){
			this._removeCellStyle(nRow, j, bUpdate);
		}
		
		result = true;
	}
	
	if(strType === 'data' || strType === 'all'){
		for(j = nHeaderCols; j < nCols; j++){
			this._removeCellStyle(nRow, j, bUpdate);
		}
		
		result = true;
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._hasCellStyle = function(nRow, nCol){
	try{
		var htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row');
		
		if(htStyleIdxInfoOfRow.containsKey(nRow)){
			return htStyleIdxInfoOfRow.get(nRow).containsKey(nCol);
		}
		
		return false;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._hasCellStyle', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._getCellStyle = function(nRow, nCol){
	var htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row');
	
	if(htStyleIdxInfoOfRow.containsKey(nRow)){
		var htStyleInfoOfRow = htStyleIdxInfoOfRow.get(nRow);
		if(htStyleInfoOfRow.containsKey(nCol)){
			return QBOX._.clone(htStyleInfoOfRow.get(nCol));
		}
	}
	
	return {};
};

QBOX.QCELL.BasicQCELL.prototype._setCellStyle = function(nRow, nCol, objStyle, bUpdate){
	try{
		var htSyncInfoOfRow = this._getSyncInfo('row'),
		htSyncInfoOfCol = this._getSyncInfo('col'),
		htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row'),
		htStyleIdxInfoOfCol = this._getIdxInfo('style', 'col'),
		htStyleInfoOfRow,
		htStyleInfoOfCol,arrCD = this.attr('currentdata');
		
		if(arrCD[nRow - this.getRows('header')]._rt_qc_style === undefined){
			arrCD[nRow - this.getRows('header')]._rt_qc_style = {};
		}
		var skey = this._getKeyOfCol(nCol);
		
		if(skey !== null && skey !==undefined){
			arrCD[nRow - this.getRows('header')]._rt_qc_style[skey] = {'row' : nRow, 'col' : nCol, 'style' : QBOX._.clone(objStyle)};	
		}
		
		if(bUpdate){
			var heCell = this._getCellDOM(nRow, nCol);
			
			if(QBOX._.isElement(heCell)){
				var strStyle = '';
				for(var key in objStyle){
					strStyle += key +': ' + objStyle[key] + ';';
				}

				$(heCell).attr('style', function(i,s) { return (s || '') + strStyle; });
				//QBOX.$(heCell).css(objStyle);
			}
		}
		
		if(htSyncInfoOfRow.containsKey(nRow) === false){
			htSyncInfoOfRow.put(nRow, new _QHashSet());
		}
		htSyncInfoOfRow.get(nRow).add('style');
		
		if(htStyleIdxInfoOfRow.containsKey(nRow) === false){
			htStyleIdxInfoOfRow.put(nRow, new _QHashtable());
		}
		
		htStyleInfoOfRow = htStyleIdxInfoOfRow.get(nRow);
		
		if(htStyleInfoOfRow.containsKey(nCol)){
			htStyleInfoOfRow.put(nCol, QBOX._.extend(htStyleInfoOfRow.get(nCol), objStyle));
		} else{
			htStyleInfoOfRow.put(nCol, QBOX._.clone(objStyle));
		}
		
		if(htSyncInfoOfCol.containsKey(nCol) === false){
			htSyncInfoOfCol.put(nCol, new _QHashSet());
		}
		htSyncInfoOfCol.get(nCol).add('style');
		
		if(htStyleIdxInfoOfCol.containsKey(nCol) === false){
			htStyleIdxInfoOfCol.put(nCol, new _QHashtable());
		}
		
		htStyleInfoOfCol = htStyleIdxInfoOfCol.get(nCol);
		
		if(htStyleInfoOfCol.containsKey(nRow)){
			htStyleInfoOfCol.put(nRow, QBOX._.extend(htStyleInfoOfCol.get(nRow), objStyle));
		} else{
			htStyleInfoOfCol.put(nRow, QBOX._.clone(objStyle));
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._setCellStyle', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._setCellStyles = function(nFirstRow, nFirstCol, nLastRow, nLastCol, objStyle, bUpdate){
	var bRowReverse = nFirstRow > nLastRow,
	bColReverse = nFirstCol > nLastCol,
	result = true;
	
	for(var i = nFirstRow; bRowReverse ? i >= nLastRow : i <= nLastRow; bRowReverse ? i-- : i++){
		if(result === false){
			break;
		}
		
		for(var j = nFirstCol; bColReverse ? j >= nLastCol : j <= nLastCol; bColReverse ? j-- : j++){
			if(this._setCellStyle(i, j, objStyle, bUpdate) === false){
				result = false;
				break;
			}
		}
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._removeCellStyle = function(nRow, nCol, bUpdate){
	try{
		var htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row'),
		htStyleIdxInfoOfCol = this._getIdxInfo('style', 'col'),
		htSyncInfoOfRow = this._getSyncInfo('row'),
		htSyncInfoOfCol = this._getSyncInfo('col');
		
		//1. "idxinfo" 정보에서 해당 셀 스타일 정보를 지운다.
		//2. "idxinfo" 정보에서 셀 스타일 정보를 지운 후 "syncinfo" 정보에서 행/열 정보가 하나도 없는 경우 제거한다.
		
		if(bUpdate){
			var heCell = this._getCellDOM(nRow, nCol);
			
			if(QBOX._.isElement(heCell)){
				QBOX.$(heCell).css(QBOX._.mapObject(this._getCellStyle(nRow, nCol), function(val, key){
					return '';
				}));
			}
		}
		
		if(htStyleIdxInfoOfRow.containsKey(nRow)){
			var htStyleInfoOfRow = htStyleIdxInfoOfRow.get(nRow);
			
			if(htStyleInfoOfRow.containsKey(nCol)){
				htStyleInfoOfRow.remove(nCol);
				
				if(htStyleInfoOfRow.size() === 0){
					htStyleIdxInfoOfRow.remove(nRow);
				}
			}
			
			if(htStyleInfoOfRow.size() === 0){
				if(htSyncInfoOfRow.containsKey(nRow)){
					var hsRowSyncInfo = htSyncInfoOfRow.get(nRow);
					
					hsRowSyncInfo.remove('style');
					
					if(hsRowSyncInfo.isEmpty()){
						htSyncInfoOfRow.remove(nRow);
					}
				}
			}
		}
		
		if(htStyleIdxInfoOfCol.containsKey(nCol)){
			var htStyleInfoOfCol = htStyleIdxInfoOfCol.get(nCol);
			
			if(htStyleInfoOfCol.containsKey(nRow)){
				htStyleInfoOfCol.remove(nRow);
				
				if(htStyleInfoOfCol.size() === 0){
					htStyleIdxInfoOfCol.remove(nCol);
				}
			}
			
			if(htStyleInfoOfCol.size() === 0){
				if(htSyncInfoOfCol.containsKey(nCol)){
					var hsColSyncInfo = htSyncInfoOfCol.get(nCol);
					
					hsColSyncInfo.remove('style');
					
					if(hsColSyncInfo.isEmpty()){
						htSyncInfoOfCol.remove(nCol);
					}
				}
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._removeCellStyle', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._removeCellStyles = function(nFirstRow, nFirstCol, nLastRow, nLastCol, bUpdate){
	var bRowReverse = nFirstRow > nLastRow,
	bColReverse = nFirstCol > nLastCol,
	result = true;
	
	for(var i = nFirstRow; bRowReverse ? i >= nLastRow : i <= nLastRow; bRowReverse ? i-- : i++){
		if(result === false){
			break;
		}
		
		for(var j = nFirstCol; bColReverse ? j >= nLastCol : j <= nLastCol; bColReverse ? j-- : j++){
			
			if(this._removeCellStyle(i, j, bUpdate) === false){
				result = false;
				break;
			}
		}
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._removeCellStylesOfRow = function(nRow, bUpdate){
	var htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row');
	
	if(htStyleIdxInfoOfRow.containsKey(nRow)){
		var htStyleInfoOfRow = htStyleIdxInfoOfRow.get(nRow),
		objQCell = this;
		
		htStyleInfoOfRow.each(function(nCol, objStyle){
			objQCell._removeCellStyle(nRow, nCol, bUpdate);
		});
	}
};

QBOX.QCELL.BasicQCELL.prototype._clearCellStyles = function(){
	try{
		var objQCell = this,
		htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row'),
		htStyleIdxInfoOfCol = this._getIdxInfo('style', 'col'),
		htSyncInfoOfRow = this._getSyncInfo('row'),
		htSyncInfoOfCol = this._getSyncInfo('col');
		
		this._clearCellStyleCSS('row', 'all');
		
		QBOX._.each(htStyleIdxInfoOfRow.keys(), function(nRow){
			if(htSyncInfoOfRow.containsKey(nRow)){
				var hsRowSyncInfo = htSyncInfoOfRow.get(nRow);
				
				hsRowSyncInfo.remove('style');
				
				if(hsRowSyncInfo.isEmpty()){
					htSyncInfoOfRow.remove(nRow);
				}
			}
		});
		htStyleIdxInfoOfRow.clear();
		
		QBOX._.each(htStyleIdxInfoOfCol.keys(), function(nCol){
			if(htSyncInfoOfCol.containsKey(nCol)){
				var hsColSyncInfo = htSyncInfoOfCol.get(nCol);
				
				hsColSyncInfo.remove('style');
				
				if(hsColSyncInfo.isEmpty()){
					htSyncInfoOfCol.remove(nCol);
				}
			}
		});
		htStyleIdxInfoOfCol.clear();
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._clearCellStyles', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._clearCellStyleCSS = function(axis, group){
//	var objQCell = this,
//	htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row');
//	
//	_.each(htStyleIdxInfoOfRow.keys(), function(nRow){
//		var htStyleInfoOfRow = htStyleIdxInfoOfRow.get(nRow);
//		
//		htStyleInfoOfRow.each(function(nCol, objStyle){
//			var heCell = objQCell._getCellDOM(nRow, nCol);
//			
//			if(_.isElement(heCell)){
//				QBOX.$(heCell).css(_.mapObject(objStyle, function(val, key){
//					return '';
//				}));
//			}
//		});
//	});
	var objQCell = this;
	
	if(axis === 'row'){
		var htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row'),
		objVSInfo = this.attr('vsinfo'),
		arrTargetRows,
		nHeaderRows = this.attr('headerrows'),
		nFrozenRows = this.attr('frozenrows'),
		nFrozenBottomRows = this.attr('frozenbottomrows'),
		nRows = this.attr('rows');
		
		arrTargetRows = QBOX._.reject(htStyleIdxInfoOfRow.keys().sort(QBOX.st.asc), function(nRow){//화면에 보이는 행들의 셀 스타일 정보가 있는 경우만
			return (nRow < objVSInfo.nTopRow && nRow >= nHeaderRows + nFrozenRows) || (nRow > objVSInfo.nBottomRow && nRow < nRows - nFrozenBottomRows);
		});
		
		if(group !== 'all'){
			arrTargetRows = QBOX._.filter(arrTargetRows, group === 'header' ? function(nRow){return nRow < nHeaderRows;} : function(nRow){return nRow >= nHeaderRows;});
			/*
			var fnTargetRowFilter;
			
			if(group === 'header'){
				fnTargetRowFilter = function(nRow){return nRow < nHeaderRows;};
			} else if(group === 'frozen'){
				fnTargetRowFilter = function(nRow){
					return nRow >= nHeaderRows && nRow < nHeaderRows + nFrozenRows;
				};
			} else if(group === 'normal'){
				fnTargetRowFilter = function(nRow){
					return nRow >= nHeaderRows + nFrozenRows && nRow < nRows - nFrozenBottomRows;
				};
			} else if(group === 'frozenbottom'){
				fnTargetRowFilter = function(nRow){
					return nRow >= nRows - nFrozenBottomRows;
				};
			}
			
			arrTargetRows = QBOX._.filter(arrTargetRows, fnTargetRowFilter);
			
			fnTargetRowFilter = null;
			*/
		}
		
		//console.log(JSON.stringify(arrTargetRows));
		
		QBOX._.each(arrTargetRows, function(nRow){
			var htStyleInfoOfRow = htStyleIdxInfoOfRow.get(nRow);
			
			htStyleInfoOfRow.each(function(nCol, objStyle){
				var heCell = objQCell._getCellDOM(nRow, nCol);
				
				/*if(_.isElement(heCell))*/{//이미 보이는 영역의 셀들만 추출했기 때문에 element인지 체크할 필요가 없고 만약에 에러가 나면 무결성에 문제가 있는 경우다.
					QBOX.$(heCell).css(QBOX._.mapObject(objStyle, function(val, key){
						return '';
					}));
				}
			});
		});
		
		return true;
	} else if(axis === 'col'){
		var htStyleIdxInfoOfCol = this._getIdxInfo('style', 'col'),
		objHSInfo = this.attr('hsinfo'),
		arrTargetCols,
		nHeaderCols = this.attr('headercols'),
		nFrozenCols = this.attr('frozencols'),
		nCols = this.attr('cols');
		
		arrTargetCols = QBOX._.reject(htStyleIdxInfoOfCol.keys().sort(QBOX.st.asc), function(nCol){//화면에 보이는 행들의 셀 스타일 정보가 있는 경우만
			return (nCol < objHSInfo.nLeftCol && nCol >= nHeaderCols + nFrozenCols) || (nCol > objHSInfo.nRightCol);
		});
		
		if(group !== 'all'){
			arrTargetCols = QBOX._.filter(arrTargetCols, group === 'header' ? function(nCol){return nCol < nHeaderCols;} : function(nCol){return nCol >= nHeaderCols;});
			/*
			var fnTargetColFilter;
			
			if(group === 'header'){
				fnTargetColFilter = function(nCol){return nCol < nHeaderCols;};
			} else if(group === 'frozen'){
				fnTargetColFilter = function(nCol){
					return nCol >= nHeaderCols && nCol < nHeaderCols + nFrozenCols;
				};
			} else if(group === 'normal'){
				fnTargetColFilter = function(nCol){
					return nCol >= nHeaderCols + nFrozenCols && nCol < nCols;
				};
			}
			
			arrTargetCols = QBOX._.filter(arrTargetCols, fnTargetColFilter);
			
			fnTargetColFilter = null;
			*/
		}

		//console.log(JSON.stringify(arrTargetCols));
		
		QBOX._.each(arrTargetCols, function(nCol){
			var htStyleInfoOfCol = htStyleIdxInfoOfCol.get(nCol);
			
			htStyleInfoOfCol.each(function(nRow, objStyle){
				var heCell = objQCell._getCellDOM(nRow, nCol);
				
				/*if(_.isElement(heCell))*/{//이미 보이는 영역의 셀들만 추출했기 때문에 element인지 체크할 필요가 없고 만약에 에러가 나면 무결성에 문제가 있는 경우다.
					QBOX.$(heCell).css(QBOX._.mapObject(objStyle, function(val, key){
						return '';
					}));
				}
			});
		});
	}
	
	return false;
};

QBOX.QCELL.BasicQCELL.prototype._removeAllCellStyleCSS = function(){
	var objQCell = this,
	htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row');
	
	QBOX._.each(htStyleIdxInfoOfRow.keys(), function(nRow){
		var htStyleInfoOfRow = htStyleIdxInfoOfRow.get(nRow);
		
		htStyleInfoOfRow.each(function(nCol, objStyle){
			var heCell = objQCell._getCellDOM(nRow, nCol);
			
			if(QBOX._.isElement(heCell)){
				QBOX.$(heCell).css(QBOX._.mapObject(objStyle, function(val, key){
					return '';
				}));
			}
		});
	});
};

QBOX.QCELL.BasicQCELL.prototype._setCellStyleCSS = function(heCell, objStyle){
	var strStyle = '';
	for(var key in objStyle){
		strStyle += key +': ' + objStyle[key] + ';';
	}

	$(heCell).attr('style', function(i,s) { return (s || '') + strStyle ;});		
/*	QBOX._.each(QBOX._.keys(objStyle), function(key){
		objStyle[key] =  QBOX.util.replaceAll(objStyle[key],'!important','');
		heCell.style[QBOX.$.camelCase(key)] = objStyle[key];
	});*/
};

QBOX.QCELL.BasicQCELL.prototype._removeCellStyleCSS = function(heCell, objStyle){
	QBOX._.each(QBOX._.keys(objStyle), function(key){
		heCell.style[QBOX.$.camelCase(key)] = '';
	});
};

QBOX.QCELL.BasicQCELL.prototype._clearDynamicStyles = function(){
	return this._clearCellStyles() && this._setHighlightRepeat(this.getProperties().highlightrepeat);
};

QBOX.QCELL.BasicQCELL.prototype._clearDynamicCSS = function(/*"row" or "col"*/axis, /*"header" or "data"*/group){
	//자료구조는 건들지 않고 inline 스타일과 적용된 CSS 클래스만 제거하는 함수
	if(group !== 'header'){
		this._clearFocusCSS();
		this._clearSelectionCSS();
	}
	
	this._clearCellStyleCSS(axis, group);
};

QBOX.QCELL.BasicQCELL.prototype._isCellStyleRow = function(nRow){
	return this._getIdxInfo('style', 'row').containsKey(nRow);
};

QBOX.QCELL.BasicQCELL.prototype._isCellStyleCol = function(nCol){
	return this._getIdxInfo('style', 'col').containsKey(nCol);
};

QBOX.QCELL.BasicQCELL.prototype._hasCellStyle = function(nRow, nCol){
	try{
		var htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row');
		
		if(htStyleIdxInfoOfRow.containsKey(nRow)){
			return htStyleIdxInfoOfRow.get(nRow).containsKey(nCol);
		}
		
		return false;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._hasCellStyle', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._getIdxInfo = function(/*cursor|click|drag|focus|select|selected|style*/type, /*row|col*/axis){
	return this.attr('idxinfo')[type][axis];
};

QBOX.QCELL.BasicQCELL.prototype._getSyncInfo = function(/*row|col*/axis){
	return this.attr('syncinfo')[axis];
};

QBOX.QCELL.BasicQCELL.prototype._popColSyncInfos = function (nBeforeCol, nCount){
	//컬럼 이동 시 이동된 컬럼의 syncinfo가 존재하는 경우 임시로 제거했다가 이동된 위치의 열 인덱스 정보로 재 삽입하는 동기화가 필요하다.
	//ex> 3,4,5열에 열 동기화 정보가 존재하는 상태에서 3열을 5열 위치로 이동하는 경우 3열의 동기화정보를 잠시 백업하고 삭제한 후 4,5열의 정보를 3,4열로 열 인덱스를 업데이트하고, 백업해두었던 기존의 3열 정보를 5열 인덱스로 업데이트해야 한다.
	//_popColSyncInfo() 내부함수는 "idxinfo"에서 열 이동 시 동기화해야 하는 항목들의 정보와 "syncinfo"의 정보에서 지정한 열 인덱스의 정보를 pop하여 반환한다.
	//반환된 값은 _putColSyncInfos() 내부함수를 이용하여 지정한 열 인덱스 정보로 재 삽입 해 줄 수 있다. 
	/*
	 *	[
	 *		{
	 *			"idxinfo": {
	 *				"style": {},	//hashtable, 해당 컬럼의 style 정보
	 *				"state": {}		//hashtable, 해당 컬럼의 state 정보
	 *			},
	 *			"syncinfo": {}//hashset, 현재 컬럼의 "syncinfo"
	 *		},
	 *		.
	 *		.
	 *		.
	 *	]
	 * */
	var result = [],
	htSyncInfoOfCol = this._getSyncInfo('col'),
	objQCell = this,
	fnTemp = function(strSyncName){//loop에서 anonymous functon 정의 시 jshint에서 에러가 나서 상위에서 정의
		objColSyncInfo.idxinfo = {
			'style'	: null,
			'state'	: null
		};
		
		//'style', 'state'정보의 열 인덱스들을 업데이트한다.
		switch(strSyncName){
			case 'style': {
				var htStyleIdxInfoOfCol = objQCell._getIdxInfo('style', 'col'),
				htStyleIdxInfoOfRow = objQCell._getIdxInfo('style', 'row'),
				htStyleRowIndexOfCol = htStyleIdxInfoOfCol.remove(nCol);
				
				objColSyncInfo.idxinfo.style = htStyleRowIndexOfCol;
				
				QBOX._.each(htStyleRowIndexOfCol.keys(), function(nRow){
					htStyleIdxInfoOfRow.get(nRow).remove(nCol);
				});
				
				break;
			}
			case 'state': {
				var htStateIdxInfoOfCol = objQCell._getIdxInfo('state', 'col');
				
				objColSyncInfo.idxinfo.style = htStateIdxInfoOfCol.remove(nCol);
				
				break;
			}
			default: break;
		}
	};
	
	for(var j = nBeforeCol; j < nBeforeCol + nCount; j++){
		var nCol = j,
		objColSyncInfo = {
			'idxinfo'	: null,
			'syncinfo'	: null
		};
		
		if(htSyncInfoOfCol.containsKey(nCol)){
			var hsSyncInfoOfCol = htSyncInfoOfCol.remove(nCol);
			
			QBOX._.each(hsSyncInfoOfCol.values(), fnTemp);
			
			objColSyncInfo.syncinfo = hsSyncInfoOfCol;
		}
		
		result.push(objColSyncInfo);
	}
	
	return result;
};

QBOX.QCELL.BasicQCELL.prototype._putColSyncInfos = function (arrTargetCols, arrColSyncInfos){
	//컬럼 이동 시 이동된 컬럼의 syncinfo가 존재하는 경우 임시로 제거했다가 이동된 위치의 열 인덱스 정보로 재 삽입하는 동기화가 필요하다.
	//ex> 3,4,5열에 열 동기화 정보가 존재하는 상태에서 3열을 5열 위치로 이동하는 경우 3열의 동기화정보를 잠시 백업하고 삭제한 후 4,5열의 정보를 3,4열로 열 인덱스를 업데이트하고, 백업해두었던 기존의 3열 정보를 5열 인덱스로 업데이트해야 한다.
	//_popColSyncInfo() 내부함수는 "idxinfo"에서 열 이동 시 동기화해야 하는 항목들의 정보와 "syncinfo"의 정보에서 지정한 열 인덱스의 정보를 pop하여 반환한다.
	//반환된 값은 _putColSyncInfos() 내부함수를 이용하여 지정한 열 인덱스 정보로 재 삽입 해 줄 수 있다. 
	/*
	 *	[
	 *		{
	 *			"idxinfo": {
	 *				"style": {},	//hashtable, 해당 컬럼의 style 정보
	 *				"state": {}		//hashtable, 해당 컬럼의 state 정보
	 *			},
	 *			"syncinfo": {}//hashset, 현재 컬럼의 "syncinfo"
	 *		},
	 *		.
	 *		.
	 *		.
	 *	]
	 * */
	var objQCell = this,
	htSyncInfoOfCol = this._getSyncInfo('col');
	
	QBOX._.each(arrTargetCols, function(nCol, idx){
		var objColSyncInfo = arrColSyncInfos[idx],
		hsSyncInfoOfCol = objColSyncInfo.syncinfo;
		
		
		if(hsSyncInfoOfCol !== null){
			QBOX._.each(hsSyncInfoOfCol.values(), function(strSyncName){
				//'style', 'state', 'sort'정보의 열 인덱스들을 업데이트한다.
				switch(strSyncName){
					case 'style': {
						var htStyleIdxInfoOfCol = objQCell._getIdxInfo('style', 'col'),
						htStyleIdxInfoOfRow = objQCell._getIdxInfo('style', 'row'),
						htStyleRowIndexOfCol = objColSyncInfo.idxinfo.style;
						
						htStyleIdxInfoOfCol.put(nCol, htStyleRowIndexOfCol);
						
						QBOX._.each(htStyleRowIndexOfCol.keys(), function(nRow){
							htStyleIdxInfoOfRow.get(nRow).put(nCol, htStyleRowIndexOfCol.get(nRow));
						});
						
						break;
					}
					case 'state': {
						var htStateIdxInfoOfCol = objQCell._getIdxInfo('state', 'col');
						
						htStateIdxInfoOfCol.put(nCol, objColSyncInfo.idxinfo.state);
						
						break;
					}
					case 'sort': {
						var objQCellCol = objQCell._getQCellCol(nCol),
						arrSortInfo = objQCell.attr('sortinfo');
						
						arrSortInfo[objQCellCol.attr('sortinfoofcol').order - 1][0] = nCol;
						
						break;
					}
					default: break;
				}
			});
			
			htSyncInfoOfCol.put(nCol, hsSyncInfoOfCol);
		}
	});
};

QBOX.QCELL.BasicQCELL.prototype._pushColSyncInfo = function (arrPushedCols, nCount){
	if(arrPushedCols.length > 0){
		var htSyncInfoOfCol = this._getSyncInfo('col');
		
		if(htSyncInfoOfCol.size() > 0){
			var objQCell = this;
			
			QBOX._.each(arrPushedCols, function(nCol){
				//console.log(nCol, ':', htSyncInfoOfCol.get(nCol).values());
				var hsBeforeSyncInfoOfCol = htSyncInfoOfCol.remove(nCol);
				
				QBOX._.each(hsBeforeSyncInfoOfCol.values(), function(strSyncName){
					//'style', 'state', 'sort'정보의 열 인덱스들을 업데이트한다.
					switch(strSyncName){
						case 'style': {
							var htStyleIdxInfoOfCol = objQCell._getIdxInfo('style', 'col'),
							htStyleIdxInfoOfRow = objQCell._getIdxInfo('style', 'row'),
							htStyleRowIndexOfCol = htStyleIdxInfoOfCol.remove(nCol);
							
							//console.log(htStyleRowIndexOfCol.keys());
							htStyleIdxInfoOfCol.put(nCol + nCount, htStyleRowIndexOfCol);
							
							QBOX._.each(htStyleRowIndexOfCol.keys(), function(nRow){
								var htStyleColIndexOfRow = htStyleIdxInfoOfRow.get(nRow);
								
								htStyleColIndexOfRow.put(nCol + nCount, htStyleColIndexOfRow.remove(nCol));
							});
							
							break;
						}
						case 'state': {
							var htStateIdxInfoOfCol = objQCell._getIdxInfo('state', 'col');
							
							htStateIdxInfoOfCol.put(nCol + nCount, htStateIdxInfoOfCol.remove(nCol));
							
							break;
						}
						case 'sort': {
							var arrSortInfo = objQCell.attr('sortinfo');
							
							QBOX._.each(arrSortInfo, function(arrTemp){
								if(arrTemp[0] === nCol){
									arrTemp[0] = (nCol + nCount);
								}
							});
							
							break;
						}
						default: break;
					}
				});
				
				htSyncInfoOfCol.put((nCol + nCount), hsBeforeSyncInfoOfCol);
			});
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._pullColSyncInfo = function (arrPushedCols, nCount){
	if(arrPushedCols.length > 0){
		var htSyncInfoOfCol = this._getSyncInfo('col');
		
		if(htSyncInfoOfCol.size() > 0){
			var objQCell = this;
			
			QBOX._.each(arrPushedCols, function(nCol){
//				console.log(nCol, ':', htSyncInfoOfCol.get(nCol).values());
				var hsBeforeSyncInfoOfCol = htSyncInfoOfCol.remove(nCol);
				
				QBOX._.each(hsBeforeSyncInfoOfCol.values(), function(strSyncName){
					//'style', 'state', 'sort'정보의 열 인덱스들을 업데이트한다.
					switch(strSyncName){
						case 'style': {
							var htStyleIdxInfoOfCol = objQCell._getIdxInfo('style', 'col'),
							htStyleIdxInfoOfRow = objQCell._getIdxInfo('style', 'row'),
							htStyleRowIndexOfCol = htStyleIdxInfoOfCol.remove(nCol);
							
							//console.log(htStyleRowIndexOfCol.keys());
							htStyleIdxInfoOfCol.put(nCol - nCount, htStyleRowIndexOfCol);
							
							QBOX._.each(htStyleRowIndexOfCol.keys(), function(nRow){
								var htStyleColIndexOfRow = htStyleIdxInfoOfRow.get(nRow);
								
								htStyleColIndexOfRow.put(nCol - nCount, htStyleColIndexOfRow.remove(nCol));
							});
							
							break;
						}
						case 'state': {
							var htStateIdxInfoOfCol = objQCell._getIdxInfo('state', 'col');
							
							htStateIdxInfoOfCol.put(nCol - nCount, htStateIdxInfoOfCol.remove(nCol));
							
							break;
						}
						case 'sort': {
							var arrSortInfo = objQCell.attr('sortinfo');
							
							QBOX._.each(arrSortInfo, function(arrTemp){
								if(arrTemp[0] === nCol){
									arrTemp[0] = (nCol - nCount);
								}
							});
							
							break;
						}
						default: break;
					}
				});
				
				htSyncInfoOfCol.put((nCol - nCount), hsBeforeSyncInfoOfCol);
			});
		}
	}
};


QBOX.QCELL.BasicQCELL.prototype._createTooltip = function($heElement, event,strData){
	var def = QBOX.QCELL.def,
	id = def.cssprefix + this.attr('id') + '-' + 'tooltip',
	markup = '<div id="'+id+'" class="'+def.css.TOOLTIP+'"><div class="content"></div></div>',
	htElementPool = this.attr('elementpool'),
	heRoot = htElementPool.get('$root'),
	htmlStr = QBOX.$.trim($heElement.html()) === '' ? '&nbsp;' : $heElement.html().replace(/\r\n/g, "<br>").replace(/\n/g, "<br>").replace(/&amp;/g, "&").replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"').replace(/&#39;/g, "'"),
	pos = this._setTooltipPos(event);
	
	if(strData !== undefined)
		htmlStr = strData;	
		
	//if(this.attr('_createTooltip')){
		this._removeTooltip();
	//}
	
	if(this.attr('tooltipvisible') === false){
		if(QBOX.$.browser.msie)
			QBOX.$(document.body).append(markup);
		else{
			QBOX.$(heRoot).append(markup);	
		}
		
		QBOX.$('#'+id+' > .content').append(htmlStr);
		
		QBOX.$('#'+id).hide().css(pos).fadeIn(400);
		
		this.attr('tooltipvisible', true, 'boolean');
	}
};

QBOX.QCELL.BasicQCELL.prototype._moveTooltip = function($heElement, event){
	var def = QBOX.QCELL.def,
	id = def.cssprefix + this.attr('id') + '-' + 'tooltip',
	pos = this._setTooltipPos(event);
	
	QBOX.$('#'+id).hide().css(pos).fadeIn(400);
};

QBOX.QCELL.BasicQCELL.prototype._setTooltipPos = function(event){ // tooltip의 position을 마우스의 하단으로 위치 고정
	var finalPosX = 0, finalPosY = 0, spacingY = 7;
	finalPosX = event.clientX;
	finalPosY = event.clientY + (spacingY * 3);
	
	return {top: finalPosY+'px', left: finalPosX+'px'};
};

QBOX.QCELL.BasicQCELL.prototype._removeTooltip = function(){
	var css = QBOX.QCELL.def.css;
	QBOX.$('.'+css.TOOLTIP).remove();
	
	this.attr('tooltipvisible', false, 'boolean');
};
//스크롤 동기화를 위한 화면 갱신을 "update"라 칭한다.
//동적 변경사항 정보를 반영하기 위한 화면 갱신을 "refresh"라 칭한다.

QBOX.QCELL.BasicQCELL.prototype._refreshRs = function(){//Rs -> Rows
	this._refreshHRs();	//HRs -> HeaderRows
	this._refreshDRs();	//FRs -> DataRows
};

QBOX.QCELL.BasicQCELL.prototype._refreshCs = function(){//Cs -> Cols
	this._refreshHCs();	//HCs -> HeaderCols
	this._refreshDCs();	//DCs -> DataCols
};

QBOX.QCELL.BasicQCELL.prototype._refreshDRs = function(){//DRs -> DataRows
	this._refreshFRs();	//FRs -> FrozenRows
	this._refreshNRs();	//NRs -> NormalRows
	this._refreshFBRs();//FBRs -> FrozenBottomRows
};

QBOX.QCELL.BasicQCELL.prototype._refreshDCs = function(){//DCs -> DataCols
	this._refreshFCs();	//FCs -> FrozenCols
	this._refreshNCs();	//NCs -> NormalCols
};
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._refreshHRs = function(){//HRs -> HeaderRows
	//_refreshHRs()은 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 HeaderRows에 반영하기 위해 사용되는 함수이다.
	//HeaderRows영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshHRs()를 사용해야 한다. 
	try{
		var objQCell = this,
		arrHeaderText = this.attr('headertext'),
		arrHeaderRowsCellDOMs = this._getCellGroupDOMs('row', 'header'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols');
		
		this._clearMergeHeader(); // Merge 정보 클리어
		this._createHeaderMergeInfo();
		
		QBOX._.each(arrHeaderRowsCellDOMs, function(arrHeaderRowCellDOMs, idx){
			var nRow = idx,
			bStyleRow = objQCell._isCellStyleRow(nRow);
			
			QBOX._.each(arrHeaderRowCellDOMs, function(heCell, idx2){
				if(heCell !== null){//멀티캡션 사용 시 headerCols의 HeaderRows영역은 첫번째 행만 셀 div가 존재한다.
					if(heCell.getAttribute('data-footer') !== 'true'){
						var nCol = parseInt(heCell.getAttribute('data-col')),
						bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
								strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow];
						
						heCell.setAttribute('data-row', nRow);
						heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
						
						if(nCol >= nHeaderCols){//HeaderCols가 아니면
							heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText);
							
							if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
								
								if(objQCell.attr('useGroupUI')){
									QBOX.$(heCell).draggable({
										helper: objQCell._setGroupMakeHelper,
										revert: 'invalid'
									});
								}
								
								if(objQCell._getQCellCol(nCol).attr('move')){
									heCell.appendChild(objQCell._getColHeaderDragDropArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('search')){
									heCell.appendChild(objQCell._getColSearchArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('sort')){
									if(objQCell._getQCellCol(nCol).attr('colsortarea') === null){
										objQCell._getQCellCol(nCol).attr('colsortarea', objQCell.attr('defaultsortarea').clone(true), 'jquery');
									}
									
									heCell.appendChild(objQCell._getDefaultSortArea(nCol));
								}
								
								if(objQCell._getQCellCol(nCol).attr('resize')){
									heCell.appendChild(objQCell._getColResizeArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('filter')){									
									heCell.appendChild(objQCell._getFilterArea(nCol));
								}
								
								if(objQCell._getQCellCol(nCol).attr('editor')){
									heCell.appendChild(objQCell._getColStyleEditorArea());
								}
							}
						}
						
						if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
							objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
						}
					}
				}
			});
		});
		
		this._clearMergeHeader(); //머지 정보 설정
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._refreshHRs', e.message);
	}
};
*/
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._refreshFRs = function(){//FRs -> FrozenRows
	//_refreshFRs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 FrozenRows에 반영하기 위해 사용되는 함수이다.
	//FrozenRows영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshFRs()를 사용해야 한다.
	try{
		var css = QBOX.QCELL.def.css,
		objQCell = this,
		objGroupState = this.attr('groupstate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrFrozenRowsCellDOMs = this._getCellGroupDOMs('row', 'frozen'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'),
		nHighlightRepeat = this.attr('highlightrepeat'),
		bIsRowSelectMode = this.attr('selectmode').indexOf('row') > -1 ? true : false,
		cellData;
		
		this._clearMergeData(); // Merge 정보 클리어
		this._createDataMergeInfo();
		
		QBOX._.each(arrFrozenRowsCellDOMs, function(arrFrozenRowCellDOMs, idx){
			var nRow = nHeaderRows + idx,
			nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
			bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
			objNode = null,
			arrRowData = arrCurrentData[nRow - nHeaderRows],
			bFocusRow = objQCell._isFocusRow(nRow),
			bSelectedRow = objQCell._isSelectedRow(nRow),
			bStyleRow = objQCell._isCellStyleRow(nRow),
			bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
			
			if(objGroupState.grouped){
				if(objGroupState.type === 'tree'){
					nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
				}
				
				if(nIdxOfGroupTreeUIRow > -1){
					bIsGroupTreeUIRow = true;
					objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
					
					bIsGroupHeaderRow = bIsGroupFooterRow = false;
				} else{
					nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
					
					if(nIdxOfGroupHeaderRow > -1){
						bIsGroupHeaderRow = true;
						objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
						
						bIsGroupFooterRow = false;
					} else{
						nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
						
						if(nIdxOfGroupFooterRow > -1){
							bIsGroupFooterRow = true;
							objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
							
							bIsGroupHeaderRow = false;
						}
					}
				}
			}
			
			QBOX._.each(arrFrozenRowCellDOMs, function(heCell, idx2){
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nCol = parseInt(heCell.getAttribute('data-col')),
					strColID = objQCell._getColID(nCol),
					keyOfCol = objQCell._getKeyOfCol(nCol),
					bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
					bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
					bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
					heCheckbox;
					
					heCell.setAttribute('data-row', nRow);
					heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
					
					if(nCol < nHeaderCols){
						var objPaginationInfo = objQCell.attr('paginationinfo');
						
						if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows) : nRow - nHeaderRows + 1);
							} else if(arrRowHeaders[nCol] === 'checkbox') {
								heCell.innerHTML = '';
								heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
								heCell.appendChild(heCheckbox);
								
								heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
							} else if(arrRowHeaders[nCol] === 'state') {
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						} else {
							var nPageRow = nRow;
							// multiheader 일 때
							if(nHeaderRows > 1) {
								nPageRow = nRow - (nHeaderRows - 1);
							}
							
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
							} else if(arrRowHeaders[nCol] === 'checkbox') {
								heCell.innerHTML = '';
								heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
								heCell.appendChild(heCheckbox);
								
								heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
							} else if(arrRowHeaders[nCol] === 'state') {
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						}
					} else{
						cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
						var strDataFormat = objQCell._showDataFormat(nCol, cellData),
						strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData);
						
						QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
						
						if(objGroupState.grouped && strColID === strFirstGroupColID){
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
								objQCell._setGroupTreeUICell(heCell, objNode, strDataFormat);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setGroupTreeDataCell(heCell, strDataFormat);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								QBOX.util.textContent(heCell, cellData);
							}
						}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								QBOX.util.textContent(heCell, cellData);
							}
						} else{
							if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
								QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
								strDataFormat = cellData;
							}
							
							QBOX.util.textContent(heCell, cellData);
						}
					}
					
					if(nCol >= nHeaderCols){
						if(bHighlightRepeatRow){
							QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
						}
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
				}
			});
		});
		
		//this._updateMergeData(); //머지 정보 설정
		this._updateMergeHeader(); //머지 정보 갱신
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._refreshFRs', e.message);
	}
};
*/
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._refreshFBRs = function(){//FBRs -> FrozenBottomRows
	//_refreshFBRs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 FrozenBottomRows에 반영하기 위해 사용되는 함수이다.
	//FrozenBottomRows영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshFBRs()를 사용해야 한다.
	try{
		var css = QBOX.QCELL.def.css,
		objVSInfo = this.attr('vsinfo'), objQCell = this,
		objGroupState = this.attr('groupstate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrFrozenBottomRowsCellDOMs = this._getCellGroupDOMs('row', 'frozenbottom'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'),
		nHighlightRepeat = this.attr('highlightrepeat'),
		bIsRowSelectMode = this.attr('selectmode').indexOf('row') > -1 ? true : false,
		cellData;
		
		this._clearMergeData(); // Merge 정보 클리어
		this._createDataMergeInfo();
		
		QBOX._.each(arrFrozenBottomRowsCellDOMs, function(arrFrozenBottomRowCellDOMs, idx){
			var nRow = objVSInfo.nEndRow + idx + 1,
			nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
			bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
			objNode = null,
			arrRowData = arrCurrentData[nRow - nHeaderRows],
			bFocusRow = objQCell._isFocusRow(nRow),
			bSelectedRow = objQCell._isSelectedRow(nRow),
			bStyleRow = objQCell._isCellStyleRow(nRow),
			bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
			
			if(objGroupState.grouped){
				if(objGroupState.type === 'tree'){
					nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
				}
				
				if(nIdxOfGroupTreeUIRow > -1){
					bIsGroupTreeUIRow = true;
					objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
					
					bIsGroupHeaderRow = bIsGroupFooterRow = false;
				} else{
					nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
					
					if(nIdxOfGroupHeaderRow > -1){
						bIsGroupHeaderRow = true;
						objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
						
						bIsGroupFooterRow = false;
					} else{
						nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
						
						if(nIdxOfGroupFooterRow > -1){
							bIsGroupFooterRow = true;
							objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
							
							bIsGroupHeaderRow = false;
						}
					}
				}
			}
			
			QBOX._.each(arrFrozenBottomRowCellDOMs, function(heCell, idx2){
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nCol = parseInt(heCell.getAttribute('data-col')),
					strColID = objQCell._getColID(nCol),
					keyOfCol = objQCell._getKeyOfCol(nCol),
					bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
					bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
					bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false;
					
					heCell.setAttribute('data-row', nRow);
					heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
					
					if(nCol < nHeaderCols){
						var objPaginationInfo = objQCell.attr('paginationinfo'),
						heCheckbox;
						
						if( _.isObject(objPaginationInfo) && _.isEmpty(objPaginationInfo) ) {
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows) : nRow - nHeaderRows + 1);
							} else if(arrRowHeaders[nCol] === 'checkbox') {
								heCell.innerHTML = '';
								heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
								heCell.appendChild(heCheckbox);
								
								heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
							} else if(arrRowHeaders[nCol] === 'state') {
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						} else {
							var nPageRow = nRow;
							// multiheader 일 때
							if(nHeaderRows > 1) {
								nPageRow = nRow - (nHeaderRows - 1);
							}
							
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
							} else if(arrRowHeaders[nCol] === 'checkbox') {
								heCell.innerHTML = '';
								heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
								heCell.appendChild(heCheckbox);
								
								heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
							} else if(arrRowHeaders[nCol] === 'state') {
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						}
					} else{
						cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
						var strDataFormat = objQCell._showDataFormat(nCol, cellData);
						
						QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
						
						if(objGroupState.grouped && strColID === strFirstGroupColID){
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
								objQCell._setGroupTreeUICell(heCell, objNode, strDataFormat);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setGroupTreeDataCell(heCell, strDataFormat);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								QBOX.util.textContent(heCell, strDataFormat);
							}
						}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								QBOX.util.textContent(heCell, cellData);
							}
						} else{
							if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
								QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
								strDataFormat = cellData;
							}
							
							QBOX.util.textContent(heCell, strDataFormat);
						}
					}
					
					if(nCol >= nHeaderCols){
						if(bHighlightRepeatRow){
							QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
						}
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
				}
			});
		});
		
		this._updateMergeData(); //머지 정보 설정
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._refreshFBRs', e.message);
	}
};
*/
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._refreshNRs = function(){//NRs -> NormalRows
	//_refreshNRs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 NormalRows에 반영하기 위해 사용되는 함수이다.
	//NormalRows영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshNRs()를 사용해야 한다.
	try{
		var css = QBOX.QCELL.def.css,
		objVSInfo = this.attr('vsinfo'), objQCell = this,
		objGroupState = this.attr('groupstate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrNormalRowsCellDOMs = this._getCellGroupDOMs('row', 'normal'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'),
		nHighlightRepeat = this.attr('highlightrepeat'),
		bIsRowSelectMode = this.attr('selectmode').indexOf('row') > -1 ? true : false,
		cellData;
		
		this._clearMergeData(); // Merge 정보 클리어
		this._createDataMergeInfo();
		
		QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, idx){
			var nRow = objVSInfo.nTopRow + idx,
			nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
			bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
			objNode = null,
			arrRowData = arrCurrentData[nRow - nHeaderRows],
			bFocusRow = objQCell._isFocusRow(nRow),
			bSelectedRow = objQCell._isSelectedRow(nRow),
			bStyleRow = objQCell._isCellStyleRow(nRow),
			bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
			
			if(objGroupState.grouped){
				if(objGroupState.type === 'tree'){
					nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
				}
				
				if(nIdxOfGroupTreeUIRow > -1){
					bIsGroupTreeUIRow = true;
					objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
					
					bIsGroupHeaderRow = bIsGroupFooterRow = false;
				} else{
					nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
					
					if(nIdxOfGroupHeaderRow > -1){
						bIsGroupHeaderRow = true;
						objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
						
						bIsGroupFooterRow = false;
					} else{
						nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
						
						if(nIdxOfGroupFooterRow > -1){
							bIsGroupFooterRow = true;
							objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
							
							bIsGroupHeaderRow = false;
						}
					}
				}
			}
			
			QBOX._.each(arrNormalRowCellDOMs, function(heCell, idx2){
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nCol = parseInt(heCell.getAttribute('data-col')),
					strColID = objQCell._getColID(nCol),
					keyOfCol = objQCell._getKeyOfCol(nCol),
					bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
					bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
					bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
					strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata');
					
					heCell.setAttribute('data-row', nRow);
					heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
					
					if(nCol < nHeaderCols){
						var objPaginationInfo = objQCell.attr('paginationinfo'),
						heCheckbox;
						
						if( _.isObject(objPaginationInfo) && _.isEmpty(objPaginationInfo) ) {
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows) : nRow - nHeaderRows + 1);
							} else if(arrRowHeaders[nCol] === 'checkbox') {
								heCell.innerHTML = '';
								heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
								heCell.appendChild(heCheckbox);
								
								heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
							} else if(arrRowHeaders[nCol] === 'state') {
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						} else {
							var nPageRow = nRow;
							// multiheader 일 때
							if(nHeaderRows > 1) {
								nPageRow = nRow - (nHeaderRows - 1);
							}
							
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
							} else if(arrRowHeaders[nCol] === 'checkbox') {
								heCell.innerHTML = '';
								heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
								heCell.appendChild(heCheckbox);
								
								heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
							} else if(arrRowHeaders[nCol] === 'state') {
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						}
					} else{
						if(arrRowData !== undefined){
							cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리							
						}else{
							cellData = '';
						}

						var strDataFormat = objQCell._showDataFormat(nCol, cellData);
						
						QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
						
						if(objGroupState.grouped && strColID === strFirstGroupColID){
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
								objQCell._setGroupTreeUICell(heCell, objNode, strDataFormat);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setGroupTreeDataCell(heCell, strDataFormat);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
									heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
								}
								else {
									QBOX.util.textContent(heCell, strDataFormat);
								}
							}
						}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								QBOX.util.textContent(heCell, cellData);
							}
						} else{
							if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
								QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
								strDataFormat = cellData;
							}
							
							if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
								heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
							}
							else {
								QBOX.util.textContent(heCell, strDataFormat);
							}
						}
					}
					
					if(nCol >= nHeaderCols){
						if(bHighlightRepeatRow){
							QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
						}
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
				}
			});
		});
		
		this._updateMergeData(); //머지 정보 설정
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._refreshNRs', e.message);
	}
};
*/
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._refreshHCs = function(){//HCs -> HeaderCols
	//_refreshHCs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 HeaderCols에 반영하기 위해 사용되는 함수이다.
	//HeaderCols영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshHCs()를 사용해야 한다.
	try{
		var css = QBOX.QCELL.def.css,
		objQCell = this,
		arrHeaderColsCellDOMs = this._getCellGroupDOMs('col', 'header'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'),
		nAdjustColWidths = 0;
		
		QBOX._.each(arrHeaderColsCellDOMs, function(arrHeaderColCellDOMs, idx){
			var nCol = idx,
			nColWidth = objQCell._getColWidth(nCol),
			nCellLeft = nAdjustColWidths,
			keyOfCol = objQCell._getKeyOfCol(nCol),
			bStyleCol = objQCell._isCellStyleCol(nCol),
			objColStyle = objQCell._getQCellCol(nCol).attr('style');
			
			QBOX._.each(arrHeaderColCellDOMs, function(heCell){
				if(heCell !== null){//멀티캡션 사용 시 headerCols의 HeaderRows영역은 첫번째 행만 셀 div가 존재한다.
					heCell.setAttribute('data-col', nCol);
					heCell.style.left = nCellLeft + 'px';
					if(nColWidth !== parseInt(heCell.style.width)){
						heCell.style.width = nColWidth + 'px';
					}
					
					if(heCell.getAttribute('data-footer') !== 'true'){
						var nRow = parseInt(heCell.getAttribute('data-row')),
						bHeaderRow = nRow < nHeaderRows,
						bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
						strColStyleGroup = bHeaderRow ? 'header' : 'data';
						
						heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
						
						QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
						
						if(!QBOX._.isEmpty(objColStyle)){
							if(QBOX._.isObject(objColStyle[strColStyleGroup])){
								var keys = Object.keys(objColStyle[strColStyleGroup]);
								for(var k = 0; k < keys.length; k++){
									QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
								}
							}
							objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
						}
						
						if(nRow >= nHeaderRows){//HeaderRows가 아니면
							var objPaginationInfo = objQCell.attr('paginationinfo'),
							heCheckbox;
							
							if( _.isObject(objPaginationInfo) && _.isEmpty(objPaginationInfo) ) {
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows) : nRow - nHeaderRows + 1);
								} else if(arrRowHeaders[nCol] === 'checkbox') {
									heCell.innerHTML = '';
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
									heCell.appendChild(heCheckbox);
									
									heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
								} else if(arrRowHeaders[nCol] === 'state') {
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
								
							} else {
								var nPageRow = nRow;
								// multiheader 일 때
								if(nHeaderRows > 1) {
									nPageRow = nRow - (nHeaderRows - 1);
								}
								
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
								} else if(arrRowHeaders[nCol] === 'checkbox') {
									heCell.innerHTML = '';
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
									heCell.appendChild(heCheckbox);
									
									heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
								} else if(arrRowHeaders[nCol] === 'state') {
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
							}
						}
						
						if(bStyleCell){//셀 스타일을 적용해야 하는 경우
							objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
						}
					}
				}
			});
			
			nAdjustColWidths += nColWidth;
		});
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._refreshHCs', e.message);
	}
};
*/
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._refreshFCs = function(){//FCs -> FrozenCols
	//_refreshFCs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 FrozenCols에 반영하기 위해 사용되는 함수이다.
	//FrozenCols영역에 반영된 동적 변경사항(focus, selection, style)들은 모두 제거하고  _refreshFCs()를 사용해야 한다.
	try{
		var css = QBOX.QCELL.def.css,
		objQCell = this,
		objGroupState = this.attr('groupstate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrHeaderText = this.attr('headertext'),
		arrFrozenColsCellDOMs = this._getCellGroupDOMs('col', 'frozen'),
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'),
		nAdjustColWidths,
		bIsColSelectMode = this.attr('selectmode').indexOf('col') > -1 ? true : false,
		cellData,objNode = null;
		
		this._clearMerge(); // Merge 정보 클리어
		this._createMergeInfo();

		nAdjustColWidths = 0;
		QBOX._.each(arrFrozenColsCellDOMs, function(arrFrozenColCellDOMs, idx){
			var nCol = nHeaderCols + idx,
			nColWidth = objQCell._getColWidth(nCol),
			nCellLeft = nAdjustColWidths,
			strColID = objQCell._getColID(nCol),
			keyOfCol = objQCell._getKeyOfCol(nCol),
			bFirstGroupCol = strColID === strFirstGroupColID ? true : false,
			bFocusCol = objQCell._isFocusCol(nCol),
			bSelectedCol = objQCell._isSelectedCol(nCol),
			bStyleCol = objQCell._isCellStyleCol(nCol),
			strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
			objColStyle = objQCell._getQCellCol(nCol).attr('style');
			
			QBOX._.each(arrFrozenColCellDOMs, function(heCell){
				heCell.setAttribute('data-col', nCol);
				heCell.style.left = nCellLeft + 'px';
				if(nColWidth !== parseInt(heCell.style.width)){
					heCell.style.width = nColWidth + 'px';
				}
				
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nRow = parseInt(heCell.getAttribute('data-row')),
					bHeaderRow = nRow < nHeaderRows,
					bFocusCell = bFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
					bSelectedCell = bHeaderRow ? false : (bSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)) : false),
					bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
					strColStyleGroup = bHeaderRow ? 'header' : 'data',
					strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow];
					
					heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
					
					QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
					
					if(!QBOX._.isEmpty(objColStyle)){
						if(QBOX._.isObject(objColStyle[strColStyleGroup])){
							var keys = Object.keys(objColStyle[strColStyleGroup]);
							for(var k = 0; k < keys.length; k++){
								QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
							}
						}
						objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
					}
					
					if(bHeaderRow){
						heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText);
						
						if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
							
							if(objQCell.attr('useGroupUI')){
								QBOX.$(heCell).draggable({
									helper: objQCell._setGroupMakeHelper,
									revert: 'invalid'
								});
							}
							
							if(objQCell._getQCellCol(nCol).attr('move')){
								heCell.appendChild(objQCell._getColHeaderDragDropArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('search')){
								heCell.appendChild(objQCell._getColSearchArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('sort')){							
								heCell.appendChild(objQCell._getDefaultSortArea(nCol));
							}
							
							if(objQCell._getQCellCol(nCol).attr('resize')){
								heCell.appendChild(objQCell._getColResizeArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('filter')){								
								heCell.appendChild(objQCell._getFilterArea(nCol));
							}
							
							if(objQCell._getQCellCol(nCol).attr('editor')){
								heCell.appendChild(objQCell._getColStyleEditorArea());
							}
						}
					} else{
						cellData = arrCurrentData[nRow - nHeaderRows][keyOfCol] === undefined ? '' : arrCurrentData[nRow - nHeaderRows][keyOfCol]; //null이나 undefined인 경우 공백처리
						var strDataFormat = objQCell._showDataFormat(nCol, cellData),
						bIsGroupHeaderRow = false, bIsGroupFooterRow = false;
						
						QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
						
						if(objGroupState.grouped && bFirstGroupCol){
							var nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
							bIsGroupTreeUIRow = false; 
							
										
							if(objGroupState.type === 'tree'){
								nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
							}
							
							if(nIdxOfGroupTreeUIRow > -1){
								bIsGroupTreeUIRow = true;
								objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
								
								bIsGroupHeaderRow = bIsGroupFooterRow = false;
							} else{
								nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
								
								if(nIdxOfGroupHeaderRow > -1){
									bIsGroupHeaderRow = true;
									objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
									
									bIsGroupFooterRow = false;
								} else{
									nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
									
									if(nIdxOfGroupFooterRow > -1){
										bIsGroupFooterRow = true;
										objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
										
										bIsGroupHeaderRow = false;
									}
								}
							}
							
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
								objQCell._setGroupTreeUICell(heCell, objNode, strDataFormat);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setGroupTreeDataCell(heCell, strDataFormat);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
									heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
								}
								else {
									QBOX.util.textContent(heCell, strDataFormat);
								}
							}
						}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrCurrentData[nRow - nHeaderRows],keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if(objGroupState.grouped){
									if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1)
										bIsGroupHeaderRow = true;
									if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1)
										bIsGroupFooterRow = true;								
								}
								
								if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
									//QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID);
									strDataFormat = cellData;
								}
								
								QBOX.util.textContent(heCell, strDataFormat);
							}
						} else{
							if(objGroupState.grouped){
								if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1)
									bIsGroupHeaderRow = true;
								if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1)
									bIsGroupFooterRow = true;								
							}
							
							if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
								//QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID);
								strDataFormat = cellData;
							}
							
							if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
								heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
							}
							else {
								QBOX.util.textContent(heCell, strDataFormat);
							}
						}
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
				}
			});
			
			nAdjustColWidths += nColWidth;
		});
		
		this._updateMerge(); //머지 정보 설정

	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._refreshFCs', e.message);
	}
};
*/
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._refreshNCs = function(){//NCs -> NormalCols
	//_refreshNCs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 NormalCols에 반영하기 위해 사용되는 함수이다.
	//NormalCols영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshNCs()를 사용해야 한다. 
	try{
		var css = QBOX.QCELL.def.css,
		objHSInfo = this.attr('hsinfo'), objQCell = this, objUpdateInfo = objHSInfo.objUpdateInfo,
		objGroupState = this.attr('groupstate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrHeaderText = this.attr('headertext'),
		arrNormalColsCellDOMs = this._getCellGroupDOMs('col', 'normal'),
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
		nAdjustColWidths, nAdjustedLeft,
		bIsColSelectMode = this.attr('selectmode').indexOf('col') > -1 ? true : false,
		cellData,objNode = null;
		
		this._clearMerge(); // Merge 정보 클리어
		this._createMergeInfo();
		
		nAdjustedLeft = objUpdateInfo.objParams.nAdjustedLeft;//이동한 가로스크롤바의 위치가 동적 컬럼을 변경하는 것이 아닌 left값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
		nAdjustColWidths = nFrozenColsWidth;
		QBOX._.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
			var nCol = objHSInfo.nLeftCol + idx,
			nColWidth = objQCell._getColWidth(nCol),
			nCellLeft = nAdjustColWidths - nAdjustedLeft,
			strColID = objQCell._getColID(nCol),
			keyOfCol = objQCell._getKeyOfCol(nCol),
			bFirstGroupCol = strColID === strFirstGroupColID ? true : false,
			bFocusCol = objQCell._isFocusCol(nCol),
			bSelectedCol = objQCell._isSelectedCol(nCol),
			bStyleCol = objQCell._isCellStyleCol(nCol),
			strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
			objColStyle = objQCell._getQCellCol(nCol).attr('style');
			
			QBOX._.each(arrNormalColCellDOMs, function(heCell){
				heCell.setAttribute('data-col', nCol);
				heCell.style.left = nCellLeft + 'px';
				if(nColWidth !== parseInt(heCell.style.width)){
					heCell.style.width = nColWidth + 'px';
				}
				
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nRow = parseInt(heCell.getAttribute('data-row')),
					bHeaderRow = nRow < nHeaderRows,
					bFocusCell = bFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
					bSelectedCell = bHeaderRow ? false : (bSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)) : false),
					bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
					strColStyleGroup = bHeaderRow ? 'header' : 'data',
					strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow];
					
					heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
					
					QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
					
					if(!QBOX._.isEmpty(objColStyle)){
						if(QBOX._.isObject(objColStyle[strColStyleGroup])){
							var keys = Object.keys(objColStyle[strColStyleGroup]);
							for(var k = 0; k < keys.length; k++){
								QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
							}
						}
						objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
					}
					
					if(bHeaderRow){
						heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText);
						
						if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
							
							if(objQCell.attr('useGroupUI')){
								QBOX.$(heCell).draggable({
									helper: objQCell._setGroupMakeHelper,
									revert: 'invalid'
								});
							}
							
							if(objQCell._getQCellCol(nCol).attr('move')){
								heCell.appendChild(objQCell._getColHeaderDragDropArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('search')){
								heCell.appendChild(objQCell._getColSearchArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('sort')){
								heCell.appendChild(objQCell._getDefaultSortArea(nCol));
							}
							
							if(objQCell._getQCellCol(nCol).attr('resize')){
								heCell.appendChild(objQCell._getColResizeArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('filter')){
								if(objQCell._getQCellCol(nCol).attr('colfilterarea') === null){
									objQCell._getQCellCol(nCol).attr('colfilterarea', objQCell.attr('filterarea').clone(true), 'jquery');
								}
								heCell.appendChild(objQCell._getFilterArea(nCol));
							}
							
							if(objQCell._getQCellCol(nCol).attr('editor')){
								heCell.appendChild(objQCell._getColStyleEditorArea());
							}
						}
					} else{
						cellData = arrCurrentData[nRow - nHeaderRows][keyOfCol] === undefined ? '' : arrCurrentData[nRow - nHeaderRows][keyOfCol]; //null이나 undefined인 경우 공백처리
						var strDataFormat = objQCell._showDataFormat(nCol, cellData),
						bIsGroupHeaderRow = false, bIsGroupFooterRow = false;
						
						if(objGroupState.grouped && bFirstGroupCol){
							var nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
							bIsGroupTreeUIRow = false;
							
							if(objGroupState.type === 'tree'){
								nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
							}
							
							if(nIdxOfGroupTreeUIRow > -1){
								bIsGroupTreeUIRow = true;
								objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
								
								bIsGroupHeaderRow = bIsGroupFooterRow = false;
							} else{
								nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
								
								if(nIdxOfGroupHeaderRow > -1){
									bIsGroupHeaderRow = true;
									objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
									
									bIsGroupFooterRow = false;
								} else{
									nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
									
									if(nIdxOfGroupFooterRow > -1){
										bIsGroupFooterRow = true;
										objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
										
										bIsGroupHeaderRow = false;
									}
								}
							}
							
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
								objQCell._setGroupTreeUICell(heCell, objNode, strDataFormat);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setGroupTreeDataCell(heCell, strDataFormat);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									if(objNode === null){
										nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
										
										if(nIdxOfGroupHeaderRow > -1){
											objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
										} else{
											nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
											
											if(nIdxOfGroupFooterRow > -1){
												objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
											}
										}
									}
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID+ ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
									heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
								}
								else {
									QBOX.util.textContent(heCell, strDataFormat);
								}
							}
						}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrCurrentData[nRow - nHeaderRows],keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if(objGroupState.grouped){
									if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1)
										bIsGroupHeaderRow = true;
									if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1)
										bIsGroupFooterRow = true;								
								}
								
								if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
									//QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID);
									strDataFormat = cellData;
								}
								
								QBOX.util.textContent(heCell, strDataFormat);
							}
						} else{
							if(objGroupState.grouped){
								if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1)
									bIsGroupHeaderRow = true;
								if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1)
									bIsGroupFooterRow = true;								
							}
							
							if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
								//QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID);
								strDataFormat = cellData;
							}
							
							if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
								heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
							}
							else {
								QBOX.util.textContent(heCell, strDataFormat);
							}
						}
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
				}
			});
			
			nAdjustColWidths += nColWidth;
		});
		
		this._updateMerge(); //머지 정보 설정
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._refreshNCs', e.message);
	}
};
*/
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._updateNRs = function(){//NRs -> NormalRows
	//_updateNRs()는 세로스크롤바 이동 시 동기화하기 위해서 사용된다.
	//세로스크롤바 동기화 시 갱신되는 셀들의 행 인덱스는 변경된다. 이전 셀의 동적 변경사항을 제거하는 로직이 필요하다.
	try{
		var css = QBOX.QCELL.def.css,
		objVSInfo = this.attr('vsinfo'), objQCell = this, objUpdateInfo = objVSInfo.objUpdateInfo,
		objGroupState = this.attr('groupstate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrNormalRowsCellDOMs = this._getCellGroupDOMs('row', 'normal'),
		arrMovedDynamicRowsCellDOMs = [],
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'), nRows = this.attr('rows'),
		nHeaderCols = this.attr('headercols'),
		nHighlightRepeat = this.attr('highlightrepeat'),
		nDataRowHeight = this.attr('rowheight').data,
		nViewPortOffsetHeight = this.attr('layoutsize').viewport.offsetHeight,
		nFrozenRowsHeight = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
		nFrozenBottomRowsHeight = this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1),
		nAdjustHeight, nAdjustedTop,
		bIsRowSelectMode = this.attr('selectmode').indexOf('row') > -1 ? true : false,
		cellData;
		
		this._clearMergeData(); // Merge 정보 클리어
		this._createDataMergeInfo();
		
		if(objUpdateInfo.bWholeUpdate){
			nAdjustedTop = objUpdateInfo.objParams.nAdjustedTop;//이동한 세로스크롤바의 위치가 동적 행을 변경하는 것이 아닌 top값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
			nAdjustHeight = nFrozenRowsHeight;
			QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, idx){
				var nBeforeRow = parseInt(arrNormalRowCellDOMs[0].getAttribute('data-row')),
				nRow = objVSInfo.nTopRow + idx,
				nRowHeight = objQCell._getRowHeight(nRow),
				nCellTop = nAdjustHeight - nAdjustedTop,
				nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
				bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
				objNode = null,
				arrRowData = arrCurrentData[nRow - nHeaderRows],
				bBeforeFocusRow = objQCell._isFocusRow(nBeforeRow), bFocusRow = objQCell._isFocusRow(nRow),
				bBeforeSelectedRow = objQCell._isSelectedRow(nBeforeRow), bSelectedRow = objQCell._isSelectedRow(nRow),
				bBeforeStyleRow = objQCell._isCellStyleRow(nBeforeRow), bStyleRow = objQCell._isCellStyleRow(nRow),
				bBeforeHighlightRepeatRow = nHighlightRepeat > 0 && ((nBeforeRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false,
				bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
				
				if(objGroupState.grouped){
					if(objGroupState.type === 'tree'){
						nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
					}
					
					if(nIdxOfGroupTreeUIRow > -1){
						bIsGroupTreeUIRow = true;
						objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
						
						bIsGroupHeaderRow = bIsGroupFooterRow = false;
					} else{
						nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
						
						if(nIdxOfGroupHeaderRow > -1){
							bIsGroupHeaderRow = true;
							objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
							
							bIsGroupFooterRow = false;
						} else{
							nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
							
							if(nIdxOfGroupFooterRow > -1){
								bIsGroupFooterRow = true;
								objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
								
								bIsGroupHeaderRow = false;
							}
						}
					}
				}
				
				QBOX._.each(arrNormalRowCellDOMs, function(heCell, idx2){
					var nCol = parseInt(heCell.getAttribute('data-col')),
					strColID = objQCell._getColID(nCol),
					keyOfCol = objQCell._getKeyOfCol(nCol),
					bBeforeFocusCell = bBeforeFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
					bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
					bBeforeSelectedCell = bBeforeSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nBeforeRow, nCol)): false,
					bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
					bBeforeStyleCell = bBeforeStyleRow ? objQCell._hasCellStyle(nBeforeRow, nCol) : false,
					bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
					strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
					strTextAlign = objQCell._getDataTextAlign(nCol);
					
					heCell.setAttribute('data-row', nRow);
					heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
					heCell.style.top = nCellTop + 'px';
					heCell.style.textAlign = strTextAlign;
					
					if(nRowHeight !== parseInt(heCell.style.height)){
						heCell.style.height = nRowHeight + 'px';
						//wordwrap heCell.style.lineHeight = (nRowHeight - 2) + 'px';
						//console.log("QBOX.QCELL.BasicQCELL.prototype._updateNRs");						
					}
					
					if(nCol < nHeaderCols){
						var objPaginationInfo = objQCell.attr('paginationinfo'),
						heCheckbox;
						
						if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows) : nRow - nHeaderRows + 1);
							} else if(arrRowHeaders[nCol] === 'checkbox') {
								heCell.innerHTML = '';
								heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
								heCell.appendChild(heCheckbox);
								
								heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
							} else if(arrRowHeaders[nCol] === 'state') {
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						} else {
							var nPageRow = nRow;
							// multiheader 일 때
							if(nHeaderRows > 1) {
								nPageRow = nRow - (nHeaderRows - 1);
							}
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
							} else if(arrRowHeaders[nCol] === 'checkbox') {
								heCell.innerHTML = '';
								heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
								heCell.appendChild(heCheckbox);
								
								heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
							} else if(arrRowHeaders[nCol] === 'state') {
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						}
					} else{
						cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
						var strDataFormat = objQCell._showDataFormat(nCol, cellData);
						
						QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
						
						if(objGroupState.grouped && strColID === strFirstGroupColID){
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
								objQCell._setGroupTreeUICell(heCell, objNode, strDataFormat);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setGroupTreeDataCell(heCell, strDataFormat);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
									heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
								}
								else {
									QBOX.util.textContent(heCell, strDataFormat);
								}
							}
						}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								QBOX.util.textContent(heCell, cellData);
							}
						} else{
							if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
								QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
								strDataFormat = cellData;
							}
							
							if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
								heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
							}
							else {
								QBOX.util.textContent(heCell, strDataFormat);
							}
						}
					}
					
					if(nCol >= nHeaderCols){
						if(bHighlightRepeatRow){
							if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT) === false){
								QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
							}
						} else{
							if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT)){
								QBOX.util.removeClass(heCell, css.CELL_HIGHLIGHTREPEAT);
							}
						}
					}
					
					if(bFocusCell && bBeforeFocusCell === false){//갱신 전에는 포커스 셀이 아니였지만 갱신 후에는 포커스 셀인 경우
						objQCell._addFocusStyleClass(heCell);
					} else if(bBeforeFocusCell && bFocusCell === false){//갱신 전에는 포커스 셀이였지만, 갱신 후에는 포커스 셀이 아닌 경우
						objQCell._removeFocusStyleClass(heCell);
					}
					
					if(bSelectedCell && bBeforeSelectedCell === false){//갱신 전에는 선택된 셀이 아니였지만 갱신 후에는 선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					} else if(bBeforeSelectedCell && bSelectedCell === false){//갱신 전에는 선택된 셀이였지만, 갱신 후에는 선택된 셀이 아닌 경우
						QBOX.util.removeClass(heCell, css.CELL_SELECT);
					}
					
					if(bBeforeStyleCell){//갱신 전에 셀 스타일이 적용되어 있던 경우
						objQCell._removeCellStyleCSS(heCell, objQCell._getCellStyle(nBeforeRow, nCol));
					}
					if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
				});
				
				nAdjustHeight += nRowHeight;
			});
		} else{
			var bWholePositionChanged = objUpdateInfo.objParams.bWholePositionChanged,
			nMovedCount = objUpdateInfo.objParams.nMovedCount,
			nCutRowsCount = objUpdateInfo.objParams.nCutRowsCount;
			
			if(nCutRowsCount > 0){
				var nStandardRow;
				
				if(nMovedCount > 0){//세로스크롤바가 아래로 이동했을 때
					arrMovedDynamicRowsCellDOMs = arrNormalRowsCellDOMs.splice(0, nCutRowsCount);
					nAdjustHeight = nFrozenRowsHeight;
					nStandardRow = objVSInfo.nTopRow;
				} else{
					arrMovedDynamicRowsCellDOMs = arrNormalRowsCellDOMs.splice(arrNormalRowsCellDOMs.length - nCutRowsCount, nCutRowsCount);
					nAdjustHeight = nFrozenRowsHeight + this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nTopRow + nCutRowsCount - 1);
					nStandardRow = objVSInfo.nTopRow + nCutRowsCount;
				}
				
				if(!bWholePositionChanged){
					//계속 화면에 표시해야 하는 행들의 셀은 갱신하지 않고 top값만 세팅
					QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, idx){
						var nRow, nRowHeight, nCellTop;
						
						nRow = nStandardRow + idx;
						nRowHeight = objQCell._getRowHeight(nRow);
						nCellTop = nAdjustHeight;
						
						QBOX._.each(arrNormalRowCellDOMs, function(heCell){
							heCell.style.top = nCellTop + 'px';
						});
						
						nAdjustHeight += nRowHeight;
					});
				}
				
				//화면에 표시하지 않아야 하는 행 셀들은 가장 아래에 표시되고 있는 행 아래로 이동시킨 후 갱신해야 한다.
				nStandardRow = nMovedCount > 0 ? objVSInfo.nBottomRow - nCutRowsCount + 1 : objVSInfo.nTopRow;
				nAdjustHeight = nMovedCount > 0 ? nFrozenRowsHeight + this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nBottomRow - nCutRowsCount) : nFrozenRowsHeight;
				QBOX._.each(arrMovedDynamicRowsCellDOMs, function(arrMovedDynamicRowCellDOMs, idx){
					var nBeforeRow = parseInt(arrMovedDynamicRowCellDOMs[0].getAttribute('data-row')),
					nRow = nStandardRow + idx,
					nRowHeight = objQCell._getRowHeight(nRow),
					nCellTop = nAdjustHeight,
					nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
					bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
					objNode = null,
					arrRowData = arrCurrentData[nRow - nHeaderRows],
					bBeforeFocusRow = objQCell._isFocusRow(nBeforeRow), bFocusRow = objQCell._isFocusRow(nRow),
					bBeforeSelectedRow = objQCell._isSelectedRow(nBeforeRow), bSelectedRow = objQCell._isSelectedRow(nRow),
					bBeforeStyleRow = objQCell._isCellStyleRow(nBeforeRow), bStyleRow = objQCell._isCellStyleRow(nRow),
					bBeforeHighlightRepeatRow = nHighlightRepeat > 0 && ((nBeforeRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false,
					bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
					
					if(objGroupState.grouped){
						if(objGroupState.type === 'tree'){
							nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
						}
						
						if(nIdxOfGroupTreeUIRow > -1){
							bIsGroupTreeUIRow = true;
							objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
							
							bIsGroupHeaderRow = bIsGroupFooterRow = false;
						} else{
							nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
							
							if(nIdxOfGroupHeaderRow > -1){
								bIsGroupHeaderRow = true;
								objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
								
								bIsGroupFooterRow = false;
							} else{
								nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
								
								if(nIdxOfGroupFooterRow > -1){
									bIsGroupFooterRow = true;
									objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
									
									bIsGroupHeaderRow = false;
								}
							}
						}
					}
					
					QBOX._.each(arrMovedDynamicRowCellDOMs, function(heCell){
						var nCol = parseInt(heCell.getAttribute('data-col')),
						strColID = objQCell._getColID(nCol),
						keyOfCol = objQCell._getKeyOfCol(nCol),
						bBeforeFocusCell = bBeforeFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
						bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
						bBeforeSelectedCell = bBeforeSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nBeforeRow, nCol)): false,
						bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
						bBeforeStyleCell = bBeforeStyleRow ? objQCell._hasCellStyle(nBeforeRow, nCol) : false,
						bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
						strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
						strTextAlign = objQCell._getDataTextAlign(nCol);
						
						heCell.setAttribute('data-row', nRow);
						heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
						heCell.style.textAlign = strTextAlign;
						
						if(nRowHeight !== parseInt(heCell.style.height)){
							heCell.style.height = nRowHeight + 'px';
							//wordwrap heCell.style.lineHeight = (nRowHeight - 2) + 'px';
							//console.log("QBOX.QCELL.BasicQCELL.prototype._updateNRs");							
						}
						
						if(!bWholePositionChanged){
							heCell.style.top = nCellTop + 'px';
						}
						
						if(nCol < nHeaderCols){
							var objPaginationInfo = objQCell.attr('paginationinfo'),
							heCheckbox;
							
							if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows) : nRow - nHeaderRows + 1);
								} else if(arrRowHeaders[nCol] === 'checkbox') {
									heCell.innerHTML = '';
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
									heCell.appendChild(heCheckbox);
									
									heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
								} else if(arrRowHeaders[nCol] === 'state') {
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
							} else {
								var nPageRow = nRow;
								// multiheader 일 때
								if(nHeaderRows > 1) {
									nPageRow = nRow - (nHeaderRows - 1);
								}
								
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
								} else if(arrRowHeaders[nCol] === 'checkbox') {
									heCell.innerHTML = '';
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol);
									heCell.appendChild(heCheckbox);
									
									heCell.className += ' ' + css.ROWHEADER_CELL_CHECKBOX;
								}  else if(arrRowHeaders[nCol] === 'state') {
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
							}
						} else{
							cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
							var strDataFormat = objQCell._showDataFormat(nCol, cellData);
							
							QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
							
							if(objGroupState.grouped && strColID === strFirstGroupColID){
								if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
									//tree 아이콘 표시
									//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
									objQCell._setGroupTreeUICell(heCell, objNode, strDataFormat);
								} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
									//탭처리
									objQCell._setGroupTreeDataCell(heCell, strDataFormat);
								} else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
										strDataFormat = cellData;
									}
									
									if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
										heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
									}
									else {
										QBOX.util.textContent(heCell, strDataFormat);
									}
								}
							}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
									QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
								objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
								if(objNode !== null){
									objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
								}else{
									if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
										strDataFormat = cellData;
									}
									
									QBOX.util.textContent(heCell, cellData);
								}
							} else{
								if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								QBOX.util.textContent(heCell, strDataFormat);
							}
						}
						
						if(nCol >= nHeaderCols){
							if(bHighlightRepeatRow){
								if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT) === false){
									QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
								}
							} else{
								if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT)){
									QBOX.util.removeClass(heCell, css.CELL_HIGHLIGHTREPEAT);
								}
							}
						}
						
						if(bFocusCell && bBeforeFocusCell === false){//갱신 전에는 포커스 셀이 아니였지만 갱신 후에는 포커스 셀인 경우
							objQCell._addFocusStyleClass(heCell);
						} else if(bBeforeFocusCell && bFocusCell === false){//갱신 전에는 포커스 셀이였지만, 갱신 후에는 포커스 셀이 아닌 경우
							objQCell._removeFocusStyleClass(heCell);
						}
						
						if(bSelectedCell && bBeforeSelectedCell === false){//갱신 전에는 선택된 셀이 아니였지만 갱신 후에는 선택된 셀인 경우
							QBOX.util.addClass(heCell, css.CELL_SELECT);
						} else if(bBeforeSelectedCell && bSelectedCell === false){//갱신 전에는 선택된 셀이였지만, 갱신 후에는 선택된 셀이 아닌 경우
							QBOX.util.removeClass(heCell, css.CELL_SELECT);
						}
						
						if(bBeforeStyleCell){//갱신 전에 셀 스타일이 적용되어 있던 경우
							objQCell._removeCellStyleCSS(heCell, objQCell._getCellStyle(nBeforeRow, nCol));
						}
						if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
							objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
						}
					});
					nAdjustHeight += nRowHeight;
				});
			}
			
			if(bWholePositionChanged){
				//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 셀의 top을 보정해야 하는 경우다.
				if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
					arrNormalRowsCellDOMs = arrNormalRowsCellDOMs.concat(arrMovedDynamicRowsCellDOMs);
					
					if(objVSInfo.nLastPos === objVSInfo.nPos){//viewport의 하단 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우(FrozenBottomRows가 있는 경우, viewport의 끝이 아닌 FrozenBottomRows의 시작점과 맞춰야 한다.)
						nAdjustedTop = nFrozenRowsHeight + this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nEndRow) - (nViewPortOffsetHeight - nFrozenBottomRowsHeight);
					} else{//행의 height만큼 top을 이동시켜야 하는 경우
						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objVSInfo.nLastPos - objVSInfo.nAdjustRows
						nAdjustedTop = this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nTopRow + (objVSInfo.nPos - (objVSInfo.nLastPos - objVSInfo.nAdjustRows)) - 1);
					}
					
				} else{//가로 스크롤바가 왼쪽으로 이동했을 때
					arrNormalRowsCellDOMs = arrMovedDynamicRowsCellDOMs.concat(arrNormalRowsCellDOMs);
					nAdjustedTop = this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nTopRow + (objVSInfo.nAdjustRows - (objVSInfo.nLastPos - objVSInfo.nPos)) - 1);
				}
				
				nAdjustHeight = nFrozenRowsHeight;
				QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, idx){
					var nRow, nRowHeight, nCellTop;
					
					nRow = objVSInfo.nTopRow + idx;
					nRowHeight = objQCell._getRowHeight(nRow);
					nCellTop = nAdjustHeight - nAdjustedTop;
					
					QBOX._.each(arrNormalRowCellDOMs, function(heCell){
						heCell.style.top = nCellTop + 'px';
					});
					
					nAdjustHeight += nRowHeight;
				});
				
				this._setCellGroupDOMs('row', 'normal', arrNormalRowsCellDOMs);
			} else{
				if(nMovedCount > 0){
					this._setCellGroupDOMs('row', 'normal', arrNormalRowsCellDOMs.concat(arrMovedDynamicRowsCellDOMs));
				} else{
					this._setCellGroupDOMs('row', 'normal', arrMovedDynamicRowsCellDOMs.concat(arrNormalRowsCellDOMs));
				}
			}
			
			this._syncCellMatrix('row');				//row의 cellMatrix 기준으로 col의 cellMatrix 동기화
		}
		this._updateMergeData(); //머지 정보 설정
		arrMovedDynamicRowsCellDOMs = null;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._updateNRs', e.message);
	}
};
*/
/* jklee diet
QBOX.QCELL.BasicQCELL.prototype._updateNCs = function(){//NCs -> NormalCols
	//_updateNCs()는 가로스크롤바 이동 시 동기화하기 위해서 사용된다.
	//가로스크롤바 동기화 시 갱신되는 셀들의 열 인덱스는 변경된다. 이전 셀의 동적 변경사항을 제거하는 로직이 필요하다.
	try{
		var css = QBOX.QCELL.def.css,
		objHSInfo = this.attr('hsinfo'), objQCell = this, objUpdateInfo = objHSInfo.objUpdateInfo,
		objGroupState = this.attr('groupstate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrHeaderText = this.attr('headertext'),
		arrNormalColsCellDOMs = this._getCellGroupDOMs('col', 'normal'),
		arrMovedDynamicColsCellDOMs = [],
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth,
		nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
		nAdjustColWidths, nAdjustedLeft,
		bIsColSelectMode = this.attr('selectmode').indexOf('col') > -1 ? true : false,
		cellData,objNode = null;
		
		this._clearMerge(); // Merge 정보 클리어
		this._createMergeInfo();
		
		if(objUpdateInfo.bWholeUpdate){
			nAdjustedLeft = objUpdateInfo.objParams.nAdjustedLeft;//이동한 가로스크롤바의 위치가 동적 컬럼을 변경하는 것이 아닌 left값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
			nAdjustColWidths = nFrozenColsWidth;
			QBOX._.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
				var nBeforeCol = parseInt(arrNormalColCellDOMs[0].getAttribute('data-col')),
				nCol = objHSInfo.nLeftCol + idx,
				nColWidth = objQCell._getColWidth(nCol),
				nCellLeft = nAdjustColWidths - nAdjustedLeft,
				strColID = objQCell._getColID(nCol),
				keyOfCol = objQCell._getKeyOfCol(nCol),
				bFirstGroupCol = strColID === strFirstGroupColID ? true : false,
				bBeforeFocusCol = objQCell._isFocusCol(nBeforeCol), bFocusCol = objQCell._isFocusCol(nCol),
				bBeforeSelectedCol = objQCell._isSelectedCol(nBeforeCol), bSelectedCol = objQCell._isSelectedCol(nCol),
				bBeforeStyleCol = objQCell._isCellStyleCol(nBeforeCol), bStyleCol = objQCell._isCellStyleCol(nCol),
				strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
				objColStyle = objQCell._getQCellCol(nCol).attr('style'),
				strTextAlign = objQCell._getDataTextAlign(nCol);
				
				QBOX._.each(arrNormalColCellDOMs, function(heCell){
					heCell.setAttribute('data-col', nCol);
					heCell.style.left = nCellLeft + 'px';
					heCell.style.textAlign = strTextAlign;
					if(nColWidth !== parseInt(heCell.style.width)){
						heCell.style.width = nColWidth + 'px';
					}
					
					if(heCell.getAttribute('data-footer') !== 'true'){
						var nRow = parseInt(heCell.getAttribute('data-row')),
						bHeaderRow = nRow < nHeaderRows,
						bBeforeFocusCell = bBeforeFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
						bFocusCell = bFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
						bBeforeSelectedCell = bHeaderRow ? false : (bBeforeSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nBeforeCol)) : false),
						bSelectedCell = bHeaderRow ? false : (bSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)) : false),
						bBeforeStyleCell = bBeforeStyleCol ? objQCell._hasCellStyle(nRow, nBeforeCol) : false,
						bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
						strColStyleGroup = bHeaderRow ? 'header' : 'data',
						strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow];
						
						heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
						
						QBOX.util.removeClass(heCell, objQCell._getColStyleClassName(nBeforeCol, strColStyleGroup));
						QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
						
						if(!QBOX._.isEmpty(objColStyle)){
							if(QBOX._.isObject(objColStyle[strColStyleGroup])){
								var keys = Object.keys(objColStyle[strColStyleGroup]);
								for(var k = 0; k < keys.length; k++){
									QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
								}
							}
							objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
						}
						
						if(bHeaderRow){
							heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText);
							
							if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
								
								if(objQCell.attr('useGroupUI')){
									QBOX.$(heCell).draggable({
										helper: objQCell._setGroupMakeHelper,
										revert: 'invalid'
									});
								}
								
								if(objQCell._getQCellCol(nCol).attr('move')){
									heCell.appendChild(objQCell._getColHeaderDragDropArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('search')){
									heCell.appendChild(objQCell._getColSearchArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('sort')){
									heCell.appendChild(objQCell._getDefaultSortArea(nCol));
								}
								
								if(objQCell._getQCellCol(nCol).attr('resize')){
									heCell.appendChild(objQCell._getColResizeArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('filter')){									
									heCell.appendChild(objQCell._getFilterArea(nCol));
								}
								
								if(objQCell._getQCellCol(nCol).attr('editor')){
									heCell.appendChild(objQCell._getColStyleEditorArea());
								}
							}
						} else{
							cellData = arrCurrentData[nRow - nHeaderRows][keyOfCol] === undefined ? '' : arrCurrentData[nRow - nHeaderRows][keyOfCol]; //null이나 undefined인 경우 공백처리
							var strDataFormat = objQCell._showDataFormat(nCol, cellData),
							bIsGroupHeaderRow = false, bIsGroupFooterRow = false;
							
							QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
							if(objGroupState.grouped){															
								if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1){
									bIsGroupHeaderRow = true;																		
									bIsGroupFooterRow = false;
								} else{									
									if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1){
										bIsGroupFooterRow = true;
										bIsGroupHeaderRow = false;
									}
								}
							} 
							if(objGroupState.grouped && bFirstGroupCol){
								var nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
								bIsGroupTreeUIRow = false;
											
								if(objGroupState.type === 'tree'){
									nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
								}
								
								if(nIdxOfGroupTreeUIRow > -1){
									bIsGroupTreeUIRow = true;
									objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
									
									bIsGroupHeaderRow = bIsGroupFooterRow = false;
								} else{
									nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
									
									if(nIdxOfGroupHeaderRow > -1){
										bIsGroupHeaderRow = true;
										objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
										
										bIsGroupFooterRow = false;
									} else{
										nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
										
										if(nIdxOfGroupFooterRow > -1){
											bIsGroupFooterRow = true;
											objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
											
											bIsGroupHeaderRow = false;
										}
									}
								}
								
								if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
									//tree 아이콘 표시
									//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
									objQCell._setGroupTreeUICell(heCell, objNode, strDataFormat);
								} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
									//탭처리
									objQCell._setGroupTreeDataCell(heCell, strDataFormat);
								} else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
										strDataFormat = cellData;
									}
									
									if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
										heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
									}
									else {
										QBOX.util.textContent(heCell, strDataFormat);
									}
								}
							}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
									QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
								objNode = objQCell._getGroupNode(arrCurrentData[nRow - nHeaderRows],keyOfCol);
								if(objNode !== null){
									objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
								}else{
									if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
										strDataFormat = cellData;
									}
									
									QBOX.util.textContent(heCell, cellData);
								}
							} else{
								if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
									strDataFormat = cellData;
								}
								
								if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
									heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
								}
								else {
									QBOX.util.textContent(heCell, strDataFormat);
								}
							}
						}
						
						if(bFocusCell && bBeforeFocusCell === false){//갱신 전에는 포커스 셀이 아니였지만 갱신 후에는 포커스 셀인 경우
							objQCell._addFocusStyleClass(heCell);
						} else if(bBeforeFocusCell && bFocusCell === false){//갱신 전에는 포커스 셀이였지만, 갱신 후에는 포커스 셀이 아닌 경우
							objQCell._removeFocusStyleClass(heCell);
						}
						
						if(bSelectedCell && bBeforeSelectedCell === false){//갱신 전에는 선택된 셀이 아니였지만 갱신 후에는 선택된 셀인 경우
							QBOX.util.addClass(heCell, css.CELL_SELECT);
						} else if(bBeforeSelectedCell && bSelectedCell === false){//갱신 전에는 선택된 셀이였지만, 갱신 후에는 선택된 셀이 아닌 경우
							QBOX.util.removeClass(heCell, css.CELL_SELECT);
						}
						
						if(bBeforeStyleCell){//갱신 전에 셀 스타일이 적용되어 있던 경우
							objQCell._removeCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nBeforeCol));
						}
						if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
							objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
						}
					}
				});
				
				nAdjustColWidths += nColWidth;
			});
		} else{
			var bWholePositionChanged = objUpdateInfo.objParams.bWholePositionChanged,
			nMovedCount = objUpdateInfo.objParams.nMovedCount,
			nCutColsCount = objUpdateInfo.objParams.nCutColsCount;
			
			if(nCutColsCount > 0){
				var nStandardCol;
				
				if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
					arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(0, nCutColsCount);
					//nMovedColWidths = -(this._getSumOfColWidth(objHSInfo.nLeftCol - nCutColsCount, objHSInfo.nLeftCol - 1));
					//nAdjustColWidths = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nRightCol - nCutColsCount);
					nAdjustColWidths = nFrozenColsWidth;
					nStandardCol = objHSInfo.nLeftCol;
				} else{
					arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(arrNormalColsCellDOMs.length - nCutColsCount, nCutColsCount);
					//nMovedColWidths = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nCutColsCount - 1);
					//nAdjustColWidths = nFrozenColsWidth;
					nAdjustColWidths = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nCutColsCount - 1);
					nStandardCol = objHSInfo.nLeftCol + nCutColsCount;
				}
				
				if(!bWholePositionChanged){
					//계속 화면에 표시해야 하는 컬럼들의  셀은 갱신하지 않고 left값만 세팅
					QBOX._.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
						var nCol, nColWidth, nCellLeft;
						
						nCol = nStandardCol + idx;
						nColWidth = objQCell._getColWidth(nCol);
						nCellLeft = nAdjustColWidths;
						
						QBOX._.each(arrNormalColCellDOMs, function(heCell){
							heCell.style.left = nCellLeft + 'px';
						});
						
						nAdjustColWidths += nColWidth;
					});
				}
				
				//화면에 표시하지 않아야 하는 컬럼 셀들은 가장 우측에 표시되고 있는 컬럼 옆으로 이동시킨 후 갱신해야 한다.
				nStandardCol = nMovedCount > 0 ? objHSInfo.nRightCol - nCutColsCount + 1 : objHSInfo.nLeftCol;
				nAdjustColWidths = nMovedCount > 0 ? nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nRightCol - nCutColsCount) : nFrozenColsWidth;
				QBOX._.each(arrMovedDynamicColsCellDOMs, function(arrMovedColCellDOMs, idx){
					var nBeforeCol = parseInt(arrMovedColCellDOMs[0].getAttribute('data-col')),
					nCol = nStandardCol + idx,
					nColWidth = objQCell._getColWidth(nCol),
					nCellLeft = nAdjustColWidths,
					strColID = objQCell._getColID(nCol),
					keyOfCol = objQCell._getKeyOfCol(nCol),
					bFirstGroupCol = strColID === strFirstGroupColID ? true : false,
					bBeforeFocusCol = objQCell._isFocusCol(nBeforeCol), bFocusCol = objQCell._isFocusCol(nCol),
					bBeforeSelectedCol = objQCell._isSelectedCol(nBeforeCol), bSelectedCol = objQCell._isSelectedCol(nCol),
					bBeforeStyleCol = objQCell._isCellStyleCol(nBeforeCol), bStyleCol = objQCell._isCellStyleCol(nCol),
					strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
					objColStyle = objQCell._getQCellCol(nCol).attr('style'),
					strTextAlign = objQCell._getDataTextAlign(nCol);
					
					QBOX._.each(arrMovedColCellDOMs, function(heCell){
						heCell.setAttribute('data-col', nCol);
						
						if(nColWidth !== parseInt(heCell.style.width)){
							heCell.style.width = nColWidth + 'px';
						}
						
						if(!bWholePositionChanged){
							heCell.style.left = nCellLeft + 'px';
						}
						heCell.style.textAlign = strTextAlign;
						
						if(heCell.getAttribute('data-footer') !== 'true'){
							var nRow = parseInt(heCell.getAttribute('data-row')),
							bHeaderRow = nRow < nHeaderRows,
							bBeforeFocusCell = bBeforeFocusCol ? (objQCell._isFocusRow(nRow) ? true : false) : false,
							bFocusCell = bFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
							bBeforeSelectedCell = bHeaderRow ? false : (bBeforeSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nBeforeCol)) : false),
							bSelectedCell = bHeaderRow ? false : (bSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)) : false),
							bBeforeStyleCell = bBeforeStyleCol ? objQCell._hasCellStyle(nRow, nBeforeCol) : false,
							bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
							strColStyleGroup = bHeaderRow ? 'header' : 'data',
							strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow];
							
							heCell.setAttribute('id', 'cell_' + nRow + '_' + nCol);
							
							QBOX.util.removeClass(heCell, objQCell._getColStyleClassName(nBeforeCol, strColStyleGroup));
							QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
							
							if(!QBOX._.isEmpty(objColStyle)){
								if(QBOX._.isObject(objColStyle[strColStyleGroup])){
									var keys = Object.keys(objColStyle[strColStyleGroup]);
									for(var k = 0; k < keys.length; k++){
										QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
									}
								}
								objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
							}
							
							if(bHeaderRow){
								heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText);
								
								if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
									
									if(objQCell.attr('useGroupUI')){
										QBOX.$(heCell).draggable({
											helper: objQCell._setGroupMakeHelper,
											revert: 'invalid'
										});
									}
									
									if(objQCell._getQCellCol(nCol).attr('move')){
										heCell.appendChild(objQCell._getColHeaderDragDropArea());
									}
									
									if(objQCell._getQCellCol(nCol).attr('search')){
										heCell.appendChild(objQCell._getColSearchArea());
									}
									
									if(objQCell._getQCellCol(nCol).attr('sort')){										
										heCell.appendChild(objQCell._getDefaultSortArea(nCol));
									}
									
									if(objQCell._getQCellCol(nCol).attr('resize')){
										heCell.appendChild(objQCell._getColResizeArea());
									}
									
									if(objQCell._getQCellCol(nCol).attr('filter')){										
										heCell.appendChild(objQCell._getFilterArea(nCol));
									}
									
									if(objQCell._getQCellCol(nCol).attr('editor')){										
										heCell.appendChild(objQCell._getColStyleEditorArea());
									}
								}
							} else{
								cellData = arrCurrentData[nRow - nHeaderRows][keyOfCol] === undefined ? '' : arrCurrentData[nRow - nHeaderRows][keyOfCol]; //null이나 undefined인 경우 공백처리
								var strDataFormat = objQCell._showDataFormat(nCol, cellData),
								bIsGroupHeaderRow = false, bIsGroupFooterRow = false;
								
								QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
								if(objGroupState.grouped){															
									if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1){
										bIsGroupHeaderRow = true;																		
										bIsGroupFooterRow = false;
									} else{									
										if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1){
											bIsGroupFooterRow = true;
											bIsGroupHeaderRow = false;
										}
									}
								} 
								if(objGroupState.grouped && bFirstGroupCol){
									var nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
									bIsGroupTreeUIRow = false;
												
									if(objGroupState.type === 'tree'){
										nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
									}
									
									if(nIdxOfGroupTreeUIRow > -1){
										bIsGroupTreeUIRow = true;
										objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
										
										bIsGroupHeaderRow = bIsGroupFooterRow = false;
									} else{
										nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
										
										if(nIdxOfGroupHeaderRow > -1){
											bIsGroupHeaderRow = true;
											objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
											
											bIsGroupFooterRow = false;
										} else{
											nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
											
											if(nIdxOfGroupFooterRow > -1){
												bIsGroupFooterRow = true;
												objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
												
												bIsGroupHeaderRow = false;
											}
										}
									}
									
									if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
										//tree 아이콘 표시
										//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
										objQCell._setGroupTreeUICell(heCell, objNode, strDataFormat);
									} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
										//탭처리
										objQCell._setGroupTreeDataCell(heCell, strDataFormat);
									} else{
										if(bIsGroupHeaderRow || bIsGroupFooterRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
											strDataFormat = cellData;
										}
										
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
									}
								}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
										QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
									objNode = objQCell._getGroupNode(arrCurrentData[nRow - nHeaderRows],keyOfCol);
									if(objNode !== null){
										objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
									}else{
										if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
											strDataFormat = cellData;
										}
										
										QBOX.util.textContent(heCell, cellData);
									}
								} else{
									if((bIsGroupHeaderRow || bIsGroupFooterRow) && parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objNode.level);
										strDataFormat = cellData;
									}
									
									if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
										heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
									}
									else {
										QBOX.util.textContent(heCell, strDataFormat);
									}
								}
							}
							
							if(bFocusCell && bBeforeFocusCell === false){//갱신 전에는 포커스 셀이 아니였지만 갱신 후에는 포커스 셀인 경우
								objQCell._addFocusStyleClass(heCell);
							} else if(bBeforeFocusCell && bFocusCell === false){//갱신 전에는 포커스 셀이였지만, 갱신 후에는 포커스 셀이 아닌 경우
								objQCell._removeFocusStyleClass(heCell);
							}
							
							if(bSelectedCell && bBeforeSelectedCell === false){//갱신 전에는 선택된 셀이 아니였지만 갱신 후에는 선택된 셀인 경우
								QBOX.util.addClass(heCell, css.CELL_SELECT);
							} else if(bBeforeSelectedCell && bSelectedCell === false){//갱신 전에는 선택된 셀이였지만, 갱신 후에는 선택된 셀이 아닌 경우
								QBOX.util.removeClass(heCell, css.CELL_SELECT);
							}
							
							if(bBeforeStyleCell){//갱신 전에 셀 스타일이 적용되어 있던 경우
								objQCell._removeCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nBeforeCol));
							}
							if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
								objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
							}
						}
					});
					
					nAdjustColWidths += nColWidth;
				});
			}
			
			if(bWholePositionChanged){
				//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 셀의 left를 보정해야 하는 경우다.
				if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
					arrNormalColsCellDOMs = arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs);
					
					if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
						nAdjustedLeft = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
					} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
						nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
					}
				} else{//가로 스크롤바가 왼쪽으로 이동했을 때
					arrNormalColsCellDOMs = arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs);
					nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos)) - 1);
				}
				
				nAdjustColWidths = nFrozenColsWidth;
				QBOX._.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
					var nCol, nColWidth, nCellLeft;
					
					nCol = objHSInfo.nLeftCol + idx;
					nColWidth = objQCell._getColWidth(nCol);
					nCellLeft = nAdjustColWidths - nAdjustedLeft;
					
					QBOX._.each(arrNormalColCellDOMs, function(heCell){
						heCell.style.left = nCellLeft + 'px';
					});
					
					nAdjustColWidths += nColWidth;
				});
				
				this._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs);
			} else{
				if(nMovedCount > 0){
					this._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs));
				} else{
					this._setCellGroupDOMs('col', 'normal', arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs));
				}
			}
			
			this._syncCellMatrix('col');				//col의 cellMatrix 기준으로 row의 cellMatrix 동기화
		}
		
		this._updateMerge(); //머지 정보 설정
		
		arrMovedDynamicColsCellDOMs = null;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._updateNCs', e.message);
	}
};
*/
QBOX.QCELL.BasicQCELL.prototype._setVSRange = function(){
	try{
		var objVSInfo = this.attr('vsinfo'),
		nHeaderRows = this.attr('headerrows'), nRows = this.attr('rows');
		
		if(nRows - nHeaderRows > 0){
			//nStartRow와 nEndRow는 frozenRows와 frozenBottomRows가 결정된 후 세팅해야 한다.
			objVSInfo.nStartRow = nHeaderRows + this.attr('frozenrows');
			objVSInfo.nEndRow = nRows - this.attr('frozenbottomrows') - 1;
		} else{
			objVSInfo.nStartRow = objVSInfo.nEndRow = -1;
		}
		
		return true;
	}  catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._setVSRange', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._initVSInfo = function(){
	var objVSInfo = this.attr('vsinfo');
	
	objVSInfo.bVScroll = false;	//VScrollbar 존재여부
	
	objVSInfo.nStartRow =		//headerrows, frozenrows를 제외한 첫번째 normalRow의 인덱스
	objVSInfo.nEndRow =			//frozenbottomrows를 제외한 마지막 normalRow의 인덱스
	objVSInfo.nTopRow =			//동적컬럼의 첫번째 normalRow의 인덱스(현재 스크롤 위치에서  viewport 영역에 표시 할 첫 번째 일반행의 index)
	objVSInfo.nBottomRow = -1;	//동적컬럼의 마지막 normalRow의 인덱스(현재 스크롤 위치에서  viewport 영역에 표시 할 마지막 일반행의 index)
	
	objVSInfo.nAdjustRows =		//행 셀 div들을  뜯어내지 않고 전체 top을 보정할 때 사용하는 보정 행의 수
	objVSInfo.nDynamicRows =	//viewport 영역을 구성하는 동적 행의 수
	objVSInfo.nLength =			//스크롤바의 길이
	objVSInfo.nLastPos =		//스크롤바의 마지막 위치 / nLengthPerRows -> 세로스크롤바의 마지막 위치가 nLengthPerRows값 단위를 기준으로 몇 번 이동할 수 있는지
	objVSInfo.nPos =			//스크롤바 위치 / nLengthPerRows -> 세로스크롤바의 현재 위치가 nLengthPerRows값 단위를 기준으로 몇 번 이동했는지
	objVSInfo.nTop =			//현재 스크롤바의 위치
	objVSInfo.nBeforeTop =		//스크롤바가 이동하기 전의 스크롤바의 위치
	objVSInfo.nLengthPerRow = 0;//한 행 당 평균 이동 거리(모든 행은 height에 상관없이 동일한 스크롤 이동거리를 갖는다.)
	
	objVSInfo.objUpdateInfo = {	//셀 갱신 시 필요한 정보를 저장
		bWholeUpdate	: false,
		//strDirection	: '',
		objParams		: {
			/*
				bWholePositionChanged	: false,
				nCutRowsCount			: 0,//데이터와 위치를 갱신해야 하는 동적 행의 수(ex> 세로스크롤바가 아래쪽으로 3칸 이동 시 3개의 일반 행을 표시하던 div들을 새로 나타해야 할 새로운 3개의 행 위치로 이동시키고 데이터를 갱신해야 한다.)
				nMovedCount				: 0,
				nAdjustedTop			: 0//이동한 세로스크롤바의 위치가 동적 행을 변경하는 것이 아닌 top값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
			 */
		}
	};
};

QBOX.QCELL.BasicQCELL.prototype._updateVSInfo = function(){
	try{
		var objVSInfo = this.attr('vsinfo'), objUpdateInfo = objVSInfo.objUpdateInfo,
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'),
		nRows = this.attr('rows');
		
		objUpdateInfo.objParams = {};
		
		if(objVSInfo.bVScroll){
			var nAdjustedTop = 0;//세로스크롤바의 위치가 동적 행을 변경하는 것이 아닌 top값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
			
			objUpdateInfo.bWholeUpdate = true;
			
			objVSInfo.nTopRow = objVSInfo.nStartRow + objVSInfo.nPos;
			if(objVSInfo.nDynamicRows > nCurrentDataCount){
				objVSInfo.nBottomRow = objVSInfo.nEndRow;
			} else{
				var nFrozenRows = this.attr('frozenrows'),
				nFrozenBottomRows = this.attr('frozenbottomrows');
				
				//"nBottomRow" = nTopRow + "스크롤링 발생 시 동적으로 변경되는 dynamicRows의 수", nDynamicRows는 frozenRows와 frozenBottomRows까지 합한 값이다.
				objVSInfo.nBottomRow = objVSInfo.nTopRow + (objVSInfo.nDynamicRows - nFrozenRows - nFrozenBottomRows) - 1;
				
				if(objVSInfo.nBottomRow > objVSInfo.nEndRow){//스크롤바의 위치가 보정 범위 내에 있을 때
					objVSInfo.nTopRow -= objVSInfo.nBottomRow - objVSInfo.nEndRow; 
					objVSInfo.nBottomRow = objVSInfo.nEndRow;
					
					if(objVSInfo.nLastPos === objVSInfo.nPos){//viewport의 하단 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
						//console.log('viewport의 하단 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우');
						var nViewPortOffsetHeight = this.attr('layoutsize').viewport.offsetHeight,
						nFrozenRowsHeight = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
						nFrozenBottomRowsHeight = this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1);
						
						nAdjustedTop = nFrozenRowsHeight + this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nEndRow) - (nViewPortOffsetHeight - nFrozenBottomRowsHeight);
					} else{//행의 height만큼 top을 이동시켜야 하는 경우
						//console.log('행의 height만큼 top을 이동시켜야 하는 경우');
						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objVSInfo.nLastPos - objVSInfo.nAdjustRows
						nAdjustedTop = this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nTopRow + (objVSInfo.nPos - (objVSInfo.nLastPos - objVSInfo.nAdjustRows)) - 1);
					}
				}
			}
			
			objUpdateInfo.objParams.nAdjustedTop = nAdjustedTop;
			
			if(this.attr('useall') || this.attr('usetreeall')){
				if(objVSInfo.nTopRow > objVSInfo.nStartRow){
					QBOX.$('#'+this.getID()+'_vsbp').prop('disabled' , false);
				}else{
					QBOX.$('#'+this.getID()+'_vsbp').prop('disabled' , true);
				}
				if(objVSInfo.nBottomRow === objVSInfo.nEndRow){
					QBOX.$('#'+this.getID()+'_vsbn').prop('disabled' , true);
				}else{
					QBOX.$('#'+this.getID()+'_vsbn').prop('disabled' , false);
				}
				
			}
		} else{
			objUpdateInfo.bWholeUpdate = false;
			
			if(nCurrentDataCount > 0){
				objVSInfo.nTopRow = nHeaderRows;
				objVSInfo.nBottomRow = nRows - 1;
			} else{
				objVSInfo.nTopRow = objVSInfo.nBottomRow = -1;
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._updateVSInfo', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype.onVScroll = function(nScrollTop){
	var objVSInfo = this.attr('vsinfo'), objQCell = this,THAT = this,
	nMovedCount = 0;
	
	if(Math.abs(objVSInfo.nTop - nScrollTop) >= objVSInfo.nLengthPerRow){//한 행 당 평균 이동 거리(nLengthPerRow)이상으로 세로스크롤바가 움직였을 때만 QCELL의 스크롤바가 이동했다고 판단한다.
		nMovedCount = parseInt(-(nScrollTop - objVSInfo.nTop) / objVSInfo.nLengthPerRow);//nMovedCount:스크롤바가 이동한 카운트
		
		objVSInfo.nBeforeTop = objVSInfo.nTop;
		objVSInfo.nTop = objVSInfo.nTop - (nMovedCount * objVSInfo.nLengthPerRow);//세로스크롤바가 nLengthPerRow값 단위로 딱딱 맞아떨어지게 이동하면 좋겠지만 그렇지 않기 때문에 nScrollTop값으로 설정하면 안되고, 이동한 행 수 만큼 nLengthPerRow값을 곱한 값을 더 해 줘야 한다.
		objVSInfo.nPos = -(objVSInfo.nTop / objVSInfo.nLengthPerRow);
		this._adjustScrollPos();
		this._syncVSInfo();
		this._updateNRs();
		
		if(this.attr('useall') || this.attr('usetreeall')){
			if(objVSInfo.nTopRow > objVSInfo.nStartRow){
				QBOX.$('#'+this.getID()+'_vsbp').prop('disabled' , false);
			}else{
				QBOX.$('#'+this.getID()+'_vsbp').prop('disabled' , true);
			}
			if(objVSInfo.nBottomRow === objVSInfo.nEndRow){
				QBOX.$('#'+this.getID()+'_vsbn').prop('disabled' , true);
			}else{
				QBOX.$('#'+this.getID()+'_vsbn').prop('disabled' , false);
			}
			if(this.attr('isFocussing') !== true){
				setTimeout(function(){
					var heContainer = document.getElementById('container-'+THAT.getID());
					if(heContainer !== null && heContainer!==undefined)
						heContainer.focus();
				},100);
			}
		}		
	}
};

QBOX.QCELL.BasicQCELL.prototype._syncVSInfo = function(){
	var objVSInfo = this.attr('vsinfo'), objUpdateInfo = objVSInfo.objUpdateInfo,
	nMovedCount = (objVSInfo.nBeforeTop - objVSInfo.nTop) / objVSInfo.nLengthPerRow,
	nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'), nRows = this.attr('rows'),
	nViewPortOffsetHeight = this.attr('layoutsize').viewport.offsetHeight,
	nFrozenRowsHeight = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
	nFrozenBottomRowsHeight = this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1),
	nAdjustCountBeforeScrolling;
	//console.log('nMovedCount:', nMovedCount);
	
	objUpdateInfo.objParams = {};
	
	if(Math.abs(nMovedCount) >= objVSInfo.nDynamicRows - nFrozenRows - nFrozenBottomRows){//스크롤바로 이동한 행 수가 동적 행 수보다 많은 경우
		//console.log('스크롤바로 이동한 행 수가 동적 행 수보다 많은 경우');
		
		var nAdjustCount = 0,//nAdjustCount: 보정 행 수
		nAdjustedTop = 0;//이동한 세로스크롤바의 위치가 동적 행을 변경하는 것이 아닌 top값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
		
		objUpdateInfo.bWholeUpdate = true;
		
		if(nMovedCount > 0){//세로스크롤바가 아래로 이동했을 때
			//objUpdateInfo.strDirection = 'down';
			
			//console.log('세로스크롤바가 아래로 이동했을 때');
			//if(objVSInfo.nBottomRow + nMovedCount > objVSInfo.nEndRow){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
			if(objVSInfo.nPos > objVSInfo.nLastPos - objVSInfo.nAdjustRows){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
				//console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때, nMovedCount:', nMovedCount);
				//nAdjustCount = (objVSInfo.nBottomRow + nMovedCount) - objVSInfo.nEndRow;
				nAdjustCount = objVSInfo.nPos - (objVSInfo.nLastPos - objVSInfo.nAdjustRows);
				
				objVSInfo.nTopRow += nMovedCount - nAdjustCount;
				objVSInfo.nBottomRow += nMovedCount - nAdjustCount;
				
				if(objVSInfo.nLastPos === objVSInfo.nPos){//viewport의 하단 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
					//console.log('viewport의 하단 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우');
					nAdjustedTop = nFrozenRowsHeight + this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nEndRow) - (nViewPortOffsetHeight - nFrozenBottomRowsHeight);
				} else{//행의 height만큼 top을 이동시켜야 하는 경우
					//console.log('행의 height만큼 top을 이동시켜야 하는 경우');
					//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objVSInfo.nLastPos - objVSInfo.nAdjustRows
					nAdjustedTop = this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nTopRow + (objVSInfo.nPos - (objVSInfo.nLastPos - objVSInfo.nAdjustRows)) - 1);
				}
			} else{
				//console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때, nMovedCount:', nMovedCount);
				objVSInfo.nTopRow += nMovedCount;
				objVSInfo.nBottomRow += nMovedCount;
			}
			
		} else{//세로스크롤바가 위로 이동했을 때
			//objUpdateInfo.strDirection = 'up';
			
			//console.log('세로스크롤바가 위로 이동했을 때');
			if(objVSInfo.nPos >= objVSInfo.nLastPos - objVSInfo.nAdjustRows){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
				//console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때, nMovedCount:', nMovedCount);
				nAdjustCount = objVSInfo.nPos - (objVSInfo.nLastPos - objVSInfo.nAdjustRows);
				nAdjustedTop = this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nTopRow + nAdjustCount - 1);
			} else{//이동한 스크롤바의 위치가 보정 범위 밖에 있을 때
				//console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때, nMovedCount:', nMovedCount);
				//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간만큼은 nTopRow, nBottomRow값이 변하지 않아야 한다.
				nAdjustCountBeforeScrolling = objVSInfo.nPos - nMovedCount >= objVSInfo.nLastPos - objVSInfo.nAdjustRows ? objVSInfo.nPos - nMovedCount - (objVSInfo.nLastPos - objVSInfo.nAdjustRows) : 0;
				//console.log("스크롤바가 이동하기 전 기준 보정영역범위:", nAdjustCountBeforeScrolling);
				
				objVSInfo.nTopRow += nMovedCount + nAdjustCountBeforeScrolling;
				objVSInfo.nBottomRow += nMovedCount + nAdjustCountBeforeScrolling;
			}
		}
		
		objUpdateInfo.objParams.nAdjustedTop = nAdjustedTop;
	} else{//스크롤바로 이동한 행 수가 동적 행 수보다 적은 경우
		var nCutRowsCount = 0;//nCutRowsCount:데이터와 위치를 갱신해야 하는 동적 행의 수(ex> 세로스크롤바가 아래쪽으로 3칸 이동 시 3개의 일반행을 표시하던 div들을 새로 나타해야 할 새로운 3개의 행 위치로 이동시키고 데이터를 갱신해야 한다.)
		
		objUpdateInfo.bWholeUpdate = false;
		objUpdateInfo.objParams.nMovedCount = nMovedCount;
		
		if(nMovedCount > 0){//세로스크롤바가 아래로 이동했을 때
			//console.log('세로스크롤바가 아래로 이동했을 때');
			//objUpdateInfo.strDirection = 'down';
			
			//if(objVSInfo.nBottomRow + nMovedCount > objVSInfo.nEndRow){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
			if(objVSInfo.nPos > objVSInfo.nLastPos - objVSInfo.nAdjustRows){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
				//console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때, nMovedCount:', nMovedCount);
				nCutRowsCount = objVSInfo.nEndRow - objVSInfo.nBottomRow;
				objUpdateInfo.objParams.bWholePositionChanged = true;
			} else{
				//console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때, nMovedCount:', nMovedCount);
				nCutRowsCount = nMovedCount;
				objUpdateInfo.objParams.bWholePositionChanged = false;
			}
			
			objVSInfo.nTopRow += nCutRowsCount;
			objVSInfo.nBottomRow += nCutRowsCount;
		} else{//세로스크롤바가 위로 이동했을 때
			//console.log('세로스크롤바가 위로 이동했을 때');
			//objUpdateInfo.strDirection = 'up';
			
			if(objVSInfo.nPos >= objVSInfo.nLastPos - objVSInfo.nAdjustRows){//이동한 스크롤바의 위치가 보정 범위 내에 있을 때
				//console.log('이동한 스크롤바의 위치가 보정 범위 내에 있을 때, nMovedCount:', nMovedCount);
				objUpdateInfo.objParams.bWholePositionChanged = true;
			} else{//이동한 스크롤바의 위치가 보정 범위 밖에 있을 때
				//console.log('이동한 스크롤바의 위치가 보정 범위 밖에 있을 때, nMovedCount:', nMovedCount);
				//이전 스크롤바 위치가 보정영역이였으면 보정영역 내 스크롤 이동 구간만큼은 nTopRow, nBottomRow값이 변하지 않아야 한다.
				nAdjustCountBeforeScrolling = objVSInfo.nPos - nMovedCount >= objVSInfo.nLastPos - objVSInfo.nAdjustRows ? objVSInfo.nPos - nMovedCount - (objVSInfo.nLastPos - objVSInfo.nAdjustRows) : 0;
				nCutRowsCount = Math.abs(nMovedCount) - nAdjustCountBeforeScrolling;
				
				objVSInfo.nTopRow -= nCutRowsCount;
				objVSInfo.nBottomRow -= nCutRowsCount;
				objUpdateInfo.objParams.bWholePositionChanged = false;
			}
		}
		
		objUpdateInfo.objParams.nCutRowsCount = nCutRowsCount;
	}
};

QBOX.QCELL.BasicQCELL.prototype._resizeVScrollbar = function(bKeep){
	try{
		var htElementPool = this.attr('elementpool'),
		heVScrollThumb = htElementPool.get('vscrollthumb'),
		$jqVScrollbar = htElementPool.get('$jqvscrollbar'),
		objLayoutSize = this.attr('layoutsize'), objVSInfo = this.attr('vsinfo');
		
		/*
		if(스크롤바를 표시 할 때){
			nLengthPerRow계산
			nLastPos계산
			nAdjustRows계산
			nPos,nTop보정
			nLength계산
			nVScrollThumbLength계산
		} else{
			nLengthPerRow = 0;
			nLastPos = 0;
			nPos = 0;
			nTop = 0;
			nBeforeTop = 0;
			nAdjustRows = 0;
			nLength = 0;
			nVScrollThumbLength = 0;
		}
		*/
		if(objVSInfo.bVScroll){
			var nViewPortDisplayRows = 0,//viewport에 표시되고 있는 행의 수
			nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'), nRows = this.attr('rows'),
			nViewPortOffsetHeight = objLayoutSize.viewport.offsetHeight,
			nVScrollbarClientHeight = objLayoutSize.vscrollbar.clientHeight,
			nFrozenRowsHeight = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
			nFrozenBottomRowsHeight = this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1),
			fnCallback, i,fnCallbackScrollTop,fnCallbackScrollBottom;
			
			//viewport에 표시되고 있는 행의 수 = height의 합이 viewport의 height보다 크거나 같을 때까지의 행 수
			for(i = nHeaderRows; i < nRows ; i++){
				if(this._getSumOfRowHeight(nHeaderRows, i) >= nViewPortOffsetHeight){
					nViewPortDisplayRows = i - nHeaderRows + 1;
					break;
				}
			}
			//console.log('viewport에 표시되고 있는 행의 수:', nViewPortDisplayRows);
			
			//objVSInfo.nLengthPerRow = Math.round(this._getSumOfRowHeight(objVSInfo.nStartRow, objVSInfo.nEndRow) / (objVSInfo.nEndRow - objVSInfo.nStartRow));
			objVSInfo.nLengthPerRow = Math.round(nVScrollbarClientHeight / nViewPortDisplayRows);//"한 행 당 scroll 이동 거리" = 세로스크롤바영역의 height / 화면에 표시되고 있는 행의 수
			objVSInfo.nAdjustRows = 0;
			//"VScrollbar가 이동할 수 있는 행의 수" = "화면에 표시되지 않은 행의 수" + (마지막 동적행 div가 이미 마지막 행(nEndRow)으로 세팅되었지만, ("동적 행의 heigt합" + "frozenRows의 height의 합" + "frozenBottomRows의 height의 합")이 viewport의 height보다 커서 top를 이동시켜야 하는 행의 수)
			objVSInfo.nLastPos = objVSInfo.nEndRow - (objVSInfo.nStartRow + (objVSInfo.nDynamicRows - nFrozenRows - nFrozenBottomRows) - 1);//nEndRow - "스크롤바가 맨 위에 있을 때의 nBottomRow" - 1
			
			for(i = objVSInfo.nStartRow + objVSInfo.nLastPos; i <= objVSInfo.nEndRow; i++){
				//세로스크롤바가 끝까지 움직였을 때의 nTopRow:objVSInfo.nStartRow + objVSInfo.nLastPos
				var nVal = nFrozenRowsHeight + nFrozenBottomRowsHeight + this._getSumOfRowHeight(objVSInfo.nStartRow + objVSInfo.nLastPos + objVSInfo.nAdjustRows, objVSInfo.nEndRow);
				if(nVal > nViewPortOffsetHeight){
					objVSInfo.nAdjustRows += 1;
				} else{
					break;
				}
			}
			objVSInfo.nLastPos += objVSInfo.nAdjustRows;
			//console.log('VScrollbar가 이동할 수 있는 행의 수:' + objVSInfo.nLastPos);
			
			if(bKeep === undefined){
				if(objVSInfo.nPos !== 0 && objVSInfo.nPos + 1 < objVSInfo.nLastPos){ //QCELL을 최초 생성시 nPos는 0, 이후 addRow시 LastPos와 Pos의 값이 벌어질 때 nPos값 조정
					objVSInfo.nPos = objVSInfo.nLastPos - 1;
					objVSInfo.nTop = -(objVSInfo.nPos * objVSInfo.nLengthPerRow);
				}
				
				if(objVSInfo.nPos > objVSInfo.nLastPos){
					objVSInfo.nPos = objVSInfo.nLastPos;
					objVSInfo.nTop = -(objVSInfo.nPos * objVSInfo.nLengthPerRow);
				}
				
				if(objVSInfo.nTop !== -(objVSInfo.nPos * objVSInfo.nLengthPerRow)){//nTop값이 갱신된 nLengthPerRow의 배수가 아닌 경우
					objVSInfo.nTop = -(objVSInfo.nPos * objVSInfo.nLengthPerRow);//세로스크롤바가 움직인 상태에서 세로스크롤바 영역의 사이즈가 변경된 후 _resizeVScrollbar() 수행 시 nTop값을 보정
				}				
			}

			
			objVSInfo.nLength = objVSInfo.nLastPos * objVSInfo.nLengthPerRow;
			
			if(nVScrollbarClientHeight + objVSInfo.nLength > 1533917){//browser의 스크롤 길이 제한으로 인해 nLengthPerRow를 보정해야 하는 경우, IE의 최대 스크롤바 길이가 가장 짧아 IE를 기준으로 한다.
				objVSInfo.nLengthPerRow = Math.floor((1533917 - nVScrollbarClientHeight) / objVSInfo.nLastPos);
				if(objVSInfo.nLengthPerRow < 1){//보정 할 수 있는 nLengthPerRow의 값은 1까지이며, 1보다 적은 경우엔 오동작한다. 
					objVSInfo.nLengthPerRow = 1;
					//console.log('지원 가능한 세로스크롤바 범위 초과');
				}
				objVSInfo.nLength = objVSInfo.nLastPos * objVSInfo.nLengthPerRow;
			}
			//"VScrollThumb의 height" = "세로스크롤바 영역의 height" + ("한 행 당 평균스크롤 이동 거리" * "VScrollbar가 이동할 수 있는 행의 수")
			heVScrollThumb.style.height = (nVScrollbarClientHeight + objVSInfo.nLength) + 'px';
			
			var THAT = this;
			
			fnCallback = function(params){
				var nScrollTop = this.mcs.top;
				
				if(params === undefined){//mCustomScrollbar UI를 직접 움직였을 때만(mousewheel 이벤트를 이용 해 세로스크롤가 이동 시에는 )
					try{
						QBOX.util.rAF(function(){
							THAT.onVScroll(nScrollTop);
							THAT._trigger("scrollmove");
						});						
					}  catch(e){
						QCELL.log('err', 'VScrollbar.onScroll ', e.message);						
					}
				}
			};
			
			fnCallbackScrollTop = function (params){
				THAT.onScrollTop();
				
			};
			fnCallbackScrollBottom = function (params){				
				THAT.onScrollBottom();				
			};			
			
			/*
			$jqVScrollbar.mCustomScrollbar('destroy').mCustomScrollbar({
				axis:"y",
				theme:"qcell-default",
				setWidth:'100%',
				setHeight:'100%',
				scrollInertia:0,//모멘텀 에니메이션 효과 간격
				snapAmount: objVSInfo.nLengthPerRow,//scrollDragger를 마우스로 드래그하거나 scrollbar 영역을 클릭하여 스크롤바 이동 시 고정값으로 이동하도록 기본 고정값 설정
				mouseWheel:{
					enable:true,
					preventDefault:true,
					normalizeDelta:true,//OS/브라우저별로 다른 delta값을 일반화하여 동일하게 동작하도록 설정한다.
					scrollAmount:objVSInfo.nLengthPerRow//마우스 휠 이벤트 발생 시 이동할 pixel값
				},
				scrollButtons:{
					enable:true,
					scrollAmount:objVSInfo.nLengthPerRow//,//스크롤이동버튼 클릭 시 이동할 pixel값
					//scrollType:'stepped'
				},
				keyboard:{enable:false},
				advanced:{updateOnContentResize:false},
				callbacks:{
					onScroll		: fnCallback,
					whileScrolling	: fnCallback,
					onTotalScroll :	fnCallbackScrollBottom,
				    onTotalScrollBack : fnCallbackScrollTop
				},
				target:this
			});
			*/
			
			QBOX.$($jqVScrollbar).rt_qc_mCSbar('destroy').rt_qc_mCSbar({ // 기존의 스크롤바는 destroy를 실행 후 스크롤바를 재생성하기 때문에 row 추가/삭제 시 스크롤이 가장 위로 올라갔다가 위치정보 설정이 되는 사항있었음
				axis:"y",
				theme:"qcell-default",
				setWidth:'100%',
				setHeight:'100%',
				scrollInertia:0,//모멘텀 에니메이션 효과 간격
				snapAmount: objVSInfo.nLengthPerRow,//scrollDragger를 마우스로 드래그하거나 scrollbar 영역을 클릭하여 스크롤바 이동 시 고정값으로 이동하도록 기본 고정값 설정
				mouseWheel:{
					enable:true,
					preventDefault:true,
					normalizeDelta:true,//OS/브라우저별로 다른 delta값을 일반화하여 동일하게 동작하도록 설정한다.
					scrollAmount:objVSInfo.nLengthPerRow//마우스 휠 이벤트 발생 시 이동할 pixel값
				},
				scrollButtons:{
					enable:true,
					scrollAmount:objVSInfo.nLengthPerRow/*,//스크롤이동버튼 클릭 시 이동할 pixel값
					scrollType:'stepped'*/
				},
				keyboard:{enable:false},
				advanced:{updateOnContentResize:false},
				callbacks:{
					onScroll		: fnCallback,
					whileScrolling	: fnCallback,
					onTotalScroll :	fnCallbackScrollBottom,
				    onTotalScrollBack : fnCallbackScrollTop
				},
				documentTouchScroll : QBOX.util.isMobile() === null? false : true,
				target:this
			});
			
			if(objVSInfo.nTop < 0){//_rebuild()를 연속으로 수행 시에 스크립트 오류가 난다. scrollTo가 비동기로 처리되서 그런 듯...
				$jqVScrollbar.rt_qc_mCSbar('scrollTo', objVSInfo.nTop, '', {ignorecallback:true});
			}
			
			fnCallback = null;
			
			var heV = this.attr('elementpool').get('jqvscrollbar').getElementsByClassName('rt_qc_mCSB_scrollTools')[0];
			if(heV !== undefined && heV !== null){
				
				var nFocusRow,nFocusCol,nTopRow,nBottomRow,ovs,heChild,x,bTag;
				
				var preB = document.createElement('button');
				preB.setAttribute('id', this.getID()+'_vsbp');
				preB.setAttribute('type', 'button');
				preB.className += 'rt_qc_mCSB_buttonPrev';
				preB.onclick = function (){
					nFocusRow = THAT._idx('row', 'focus', 'current');
					nFocusCol = THAT._idx('col', 'focus', 'current');
					ovs = THAT.attr('vsinfo');
					nTopRow = THAT._getTopRowOfScreen();
					nBottomRow = THAT._getBottomRowOfScreen();
					
					if(nFocusRow === -1)
						nFocusRow = ovs.nTopRow;	
					
					if(nFocusCol === -1)
						nFocusCol = THAT.getCols('header');					
					
					nFocusRow--;
					
					if(THAT.attr('frozenrows') > 0 && (nFocusRow <= (THAT.attr('frozenrows') + THAT.attr('headerrows')) - 1)){
						//focus가 현재 frozenrows 영역에 위치할 경우
						return false;
					} else{
						if(nFocusRow >= nTopRow && nFocusRow <= nBottomRow){
							//focus가 현재 보이는 영역에 위치한 경우
							nFocusRow -= (nBottomRow - nTopRow);
							nTopRow -= (nBottomRow - nTopRow);
						} else{//focus가 현재 보이지 않는 영역에 있을 경우
							nFocusRow = nTopRow - (nBottomRow - nTopRow);
							nTopRow = nTopRow - (nBottomRow - nTopRow);
						}
					}
					nFocusRow--;
					nTopRow--;
					if(nFocusRow <= THAT.attr('headerrows')){
						nTopRow = ovs.nStartRow;
					}	
					THAT._scrollTop(nTopRow);
					THAT._scrollLeft(THAT.getCols('header'));
					setTimeout(function(){
						var heContainer = document.getElementById('container-'+THAT.getID());
						if(heContainer !== null && heContainer!==undefined)
							heContainer.focus();
					},100);
					/*
					setTimeout(function(){
						try{
							bTag = false;
							heChild = null;
							for(x=THAT.getCols('header'); x< THAT.getCols();x++){
								if(THAT._getColType(x) ==='checkbox'){
									heChild = THAT._getCellDOM(nTopRow,x).getElementsByTagName('input')[0];					
									if(heChild !== null && heChild !== undefined){
										bTag = true;
										break;
									}
									break;
								}
								if(THAT._getColType(nFocusCol) === 'html'){
									heChild = THAT._getCellDOM(nTopRow,x).getElementsByTagName('button')[0];										
										
									if(heChild !== null && heChild !== undefined){
										bTag = true;
										break;
									}
									
									heChild = THAT._getCellDOM(nTopRow,x).getElementsByTagName('a')[0];
									
									if(heChild !== null && heChild !== undefined){
										bTag = true;
										break;
									}										
									
								}
								
								heChild = THAT._getCellDOM(nTopRow,x).getElementsByTagName('button')[0];
								
								if(heChild !== null && heChild !== undefined){
									//heChild.focus();
									bTag = true;
									break;
								}
							}
							if(bTag === true){
								
								heChild.focus();
								
							}
							

							
						}catch(e){
							var ttt=0;
						}
					},300);*/
					
				};
				var preBT = document.createTextNode('이전 데이터 정보');
				preB.appendChild(preBT);
				heV.appendChild(preB);
				
				var nexB = document.createElement('button');
				nexB.setAttribute('id', this.getID()+'_vsbn');
				nexB.setAttribute('type', 'button');
				nexB.className += 'rt_qc_mCSB_buttonNext';				
				nexB.onclick = function (){
					nFocusRow = THAT._idx('row', 'focus', 'current');
					nFocusCol = THAT._idx('col', 'focus', 'current');					

					nTopRow = THAT._getTopRowOfScreen();
					nBottomRow = THAT._getBottomRowOfScreen();
					ovs = THAT.attr('vsinfo');
					
					if(nFocusRow === -1)
						nFocusRow = ovs.nBottomRow;	
					
					if(nFocusCol === -1)
						nFocusCol = THAT.getCols('header');
					
					if(nFocusRow >= THAT.attr('headerrows') && nFocusRow < THAT.attr('rows') - 1){ //Pagedown 동작 범위
						/* index 계산 */
						if(nFocusRow >= THAT.attr('rows') - THAT.attr('frozenbottomrows')){ //focus가 현재 frozenbottomrows 영역에 위치할 경우
							return false;
						} else{
							if(nFocusRow >= nTopRow && nFocusRow <= nBottomRow){
								//focus가 현재 보이는 영역에 위치한 경우
								nFocusRow += (nBottomRow - nTopRow);
							} else{//focus가 현재 보이지 않는 영역에 있을 경우
								nFocusRow = nBottomRow;
							}
						}
						
						if(nFocusRow >= THAT.attr('rows')){
							nFocusRow = ovs.nBottomRow +1;
						}
						
						nTopRow += (nBottomRow - nTopRow);
						nTopRow++;
						
						if(nTopRow >= ovs.nEndRow)
							nTopRow = ovs.nEndRow;
						
						THAT._scrollTop(nTopRow);
						
						THAT._scrollLeft(THAT.getCols('header'));
						
						setTimeout(function(){
							var heContainer = document.getElementById('container-'+THAT.getID());
							if(heContainer !== null && heContainer!==undefined)
								heContainer.focus();
						},100);
						/*
						setTimeout(function(){
							try{
								bTag = false;
								heChild = null;
								for(x=THAT.getCols('header'); x< THAT.getCols();x++){
									if(THAT._getColType(x) ==='checkbox'){
										heChild = THAT._getCellDOM(nTopRow,x).getElementsByTagName('input')[0];					
										if(heChild !== null && heChild !== undefined){
											bTag = true;
											break;
										}
									}
									if(THAT._getColType(nFocusCol) === 'html'){
										heChild = THAT._getCellDOM(nTopRow,x).getElementsByTagName('button')[0];										
											
										if(heChild !== null && heChild !== undefined){
											bTag = true;
											break;
										}
										
										heChild = THAT._getCellDOM(nTopRow,x).getElementsByTagName('a')[0];
										
										if(heChild !== null && heChild !== undefined){
											bTag = true;
											break;
										}										
										
									}
									
									heChild = THAT._getCellDOM(nTopRow,x).getElementsByTagName('button')[0];
									
									if(heChild !== null && heChild !== undefined){
								
										bTag = true;
										break;
									}
								}
								if(bTag === true){
									

									heChild.focus();
									
								}
								

								
							}catch(e){
								
							}
						},300); */
						
					}
				};
				var nexBT = document.createTextNode('다음 데이터 정보');
				nexB.appendChild(nexBT);
				heV.appendChild(nexB);	
				
				QBOX.$('#'+this.getID()+'_vsbp').prop('disabled' , true);
				QBOX.$('#'+this.getID()+'_vsbn').prop('disabled' , false);		
				
			}			
		} else{
			$jqVScrollbar.rt_qc_mCSbar('destroy');
			objVSInfo.nLengthPerRow = objVSInfo.nLastPos = objVSInfo.nPos = objVSInfo.nTop = objVSInfo.nBeforeTop = objVSInfo.nAdjustRows = objVSInfo.nLength = 0;
			heVScrollThumb.style.height = '0px';
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._resizeVScrollbar', e.message);
		return false;
	}
};
//QBOX.QCELL.BasicQCELL.prototype._resizeVScrollbar1 = function(){
//	var htElementPool = this.attr('elementpool'),
//	heVScrollbar = htElementPool.get('vscrollbar'),
//	heVScrollThumb = htElementPool.get('vscrollthumb'),
//	objLayoutSize = this.attr('layoutsize'), objVSInfo = this.attr('vsinfo');
//	
//	if(objVSInfo.bVScroll){
//		var nHeaderRows = this.attr('headerrows'),
//		nFrozenRows = this.attr('frozenrows'),
//		nFrozenBottomRows = this.attr('frozenbottomrows'),
//		nCurrentDataCount = this.attr('currentdata').length,
//		nRows = this.attr('rows'),
//		nSumOfRowHeightAboutFrozenRows = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
//		nSumOfRowHeightAboutFrozenBottomRows = this._getSumOfRowHeight(nRows - nFrozenBottomRows , nRows - 1),
//		nViewPortOffsetHeight = objLayoutSize.viewport.offsetHeight,
//		nVScrollbarClientHeight = objLayoutSize.vscrollbar.clientHeight,
//		fnVScrollCallback;
//		
//		//heVScrollbar.style.display = '';
//		
//		objVSInfo.nLengthPerRow = Math.round(this._getSumOfRowHeight(objVSInfo.nStartRow, objVSInfo.nEndRow) / (objVSInfo.nEndRow - objVSInfo.nStartRow));
//		//"VScrollbar가 이동할 수 있는 행의 수" = "화면에 표시되지 않은 행의 수" + (마지막 동적행 div가 이미 마지막 행(nEndRow)으로 세팅되었지만, ("동적 행의 heigt합" + "frozenRows의 height의 합" + "frozenBottomRows의 height의 합")이 viewport의 height보다 커서 top를 이동시켜야 하는 행의 수)
//		//objVSInfo.nLastPos = objVSInfo.nEndRow - (objVSInfo.nBottomRow);
//		//nLastPos = nEndRow - "스크롤바가 맨 위에 있을 때의 nBottomRow"
//		objVSInfo.nLastPos = objVSInfo.nEndRow - (objVSInfo.nStartRow + (objVSInfo.nDynamicRows - this.attr('frozenrows') - this.attr('frozenbottomrows')) - 1);
////		if(objVSInfo.nDynamicRows > nCurrentDataCount){
////			objVSInfo.nBottomRow = objVSInfo.nEndRow;
////		} else{
////			//nBottomRow = nStartRow + "스크롤링 발생 시 동적으로 변경되는 dynamicRows의 수", nDynamicRows는 frozenRows와 frozenBottomRows까지 합한 값이다.
////			objVSInfo.nBottomRow = objVSInfo.nStartRow + (objVSInfo.nDynamicRows - this.attr('frozenrows') - this.attr('frozenbottomrows') - 1);
////		}
//		
//		objVSInfo.nAdjustRows = 0;
//		while(true){
//			//세로스크롤바가 끝까지 움직였을 때의 nTopRow:objVSInfo.nTopRow + objVSInfo.nLastPos
//			var nVal = nSumOfRowHeightAboutFrozenRows + nSumOfRowHeightAboutFrozenBottomRows + this._getSumOfRowHeight(objVSInfo.nTopRow + objVSInfo.nLastPos + objVSInfo.nAdjustRows, objVSInfo.nEndRow);
//			if(nVal > nViewPortOffsetHeight){
//				objVSInfo.nAdjustRows += 1;
//			} else{
//				break;
//			}
//		}
//		objVSInfo.nLastPos += objVSInfo.nAdjustRows;
//		objVSInfo.nLength = objVSInfo.nLastPos * objVSInfo.nLengthPerRow;
//		
//		//"VScrollThumb의 길이" = "세로스크롤바 영역의 height" + ("한 행 당 평균스크롤 이동 거리" * "VScrollbar가 이동할 수 있는 행의 수")
//		nVScrollThumbLength = nVScrollbarClientHeight + objVSInfo.nLength;
//		
//		heVScrollThumb.style.height = nVScrollThumbLength + 'px';
//		//console.log('VScrollbar가 이동할 수 있는 행의 수:' + objVSInfo.nLastPos);
//		//console.log('VScrollThumb의 길이:' + nVScrollThumbLength);
//		
//		fnVScrollCallback = function(params){
//			var objQCell = this.mcs.target,
//			nScrollTop = this.mcs.top;
//			
//			if(params === undefined){//mCustomScrollbar UI를 직접 움직였을 때만(mousewheel 이벤트를 이용 해 세로스크롤가 이동 시에는 )
//				QBOX.util.rAF(function(){
//					objQCell.onVScroll(nScrollTop);
//				});
//			}
//		};
//		
//		htElementPool.get('$jqvscrollbar').mCustomScrollbar('destroy').mCustomScrollbar({
//			axis:"y",
//			theme:"3d-thick-dark",
//			setWidth:'100%',
//			setHeight:'100%',
//			scrollInertia:0,//모멘텀 에니메이션 효과 간격
//			snapAmount: objVSInfo.nLengthPerRow,//scrollDragger를 마우스로 드래그하거나 scrollbar 영역을 클릭하여 스크롤바 이동 시 고정값으로 이동하도록 기본 고정값 설정
//			mouseWheel:{
//				enable:true,
//				preventDefault:true,
//				normalizeDelta:true,//OS/브라우저별로 다른 delta값을 일반화하여 동일하게 동작하도록 설정한다.
//				scrollAmount:objVSInfo.nLengthPerRow//마우스 휠 이벤트 발생 시 이동할 pixel값
//			},
//			scrollButtons:{
//				enable:true,
//				scrollAmount:objVSInfo.nLengthPerRow/*,//스크롤이동버튼 클릭 시 이동할 pixel값
//				scrollType:'stepped'*/
//			},
//			keyboard:{enable:false},
//			callbacks:{
//				onScroll		: fnVScrollCallback,
//				whileScrolling	: fnVScrollCallback
//			},
//			target:this
//		});
//		
//		fnVScrollCallback = null;
//	} else{
//		htElementPool.get('$jqvscrollbar').mCustomScrollbar('destroy');
//		//this._initVSInfo();
//	}
//};

//QBOX.QCELL.BasicQCELL.prototype._resizeVScrollbar2 = function(){
//	var htElementPool = this.attr('elementpool'),
//	heVScrollbar = htElementPool.get('vscrollbar'), heVScrollThumb = htElementPool.get('vscrollthumb'),
//	
//	objLayoutSize = this.attr('layoutsize'), objVSInfo = this.attr('vsinfo'),
//	
//	arrColWidthsPerPixel = this.attr('colwidthsperpixel'),
//	
//	nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'), nRows = this.attr('rows'),
//	nScrollbarWidth = this.attr('scrollbarwidth'), nViewPortClientHeight = objLayoutSize.viewport.clientHeight,
//	/*세로스크롤바영역의 height*/nVScrollbarClientHeight = objLayoutSize.vscrollbar.clientHeight,
//	/*VScrollThumb의 길이*/nVScrollThumbLength = 0;
//	
//	if(objVSInfo.bVScroll){
//		var objQCell = this;
//		heVScrollbar.style.display = '';
//		/*
//		 * 세로 스크롤바 길이 비율의 문제
//		 * rowheader, viewport 영역에 표시되는 셀들 중에서 frozenrows, frozenBottomRows 영역이 아닌 셀들만 세로 스크롤바를 이용한 스크롤링이 가능
//		 * 현재 화면에 보이는  일반컬럼 수가 전체 일반컬럼 수의 30%라면 스크롤바의 모양은 70%를 이동 할 수 있는 모양이 되어야 한다.
//		 */
//		var nViewPortDisplayRows = 0,/*viewport에 표시되고 있는 행의 수*/
//		nRowHeightSum = 0,/*viewport에 표시되고 있는 행의 수*/
//		bOverlappedRow = false;/*화면에 보이는 행 중 반쯤 걸친 행의 유무*/
//		
//		//console.log('nViewPortClientHeight:', nViewPortClientHeight);
//		
//		//viewport에 표시되고 있는 행의 수 = height의 합이 viewport의 height보다 크거나 같을 때까지의 행 수
//		for(var i = nHeaderRows ; i < nRows; i++){
//			nRowHeightSum += this._getRowHeight(i);
//			if(nRowHeightSum >= nViewPortClientHeight){
//				nViewPortDisplayRows = i - nHeaderRows + 1;
//				console.log('viewport에 표시되고 있는 행들의 height 합:', nRowHeightSum);
//				
//				if(nRowHeightSum > nViewPortClientHeight){
//					bOverlappedRow = true;
//				}
//				
//				break;
//			}
//		}
//		//console.log('viewport에 표시되고 있는 행의 수:', nViewPortDisplayRows);
//		
//		//"한 행 당 scroll 이동 거리 = 세로 스크롤바 영역의 height / 화면에 표시되고 있는 행의 수
//		objVSInfo.nLengthPerRow = Math.round(nViewPortClientHeight / (nViewPortDisplayRows/* - nFrozenRows - nFrozenBottomRows*/));
//		//console.log('한 행 당 scroll 이동 거리:' + objVSInfo.nLengthPerRow);
//		
//		//"VScrollbar가 이동할 수 있는 행의 수" = "한 행 당 scroll 이동 거리" * ("화면에 표시되지 않은 행의 수" + (화면에 보이는 행 중 반쯤 걸친 행의 유무)
//		objVSInfo.nMaxLength = nRows - nHeaderRows - nViewPortDisplayRows + (bOverlappedRow ? 1 : 0);
//		//"VScrollThumb의 길이" = "세로스크롤바 영역의 height" + ("한 행 당 평균스크롤 이동 거리" * "VScrollbar가 이동할 수 있는 행의 수")
//		nVScrollThumbLength = nViewPortClientHeight + (objVSInfo.nLengthPerRow * objVSInfo.nMaxLength);
//		
//		heVScrollThumb.style.height = nVScrollThumbLength + 'px';
//		//console.log('VScrollbar가 이동할 수 있는  행의 수:' + objVSInfo.nMaxLength);
//		//console.log('VScrollThumb의 길이:' + nVScrollThumbLength);
//		
//		htElementPool.get('$jqvscrollbar').mCustomScrollbar('destroy').mCustomScrollbar({
//			axis:"y",
//			theme:"3d-thick-dark",
//			setWidth:'100%',
//			setHeight:'100%',
//			scrollInertia:0,//모멘텀 에니메이션 효과 간격
//			snapAmount: objVSInfo.nLengthPerRow,//scrollDragger를 마우스로 드래그하거나 scrollbar 영역을 클릭하여 스크롤바 이동 시 고정값으로 이동하도록 기본 고정값 설정
//			//autoDraggerLength:false,//scrollDragger의 길이가 항상 일정하도록 설정
//			mouseWheel:{
//				enable: true,
//				scrollAmount:objVSInfo.nLengthPerRow,//마우스 휠 이벤트 발생 시 이동할 pixel값
//				preventDefault:true/*,
//				normalizeDelta:true//OS/브라우저별로 다른 delta값을 일반화하여 동일하게 동작하도록 설정한다.*/
//			},
//			scrollButtons:{
//				enable:true,
//				scrollAmount:objVSInfo.nLengthPerRow,//스크롤이동버튼 클릭 시 이동할 pixel값
//				scrollType:'stepped'
//			},
//			keyboard:{enable:false},
//			callbacks:{
//				//onScroll: function(params){},
//				//whileScrolling: QBOX.QCELL.BasicQCELL.prototype.whileVScrolling
//				/*,
//				onOverflowY:function(){console.log("Vertical scrolling required");},
//				onOverflowYNone:function(){console.log("Vertical scrolling is not required");}*/
//			}/*,
//			target:this*/
//		});
//	} else{
//		heVScrollbar.style.display = 'none';
//	}
//};

QBOX.QCELL.BasicQCELL.prototype._scrollTop = function(nRow){
	var objVSInfo = this.attr('vsinfo');
	
	if(objVSInfo.bVScroll){
		var nPos, nTop;
		
		if(nRow < objVSInfo.nStartRow){
			nRow = objVSInfo.nStartRow;
		} else{
			//세로스크롤바가 끝까지 움직였을 때의 nTopRow:objVSInfo.nStartRow + objVSInfo.nLastPos
			if(nRow > objVSInfo.nStartRow + objVSInfo.nLastPos){
				nRow = objVSInfo.nStartRow + objVSInfo.nLastPos;
			}
		}
		
		nPos = nRow - objVSInfo.nStartRow;
		//console.log("nPos:" + nPos);
		nTop = -1 * (nPos) * objVSInfo.nLengthPerRow;
		
		if(nTop !== objVSInfo.nTop){
			this.attr('adjustrow',true,'boolean');
			//console.log('nRow:' + nRow + ', nBeforeTop:' + objVSInfo.nTop + ', nTop:' + nTop);
			QBOX.$(this.attr('elementpool').get('$jqvscrollbar')).rt_qc_mCSbar('scrollTo', nTop);
		}
	}
};

//2018-01-08(sai1515): 가로스크롤바에 걸쳐저 있는 셀을 클릭했을 경우 완전히 보여지도록 세로 스르콜을 보정해 주는 내부 함수.
QBOX.QCELL.BasicQCELL.prototype._adjustRow = function(){
	try{
		var nRow = this._getSelectedRow() !== -1 ? this._getSelectedRow() : this._idx('row', 'focus'),
		nCol = this._getSelectedCol() !== -1 ? this._getSelectedCol() : this._idx('col', 'focus'),
		heCell = this._getCellDOM(nRow, nCol),
		objVSInfo = this.attr('vsinfo');
		
		if(objVSInfo.bVScroll){
			if(objVSInfo.nAdjustRows > 0){
				if(nRow >= this.attr('headerrows') + this.attr('frozenrows') && nRow < this.attr('rows') - this.attr('frozenbottomrows')){
					switch(this._getVScrollAdjustment(heCell)){
						case 'top': {
							this._scrollTop(objVSInfo.nStartRow + objVSInfo.nPos - 1);
							this.attr('adjustrow', true, 'boolean');
							break;
						}
						case 'bottom': {
							this._scrollTop(objVSInfo.nStartRow + objVSInfo.nPos + 1);
							this.attr('adjustrow', true, 'boolean');
							break;
						}
						default: {
							this.attr('adjustrow', false, 'boolean');
							break;
						}
					}
				} else{
					this.attr('adjustrow', false, 'boolean');
				}
				
				/*if(objVSInfo.nPos !== objVSInfo.nLastPos && objVSInfo.nBottomRow === this._idx('row', 'focus')){
					this._scrollTop(objVSInfo.nTopRow + 1);
					this.attr('adjustrow', true, 'boolean');
				} else if(objVSInfo.nPos === objVSInfo.nLastPos && objVSInfo.nTopRow === this._idx('row', 'focus')){
					this._scrollTop(objVSInfo.nTopRow);
					this.attr('adjustrow', true, 'boolean');
				} else{
					this.attr('adjustrow', false, 'boolean');
				}*/
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.BasicQCELL._adjustRow', e.message);
		return false;
	}
};

QBOX.QCELL.BasicQCELL.prototype._getVScrollAdjustment = function(heCell){
	//셀이 반쯤 걸친 셀인지 여부(위쪽으로 걸쳤는지, 아래쪽으로 걸쳐는지 반환)
	//headerRows, frozenRows, frozenBottomRows가 아닌 셀인 경우에만 사용해야 한다.
	var objVSInfo = this.attr('vsinfo');
	
	if(objVSInfo.bVScroll){
		var nStandard = 0;
		
		if(objVSInfo.nPos === objVSInfo.nLastPos){
			var nHeaderRows = this.attr('headerrows'),
			nFrozenRows = this.attr('frozenrows');
			
			if(nFrozenRows > 0){
				nStandard += this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1);
			}
			
			if(heCell.offsetTop < nStandard){
				return 'top';
			}
		} else{
			var nFrozenBottomRows = this.attr('frozenbottomrows'),
			nRows = this.attr('rows');
			
			nStandard += this.attr('layoutsize').viewport.offsetHeight;
			
			if(nFrozenBottomRows > 0){
				nStandard -= this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1);
			}
			
			if(heCell.offsetTop + heCell.offsetHeight > nStandard){
				return 'bottom';
			}
		}
	}
	
	return 'none';
};

QBOX.QCELL.BasicQCELL.prototype._MoveVScrollbarToDragging = function(event){
	if(this.attr('dragging')){//dragging을 이용한 스크롤바 이동
		/*
		 * 마우스 Dragging을 이용한 스크롤바 이동 시 커서가 멈춰있는 경우에도 스크롤바가 움직여야 하는 경우에 "mousemove" 이벤트가 발생하지 않아 셀의 인덱스 번호로는 처리할 수 없다.
		 * 마우스 이벤트가 걸려있는 container의 브라우저 기준 Y좌표값과 현재 커서의 clientY값을 이용하여 처리한다.
		 * */
		var objVSInfo = this.attr('vsinfo');
		
		if(objVSInfo.bVScroll){//세로스크롤바가 있는 경우에만
			var objQCell = this,
			objLayoutSize = this.attr('layoutsize'),
			nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'), nRows = this.attr('rows'),
			nHeaderRowsHeight = this._getSumOfRowHeight(0, nHeaderRows - 1),
			nFrozenRowsHeight = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
			nFrozenBottomRowsHeight = nFrozenBottomRows === 0 ? 0 : (this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1)),
			nTopBoundary = objLayoutSize.container.clientY + /*headerrows영역의 height*/nHeaderRowsHeight + /*frozenrows영역의 height*/nFrozenRowsHeight,//dragging시 세로스크롤바를 위쪽으로 움직여야 하는 경계선 -> frozenRows영역과 normalRows영역이 접한 경계선
			nBottomBoundary = objLayoutSize.container.clientY + /*headerrows영역의 height*/nHeaderRowsHeight + objLayoutSize.viewport.offsetHeight - nFrozenBottomRowsHeight,//dragging시 세로스크롤바를 아래쪽으로 움직여야 하는 경계선 -> 가로스크롤바(frozenbottomrows 사용 시에는 frozenbottomrows)와 normalRows영역이 접한 경계선
			nBoundaryHeight = 30,
			nMovedCount = 0;
			
			//console.log("container.clientY:", objLayoutSize.container.clientY, ", event.clientY:", event.clientY);
			
			if(nTopBoundary + /*기준두께*/nBoundaryHeight >= event.clientY){//커서의 위치가 nTopBoundary에 nBoundaryHeight만큼 근접한 경우
				if(this._idx('row', 'focus') >= nHeaderRows + nFrozenRows){//포커스 셀의 행이 normalRows인 경우에만, 포커스 셀의 행이 normalRows이 아닌 경우 세로스크롤바만 움직여야 하는 경우이다.
					if(objVSInfo.nPos > 0){//세로 스크롤바가 위쪽으로 움직일 수 있는 위치인지 고려
						if(nTopBoundary >= event.clientY){//커서의 위치가 첫번째 normalRow의 위치보다 더 위쪽에 있는 경우
							nMovedCount = -5;
							
							if(objVSInfo.nPos + nMovedCount < 0){
								nMovedCount = -(objVSInfo.nPos);
							}
						} else{
							nMovedCount = -1;
						}
					}
				} 
			} else if(nBottomBoundary - /*기준두께*/nBoundaryHeight <= event.clientY){//커서의 위치가 nBottomBoundary에 nBoundaryHeight만큼 근접한 경우
				if(this._idx('row', 'focus') < nRows - nFrozenBottomRows){//포커스 셀의 행이 normalRows인 경우에만, 포커스 셀의 행이 normalRows이 아닌 경우 세로스크롤바만 움직여야 하는 경우이다.
					if(objVSInfo.nPos < objVSInfo.nLastPos){//세로 스크롤바가 아래쪽으로 움직일 수 있는 위치인지 고려
						if(nBottomBoundary <= event.clientY){//커서의 위치가 화면에 보이는 아래쪽 normalRow의 위치보다 더 아래쪽에 있는 경우
							nMovedCount = 5;
							
							if(objVSInfo.nPos + nMovedCount > objVSInfo.nLastPos){
								nMovedCount = objVSInfo.nLastPos - objVSInfo.nPos;
							}
						} else{
							nMovedCount = 1;
						}
					}
				}
			}
			
			//스피드 변화 시
			if(nMovedCount !== this.attr('vdcount')){
				if(this.attr('vdhandle') !== null){
					//console.log('clearInterval 4');
					clearInterval(this.attr('vdhandle'));
					this.attr('vdhandle', null, 'number');
				}
				
				this.attr('vdcount', nMovedCount, 'number');
			}
			
			if(nMovedCount !== 0){
				if(this.attr('vdhandle') === null){
					this.attr('vdhandle', setInterval(function(){
						//console.log('interval활성화중');
						if(nMovedCount < 0 ? objVSInfo.nPos > 0 : objVSInfo.nPos < objVSInfo.nLastPos){
							if(objQCell.attr('selectmode').indexOf('col') === -1){
								var nDragRow = nMovedCount < 0 ? objQCell._getTopRowOfScreen() : objQCell._getBottomRowOfScreen(),
								nDragCol = objQCell._idx('col', 'cursor');
								
								objQCell._updateIdx('drag', nDragRow, nDragCol);
								
								if(objQCell.attr('colmove') === false && objQCell.attr('colresize') === false){
									objQCell._selectDragArea(event);
								}
							}
							
							objQCell._scrollTop(objVSInfo.nStartRow + objVSInfo.nPos + nMovedCount);
						} else{
							//console.log('clearInterval 1');
							clearInterval(objQCell.attr('vdhandle'));
							objQCell.attr('vdhandle', null, 'number');
							objQCell.attr('vdcount', 0, 'number');
						}
					}, 100), 'number');
				}
			} else{
				if(this.attr('vdhandle') !== null){
					//console.log('clearInterval 2');
					clearInterval(objQCell.attr('vdhandle'));
					objQCell.attr('vdhandle', null, 'number');
					objQCell.attr('vdcount', 0, 'number');
				}
			}
		}
	}
};

QBOX.QCELL.BasicQCELL.prototype._getTopRowOfScreen = function(){
	//실제 화면에서 보이는 첫번째 normalRow의 인덱스 번호를 반환한다.
	var objVSInfo = this.attr('vsinfo');
	
	if(objVSInfo.bVScroll === false || objVSInfo.nPos <= objVSInfo.nLastPos - objVSInfo.nAdjustRows){//보정구간에 있을 때
		return objVSInfo.nTopRow;
	} else{
		var arrNormalRowsCellDOMs = this._getCellGroupDOMs('row', 'normal'),
		objLayoutSize = this.attr('layoutsize'),
		nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'),
		nFrozenRowsHeight = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
		nTopBoundary = /*frozencols영역의 width*/nFrozenRowsHeight,
		nLength = arrNormalRowsCellDOMs.length,
		i = 0,
		nRow;
		
		while(i < nLength){
			var heCell = arrNormalRowsCellDOMs[i][0];
			
			if(heCell.offsetTop + heCell.offsetHeight > nTopBoundary){
				nRow = parseInt(heCell.getAttribute('data-row'));
				break;
			}
			
			i += 1;
		}
		
		return nRow;
	}
};

QBOX.QCELL.BasicQCELL.prototype._getBottomRowOfScreen = function(){
	//실제 화면에서 보이는 마지막 normalRow의 인덱스 번호를 반환한다.
	var objVSInfo = this.attr('vsinfo');
	
	if(objVSInfo.bVScroll === false || objVSInfo.nPos === objVSInfo.nLastPos){
		return objVSInfo.nBottomRow;
	} else{
		var arrNormalRowsCellDOMs = this._getCellGroupDOMs('row', 'normal'),
		objLayoutSize = this.attr('layoutsize'),
		nFrozenBottomRows = this.attr('frozenbottomrows'), nRows = this.attr('rows'),
		nFrozenBottomRowsHeight = nFrozenBottomRows === 0 ? 0 : (this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1)),
		nBottomBoundary = objLayoutSize.viewport.offsetHeight - nFrozenBottomRowsHeight,
		nLength = arrNormalRowsCellDOMs.length,
		i = 0,
		nRow = -1;
		
		arrNormalRowsCellDOMs.reverse();
		
		while(i < nLength){
			var heCell = arrNormalRowsCellDOMs[i][0];
			
			if(heCell.offsetTop < nBottomBoundary){
				nRow = parseInt(heCell.getAttribute('data-row'));
				break;
			}
			
			i += 1;
		}
		
		return nRow;
	}
};
QBOX.QCELL.BasicQCELL.prototype.onScrollTop = function(){
	this._trigger('scrolltop');

};
QBOX.QCELL.BasicQCELL.prototype.onScrollBottom = function(){
	this._trigger('scrollbottom');

};



QBOX.QCELL.BasicQCELL.prototype._getDefaultRemoveArea = function(nCol){
	if(this.attr('defaultremovearea') === null){
		var heDiv = document.createElement('div');
		this.attr('defaultremovearea', this._createDefaultRemoveArea(heDiv), 'jquery');
	}
	
	if(this._getQCellCol(nCol).attr('colremovearea') === null){
		this._getQCellCol(nCol).attr('colremovearea', this.attr('defaultremovearea').clone(true), 'jquery');
	}
	
	return this._getQCellCol(nCol).attr('colremovearea').get(0);
};
QBOX.QCELL.BasicQCELL.prototype._createDefaultRemoveArea = function(heDiv){
	var css = QBOX.QCELL.def.css,
	heSortArea = heDiv.cloneNode(),
	headerRowHeight = this.attr('rowheight').header;
	
	heSortArea.className += css.REMOVE_AREA;
	heSortArea.style.top = (headerRowHeight - (headerRowHeight / 2 ) -7) + 'px';
	
	return QBOX.$(heSortArea);
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description QCELL의 모든 설정을 초기화하고 UI를 재생성합니다. 
 * @returns {boolean}
 * @example
 * QCell1.rebuild();
 */
QBOX.QCELL.BasicQCELL.prototype.rebuild = function(bUsePrevData){
	this.attr('useRebuildAPI',true,'boolean');
	var bRet = this._rebuild(bUsePrevData);
	this.attr('useRebuildAPI',false,'boolean');
	return bRet;
};
/**
 * @since QCELL v2.1.156
 * @author jklee
 * @description QCELL 의 크기 변경된 정보로 UI를 재구성 합니다. 
 * @returns {boolean}
 * @example
 * QCell1.resize();
 */
QBOX.QCELL.BasicQCELL.prototype.resize = function(bUsePrevData){
	this.attr('useRebuildAPI',true,'boolean');
	var objTreeState, objGroupState;
	if(this.attr('_treeProps') !== null){
	//	this.clearTree();	
		objTreeState = QBOX._.clone(this.attr('treestate'));
	}else if (this.attr('_groupProps') !== null){
		objGroupState= QBOX._.clone(this.attr('groupstate'));
		this.clearGroup();
	}		
	this.attr('isResizing' , true , 'boolean');
	var bRet = this._rebuild(true);
	this.refresh();
	
	if(this.attr('_treeProps') !== null){
		this.attr('treestate', objTreeState, 'object');
		this.setTree(this.attr('_treeProps'));		
	}else if (this.attr('_groupProps') !== null){
		this.attr('treestate', objGroupState, 'object');
		this.setGroup(this.attr('_groupProps'));
	}
	
	this.attr('useRebuildAPI',false,'boolean');
	return bRet;
};
QBOX.QCELL.BasicQCELL.prototype.setBottomPanelData = function(strData){
	var def = QBOX.QCELL.def, strID = this.attr('id'),
	spanId = '#'+def.areaname.SHEETPANEL + '-span-' + strID;
	
	if(document.getElementById(def.areaname.SHEETPANEL + '-span-' + strID) === null)
		return false;
	
	$(spanId).html(strData);
	
	return true;
};

/**
 * @since QCELL v2.1.7
 * @author seongdeuk1985
 * @description QCELL의 현재 화면을 갱신합니다.
 * @returns {boolean}
 * @example
 * QCell1.refresh();
 */
QBOX.QCELL.BasicQCELL.prototype.refresh = function(){
	return this._refresh();
};
/**
 * @since QCELL v2.1.147
 * @author jklee
 * @description 그리드를 초기화 한다..
 * @returns {boolean}
 * @example
 * QCell1.initGrid();
 */
QBOX.QCELL.BasicQCELL.prototype.initGrid = function(bUsePrevData){
	this.attr('useInitProp',true, 'boolean');
	var bRet = this._rebuild(bUsePrevData);
	this.attr('useInitProp',false, 'boolean');
	return bRet;
};
/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description QCELL의 ID를 반환합니다.
 * @returns {string}
 * @example
 * var strID = QCell1.getID();
 */
QBOX.QCELL.BasicQCELL.prototype.getID = function(){
	return this.attr('id');
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 조건에 해당하는 행(또는 열) 인덱스를 반환합니다.
 * @param {string} axis - 인덱스 종류 ("row" | "col")
 * @param {string} [type="focus"] - 인덱스 타입 ("cursor" | "drag" | "click" | "focus")
 * @param {string} [point_of_time="current"] - 인덱스 시점 ("previous" | "current")
 * @returns {number}
 * @example
 * QCell1.getIdx("row");	//포커스 셀의 행 인덱스 반환
 * QCell1.getIdx("col");	//포커스 셀의 열 인덱스 반환
 * QCell1.getIdx("row", "cursor");	//커서가 위치한 셀의 행 인덱스 반환
 * QCell1.getIdx("col", "click");	//마우스 왼쪽 클릭이 발생한 열 인덱스 반환
 */
QBOX.QCELL.BasicQCELL.prototype.getIdx = function(axis, type, point_of_time){
	var strAPI = this.attr('id') + '.getIdx';
		
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		type = type === undefined ? 'focus' : type;
		point_of_time = point_of_time === undefined ? 'current' : point_of_time;
		
		if(typeof axis === 'string' && typeof type === 'string'){
			if(point_of_time === 'previous'){
				return this._idx(axis, type, point_of_time);
			}
			
			return this._idx(axis, type);
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return -1;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 영역에 해당하는 행의 개수를 반환합니다.
 * @param {string} [type="all"] - 영역 구분 ("all" | "header" | "data" | "frozen" | "frozenbottom")
 * @returns {number}
 * @example
 * QCell1.getRows();		//전체 행의 개수 반환
 * QCell1.getRows("data");		//헤더영역을 제외한 데이터를 표시하는 전체 행의 개수 반환
 * QCell1.getRows("frozen");	//틀고정 된 행(FrozenRows)의 개수 반환
 */
QBOX.QCELL.BasicQCELL.prototype.getRows = function(type){
	var strAPI = this.attr('id') + '.getRows',
	nRows = 0;
	
	if(type === undefined){
		type = 'all';
	}
	
	if(typeof type === 'string'){
		switch(type){
			case 'header': {
				nRows = this.attr('headerrows');
				break;
			}
			case 'data': {
				nRows = this.attr('rows') - this.attr('headerrows');
				break;
			}
			case 'frozen': {
				nRows = this.attr('frozenrows');
				break;
			}
			case 'frozenbottom': {
				nRows = this.attr('frozenbottomrows');
				break;
			}
			case 'footer': {
				nRows = this.attr('footerrows');
				break;
			}
			case 'all': {
				nRows = this.attr('rows');
				break;
			}
		}
	} else{
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
	}
	
	return nRows;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 영역에 해당하는 열의 개수를 반환합니다.
 * @param {string} [type="all"] - 영역 구분 ("all" | "header" | "data" | "frozen" | "hidden")
 * @returns {number}
 * @example
 * QCell1.getCols();		//전체 열의 개수 반환
 * QCell1.getCols("data");		//헤더영역을 제외한 데이터를 표시하는 전체 열의 개수 반환
 * QCell1.getCols("frozen");	//틀고정 된 열(FrozenRows)의 개수 반환
 */
QBOX.QCELL.BasicQCELL.prototype.getCols = function(type){
	var strAPI = this.attr('id') + '.getCols',
	nCols = 0;
	
	if(type === undefined){
		type = 'nomal';
	}
	
	if(typeof type === 'string'){
		switch(type){
			case 'header': {
				nCols = this.attr('headercols');
				break;
			}
			case 'data': {
				nCols = this.attr('cols') - this.attr('headercols');
				break;
			}
			case 'frozen': {
				nCols = this.attr('frozencols');
				break;
			}
			case 'frozenright' : {
				nCols = this.attr('frozenrightcols');
				break;			
			}
			case 'hidden' :{
				nCols = this.attr('hiddencolsprops') !== null ? this.attr('hiddencolsprops').length : 0;
				break;
			}
			case 'nomal': {
				nCols = this.attr('cols') ;
				break;
			}			
			case 'all': {
				nCols = this.attr('cols') + (this.attr('hiddencolsprops') !== null  && this.attr('hiddencolsprops') !== undefined ? this.attr('hiddencolsprops').length : 0);
				break;
			}
		}
	} else{
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
	}
	
	return nCols;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 영역의 행 높이를 반환합니다.
 * @param {string} type - 영역 구분 ("header" | "data")
 * @returns {number}
 * @example
 * QCell1.getRowHeight("header");
 */
QBOX.QCELL.BasicQCELL.prototype.getRowHeight = function(type){
	var strAPI = this.attr('id') + '.getRowHeight',
	nRowHeight = 0;
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof type === 'string'){
			switch(type){
				case 'header': case 'data': case 'footer':{
					nRowHeight = this.attr('rowheight')[type];
					break;
				}
				default: break;
			}
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return nRowHeight;
};

/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description 전체 열의 너비값을 배열로 반환합니다.
 * @returns {Array}
 * @example
 * QCell1.getColWidths();
 */
QBOX.QCELL.BasicQCELL.prototype.getColWidths = function(){
	return this.attr('colwidthsperpixel');
};

/**
 * @since QCELL v1.1.0
 * @author sai1515
 * @description 입력받은 "key" 속성값이 설정된 열들의 인덱스를 배열로 반환합니다.
 * @param {string} key - "key" 속성값
 * @returns {Array}
 * @example
 * QCell1.getColsOfKey("name");
 */
QBOX.QCELL.BasicQCELL.prototype.getColsOfKey = function(key){
	var strAPI = this.attr('id') + '.getColsOfKey';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof key === 'string'){
			return this.attr('colkeysinfo').get(key) === null ? []:this.attr('colkeysinfo').get(key).values();
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return [];
};
/**
 * @since QCELL v2.1.77
 * @author sai1515
 * @description 입력받은 "key" 속성값이 설정된 열들의 인덱스를 넘버로 반환합니다.
 * @param {string} key - "key" 속성값
 * @returns {Number}
 * @example
 * QCell1.getColOfKey("name");
 */
QBOX.QCELL.BasicQCELL.prototype.getColOfKey = function(key){
	var strAPI = this.attr('id') + '.getColOfKey';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof key === 'string'){
			if(this.attr('colkeysinfo').get(key) === null)
				return -1;
			
			return this.attr('colkeysinfo').get(key).values()[0];
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return [];
};
/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description 입력받은 열 인덱스에 해당하는 열에 설정된 "key" 속성값을 반환합니다.
 * @param {number} col - 열 인덱스
 * @returns {string}
 * @example
 * QCell1.getKeyOfCol(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getKeyOfCol = function(col){
	var strAPI = this.attr('id') + '.getKeyOfCol';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof col === 'number'){
			return this._getKeyOfCol(col);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return '';
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 열 인덱스의 열 ID를 반환합니다.
 * @param {number} col - 열 인덱스
 * @returns {string}
 * @example
 * QCell1.getColID(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getColID = function(col){
	var strAPI = this.attr('id') + '.getColID';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof col === 'number'){
			return this._getColID(col);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return '';
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 열 ID에 해당하는 열 인덱스를 반환합니다.
 * @param {string} id - 열 ID
 * @returns {number}
 * @example
 * QCell1.getColOfID("col_3");
 */
QBOX.QCELL.BasicQCELL.prototype.getColOfID = function(id){
	var strAPI = this.attr('id') + '.getColOfID';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof id === 'string'){
			return this._getColOfID(id);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return -1;
};

/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description 입력한 열 인덱스에 해당하는 열의 너비를 반환합니다.(단위: pixel)
 * @param {number} col - 너비를 반환할 열 인덱스
 * @returns {number}
 * @example
 * QCell1.getColWidth(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getColWidth = function(col){
	var strAPI = this.attr('id') + '.getColWidth';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof col === 'number'){
			return this._getColWidth(col);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return -1;
};
/**
 * @since QCELL v2.1.158
 * @author jklee
 * @description 입력한 열 인덱스에 해당하는 열의 너비를 반환합니다.(단위: pixel)
 * @param {string} key - 너비를 반환할 열 인덱스
 * @returns {number}
 * @example
 * QCell1.getColWidthEx('test');
 */
QBOX.QCELL.BasicQCELL.prototype.getColWidthEx = function(col){
	var strAPI = this.attr('id') + '.getColWidthEx';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof col === 'number'){
			return this._getColWidth(col);
		} else if (typeof col === 'string'){
			var nCol = this.getColOfKey(col);
			
			if(nCol === -1){
				var arrHCol = this.attr('hiddencolsprops');
				
				if(arrHCol !== undefined && arrHCol !== null){
					for(var i=0;i<arrHCol.length ; i++){
						if(arrHCol[i].key === col){
							if(typeof arrHCol[i].width === 'string'){
								arrHCol[i].width=QBOX.util.replaceAll(arrHCol[i].width,'px','');
								arrHCol[i].width=QBOX.util.replaceAll(arrHCol[i].width,'%','');
								arrHCol[i].width = Number(arrHCol[i].width);
								if(isNaN(arrHCol[i].width))
									arrHCol[i].width = 0;
							}
							return arrHCol[i].width;
						}
					}
					
				}	
				return -1;
			}else{
				return this.getColWidth(nCol);
			}
		}else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return -1;
};


/**
 * @since QCELL v2.1.1
 * @author sonymaker
 * @description 입력받은 열 인덱스에 해당하는 컬럼의 넓이를 변경합니다.(단위: pixel)
 * @param {number} col - 열 인덱스
 * @param {number} colwidth - 컬럼의 넓이 설정(최소값: 15)
 * @returns {boolean}
 * @example
 * QCell1.setColWidth(3, 200);
 */
QBOX.QCELL.BasicQCELL.prototype.setColWidth = function(col, colwidth){
	var strAPI = this.attr('id') + '.setColWidth';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof col === 'number' && typeof colwidth === 'number'){
			return (col < this.attr('cols') && col >= this.attr('headercols')) ? this._setColWidth(col, colwidth) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.158
 * @author jklee
 * @description 입력받은 열 인덱스에 해당하는 컬럼의 넓이를 변경합니다.(단위: pixel)
 * @param {string} key - 열 인덱스
 * @param {number} colwidth - 컬럼의 넓이 설정(최소값: 15)
 * @returns {boolean}
 * @example
 * QCell1.setColWidthEx('test', 200);
 */
QBOX.QCELL.BasicQCELL.prototype.setColWidthEx = function(key, colwidth){
	var strAPI = this.attr('id') + '.setColWidthEx';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		var col = this.getColOfKey(key);
		if(col !== -1){
			return this.setColWidth(col,colwidth);
		}else{
			var arrHCol = this.attr('hiddencolsprops');
			
			if(arrHCol !== undefined && arrHCol !== null){
				for(var i=0;i<arrHCol.length ; i++){
					if(arrHCol[i].key === key){
						arrHCol[i].width = colwidth;
						return true;
					}
				}
				
			}	
			
			return false;
		}
	
	}
	
	return false;
};
/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description 입력한 열 인덱스에 해당하는 열의 타입을 반환합니다.
 * @param {number} col - 타입을 반환할 열 인덱스 
 * @returns {String}
 * @example
 * QCell1.getColType(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getColType = function(col){
	var strAPI = this.attr('id') + '.getColType';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof col === 'number'){
			return this._getColType(col);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return '';
};

/**
 * @since QCELL v2.1.64
 * @author nightow85
 * @description 입력받은 열 인덱스에 해당하는 열에 Format을 설정합니다.
 * @param {number} nCol - Format을 설정할 열 인덱스 
 * @param {Object} formatstatic - 설정할 Format 
 * @returns {boolean}
 * @example
 * QCell1.setColFormatStatic(4, {type: "string", rule:"@ 님"});
 */
QBOX.QCELL.BasicQCELL.prototype.setColFormatStatic = function(nCol, formatstatic){
	var strAPI = this.attr('id') + '.setColFormatStatic';
	
	if(arguments.length < 2){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
		return false;
	} else{
		if(typeof nCol === 'number'){
			return this._setFormatStatic(nCol, formatstatic);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
			return false;
		}
	}
};

/**
 * @since QCELL v2.1.84
 * @author sai1515
 * @description 입력한 열 인덱스에 해당하는 열의 속성을 반환한다..
 * @param {number} col - 타입을 반환할 열 인덱스
 * @param {string} attribute - 가져올 속성 명칭  
 * @returns {String}
 * @example
 * QCell1.getColType(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getColAttribute = function(col,strName){
	var strAPI = this.attr('id') + '.getColAttribute';
	
	if(arguments.length < 2){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof col === 'number'){
			if(this._getQCellCol(col) !== undefined)
				return this._getQCellCol(col).attr(strName);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return '';
};
/**
 * @since QCELL v2.1.97
 * @author jklee
 * @description 고정열 인텍스를 반환한다.
 * @returns {Number}
 * @example
 * QCell1.getFrozenRows();
 */
QBOX.QCELL.BasicQCELL.prototype.getFrozenRows = function(){
	return this.attr('frozenrows');
};
/**
 * @since QCELL v2.1.97
 * @author jklee
 * @description 고정행을 새로 설정 한다.
 * @param {number} nIndex - 타입을 반환할 열 인덱스 
 * @returns {boolean}
 * @example
 * QCell1.getColType(3);
 */
QBOX.QCELL.BasicQCELL.prototype.setFrozenRows = function(nIndex){
	var strAPI = this.attr('id') + '.setFrozenRows';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof nIndex === 'number'){
			var objProp = this.getProperties(); 
			objProp.frozenrows = nIndex;
			
			this._rebuild();
			return true;
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.97
 * @author jklee
 * @description 고정행 인텍스를 반환한다.
 * @returns {Number}
 * @example
 * QCell1.getFrozenCols();
 */
QBOX.QCELL.BasicQCELL.prototype.getFrozenCols = function(){
	return this.attr('frozencols');
};

/**
 * @since QCELL v2.1.97
 * @author jklee
 * @description 고정열을 새로 설정 한다.
 * @param {number} nIndex - 타입을 반환할 열 인덱스 
 * @returns {boolean}
 * @example
 * QCell1.setFrozenCols(3);
 */
QBOX.QCELL.BasicQCELL.prototype.setFrozenCols = function(nIndex){
	var strAPI = this.attr('id') + '.setFrozenCols';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof nIndex === 'number'){
			var objProp = this.getProperties(); 
			objProp.frozencols = nIndex;
			
			this._rebuild();
			return true;
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	
	return false;
};
/**
 * @since QCELL v2.1.153
 * @author jklee
 * @description 오른쪽 고정열 인텍스를 반환한다.
 * @returns {Number}
 * @example
 * QCell1.getFrozenRightCols();
 */
QBOX.QCELL.BasicQCELL.prototype.getFrozenRightCols = function(){
	return this.attr('frozenrightcols');
};

/**
 * @since QCELL v2.1.153
 * @author jklee
 * @description 고정열을 새로 설정 한다.
 * @param {number} nIndex - 타입을 반환할 열 인덱스 
 * @returns {boolean}
 * @example
 * QCell1.setFrozenRightCols(3);
 */
QBOX.QCELL.BasicQCELL.prototype.setFrozenRightCols = function(nIndex){
	var strAPI = this.attr('id') + '.setFrozenRightCols';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof nIndex === 'number'){
			var objProp = this.getProperties(); 
			objProp.frozenrightcols = nIndex;
			
			this._rebuild();
			return true;
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	
	return false;
};
/**
 * @since QCELL v2.1.97
 * @author jklee
 * @description 하단 고정행 인텍스를 반환한다.
 * @returns {Number}
 * @example
 * QCell1.getFrozenBottomRows();
 */
QBOX.QCELL.BasicQCELL.prototype.getFrozenBottomRows = function(){
	return this.attr('frozenbottomrows');
};

/**
 * @since QCELL v2.1.97
 * @author jklee
 * @description 하단 고정행을 새로 설정 한다.
 * @param {number} nIndex - 타입을 반환할 열 인덱스 
 * @returns {boolean}
 * @example
 * QCell1.getColType(3);
 */
QBOX.QCELL.BasicQCELL.prototype.setFrozenBottomRows = function(nIndex){
	var strAPI = this.attr('id') + '.setFrozenBottomRows';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof nIndex === 'number'){
			var objProp = this.getProperties();			
			objProp.frozenbottomrows = nIndex;
			
			this._rebuild();
			return true;
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.147
 * @author jklee
 * @description 컬럼을 삭제 한다.
 * @param {number} nCol - 삭제할 컬럼 정보 
 * @returns {boolean}
 * @example
 * QCell1.removeColumn(3);
 */
QBOX.QCELL.BasicQCELL.prototype.removeColumn = function(nCol){
	var strAPI = this.attr('id') + '.removeColumn';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof nCol === 'number'){
			
			if(this._getQCellCol(nCol) !== null && this._getQCellCol(nCol).attr('removecallback') !==null &&
					QBOX._.isFunction(this._getQCellCol(nCol).attr('removecallback'))===true){				
				if(this._getQCellCol(nCol).attr('removecallback')(nCol) === false){					
					return false;
				}
			}
					
			
			var objProp = this.getProperties(); 
			var nHeadercols = this.attr('headercols');			
			nCol = nCol - nHeadercols;
			
			if(objProp.columns.length <= nCol || nCol < 0 || objProp.columns.length <=0)
				return false;
			objProp.columns.splice(nCol,1);
			this._rebuild(true);
			
			var THAT =this;
			setTimeout(function(){
				if(THAT._trigger !== undefined)
					THAT._trigger("removeend");
			}, 0);
			return true;
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.147
 * @author jklee
 * @description 컬럼을 추가 한다.
 * @param {number} nCol - 추가할 컬럼 위치 
 * @param {object} objCol - 추가할 컬럼 정보
 * @returns {boolean}
 * @example
 * QCell1.insertColumn(3,{width : 150, title : ['시군구'],		key : 'cdwNm'});
 */
QBOX.QCELL.BasicQCELL.prototype.insertColumn = function(nCol,objCol){
	var strAPI = this.attr('id') + '.insertColumn';
	
	if(arguments.length < 2){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof nCol === 'number' && QBOX._.isObject(objCol)){
			var objProp = this.getProperties(); 
			var nHeadercols = this.attr('headercols');			
			nCol = nCol - nHeadercols;
			
			if(objProp.columns.length < nCol || nCol < 0 || objProp.columns.length <=0)
				return false;
			objProp.columns.RT_insert(nCol,objCol);
			this._rebuild(true);
			return true;
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.158
 * @author jklee
 * @description 컬럼을 생성 시점으로 초기화 한다.
 * @returns {boolean}
 * @example
 * QCell1.resetColumns();
 */
QBOX.QCELL.BasicQCELL.prototype.resetColumns = function(){
	var strAPI = this.attr('id') + '.resetColumns';
	

	
	var objProp = this.getProperties(); 
	var objInit = this.getInitProperties();
	

	objProp.columns = QBOX._.clone(objInit.columns);
	this._rebuild(true);
	return true;
	

};

/**
 * @since QCELL v2.1.147
 * @author jklee
 * @description 현재 컬럼의 정보를 얻는다.
 * @param {number} nCol - 정보를 얻을 컬럼 정보 
 * @returns {object}
 * @example
 * QCell1.getColumnInfo(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getColumnInfo = function(nCol){
	var strAPI = this.attr('id') + '.getColumnInfo';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof nCol === 'number'){
			var objProp = this.getProperties(); 
			var nHeadercols = this.attr('headercols');			
			nCol = nCol - nHeadercols;
			
			if(objProp.columns.length <= nCol || nCol < 0 || objProp.columns.length <=0)
				return null;			
			
			return objProp.columns[nCol];
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return null;
};
/**
 * @since QCELL v2.1.155
 * @author jklee
 * @description 현재 컬럼들의 최신 정보를 얻는다.
 * @returns {Array}
 * @example
 * QCell1.getCurrentColumnsInfo(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getCurrentColumnsInfo = function(){
	var arrRet = [],nHeaderCols = this.attr('headercols'), nCols = this.attr('cols');
	
	for(var i = nHeaderCols; i< nCols ; i++){
		var obj={}, objPrev = this._getColPrevProperty(i);
		
		for(var strKey in objPrev){
			if(strKey === 'format'){
				if(objPrev.format.type === '' && objPrev.format.rule === '')
					continue;
			}
			if(strKey === 'html'){
				if(objPrev.html.data === null && objPrev.html.header === null)
					continue;
			}
			
			if(strKey === 'header_text_align' || strKey === 'id' || strKey === 'invisibled' ||
					strKey === 'parent')
					continue;
			
			if(strKey === 'width'){
				obj[strKey] = this.getColWidth(i) +'px';
			}else{
				obj[strKey] = objPrev[strKey];
			}
			
			
			
		}
		
		arrRet.push(obj);
		
		
	}
	
	return arrRet;
	
};



/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 행 스타일을 반복하여 적용하는 "highlightrepeat" 속성의 값을 반환합니다.
 * @returns {number}
 * @example
 * var nHighlightRepeat = QCell1.getHighlightRepeat();
 */
QBOX.QCELL.BasicQCELL.prototype.getHighlightRepeat = function(){
	return this.attr('highlightrepeat');
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 행 스타일을 반복하여 적용하는 "highlightrepeat" 속성의 주기를 설정합니다.
 * @param {number} cycle - 스타일 반복 주기
 * @returns {boolean}
 * @example
 * QCell1.setHighlightRepeat(3);
 */
QBOX.QCELL.BasicQCELL.prototype.setHighlightRepeat = function(cycle){
	var strAPI = this.attr('id') + '.setHighlightRepeat';
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof cycle === 'number'){
			return (cycle >= 0) ? this._setHighlightRepeat(cycle) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 열의 셀에 "셀 단위 스타일"을 설정합니다.
 * @param {number} col - 열 인덱스
 * @param {Object} style - CSS 스타일
 * @param {string} [type="all"] - 영역 구분 ("all" | "header" | "data")
 * @returns {boolean}
 * @example
 * QCell1.setColStyle(3, {"background-color" : "red", "border-color" : "red"});
 * QCell1.setColStyle(3, {"font-weight" : "bold"}, "header");
 */
QBOX.QCELL.BasicQCELL.prototype.setColStyle = function(col, style, type){
	var strAPI = this.attr('id') + '.setColStyle';
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		type = type === undefined ? 'all' : type;
		
		if(typeof col === 'number' && typeof style === 'object' && typeof type === 'string'){
			return (col < this.attr('cols') && col >= 0) ? this._setColStyle(col, style, type, true) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 열의 셀에 설정된 "셀 단위 스타일"을 제거합니다.
 * @param {number} col - 열 인덱스
 * @param {string} [type="all"] - 영역 구분 ("all" | "header" | "data")
 * @returns {boolean}
 * @example
 * QCell1.removeColStyle(3);
 * QCell1.removeColStyle(3, "header");
 */
QBOX.QCELL.BasicQCELL.prototype.removeColStyle = function(col, type){
	var strAPI = this.attr('id') + '.removeColStyle';
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		type = type === undefined ? 'all' : type;
		
		if(typeof col === 'number' && typeof type === 'string'){
			return (col < this.attr('rows') && col >= 0) ? this._removeColStyle(col, type, true) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 행의 셀에 "셀 단위 스타일"을 설정합니다.
 * @param {number} row - 행 인덱스
 * @param {Object} style - CSS 스타일
 * @param {string} [type="all"] - 영역 구분 ("all" | "header" | "data")
 * @returns {boolean}
 * @example
 * QCell1.setRowStyle(3, {"background-color" : "red", "border-color" : "red"});
 * QCell1.setRowStyle(3, {"font-weight" : "bold"}, "header");
 */
QBOX.QCELL.BasicQCELL.prototype.setRowStyle = function(row, style, type){
	var strAPI = this.attr('id') + '.setRowStyle';
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		type = type === undefined ? 'all' : type;
		
		if(typeof row === 'number' && typeof style === 'object' && typeof type === 'string'){
			return (row < this.attr('rows') && row >= 0) ? this._setRowStyle(row, style, type, true) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 행의 셀에 설정된 "셀 단위 스타일"을 제거합니다.
 * @param {number} row - 행 인덱스
 * @param {string} [type="all"] - 영역 구분 ("all" | "header" | "data")
 * @returns {boolean}
 * @example
 * QCell1.removeRowStyle(3);
 * QCell1.removeRowStyle(3, "header");
 */
QBOX.QCELL.BasicQCELL.prototype.removeRowStyle = function(row, type){
	var strAPI = this.attr('id') + '.removeRowStyle';
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		type = type === undefined ? 'all' : type;
		
		if(typeof row === 'number' && typeof type === 'string'){
			return (row < this.attr('rows') && row >= 0) ? this._removeRowStyle(row, type, true) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 인덱스의 셀에 설정된 "셀 단위 스타일" 정보를 반환합니다. ("열 단위 스타일"이 함께 설정된 경우라도 "셀 단위 스타일" 정보만을 반환합니다.)
 * @param {number} row - 행 인덱스
 * @param {number} col - 열 인덱스
 * @returns {Object}
 * @example
 * QCell1.getCellStyle(3, 5);
 */
QBOX.QCELL.BasicQCELL.prototype.getCellStyle = function(row, col){
	var strAPI = this.attr('id') + '.getCellStyle';
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{		
		if(typeof row === 'number' && typeof col === 'number'){
			return (row < this.attr('rows') && row >= 0 && col < this.attr('cols') && col >= 0) ? this._getCellStyle(row, col) : {};
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return {};
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 셀에 "셀 단위 스타일"을 설정합니다.
 * @param {number} row - 행 인덱스
 * @param {number} col - 열 인덱스
 * @param {Object} style - CSS 스타일
 * @returns {boolean}
 * @example
 * QCell1.setCellStyle(3, 5, {"background-color" : "red", "border-color" : "red"});
 */
QBOX.QCELL.BasicQCELL.prototype.setCellStyle = function(row, col, style){
	var strAPI = this.attr('id') + '.setCellStyle';
	
	if(arguments.length < 3){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{		
		if(typeof row === 'number' && typeof col === 'number' && typeof style === 'object'){
			return (row < this.attr('rows') && row >= 0 && col < this.attr('cols') && col >= 0) ? this._setCellStyle(row, col, style, true) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 범위 내의 셀들에 "셀 단위 스타일"을 설정합니다.
 * @param {number} firstrow - 설정할 범위의 시작 행 인덱스
 * @param {number} firstcol - 설정할 범위의 시작 열 인덱스
 * @param {number} lastrow - 설정할 범위의 마지막 행 인덱스
 * @param {number} lastcol - 설정할 범위의 마지막 열 인덱스
 * @param {Object} style - CSS 스타일
 * @returns {boolean}
 * @example
 * QCell1.setCellStyles(3, 5, 10, 7, {"background-color" : "red", "border-color" : "red"});
 */
QBOX.QCELL.BasicQCELL.prototype.setCellStyles = function(firstrow, firstcol, lastrow, lastcol, style){
	var strAPI = this.attr('id') + '.setCellStyles';
	
	if(arguments.length < 5){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{		
		if(typeof firstrow === 'number' && typeof firstcol === 'number' && typeof lastrow === 'number' && typeof lastcol === 'number' && typeof style === 'object'){
			return (firstrow < this.attr('rows') && firstrow >= 0 && firstcol < this.attr('cols') && firstcol >= 0 && lastrow < this.attr('rows') && lastrow >= 0 && lastcol < this.attr('cols') && lastcol >= 0) ? this._setCellStyles(firstrow, firstcol, lastrow, lastcol, style, true) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 셀에 설정된 "셀 단위 스타일"을 제거합니다.
 * @param {number} row - 행 인덱스
 * @param {number} col - 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.removeCellStyle(3, 5);
 */
QBOX.QCELL.BasicQCELL.prototype.removeCellStyle = function(row, col){
	var strAPI = this.attr('id') + '.removeCellStyle';
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof col === 'number'){
			return (row < this.attr('rows') && row >= 0 && col < this.attr('cols') && col >= 0) ? this._removeCellStyle(row, col, true) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 범위 내의 셀들에 "셀 단위 스타일"을 제거합니다.
 * @param {number} firstrow - 제거할 범위의 시작 행 인덱스
 * @param {number} firstcol - 제거할 범위의 시작 열 인덱스
 * @param {number} lastrow - 제거할 범위의 마지막 행 인덱스
 * @param {number} lastcol - 제거할 범위의 마지막 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.removeCellStyles(3, 5, 10, 7);
 */
QBOX.QCELL.BasicQCELL.prototype.removeCellStyles = function(firstrow, firstcol, lastrow, lastcol){
	var strAPI = this.attr('id') + '.setCellStyles';
	
	if(arguments.length < 4){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{		
		if(typeof firstrow === 'number' && typeof firstcol === 'number' && typeof lastrow === 'number' && typeof lastcol === 'number'){
			return (firstrow < this.attr('rows') && firstrow >= 0 && firstcol < this.attr('cols') && firstcol >= 0 && lastrow < this.attr('rows') && lastrow >= 0 && lastcol < this.attr('cols') && lastcol >= 0) ? this._removeCellStyles(firstrow, firstcol, lastrow, lastcol, true) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description QCELL에 적용된 모든 "셀 단위 스타일"을 제거합니다.
 * @returns {boolean}
 * @example
 * QCell1.clearCellStyles();
 */
QBOX.QCELL.BasicQCELL.prototype.clearCellStyles = function(){
	return this._clearCellStyles();
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description QCELL 생성 이후 적용된 모든 스타일변경사항("열 단위 스타일", "셀 단위 스타일", "highlightrepeat")을 초기화합니다.
 * @returns {boolean}
 * @example
 * QCell1.clearDynamicStyles();
 */
QBOX.QCELL.BasicQCELL.prototype.clearDynamicStyles = function(){
	return this._clearDynamicStyles();
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 가장 마지막에 선택된 셀의 행 인덱스를 반환합니다.
 * @returns {number}
 * @example
 * var nSelectedRow = QCell1.getSelectedRow();
 */
QBOX.QCELL.BasicQCELL.prototype.getSelectedRow = function(){
	return this._getSelectedRow();
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 가장 마지막에 선택된 셀의 열 인덱스를 반환합니다.
 * @returns {number}
 * @example
 * var nSelectedCol = QCell1.getSelectedCol();
 */
QBOX.QCELL.BasicQCELL.prototype.getSelectedCol = function(){
	return this._getSelectedCol();
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 선택된 셀들의 행 인덱스를 배열로 반환합니다.
 * @returns {Array}
 * @example
 * var arrSelectedRows = QCell1.getSelectedRows();
 */
QBOX.QCELL.BasicQCELL.prototype.getSelectedRows = function(){
	return this._getSelectedRows().sort(QBOX.st.asc);
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 선택된 셀들의 열 인덱스를 배열로 반환합니다.
 * @returns {Array}
 * @example
 * var arrSelectedCols = QCell1.getSelectedCols();
 */
QBOX.QCELL.BasicQCELL.prototype.getSelectedCols = function(){
	return this._getSelectedCols().sort(QBOX.st.asc);
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 열 인덱스에 해당하는 컬럼을 특정 위치로 이동시킵니다.
 * @param {number} beforecol - 이동하기 전의 열 인덱스
 * @param {number} aftercol - 이동한 후의 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.moveCol(3, 1);
 */
QBOX.QCELL.BasicQCELL.prototype.moveCol = function(beforecol, aftercol){
	var strAPI = this.attr('id') + '.moveCol';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof beforecol === 'number' && typeof aftercol === 'number'){
			return (beforecol < this.attr('cols') && beforecol >= this.attr('headercols') && aftercol < this.attr('cols') && aftercol >= this.attr('headercols')) ? this._moveCols(beforecol, 1, aftercol, false) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description 입력받은 행 인덱스로 세로 스크롤바의 scrollTop을 설정합니다.
 * @param {number} row - 행 인덱스
 * @returns {Array}
 * @example
 * QCell1.scrollTop(3);
 */
QBOX.QCELL.BasicQCELL.prototype.scrollTop = function(row){
	var strAPI = this.attr('id') + '.scrollTop';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number'){
			return (row < this.attr('rows') && row >= this.attr('headerrows')) ? this._scrollTop(row) : false;
		} else if(typeof row === 'string'){
			if(row === 'top'){
				this._scrollTop(this.attr('headerrows'));
				return true;
			}else if(row === 'bottom'){
				this._scrollTop(this.attr('rows')-1);
				return true;
			}
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
			return false;
		}
		else{		
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description 입력받은 열 인덱스로 가로 스크롤바의 scrollLeft를 설정합니다.
 * @param {number} col - 열 인덱스
 * @returns {Array}
 * @example
 * QCell1.scrollLeft(3);
 */
QBOX.QCELL.BasicQCELL.prototype.scrollLeft = function(col){
	var strAPI = this.attr('id') + '.scrollLeft';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof col === 'number'){
			return (col < this.attr('cols') && col >= this.attr('headercols')) ? this._scrollLeft(col) : false;
		} else if(typeof col === 'string'){
			if(col === 'left'){
				this._scrollLeft(this.attr('headercols'));
				return true;
			}else if (col === 'right'){
				this._scrollLeft(this.attr('cols')-1);
				return true;
			}
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
			return false;
			
		}else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description 입력받은 타입에 해당하는 스크롤바의 표시 여부를 반환합니다.
 * @param {string} type - 스크롤바 타입 {"vertical" | "horizontal"}
 * @returns {boolean}
 * @example
 * QCell1.isScroll("vertical");
 */
QBOX.QCELL.BasicQCELL.prototype.isScroll = function(type){
	var strAPI = this.attr('id') + '.isScroll',
	result = false;
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof type === 'string'){
			if(type === 'vertical'){
				result = this.attr('vsinfo').bVScroll;
			} else if(type === 'horizontal'){
				result = this.attr('hsinfo').bHScroll;
			}
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return result;
};
/**
 * @since QCELL v2.1.69
 * @author sai1515
 * @description 갱신된 화면 위치 반환
 * @param 
 * @returns {object}
 * @example
 * QCell1.getUpdateInfo();
 */
QBOX.QCELL.BasicQCELL.prototype.getUpdateInfo = function(){
	
	return {toprow : this.attr('vsinfo').nTopRow , bottomrow : this.attr('vsinfo').nBottomRow};
};

/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description QCELL의 데이터를 반환합니다.
 * @returns {Array}
 * @example
 * QCell1.getData();
 */
QBOX.QCELL.BasicQCELL.prototype.getData = function(){
	return this.attr('currentdata');
};
/**
 * @since QCELL v2.1.129
 * @author sai1515
 * @description QCELL의 모든 데이터를 반환합니다.
 * @returns {Array}
 * @example
 * QCell1.getAllData();
 */
QBOX.QCELL.BasicQCELL.prototype.getAllData = function(){
	return this.attr('data').input;
};
/**
 * @since QCELL v2.1.158
 * @author jklee
 * @description QCELL의 모든 데이터를 포멧이 적용 된 형태로 반환합니다.
 * @returns {Array}
 * @example
 * QCell1.getAllDataWithFormat();
 */
QBOX.QCELL.BasicQCELL.prototype.getAllDataWithFormat = function(){
	var arrRet = [];
	for(var i=this.getRows('header') ; i< this.getRows() ; i++){
		arrRet.push(this.getRowDataWithFormat(i));
	}
	return arrRet;
};
/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description 입력받은 데이터로 QCELL 데이터를 갱신합니다.
 * @param {Array} data - 갱신할 데이터
 * @returns {boolean}
 * @example
 * QCell1.setData([{"name" : "kevin", "age" : "35"},{"name" : "tom", "age" : "21"}]);	//QCELL의 data 타입이 "object"인 경우
 * QCell1.setData([["kevin", "35"],["tom", "21"]]);			//QCELL의 data 타입이 "array"인 경우
 */
QBOX.QCELL.BasicQCELL.prototype.setData = function(data){
	var strAPI = this.attr('id') + '.setData';
	
	if(arguments.length < 1){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isArray(data)){
			if(this._checkData(data))
				return true;
			
			return this._setData(data);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 행 인덱스의 "행 단위 데이터"를 객체(또는 배열)로 반환합니다.
 * @param {number} row - 행 인덱스
 * @returns {Object | Array | undefined}
 * @example
 * var rowdata = QCell1.getRowData(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getRowData = function(row){
	var strAPI = this.attr('id') + '.getRowData';
	
	if(arguments.length < 1){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(typeof row === 'number') {
			return (row < this.attr('rows') && row >= this.attr('headerrows')) ? this._getRowData(row) : undefined;
		} else {
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return undefined;
};

/**
 * @since QCELL v2.1.158
 * @author jklee
 * @description 입력받은 행 인덱스의 "행 단위 데이터"를 format 이 적용되어 객체(또는 배열)로 반환합니다.
 * @param {number} row - 행 인덱스
 * @returns {Object | Array | undefined}
 * @example
 * var rowdata = QCell1.getRowDataWithFormat(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getRowDataWithFormat = function(row){
	var strAPI = this.attr('id') + '.getRowDataWithFormat';
	
	if(arguments.length < 1){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(typeof row === 'number') {
			return (row < this.attr('rows') && row >= this.attr('headerrows')) ? this._getRowDataWithFormat(row) : undefined;
		} else {
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return undefined;
};
/**
 * @since QCELL v2.1.129
 * @author jklee
 * @description 현재 선택되어진 행 인덱스의 "행 단위 데이터"를 객체(또는 배열)로 반환합니다.
 * @returns {Object | Array | undefined}
 * @example
 * var rowdata = QCell1.getSelectedRowData();
 */
QBOX.QCELL.BasicQCELL.prototype.getSelectedRowData = function(){
	var strAPI = this.attr('id') + '.getSelectedRowData';
	
	var arrRows = this._getIdxInfo('selected', 'row').keys().sort();
	var arrRet = [];
	for (var i=0; i < arrRows.length ; i++){
		arrRet.push(this.getRowData(arrRows[i]));
	}
	
	return arrRet;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 행 인덱스의 "행 단위 데이터"를 갱신합니다.
 * @param {number} row - 행 인덱스
 * @param {Object | Array} data - 행 단위 데이터
 * @returns {boolean}
 * @example
 * QCell1.setRowData(3, {"name" : "kevin", "age" : "35"});	//QCELL의 data 타입이 "object"인 경우
 * QCell1.setRowData(4, ["kevin", "35"]);			//QCELL의 data 타입이 "array"인 경우
 */
QBOX.QCELL.BasicQCELL.prototype.setRowData = function(row, data){
	var strAPI = this.attr('id') + '.setRowData';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		var strDataType = this.attr('data').type;
		
		if(typeof row === 'number' && (strDataType === 'array' && QBOX._.isArray(data)) || (strDataType === 'object' && typeof data === 'object' && QBOX._.isArray(data) === false)){
			var bRet = (row < this.attr('rows') && row >= this.attr('headerrows')) ? this._setRowData(row, data) : false;
			if(bRet !== false && this.attr('setstatewithapi') === true){
				this._setRowState(row,'u');
			}
			return bRet;

		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.152
 * @author sonymaker
 * @description 입력받은 행 인덱스의 "행 단위 데이터"를 갱신합니다.
 * @param {number} row - 행 인덱스
 * @param {Object | Array} data - 행 단위 데이터
 * @returns {boolean}
 * @example
 * QCell1.setRowDataEx(3, {"name" : "kevin", "age" : "35"});	//QCELL의 data 타입이 "object"인 경우
 * QCell1.setRowDataEx(4, ["kevin", "35"]);			//QCELL의 data 타입이 "array"인 경우
 */
QBOX.QCELL.BasicQCELL.prototype.setRowDataEx = function(row, data){
	var strAPI = this.attr('id') + '.setRowData';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		var strDataType = this.attr('data').type;
		
		if(typeof row === 'number' && (strDataType === 'array' && QBOX._.isArray(data)) || (strDataType === 'object' && typeof data === 'object' && QBOX._.isArray(data) === false)){
			var bRet = (row < this.attr('rows') && row >= this.attr('headerrows')) ? this._setRowDataEx(row, data) : false;
			if(bRet !== false && this.attr('setstatewithapi') === true){
				this._setRowState(row,'u');
			}			
			
			return bRet;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v1.0.0
 * @author seongdeuk1985
 * @description 입력받은 열의 "열 단위 데이터"를 배열로 반환합니다.
 * @param {number} col - 열 인덱스
 * @returns {Array}
 * @example
 * QCell1.getColData(3);
 */
QBOX.QCELL.BasicQCELL.prototype.getColData = function(col){
	var strAPI = this.attr('id') + '.getColData';
	
	if(arguments.length < 1){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(typeof col === 'number') {
			return (col < this.attr('cols') && col >= this.attr('headercols')) ? this._getColData(col) : [];
		} else {
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return [];
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 열 인덱스의 "열 단위 데이터"를 갱신합니다.
 * @param {number} col - 열 인덱스
 * @param {Array} data - 열 단위 데이터
 * @returns {boolean}
 * @example
 * QCell1.setColData(4, ["kevin", "james"]);
 */
QBOX.QCELL.BasicQCELL.prototype.setColData = function(col, data){
	var strAPI = this.attr('id') + '.setColData';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof col === 'number' && QBOX._.isArray(data)){
			
			var bRet =(col < this.attr('cols') && col >= this.attr('headercols')) ? this._setColData(col, data) : false;

			return bRet;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 행,열 인덱스에 해당하는 셀의 데이터를 반환합니다.
 * @param {number} row - 셀의 행 인덱스
 * @param {number} col - 셀의 열 인덱스
 * @returns {*}
 * @example
 * QCell1.getCellData(3, 1);
 */
QBOX.QCELL.BasicQCELL.prototype.getCellData = function(row, col){
	var strAPI = this.attr('id') + '.getCellData';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof col === 'number'){
			return (row < this.attr('rows') && row >= this.attr('headerrows') && col < this.attr('cols') && col >= this.attr('headercols')) ? this._cellValue(row, col) : undefined;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return undefined;
};

/**
 * @since QCELL v2.1.88
 * @author jklee
 * @description 입력받은 행,key 에 해당하는 셀의 데이터를 반환합니다.
 * @param {number} row - 셀의 행 인덱스
 * @param {string} key - 셀의 Key
 * @returns {*}
 * @example
 * QCell1.getCellDataEx(3, 'name');
 */
QBOX.QCELL.BasicQCELL.prototype.getCellDataEx = function(row, key){
	var strAPI = this.attr('id') + '.getCellDataEx';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof key === 'string'){
			return (row < this.attr('rows') && row >= this.attr('headerrows') ) ? this._getRowData(row) [key] : undefined;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return undefined;
};

/**
 * @since QCELL v2.1.164
 * @author jklee
 * @description 입력받은 행,key 에 해당하는 셀의 초기 데이터를 반환합니다.
 * @param {number} row - 셀의 행 인덱스
 * @param {string} key - 셀의 Key
 * @returns {*}
 * @example
 * QCell1.getInitCellDataEx(3, 'name');
 */
QBOX.QCELL.BasicQCELL.prototype.getInitCellDataEx = function(row, key){
	var strAPI = this.attr('id') + '.getInitCellDataEx';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof key === 'string'){
			if(row < this.attr('rows') && row >= this.attr('headerrows') ){
				var obj = this._getRowData(row);
				
				if(obj.rt_qcell_initdata !== undefined)
					return obj.rt_qcell_initdata[key];
				else
					return this.getCellDataEx(row,key);
			}else{
				return undefined;
			}
			
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return undefined;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 행,열 인덱스에 해당하는 셀의 데이터를 갱신합니다.
 * @param {number} row - 셀의 행 인덱스
 * @param {number} col - 셀의 열 인덱스
 * @param {*} data - 셀 데이터
 * @returns {boolean}
 * @example
 * QCell1.setCellData(3, 1, "test");
 */
QBOX.QCELL.BasicQCELL.prototype.setCellData = function(row, col, data){
	var strAPI = this.attr('id') + '.setCellData';
	
	if(arguments.length < 3){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof col === 'number'){
			var bRet = (row < this.attr('rows') && row >= this.attr('headerrows') && col < this.attr('cols') && col >= this.attr('headercols')) ? this._cellValue(row, col, data) : false;
			if(bRet !== false && this.attr('setstatewithapi') === true){
				this._setRowState(row,'u');
			}			
			return bRet;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.88
 * @author jklee
 * @description 입력받은 행,Key 에 해당하는 셀의 데이터를 갱신합니다.
 * @param {number} row - 셀의 행 인덱스
 * @param {number} key - 셀의 열 인덱스
 * @param {*} data - 셀 데이터
 * @returns {boolean}
 * @example
 * QCell1.setCellDataEx(3, 'name', "test");
 */
QBOX.QCELL.BasicQCELL.prototype.setCellDataEx = function(row, key, data){
	var strAPI = this.attr('id') + '.setCellDataEx' , bRet = true;
	
	if(arguments.length < 3){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof key === 'string'){
			
			if(row > this.attr('rows') || row < this.attr('headerrows'))
				return false;
			
			var arrCols = this.getColsOfKey(key);
			
			if( arrCols.length > 0){
				var i;
				for(i = 0; i < arrCols.length ; i++){
					bRet = this.setCellData ( row,arrCols[i],data);	
				}
				return bRet;
			}
			
			
			objRowData = this.getRowData(row);
			if(objRowData !== undefined){
				objRowData[key] = data;			
				this.setRowData(row,objRowData);			
				return true;			
			}

		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};




/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description 지정한 셀의 현재 표기된 텍스트를 반환합니다.
 * @param {number} row - 데이터 반환할 셀의 행 인덱스
 * @param {number} col - 데이터 반환할 셀의 열 인덱스
 * @returns {*}
 * @example
 * QCell1.getCellLabel(3, 1);
 */
QBOX.QCELL.BasicQCELL.prototype.getCellLabel = function(row, col){
	var strAPI = this.attr('id') + '.getCellLabel';
	
	if(arguments.length < 2){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof col === 'number'){
			if((row >= 0 && row < this.attr('rows') && col >= 0 && col < this.attr('cols'))){
				return this._getCellLabel(row, col);
			} else{
				return undefined;
			}
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return undefined;
};

/**
 * @since QCELL v2.1.63
 * @author seongdeuk1985
 * @description 지정한 셀의 설정한 데이터를 출력합니다.
 * @param {number} row - 셀의 행 인덱스
 * @param {number} col - 셀의 열 인덱스
 * @param {*} val - 출력할 데이터
 * @returns {boolean}
 * @example
 * QCell1.setCellLabel(3, 1, '출력');
 */
QBOX.QCELL.BasicQCELL.prototype.setCellLabel = function(row, col, data){
	var strAPI = this.attr('id') + '.setCellLabel';
	
	if(arguments.length < 3){
		QCELL.log("log", strAPI, this.attr('msg').err.PARAM_COUNT);
		return false;
	} else{
		if(typeof row === 'number' && typeof col === 'number'){
			if(typeof data === 'string' || typeof data === 'number'){
				if((row >= 0 && row < this.attr('rows') && col >= 0 && col < this.attr('cols'))){
					return this._setCellLabel(row, col, data);
				} else{
					return false;
				}
			} else {
				QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
				return false;
			}
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
			return false;
		}
	}
	
	return true;
};

/**
 * @since QCELL v2.1.3
 * @author seongdeuk1985
 * @description Server와의 통신을 통해 데이터를 바인딩합니다.
 * @param {Object} properties - Server와 통신시 필요 정보
 * @param {string} properties.url - Server와 통신할 URL 주소
 * @param {Object} properties.param - Server와 통신시 전달할 Parameter
 * @param {Function} properties.callback - Server와 통신 이후 실행할 콜백 함수
 * @returns {*}
 * @example
 * var properties = 
 * {
 * 	  url:       "/data.do",
 * 	  param: {
 *        data1: "1",
 *        data2: "2"
 *    },
 *    callback: fnCallback
 * }
 * QCell1.requestData(properties);
 */
QBOX.QCELL.BasicQCELL.prototype.requestData = function(properties){
	var strAPI = this.attr('id') + '.requestData',
	objQCell = this,
	param = '';
	
	try {
		if(typeof properties.url === 'string') {
			
			if(QBOX._.isUndefined(properties.param) === false){
				if(QBOX._.isObject(properties.param)){
					param = JSON.stringify(properties.param);
				} else {
					param = properties.param;
				}
			}
			
			QBOX.$.post(properties.url, param, function(result){
				if( QBOX._.isUndefined(properties.callback) === false && QBOX._.isFunction(properties.callback) ){
					return properties.callback(JSON.parse(result));
				} else {
					return objQCell._setData(JSON.parse(result));
				}
			});
			
		} else {
			QBOX.QCELL.log('err', strAPI, 'Please check parameter. This url parameter\'s type is "string".');
		}
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
	
	return undefined;
};

/**
 * @since QCELL v2.1.6
 * @author seongdeuk1985
 * @description Progress 이미지를 화면에 출력합니다.
 * @returns {boolean}
 * @example
 * QCell1.showProgress();
 */
QBOX.QCELL.BasicQCELL.prototype.showProgress = function(){
	var strAPI = this.attr('id') + '.showProgress';
	
	try {
		this._showProgressUI(true);
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
	
	return true;
};

/**
 * @since QCELL v2.1.6
 * @author seongdeuk1985
 * @description Progress 이미지를 화면에서 숨김 처리합니다.
 * @param {number} time=500 - Progress가 숨겨될 때까지의 시간(ms)
 * @returns {boolean}
 * @example
 * QCell1.hideProgress(300);
 */
QBOX.QCELL.BasicQCELL.prototype.hideProgress = function(time){
	var strAPI = this.attr('id') + '.hideProgress';
	
	try {
		this._showProgressUI(false, time);
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
	
	return true;
};

/**
 * @since QCELL v2.1.42
 * @author seongdeuk1985
 * @description header의 title을 동적으로 변경시 사용
 * @param {number} row - 셀의 행 인덱스
 * @param {number} col - 셀의 열 인덱스
 * @param {*} data - 셀 데이터
 * @returns {boolean}
 * @example
 * QCell1.setHeaderCellValue(0, 1, 'change');
 */
QBOX.QCELL.BasicQCELL.prototype.setHeaderCellValue = function(row, col, data){
	var strAPI = this.attr('id') + '.setHeaderCellValue';
	
	if(arguments.length < 3){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof col === 'number'){
			var nHeaderCols = this.attr('headercols'),
			nCols = this.attr('cols');
			var bRet = (row < this.attr('headerrows') && col >= nHeaderCols && col < nCols) ? this._cellValue(row, col, data) : false;
			
			if(bRet === true){
				this._setRoleTitle();
				this._resetAriaLabel(col);				
			}
			
			return bRet;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
};

/**
 * @since QCELL v2.1.158
 * @author jklee
 * @description header의 title을 동적으로 변경시 사용
 * @param {number} row - 셀의 행 인덱스
 * @param {string} key - 셀의 열 키 인덱스
 * @param {*} data - 셀 데이터
 * @returns {boolean}
 * @example
 * QCell1.setHeaderCellValue(0, 'test', 'change');
 */
QBOX.QCELL.BasicQCELL.prototype.setHeaderCellValueEx = function(row, key, data){
	var strAPI = this.attr('id') + '.setHeaderCellValueEx';
	
	if(arguments.length < 3){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof key === 'string'){
			var nHeaderCols = this.attr('headercols'),
			nCols = this.attr('cols'),col = this.getColOfKey(key);
			
			if(col !==-1)
				return (row < this.attr('headerrows') && col >= nHeaderCols && col < nCols) ? this._cellValue(row, col, data) : false;
			else
				return this._hiddenHeaderCellValue(row,key,data);
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
};
/**
 * @since QCELL v2.1.158
 * @author jklee
 * @description header의 title을 동적으로 변경시 사용
 * @param {number} row - 셀의 행 인덱스
 * @param {string} key - 셀의 열 키 인덱스
 * @returns {string}
 * @example
 * QCell1.getHeaderCellValueEx(0, 'test');
 */
QBOX.QCELL.BasicQCELL.prototype.getHeaderCellValueEx = function(row, key){
	var strAPI = this.attr('id') + '.getHeaderCellValueEx';
	
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof key === 'string'){
			var nHeaderCols = this.attr('headercols'),
			nCols = this.attr('cols'),col = this.getColOfKey(key);
			
			if(col !==-1)
				return (row < this.attr('headerrows') && col >= nHeaderCols && col < nCols) ? this._cellValue(row, col) : null;
			else
				return this._hiddenHeaderCellValue(row,key);
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
};

/**
 * @since QCELL v2.1.57
 * @author seongdeuk1985
 * @description QCELL속성 original: true일 때 사용한 가능한 데이터 초기화 
 * @returns {boolean}
 * @example
 * QCell1.resetData();
 */
QBOX.QCELL.BasicQCELL.prototype.resetData = function(){
	var strAPI = this.attr('id') + '.resetData';
	
	try {
		return this._resetData();
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
	
	return true;
};

/**
 * @since QCELL v2.1.65
 * @author seongdeuk1985
 * @description 포커스된 행의 데이터 반환 
 * @returns {boolean}
 * @example
 * QCell1.getFocusRowData();
 */
QBOX.QCELL.BasicQCELL.prototype.getFocusRowData = function(){
	var strAPI = this.attr('id') + '.getFocusRowData';
	try {
		return this._getFocusRowData();
	} catch (e) {
		QCELL.log('err', strAPI, e.message);
		return false;
	}
	
	return true;
};
/**
 * @since QCELL v2.1.87
 * @author jklee
 * @description 해당 row 이하에서 대상 컬럼 중 특정 데이터 를 찾음. 
 * @param {string} data -찾을 데이터
 * @param {number} startRow - 찾기 시작할 행 인덱스
 * @param {number} targetCol - 셀의 열 인덱스
 * @returns {number}
 * @example
 * QCell1.findRow('abcd', 1, 1);
 */
QBOX.QCELL.BasicQCELL.prototype.findRow = function(data,startRow,targetCol){
	var key = this._getKeyOfCol(targetCol);
	if(key === '' || key === undefined)
		return -1;
	
	return this._findRowSub(data,startRow,key);
};
/**
 * @since QCELL v2.1.145
 * @author jklee
 * @description 해당 row 이하에서 대상 컬럼 중 특정 데이터 를 찾음. 
 * @param {string} data -찾을 데이터
 * @param {number} startRow - 찾기 시작할 행 인덱스
 * @param {string} key - 셀의 키 인덱스
 * @returns {number}
 * @example
 * QCell1.findRowEx('abcd', 1, 'name');
 */
QBOX.QCELL.BasicQCELL.prototype.findRowEx = function(data,startRow,key){	
	if(key === '' || key === undefined)
		return -1;
	
	return this._findRowSub(data,startRow,key);
};

/**
 * @since QCELL v2.1.87
 * @author jklee
 * @description 해당 row 대상 row의 데이터를 치환 함. 
 * @param {number} srcRow - 치환 하기 위한 행 인덱스
 * @param {number} dstRow - 치한 하기 위한 대상 행 인덱스
 * @returns {boolean}
 * @example
 * QCell1.swapData( 1, 5);
 */
QBOX.QCELL.BasicQCELL.prototype.swapData = function(srcRow,dstRow){
	var currentData = this.attr('currentdata'),nHeaderRow = this.getRows('header'),nRows = this.getRows();
	
	if(srcRow - nHeaderRow < 0 || dstRow - nHeaderRow <0){
		return false;
	}
	
	if(srcRow - nHeaderRow >= currentData.length || dstRow - nHeaderRow >= currentData.length){
		return false;
	}
	
	var srcObj = QBOX._.clone(currentData[ srcRow - nHeaderRow]), dstObj = QBOX._.clone(currentData[ dstRow - nHeaderRow]);
	
	currentData[ srcRow - nHeaderRow] = dstObj;
	currentData[ dstRow - nHeaderRow] = srcObj;
	
	this.refresh();
	
	return true;
};

/**
 * @since QCELL v2.1.159
 * @author jklee
 * @description 자동 생성된 frozenbottomdata 에 Key 에 해당하는 셀의 데이터를 갱신합니다.
 * @param {number} key - 셀의 열 인덱스
 * @param {*} data - 셀 데이터
 * @returns {boolean}
 * @example
 * QCell1.setFrozenDataEx('name', "test");
 */
QBOX.QCELL.BasicQCELL.prototype.setFrozenDataEx = function(key, data){
	var strAPI = this.attr('id') + '.setFrozenDataEx' , bRet = true;
	var row = this.getRows()-1;
	if(arguments.length < 2){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof key === 'string'){
			
			if(row > this.attr('rows') || row < this.attr('headerrows'))
				return false;
			
			var objRowData = this.getRowData(row);
			
			if(this.attr('makefrozenbottomdata') !== true)
				return false;
				
			if(objRowData.rt_qc_fbrd !== true)
				return false;
			
			if(key === 'rt_qc_seq'){
				var arrRowHeaders = this.attr('rowheaders');
				for(var t=0;t<arrRowHeaders.length;t++){
					if(arrRowHeaders[t]==='sequence'){
						var htCell = this._getCellDOM(row,t);
						if(htCell !== null){
							htCell.textContent = data;
						}
					}
						
				}				
				
			}else{
				var arrCols = this.getColsOfKey(key);
				
				if( arrCols.length > 0){
					var i;
					for(i = 0; i < arrCols.length ; i++){
						bRet = this.setCellData ( row,arrCols[i],data);	
					}
					return bRet;
				}			
				
			}			
			
			
			if(objRowData !== undefined){
				objRowData[key] = data;			
				this.setRowData(row,objRowData);			
				return true;			
			}

		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.159
 * @author jklee
 * @description 자동 생성된 frozenbottomdata의 key 에 해당하는 셀의 데이터를 반환합니다.
 * @param {string} key - 셀의 Key
 * @returns {*}
 * @example
 * QCell1.getFrozenDataEx( 'name');
 */
QBOX.QCELL.BasicQCELL.prototype.getFrozenDataEx = function(key){
	var strAPI = this.attr('id') + '.getFrozenDataEx';
	var row = this.getRows()-1;
	
	if(arguments.length < 1){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		
		var objRowData = this.getRowData(row);
		
		if(this.attr('makefrozenbottomdata') !== true)
			return undefined;
			
		if(objRowData.rt_qc_fbrd !== true)
			return undefined;	
		
		if(key === 'rt_qc_seq'){
			var arrRowHeaders = this.attr('rowheaders');
			for(var t=0;t<arrRowHeaders.length;t++){
				if(arrRowHeaders[t]==='sequence'){
					return this._getRowData(row)[key];
				}
					
			}				
			
		}		
		
		if(typeof row === 'number' && typeof key === 'string'){
			return (row < this.attr('rows') && row >= this.attr('headerrows') ) ? this._getRowData(row) [key] : undefined;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return undefined;
};
/**
 * @since QCELL v2.1.159
 * @author jklee
 * @description frozenbottom cell 의 style을 가져온 다.
 * @param {string} key - 셀의 Key
 * @returns {*}
 * @example
 * QCell1.getFrozenCellStyleEx( 'name');
 */
QBOX.QCELL.BasicQCELL.prototype.getFrozenCellStyleEx = function( col){
	var strAPI = this.attr('id') + '.getCellStyle';
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{	
		var row = this.getRows()-1;
		
		var objRowData = this.getRowData(row);
		
		if(this.attr('makefrozenbottomdata') !== true)
			return {};
			
		if(objRowData.rt_qc_fbrd !== true)
			return {};		
		
		
		if(typeof row === 'number' && typeof col === 'number'){
			return (row < this.attr('rows') && row >= 0 && col < this.attr('cols') && col >= 0) ? this._getCellStyle(row, col) : {};
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return {};
};

/**
 * @since QCELL v2.1.164
 * @author jklee
 * @description emptymessage 사용 여부 반환.
 * @returns {boolean}
 * @example
 * QCell1.getUseEmptyMessage();
 */
QBOX.QCELL.BasicQCELL.prototype.getUseEmptyMessage = function(){
	return this.attr('useemptymessage') !== false ? true : false;
};
/**
 * @since QCELL v2.1.164
 * @author jklee
 * @description emptymessage 사용 여부 설정.
 * @param {boolean} bUse - 사용 유무 
 * @returns {*}
 * @example
 * QCell1.setUseEmptyMessage(false);
 */
QBOX.QCELL.BasicQCELL.prototype.setUseEmptyMessage = function(bUse){
	var obj = this.getProperties();
	obj.useemptymessage = bUse === true ? true : false;
	this.attr('useemptymessage', bUse, 'boolean');
};
/**
 * @since QCELL v2.1.175
 * @author jklee
 * @description row data 전체를 지정된 위치로 변경.
 * @param {number} nSrc - 욺기기를 위한 로우 넘버
 * @param {*} nDest - 욺기기 위치  
 * @returns {boolean}
 * @example
 * QCell1.swapData(2, 'first');
 * QCell1.swapData(2, 'last');
 * QCell1.swapData(2, 3);
 */
QBOX.QCELL.BasicQCELL.prototype.swapData = function(nSrcRow, nDestRow){
	if(QBOX._.isString(nDestRow)){
		if(nDestRow === 'first'){
			nDestRow = this.getRows('header');
		}else if(nDestRow === 'last'){
			if(this.attr('makefrozenbottomdata') === true){
				nDestRow = this.getRows() -2;
			}else{
				nDestRow = this.getRows() -1;
			}					
		}else{
			return false;
		}
	}
	
	if(nSrcRow === nDestRow)
		return false;
		
	var objSrc = this.getRowData(nSrcRow);
	var objDest = this.getRowData(nDestRow);
	
	if(objSrc === undefined || objDest === undefined)
		return false;
	
	this.setRowData(nSrcRow, objDest);			
	this.setRowData(nDestRow , objSrc);
	
	var j,strData;
	
	if(this.attr('useall') || this.attr('usetreeall')){
		for(j=this.getCols('header') ; j< this.getCols(); j++){
			var heSrc = this._getCellDOM(nSrcRow,j);
			if(heSrc !==null && heSrc !== undefined){
				strData = this.getCellData(nSrcRow,j);
				strData = strData === undefined ? '' : strData;
				this._setAriaLabel(heSrc,nSrcRow,j,strData,false);
			}
			var heDest = this._getCellDOM(nDestRow,j);
			if(heDest !==null && heDest !== undefined){
				strData = this.getCellData(nDestRow,j);
				strData = strData === undefined ? '' : strData;
				this._setAriaLabel(heDest,nDestRow,j,strData,false);
			}					
		}
	
	}
	
	return true;
};

/**
 * @since QCELL v2.1.175
 * @author jklee
 * @description row data 전체를 지정된 위치로 변경.
 * @param {number} nSrc - 욺기기를 위한 로우 넘버
 * @param {*} nDest - 욺기기 위치  
 * @returns {boolean}
 * @example
 * QCell1.moveData(2, 'first');
 * QCell1.moveData(2, 'last');
 * QCell1.moveData(2, 3);
 */
QBOX.QCELL.BasicQCELL.prototype.moveData = function(nSrcRow, nDestRow){
	if(QBOX._.isString(nDestRow)){
		if(nDestRow === 'first'){
			nDestRow = this.getRows('header');
		}else if(nDestRow === 'last'){
			if(this.attr('makefrozenbottomdata') === true){
				nDestRow = this.getRows() -1;
			}else{
				nDestRow = this.getRows() ;
			}					
		}else{
			return false;
		}
	}
	
	if(nSrcRow === nDestRow)
		return false;
		

	
	var arrCD = this.attr('currentdata');

	
	var nFR = -1, nFC = -1;
	if(this.getIdx('row','focus') !== -1 && this.getIdx('col','focus') !== -1){
		nFR = this.getIdx('row','focus'); 
		nFC = this.getIdx('col','focus');
		arrCD[nFR - this.attr('headerrows')]._rt_qc_focus = {row : nFR, col :nFC};
	}
	var objSrc = this.getRowData(nSrcRow);	
	if(objSrc === undefined )
		return false;	
	
	var arrSrc = [];
	arrSrc.push(objSrc);
	nSrcRow = nSrcRow-this.attr('headerrows');
	nDestRow = nDestRow-this.attr('headerrows');
	if(nSrcRow > nDestRow){
		arrCD.splice(nSrcRow,1);
		arrCD.RT_insertArray(nDestRow,arrSrc);		
	}else{
		arrCD.RT_insertArray(nDestRow+1,arrSrc);		
		arrCD.splice(nSrcRow ,1);
	}
	

	
	var objVSinfo = this.attr('vsinfo');
	var nTempRow = nDestRow + this.attr('headerrows'); 
	if(objVSinfo.bVScroll){
		
		if(objVSinfo.nTopRow <=nTempRow && nTempRow <=objVSinfo.nBottomRow)
			this._updateNRs();
		else
			this._scrollTop(nTempRow);
	}else{
		this._updateNRs();
	}
	
	//if(this.getIdx('row','focus') ===nSrcRow +this.attr('headerrows')  ){
	var nTR = -1,nTC = -1;
		for(var i= 0; i<arrCD.length;i++){
			if(arrCD[i]._rt_qc_focus !== undefined){
				nTR = i + this.attr('headerrows');
				nTC = arrCD[i]._rt_qc_focus.col;				
				delete arrCD[i]._rt_qc_focus;
				break;
			}
		}
	if(nTR !== -1 && nTC !==-1){
		var THAT = this;
		setTimeout(function(){
			THAT._focusCell(nTR,nTC);	
			switch(THAT.attr('selectmode')){
				case 'row': case 'rows':{
					THAT._clearSelection();
					THAT._selectRow(nTR);
					break;
				}
				case 'col': case 'cols': {
					THAT._clearSelection();
					THAT._selectCol(nTC);
					break;
				}
				default: {//cell, cells
					THAT._clearSelection();
					THAT._selectCell(nTR, nTC);					
					break;
				}
			}					
		},0);
		
		
	}
		
	//}	

	return true;
};
/**
 * @since QCELL v1.0.0
 * @author sai1515
 * @description QCELL의 데이터를 특정 조건을 기준으로 정렬합니다. (조건이 2개이상이면 다중정렬)
 * @param {Array} sortlist - 정렬 조건
 * @param {number} sortlist[i].col - 열 인덱스
 * @param {string} sortlist[i].sorttype - 정렬 타입 ("asc" | "desc")
 * @param {string} sortlist[i].datatype - 데이터 타입 ("string" | "number")
 * @returns {boolean}
 * @example
 * QCell1.sort([[3, "asc", "string"]]); //3번째 열을 기준으로 (string)오름차순으로 정렬 (단일 정렬)
 * QCell1.sort([[3, "asc", "string"],[1, "desc", "number"]]); //3번째 열을 기준으로 (string)오름차순으로, 1번째 열을 기준으로 (number)내림차순으로 정렬 (다중 정렬)
 */
QBOX.QCELL.BasicQCELL.prototype.sort = function(sortlist){
	var strAPI = this.attr('id') + '.sort';
	
	if(arguments.length < 1){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isArray(sortlist)){
			if(this.attr('isSorting') === true)
				return false;
			
			return this._sort(sortlist);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.165
 * @author jklee
 * @description QCELL의 데이터를 특정 조건을 기준으로 정렬합니다. (조건이 2개이상이면 다중정렬)
 * @param {Array} sortlist - 정렬 조건
 * @param {number} sortlist[i].key - sort 를 위한 열의 key
 * @param {string} sortlist[i].sorttype - 정렬 타입 ("asc" | "desc")
 * @param {string} sortlist[i].datatype - 데이터 타입 ("string" | "number")
 * @returns {boolean}
 * @example
 * QCell1.sort([['name', "asc", "string"]]); // name 열을 기준으로 (string)오름차순으로 정렬 (단일 정렬)
 * QCell1.sort([['name', "asc", "string"],['title', "desc", "number"]]); //'name' 열을 기준으로 (string)오름차순으로, 'title' 열을 기준으로 (number)내림차순으로 정렬 (다중 정렬)
 */
QBOX.QCELL.BasicQCELL.prototype.sortEx = function(sortlist){
	var strAPI = this.attr('id') + '.sortEx';
	
	if(arguments.length < 1){
		QCELL.log('err', strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(this.attr('isSorting') === true)
			return false;
		
		if(QBOX._.isArray(sortlist)){
			return this._sort(sortlist);
		} else{
			QCELL.log('log', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 이벤트를 QCELL에 추가합니다.
 * @param {string} eventname - 이벤트 이름 (동시에 여러개의 이벤트 추가 시 띄워쓰기로 구분)("click" || "dblclick || "mouseenter" || "mouseleave" || "mousemove" || " "mouseover" || "mousedown" || "mouseup" || "keydown" || "change" || "scrollmove" || "scrolltop" || "scrollbottom" || "aftercreated" || "redrawed" || "aftermovepage" || "beforesort" || "aftersort" || "valuechanged" || "selected" || "viewport_changed" || "afterurlexceldown") ※ "afterurlexceldown"는 크로스도메인 환경에서 지원되지 않으며, URL 다운로드에서만 동작합니다. 결과값은 이벤트 객체내 filedownresult로 확인할 수 있습니다.
 * @param {requestCallback} handler - 추가된 이벤트 발생 시 호출할 핸들러 callback 함수
 * @param {object} data - 핸들러 콜백에 추가적으로 전달 할 수 있는 데이터
 * @returns {boolean}
 * @example
 * QCell1.bind("click", function(event){
 * 	var objQCell = event.data.target;//event parameter에서 QCELL객체를 추출이 가능 
 * });
 * QCell1.bind("click keydown", function(event){//하나의 핸들러 callback 함수를 여러개의 이벤트에 연동이 가능
 * 	var objQCell = event.data.target;
 * });
 * QCell1.bind("click keydown", function(event){//하나의 핸들러 callback 함수를 여러개의 이벤트에 연동이 가능
 * 	var objQCell = event.data.target;
 * },{'param': 'qcell1'});
 */
QBOX.QCELL.BasicQCELL.prototype.bind = function(eventname, handler,data){
	var strAPI = this.attr('id') + '.bind';
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof eventname === 'string' && QBOX._.isFunction(handler)){
			return this._bind(eventname, handler, true,data);
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 이벤트를 QCELL에서 제거합니다.
 * @param {string} eventname - 이벤트 이름 (동시에 여러개의 이벤트 제거 시 띄워쓰기로 구분)
 * @returns {boolean}
 * @example
 * QCell1.unbind("click");
 * QCell1.unbind("click keydown");
 */
QBOX.QCELL.BasicQCELL.prototype.unbind = function(eventname){
	var strAPI = this.attr('id') + '.unbind';
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof eventname === 'string'){
			return this._unbind(eventname, true);
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description QCELL에 추가된 사용자 이벤트 정보를 반환합니다.
 * @returns {Object}
 * @example
 * var objUserEventInfo = QCell1.getUserEventInfo();
 */

QBOX.QCELL.BasicQCELL.prototype.getUserEventInfo = function(){
	return QBOX._.clone(this.attr('usereventinfo'));
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력한 이벤트의 핸들러를 강제로 실행합니다.
 * @param {string} eventname - 이벤트 이름
 * @returns {boolean}
 * @example
 * QCell1.trigger("click");
 */
QBOX.QCELL.BasicQCELL.prototype.trigger = function(eventname){
	var strAPI = this.attr('id') + '.trigger';
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof eventname === 'string'){
			return this._trigger(eventname);
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v.2.1.5
 * @author sonymaker
 * @description 특정 Cell을 click한 것과 동일한 효과로 선택합니다.
 * @param {number} row - 행 인덱스
 * @param {number} col - 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.clickCell(1, 3);
 */
QBOX.QCELL.BasicQCELL.prototype.clickCell = function(row, col){
	var strAPI = this.attr('id') + '.clickCell';
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof col === 'number'){
			return (row < this.attr('rows') && row >= 0 && col < this.attr('cols') && col >= 0) ? this._clickCell(row, col) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v.2.1.5
 * @author sonymaker
 * @description 특정 Cell을 double click한 것과 동일한 효과로 선택합니다.
 * @param {number} row - 행 인덱스
 * @param {number} col - 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.dblClickCell(2, 4);
 */
QBOX.QCELL.BasicQCELL.prototype.dblClickCell = function(row, col){
	var strAPI = this.attr('id') + '.dblClickCell';
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number' && typeof col === 'number'){
			return (row < this.attr('rows') && row >= 0 && col < this.attr('cols') && col >= 0) ? this._dblClickCell(row, col) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v.2.1.9
 * @author seongdeuk1985
 * @description 특정 Cell을 focus 효과를 내며 선택합니다.
 * @param {number} row - 행 인덱스
 * @param {number} col - 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.focusCell(1, 3);
 */
QBOX.QCELL.BasicQCELL.prototype.focusCell = function(row, col,nTime){
	var THAT = this;
	var strAPI = this.attr('id') + '.focusCell';

	nTime = nTime === undefined? 200 : nTime;
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	}else{
		if(typeof row === 'number' && typeof col === 'number'){
			if((row < this.attr('rows') && row >= 0 && col < this.attr('cols') && col >= 0)){
				var target = this._getCellDOM(row, col);
				
				if(!QBOX._.isElement(target) ||  !QBOX.util.hasClass(target, QBOX.QCELL.def.css.CELL)){
					this.scrollTop(row);
					this.scrollLeft(col);
				}	
				
				setTimeout(function(){
					THAT.clickCell(row,col);
				},nTime);
				
			}else{
				return false;
			}
			return true;
		}
		else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
};
/**
 * @since QCELL v1.0.0
 * @author seongdeuk1985
 * @description QCELL 에서 출력되는 내용을 엑셀파일로 저장합니다. (IE9 이하의 브라우저는 Server를 통하여 저장, 그 외의 브라우저는 자체 저장 및 Server틑 통한 저장 지원)
 * @param {Object} properties - Excel Download 정보 설정
 * @param {string} properties.filename - 저장할 파일명 설정 (필수)
 * @param {string} [properties.fileExt="xlsx"] - 저장할 파일의 확장자명 설정
 * @param {string} properties.url - 서버 다운로드 시 호출 URL 설정 (IE9 이하 및 서버 다운로드시 필수)
 * @param {boolean} [properties.border=false] - Excel 문서에 각 영역별 border처리 여부 설정
 * @param {boolean} [properties.headershow=false] - Excel 문서에 Header 영역 출력 여부 설정
 * @param {boolean} [properties.colwidth=false] - Excel 문서에 QCELL과 같은 column 별 "px" 적용 여부 설정
 * @param {boolean} [properties.huge=false] - 대용량 데이터 여부 설정
 * @param {string} [properties.datatype="string"] - Export 시 모든 샐을 String 형식으로 내보낼지 여부 
 * @param {boolean} [properties.totaldata=false] - 로컬 pagination 기능 사용 중 전체 데이터 저장 설정
 * @param {boolean} [properties.label=false] - 데이터를 value값이 아닌 label으로 출력 (v2.1.4 부터 지원)<br>
 * col의 type이 "static", "input", "textarea", "datepicker"일 때 현재 화면의 표시되는 값으로 출력 (v.2.1.44 부터 지원)
 * @param {Object} [properties.param] - 서버로 전송할 파라미터(JSON) (v2.1.3 부터 지원)
 * @param {Object} [properties.addColumns] - Excel 저장시 추가할 Column 정보 (v2.1.7 이상부터 지원)
 * @param {string} properties.addColumns.key - 추가할 Column 정보의 key
 * @param {string} [properties.addColumns.width=100] - 추가할 Column 정보의 width (단위 "px")
 * @param {string} [properties.addColumns.position=마지막 열 인덱스] - 추가할 Column 정보의 열 인덱스
 * @param {Object} properties.addColumns.title - 추가할 Column 정보의 헤더 타이틀 (멀티 타이틀 설정 가능, string 배열)
 * @param {Array} [properties.delColumns] - Excel 저장시 삭제할 Column의 index 정보 (v2.1.7 이상부터 지원)
 * @param {Array} [properties.orderColumns] - Excel 저장시 변경할 Column의 index 순서 정보, QCELL 생성시점의 column정보의 수가 동일해야 하며, 
 * orderColumns > delColumns > addColumns 순으로 실행됨 (v2.1.7 이상부터 지원)
 * @returns {boolean}
 * @example
 * var properties = 
 * {
 * 	filename:       "excel",
 *  fileExt:		"xlsx",
 * 	border:         true,
 * 	headershow:     true,
 * 	colwidth:       true,
 * 	param:       {"data1": "data1", "data2": "data2"},
 * 	addColumns:     [{"key": "abc", "width": "250", "title": ["title1", "title1-1"], "position": "2"}, {...}],
 * 	delColumns:     [3, 4, ...],
 * 	orderColumns:   [1, 6, 4, 3, ...]
 * }
 * QCell1.excelDownload(properties);
 */
QBOX.QCELL.BasicQCELL.prototype.excelDownload = function(properties) {
	var strAPI = this.attr('id') + '.excelDownload',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(typeof properties === "object"){
			this._excelDownload(properties);
			bool = true;
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v1.0.0
 * @author seongdeuk1985
 * @description QCELL 에서 업로드한 엑셀파일의 정보를 설정합니다. (IE9 이하의 브라우저는 Server를 통하여 업로드, 그 외의 브라우저는 자체 업로드 및 Server틑 통한 업로드 지원)
 * @param {Object} properties - Excel Upload 정보 설정
 * @param {number} properties.headerrows - header영역의 행 카운트 설정 (필수)
 * @param {Event} properties.event - 파일 객체의 file change event 설정 (로컬 업로드시 필수)
 * @param {string} properties.cellname - QCell의 객체명 설정 (IE9 이하 및 서버업로드 필수)
 * @param {string} properties.fileid - 파일 객체의 ID 설정 (IE9 이하 및 서버업로드 필수)
 * @param {string} properties.url - 서버 업로드 시 호출 URL 설정 (IE9 이하 및 서버업로드 필수)
 * @returns {boolean}
 * @example
 * var properties = 
 * {
 * 	headerrows:     2,
 * 	cellname:       "QCell1",
 * 	fileid:         "file",
 * 	url:            "/filedownload.do"
 * } 
 * QCell1.excelUpload(properties);
 */
QBOX.QCELL.BasicQCELL.prototype.excelUpload = function(properties) {
	var strAPI = this.attr('id') + '.excelUpload',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(typeof properties === "object"){
			this._excelUpload(properties);
			bool = true;
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.9
 * @author seongdeuk1985
 * @description QCELL 에서 엑셀로 저장할 때 필요한 정보들을 추출합니다. (.excelDownload() API에서 파라미터 filename과 url외 동일)
 * @param {Object} properties - Excel 저장시 설정 정보
 * @param {boolean} [properties.border=false] - Excel 문서에 각 영역별 border처리 여부 설정
 * @param {boolean} [properties.headershow=false] - Excel 문서에 Header 영역 출력 여부 설정
 * @param {boolean} [properties.colwidth=false] - Excel 문서에 QCELL과 같은 column 별 "px" 적용 여부 설정
 * @param {boolean} [properties.huge=false] - 대용량 데이터 여부 설정
 * @param {boolean} [properties.label=false] - 데이터를  value값이 아닌 label으로 출력 (v2.1.4 부터 지원)<br>
 * col의 type이 "static", "input", "textarea", "datepicker"일 때 현재 화면의 표시되는 값으로 출력 (v.2.1.44 부터 지원)
 * @param {Object} [properties.param] - 서버로 전송할 파라미터(JSON) (v2.1.3 부터 지원)
 * @param {Object} [properties.addColumns] - Excel 저장시 추가할 Column 정보 (v2.1.7 이상부터 지원)
 * @param {string} properties.addColumns.key - 추가할 Column 정보의 key
 * @param {string} [properties.addColumns.width=100] - 추가할 Column 정보의 width (단위 "px")
 * @param {string} [properties.addColumns.position=마지막 열 인덱스] - 추가할 Column 정보의 열 인덱스
 * @param {Object} properties.addColumns.title - 추가할 Column 정보의 헤더 타이틀 (멀티 타이틀 설정 가능, string 배열)
 * @param {Array} [properties.delColumns] - Excel 저장시 삭제할 Column의 index 정보 (v2.1.7 이상부터 지원)
 * @param {Array} [properties.orderColumns] - Excel 저장시 변경할 Column의 index 순서 정보, QCELL 생성시점의 column정보의 수가 동일해야 하며, 
 * orderColumns > delColumns > addColumns 순으로 실행됨 (v2.1.7 이상부터 지원)
 * @returns {Object}
 * @example
 * var properties = 
 * {
 * 	border:         true,
 * 	headershow:     true,
 * 	colwidth:       true,
 * 	param:       {"data1": "data1", "data2": "data2"},
 * 	addColumns:     [{"key": "abc", "width": "250", "title": ["title1", "title1-1"], "position": "2"}, {...}],
 * 	delColumns:     [3, 4, ...],
 * 	orderColumns:   [1, 6, 4, 3, ...]
 * }
 * QCell1.excelExportInfo(pr_exportCellInfooperties);
 */
QBOX.QCELL.BasicQCELL.prototype.excelExportInfo = function(properties) {
	var strAPI = this.attr('id') + '.excelExportInfo',
	result = {};
	
	if(arguments.length === 0){
		result = this._exportCellInfo();
	} 
	else if(arguments.length > 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(typeof properties === "object"){
			result = this._exportCellInfo(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return result;
};

/**
 * @since QCELL v2.1.64
 * @author seongdeuk1985
 * @description QCELL을 HTML파일로 저장합니다.
 * @param {Object} properties - HTML 저장시 설정 정보
 * @param {string} properties.filename - 저장할 HTML 파일명 설정 (필수)
 * @param {boolean} [properties.label=false] - 데이터를 value값이 아닌 label으로 출력<br>
 * @returns {Boolean}
 */
QBOX.QCELL.BasicQCELL.prototype.htmlDownload = function(properties) {
	var strAPI = this.attr('id') + '.htmlDownload',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		bool = false;
	} else {
		if(typeof properties === "object"){
			bool = this._htmlDownload(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
			bool = false;
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.164
 * @author jklee
 * @description QCELL을 HTML파일을 반환합니다..
 * @param {Object} properties - HTML 저장시 설정 정보
 * @param {boolean} [properties.label=false] - 데이터를 value값이 아닌 label으로 출력<br>
 * @returns {string}
 */
QBOX.QCELL.BasicQCELL.prototype.htmlExport = function(properties) {
	var strAPI = this.attr('id') + '.htmlExport',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		bool = false;
	} else {
		if(typeof properties === "object"){
			properties.export = true;
			properties.filename = 'temp';
			bool = this._htmlDownload(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
			bool = false;
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.64
 * @author seongdeuk1985
 * @description QCELL을 PDF파일로 저장합니다.
 * @param {Object} properties - PDF 저장시 설정 정보
 * @param {string} properties.filename - 저장할 PDF 파일명 설정 (필수)
 * @param {boolean} [properties.label=false] - 데이터를 value값이 아닌 label으로 출력<br>
 * @returns {Boolean}
 */
QBOX.QCELL.BasicQCELL.prototype.pdfDownload = function(properties) {
	var strAPI = this.attr('id') + '.pdfDownload',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		bool = false;
	} else {
		if(typeof properties === "object"){
			bool = this._pdfDownload(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
			bool = false;
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.158
 * @author jklee
 * @description QCELL을 txt파일로 다운로드 한다.
 * @param {Object} properties - txt 저장시 설정 정보
 * @param {string} properties.filename - 저장할 txt 파일명 설정 (필수)
 * @param {boolean} [properties.label=false] - 데이터를 value값이 아닌 label으로 출력<br>
 * @returns {Boolean}
 */
QBOX.QCELL.BasicQCELL.prototype.txtDownload = function(properties) {
	var strAPI = this.attr('id') + '.txtDownload',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		bool = false;
	} else {
		if(typeof properties === "object"){
			bool = this._txtDownload(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
			bool = false;
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.67
 * @author seongdeuk1985
 * @description QCELL 에서 출력되는 내용을 대용량 엑셀파일로 저장합니다. (Server를 통하여 저장)<br>기존 다운로드에서의 속성 border, headershow, colwidth, huge, label들은 true로 지정되어 동작하며 기존의 totaldata는 제거
 * @param {Object} properties - Excel Download 정보 설정
 * @param {string} properties.filename - 저장할 파일명 설정 (필수)
 * @param {string} [properties.fileExt="xlsx"] - 저장할 파일의 확장자명 설정
 * @param {string} properties.url - 서버 다운로드 시 호출 URL 설정 (IE9 이하 및 서버 다운로드시 필수)
 * @param {Object} [properties.param] - 서버로 전송할 파라미터(JSON) (v2.1.3 부터 지원)
 * @param {Object} [properties.addColumns] - Excel 저장시 추가할 Column 정보 (v2.1.7 이상부터 지원)
 * @param {string} properties.addColumns.key - 추가할 Column 정보의 key
 * @param {string} [properties.addColumns.width=100] - 추가할 Column 정보의 width (단위 "px")
 * @param {string} [properties.addColumns.position=마지막 열 인덱스] - 추가할 Column 정보의 열 인덱스
 * @param {Object} properties.addColumns.title - 추가할 Column 정보의 헤더 타이틀 (멀티 타이틀 설정 가능, string 배열)
 * @param {Array} [properties.delColumns] - Excel 저장시 삭제할 Column의 index 정보 (v2.1.7 이상부터 지원)
 * @param {Array} [properties.orderColumns] - Excel 저장시 변경할 Column의 index 순서 정보, QCELL 생성시점의 column정보의 수가 동일해야 하며, 
 * orderColumns > delColumns > addColumns 순으로 실행됨 (v2.1.7 이상부터 지원)
 * @returns {boolean}
 * @example
 * var properties = 
 * {
 * 	filename:       "excel",
 *  fileExt:		"xlsx",
 * 	param:       {"data1": "data1", "data2": "data2"},
 * 	addColumns:     [{"key": "abc", "width": "250", "title": ["title1", "title1-1"], "position": "2"}, {...}],
 * 	delColumns:     [3, 4, ...],
 * 	orderColumns:   [1, 6, 4, 3, ...]
 * }
 * QCell1.excelDownloadURLHuge(properties);
 */
QBOX.QCELL.BasicQCELL.prototype.excelDownloadURLHuge = function(properties) {
	var strAPI = this.attr('id') + '.excelDownloadURLHuge',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(typeof properties === "object"){
			this._excelDownloadURLHuge(properties);
			bool = true;
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.67
 * @author seongdeuk1985
 * @description QCELL 에서 엑셀로 저장할 때 필요한 정보들을 추출합니다. (.excelDownloadURLHuge() API에서 파라미터 filename과 url외 동일)<br>기존 다운로드에서의 속성 border, headershow, colwidth, huge, label들은 true로 지정되어 동작하며 기존의 totaldata는 제거
 * @param {Object} properties - Excel 저장시 설정 정보
 * @param {Object} [properties.param] - 서버로 전송할 파라미터(JSON) (v2.1.3 부터 지원)
 * @param {Object} [properties.addColumns] - Excel 저장시 추가할 Column 정보 (v2.1.7 이상부터 지원)
 * @param {string} properties.addColumns.key - 추가할 Column 정보의 key
 * @param {string} [properties.addColumns.width=100] - 추가할 Column 정보의 width (단위 "px")
 * @param {string} [properties.addColumns.position=마지막 열 인덱스] - 추가할 Column 정보의 열 인덱스
 * @param {Object} properties.addColumns.title - 추가할 Column 정보의 헤더 타이틀 (멀티 타이틀 설정 가능, string 배열)
 * @param {Array} [properties.delColumns] - Excel 저장시 삭제할 Column의 index 정보 (v2.1.7 이상부터 지원)
 * @param {Array} [properties.orderColumns] - Excel 저장시 변경할 Column의 index 순서 정보, QCELL 생성시점의 column정보의 수가 동일해야 하며, 
 * orderColumns > delColumns > addColumns 순으로 실행됨 (v2.1.7 이상부터 지원)
 * @returns {Object}
 * @example
 * var properties = 
 * {
 * 	param:       {"data1": "data1", "data2": "data2"},
 * 	addColumns:     [{"key": "abc", "width": "250", "title": ["title1", "title1-1"], "position": "2"}, {...}],
 * 	delColumns:     [3, 4, ...],
 * 	orderColumns:   [1, 6, 4, 3, ...]
 * }
 * QCell1.exportCellInfoURLHuge(properties);
 */
QBOX.QCELL.BasicQCELL.prototype.exportCellInfoURLHuge = function(properties) {
	var strAPI = this.attr('id') + '.excelExportInfoURLHuge',
	result = {};
	
	if(arguments.length === 0){
		result = this._exportCellInfo();
	} 
	else if(arguments.length > 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(typeof properties === "object"){
			result = this._exportCellInfoURLHuge(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return result;
};
/**
 * @since QCELL v1.0.0
 * @author jklee
 * @description 병합할 영역과 방식을 설정합니다.
 * @param {string} strArea - 병합할 영역 ("header" | "data")
 * @param {string} strMergeType="none" - 병합할 방식<br>
 * ("header" 영역은 "row" | "col" | "rowandcol" | "colandrow" | "none")<br>
 * ("data" 영역은 "row" | "col" | "group" | "none")
 * @returns {boolean}
 * @example
 * QCell1.merge("header", "rowandcol");
 */
QBOX.QCELL.BasicQCELL.prototype.merge = function(strArea, strMergeType) {
	var arrInfo = null;
	var objMergeType = this.attr("merge");
	
	switch (strMergeType){
		case 'row' :
		case 'col' :
		case 'rowandcol' :
		case 'colandrow' :
		case 'group' : 
		case 'none' : 
			break;
		default : 
			return false;
	}
	
	if(strArea == 'header'){
		
		arrInfo =this.attr('merge_header_info');
		this._clearMergeHeader();
		
		if(arrInfo)
			arrInfo.RT_clear();
		
		objMergeType.header = strMergeType;
		this._createHeaderMergeInfo();
		this._updateMergeHeader();
		this._refresh();
	}
	else if(strArea == 'data'){
		arrInfo =this.attr('merge_data_info');
		this._clearMergeData();
		
		if(arrInfo)
			arrInfo.RT_clear();
		
		objMergeType.data = strMergeType;
		this._createDataMergeInfo();
		this._updateMergeData();
		this._refresh();
	}
	else return false;
	
	return true;
};


/**
 * @since QCELL v2.1.2
 * @author seongdeuk1985
 * @description "현재 페이지 번호"를 설정합니다.
 * @param {number} index - 변경할 페이지 번호
 * @returns {boolean}
 * @example
 * QCell1.setPageIndex(2);
 */
QBOX.QCELL.BasicQCELL.prototype.setPageIndex = function(index) {
	var strAPI = this.attr('id') + '.setPageIndex',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(QBOX._.isNumber(index)){
			this._movePage(index);
			bool = true;
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.2
 * @author seongdeuk1985
 * @description "현재 페이지 번호"를 반환합니다.
 * @returns {number}
 * @example
 * var nPageIndex = QCell1.getPageIndex();
 */
QBOX.QCELL.BasicQCELL.prototype.getPageIndex = function() {
	return QBOX._.clone(this.attr('paginationinfo').pageindex);
};

/**
 * @since QCELL v2.1.2
 * @author seongdeuk1985
 * @description "페이지 출력 행의 수"를 설정합니다.
 * @param {number} index - 변경할 페이지 출력 행의 수
 * @returns {boolean}
 * @example
 * QCell1.setPageUnit(10);
 */
QBOX.QCELL.BasicQCELL.prototype.setPageUnit = function(index) {
	var strAPI = this.attr('id') + '.setPageUnit',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(QBOX._.isNumber(index)){
			this._movePage(this.attr('paginationinfo').pageindex, index);
			bool = true;
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.2
 * @author seongdeuk1985
 * @description "페이지 출력 행의 수"를 반환합니다.
 * @returns {number}
 * @example
 * var nPageUnit = QCell1.getPageUnit();
 */
QBOX.QCELL.BasicQCELL.prototype.getPageUnit = function() {
	return QBOX._.clone(this.attr('paginationinfo').pageunit);
};

/**
 * @since QCELL v2.1.2
 * @author seongdeuk1985
 * @description pagination 속성 "param"을 설정합니다.
 * @param {Object} property - 서버로 전송시 전달할 파라미터(JSON)
 * @returns {boolean}
 * @example
 * QCell1.setPaginationParam({"param1": 1, "param2": "RightTech"});
 */
QBOX.QCELL.BasicQCELL.prototype.setPaginationParam = function(property) {
	var strAPI = this.attr('id') + '.setPaginationParam',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(QBOX._.isObject(property) && QBOX._.isArray(property) === false){
			this._setPaginationParam(property);
			bool = true;
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.2
 * @author seongdeuk1985
 * @description pagination 속성 "param"을 반환합니다.
 * @returns {Object}
 * @example
 * QCell1.getPaginationParam();
 */
QBOX.QCELL.BasicQCELL.prototype.getPaginationParam = function() {
	return QBOX._.clone(this.attr('paginationinfo').param);
};

/**
 * @since QCELL v2.1.3
 * @author seongdeuk1985
 * @description pagination 속성 "datacount"를 설정합니다.
 * @param {number} count - 전체 데이터의 수
 * @returns {boolean}
 * @example
 * QCell1.setPaginationDatacount(100);
 */
QBOX.QCELL.BasicQCELL.prototype.setPaginationDatacount = function(count){
	var strAPI = this.attr('id') + '.setPaginationDatacount',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(QBOX._.isNumber(count) === true){
			this.attr('paginationinfo').datacount = count;
			bool = true;
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.3
 * @author seongdeuk1985
 * @description pagination 속성 "datacount"을 반환합니다.
 * @returns {number}
 * @example
 * QCell1.getPaginationDatacount();
 */
QBOX.QCELL.BasicQCELL.prototype.getPaginationDatacount = function() {
	return QBOX._.clone(this.attr('paginationinfo').datacount);
};

/**
 * @since QCELL v2.1.3
 * @author seongdeuk1985
 * @description pagination 속성 "url"를 설정합니다.
 * @param {string} url - 서버와 통신할 url 주소
 * @returns {boolean}
 * @example
 * QCell1.setPaginationUrl("/loadurl.do");
 */
QBOX.QCELL.BasicQCELL.prototype.setPaginationUrl = function(url){
	var strAPI = this.attr('id') + '.setPaginationUrl',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(QBOX._.isString(url) === true){
			this.attr('paginationinfo').url = url;
			bool = true;
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.3
 * @author seongdeuk1985
 * @description pagination 속성 "url"을 반환합니다.
 * @returns {string}
 * @example
 * QCell1.getPaginationUrl();
 */
QBOX.QCELL.BasicQCELL.prototype.getPaginationUrl = function() {
	return QBOX._.clone(this.attr('paginationinfo').url);
};

/**
 * @since QCELL v2.1.3
 * @author seongdeuk1985
 * @description pagination 속성 "loadonce"를 설정합니다.
 * @param {boolean} loadonce - 서버와 통신할 때 전체 데이터를 가져올 것인지 부분 데이터를 가져올 것인지 구분 여부
 * @returns {boolean}
 * @example
 * QCell1.setPaginationLoadonce(true);
 */
QBOX.QCELL.BasicQCELL.prototype.setPaginationLoadonce = function(loadonce){
	var strAPI = this.attr('id') + '.setPaginationLoadonce',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(QBOX._.isBoolean(loadonce) === true){
			this.attr('paginationinfo').loadonce = loadonce;
			bool = true;
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.3
 * @author seongdeuk1985
 * @description pagination 속성 "loadonce"을 반환합니다.
 * @returns {boolean}
 * @example
 * QCell1.getPaginationLoadonce();
 */
QBOX.QCELL.BasicQCELL.prototype.getPaginationLoadonce = function() {
	return QBOX._.clone(this.attr('paginationinfo').loadonce);
};

/**
 * @since QCELL v2.1.4
 * @author seongdeuk1985
 * @description pagination 사용 중 설정된 sort정보를 초기화합니다.
 * @returns {boolean}
 * @example
 * QCell1.setPaginationInitSort();
 */
QBOX.QCELL.BasicQCELL.prototype.setPaginationInitSort = function(){
	this.attr('paginationinfo').initsort = true;
	return true;
};
/**
 * @since QCELL v2.1.4
 * @author seongdeuk1985
 * @description rowheader "checkbox"인 열 인덱스의 checkbox에서 check 된 행 인덱스들을 배열로 반환합니다.
 * @param {number} nCol - 열 인덱스
 * @returns {Array}
 * @example
 * QCell1.getRowheaderChecked(1);
 */
QBOX.QCELL.BasicQCELL.prototype.getRowheaderChecked = function(nCol) {
	var strAPI = this.attr('id') + '.getRowheaderChecked',
	arrChecked = [];
	
	if(arguments.length < 1) {
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(QBOX._.isNumber(nCol)) {
			var type = this.attr('rowheaders')[nCol];
			if(type === 'checkbox' || type==='radio') {
				var arrStatic =  this.attr('staticrowsinfo') !== undefined ? this.attr('staticrowsinfo') : [],
				nStaticLen = arrStatic.length,bSkip=false,nTemp;				
				
				for(var i = this.attr('headerrows'), i_len = this.attr('rows'); i < i_len; i++) { // 전체 데이터 확인
					if(this._getRowheaderData(i, nCol) === true){
						if(this._getQCellCol(nCol).attr('cellinvisible')[i] !== undefined && this._getQCellCol(nCol).attr('cellinvisible')[i] === true){
							continue;
						} 
						if(nStaticLen > 0){
							bSkip = false;
							for(nTemp = 0 ; nTemp <nStaticLen; nTemp++){
								if(arrStatic[nTemp].nRow === i){
									bSkip = true;
									break;
								}
							}
						}
						if(bSkip){
							continue;
						}
						arrChecked.push(i);
					}
				}
			} else {
				QBOX.QCELL.log("err", strAPI, 'This Rowheader Type is not "Checkbox".');
			}
		} else {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return arrChecked;
};

/**
 * @since QCELL v2.1.4
 * @author seongdeuk1985
 * @description rowheader "checkbox"로 입력받은 행,열 인덱스에 해당하는 checkbox의 상태값을 갱신합니다.
 * @param {number} nRow - 행 인덱스
 * @param {number} nCol - 열 인덱스
 * @param {boolean} bState - checkbox 상태값
 * @returns {boolean}
 * @example
 * QCell1.setRowheaderChecked(1, 0, true);
 */
QBOX.QCELL.BasicQCELL.prototype.setRowheaderChecked = function(nRow, nCol, bState) {
	var strAPI = this.attr('id') + '.setRowheaderChecked',
	bool = false;
	
	if(arguments.length < 3) {
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if(QBOX._.isNumber(nCol)) {
			var type = this.attr('rowheaders')[nCol];
			if(type === 'checkbox' || type==='radio') {
				if(QBOX._.isNumber(nRow) && QBOX._.isBoolean(bState)){
					var heParentElement = this._getCellDOM(nRow, nCol);
					this._setRowheaderData(nRow, nCol, bState);
					if(heParentElement !== null){
						var heTargetElement = heParentElement.childNodes[0];
						if(heTargetElement !== undefined)
							heTargetElement.checked = bState;
					}else{
						if( type === 'radio'){
							for (var i=this.getRows('header') ; i< this.getRows();i++){
								var heElement = this._getCellDOM(i, nCol);
								
								if(heElement !== null){
									var heTarget = heElement.childNodes[0];
									if(heTarget !== undefined)
										heTarget.checked = this._getRowheaderData(i, nCol);
								}
							}
						}
					}
					
					bool = true;
				} else {
					QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
				}
			} else {
				QBOX.QCELL.log("err", strAPI, 'This Rowheader Type is not "Checkbox".');
			}
		} else {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	return bool;
};

/**
 * @since QCELL v2.1.4
 * @author seongdeuk1985
 * @description rowheader "checkbox"로 입력받은 행의 배열,열 인덱스에 해당하는 checkbox를 check상태로 갱신합니다.
 * @param {Array} arrRow - 행 인덱스 배열
 * @param {number} nCol - 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.setRowheaderCheckedArr([1, 3, 5], 0);
 */
QBOX.QCELL.BasicQCELL.prototype.setRowheaderCheckedArr = function(arrRow, nCol) {
	var strAPI = this.attr('id') + '.setRowheaderChecked',
	bool = false;
	
	if(arguments.length < 2) {
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
	} else {
		if(QBOX._.isArray(arrRow) && QBOX._.isNumber(nCol)) {
			for(var i = 0; i < arrRow.length; i++){
				var heParentElement = this._getCellDOM(arrRow[i], nCol);
				
				this._setRowheaderData(arrRow[i], nCol, true);
				if(heParentElement === null || heParentElement === undefined)
					return true;
				
				var heTargetElement = heParentElement.childNodes[0];
				heTargetElement.checked = true;
			}
			bool = true;
		} else {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return bool;
};
/**
 * @since QCELL v2.1.5
 * @author sonymaker
 * @description 입력받은 정보를 이용하여 QCELL의 데이터를 그룹화(Groupping)합니다.
 * @param {Object} properties - 그룹화 정보
 * @param {string} [properties.type="normal"] - 그룹화 타입("normal" | "tree")
 * @param {boolean} [properties.hidekeydata=false] - 그룹화 타입이 "tree"일 때 그룹화 할 컬럼의 데이터의 숨김 여부 (v.2.1.47부터 적용)
 * @param {Array.<Object>} properties.columns - 그룹화 할 컬럼들의 정보<br><br>
 * <b>통계함수</b>
 * <table>
 * 	<thead>
 * 		<tr>
 * 			<th>Name</th>
 * 			<th>Parameters</th>
 * 			<th>Description</th>
 * 			<th>Return Type</th>
 * 		</tr>
 * 	</thead>
 * 	<tbody>
 * 		<tr>
 * 			<td>childcount</td>
 * 			<td>없음</td>
 * 			<td>직계 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>count</td>
 * 			<td>없음</td>
 * 			<td>전체 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>countif</td>
 * 			<td>countif(colkey, value)</td>
 * 			<td>전체 자식노드들 중에서 지정한 컬럼의 데이터가 기준값과 동일한 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>sum</td>
 * 			<td>sum(colkey)</td>
 * 			<td>전체 자식노드 데이터들의 총합(colkey값 미입력 시 데이터를 표시 할 컬럼의 키값으로 설정)</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>average</td>
 * 			<td>average(colkey)</td>
 * 			<td>전체 자식노드 데이터들의 평균(colkey값 미입력 시 데이터를 표시 할 컬럼의 키값으로 설정)</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>groupvalue</td>
 * 			<td>groupvalue(grouplevel)</td>
 * 			<td>그룹 헤더/푸터가 그려진 기준이 되는 그룹의 값</td>
 * 			<td>string</td>
 * 		</tr>
 *	</tbody>
 * </table>
 * @param {string} properties.columns[].key - 그룹화 할 컬럼의 키값
 * @param {boolean} [properties.columns[].expand=true] - "tree" 그룹화 타입 사용 시 펼침 여부 설정("normal" 그룹화 타입 사용 시 사용불가)
 * @param {Object.<key:string, celldata:Array>} [properties.columns[].header={}] - 그룹화 시 표시 할 그룹 헤더 행 정보
 * @param {string} properties.columns[].header.key - 그룹 헤더 행에 데이터를 표시 할 컬럼의 키값
 * @param {Array.<string>} properties.columns[].header.celldata - 그룹 헤더 행에 표시 할 텍스트 데이터 배열(텍스트 or <b>통계함수</b>)
 * @param {Object.<key:string, celldata:Array>} [properties.columns[].footer={}] - 그룹화 시 표시 할 그룹 푸터 행 정보
 * @param {string} properties.columns[].footer.key - 그룹 푸터 행에 데이터를 표시 할 컬럼의 키값
 * @param {Array.<string>} properties.columns[].footer.celldata - 그룹 푸터 행에 표시 할 텍스트 데이터 배열(텍스트 or <b>통계함수</b>)
 * @returns {boolean}
 * @example
 * QCell1.setGroup({
 * 	type	: "tree",
 * 	columns	: [
 * 		{
 * 			key	: "sido",
 * 			expand	: true,
 * 			footer	: {
 * 				"sido"	: ["시도: " : "groupvalue(0)", "의 Footer"],
 * 				"goongu": ["읍면동 갯수: ", "count('dong')"],
 * 				.
 * 				.
 * 				.
 * 			}
 * 		},
 * 		{
 * 			key	: "goongu",
 * 			expand	: false,
 * 			footer	: {
 * 				"sido"	: ["군구: " : "groupvalue(0)", "의 Footer"],
 * 				"goongu": ["읍면동 갯수: ", "count('dong')"],
 * 				.
 * 				.
 * 				.
 * 			}
 * 		},
 * 		.
 * 		.
 * 		.
 * 	]
 * });
 */
QBOX.QCELL.BasicQCELL.prototype.setGroup = function(properties){
	var strAPI = this.attr('id') + '.setGroup';
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
			return this._setGroup(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.5
 * @author sonymaker
 * @description 그룹화(Groupping)를 해제합니다.
 * @returns {boolean}
 * @example
 * QCell1.clearGroup();
 */
QBOX.QCELL.BasicQCELL.prototype.clearGroup = function(){
	return this._clearGroup();
};


/**
 * @since QCELL v2.1.120
 * @author jklee
 * @description 입력받은 정보를 이용하여 QCELL의 데이터를 활용하여 Grand total 을 추가합니다..
 * @param {Object} properties - Grand total 정보
 * <b>통계함수</b>
 * <table>
 * 	<thead>
 * 		<tr>
 * 			<th>Name</th>
 * 			<th>Parameters</th>
 * 			<th>Description</th>
 * 			<th>Return Type</th>
 * 		</tr>
 * 	</thead>
 * 	<tbody>
 * 		<tr>
 * 			<td>childcount</td>
 * 			<td>없음</td>
 * 			<td>직계 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>count</td>
 * 			<td>없음</td>
 * 			<td>전체 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>countif</td>
 * 			<td>countif(colkey, value)</td>
 * 			<td>전체 자식노드들 중에서 지정한 컬럼의 데이터가 기준값과 동일한 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>sum</td>
 * 			<td>sum(colkey)</td>
 * 			<td>전체 자식노드 데이터들의 총합(colkey값 미입력 시 데이터를 표시 할 컬럼의 키값으로 설정)</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>average</td>
 * 			<td>average(colkey)</td>
 * 			<td>전체 자식노드 데이터들의 평균(colkey값 미입력 시 데이터를 표시 할 컬럼의 키값으로 설정)</td>
 * 			<td>number</td>
 * 		</tr>
 *	</tbody>
 * </table>
 * @param {Object.<key:string, celldata:Array>} [properties.header=[{}]] - GrandTotal에 표시 할 헤더 행 정보
 * @param {string} properties.header[].key - GrandTotal 헤더 행에 데이터를 표시 할 컬럼의 키값
 * @param {Array.<string>} properties.header[].celldata - 그룹 헤더 행에 표시 할 텍스트 데이터 배열(텍스트 or <b>통계함수</b>)
 * @param {Object.<key:string, celldata:Array>} [properties.footer=[{}]] - 그룹화 시 표시 할 그룹 푸터 행 정보
 * @param {string} properties.footer[].key - 그룹 푸터 행에 데이터를 표시 할 컬럼의 키값
 * @param {Array.<string>} properties.footer[].celldata - 그룹 푸터 행에 표시 할 텍스트 데이터 배열(텍스트 or <b>통계함수</b>)
 * @returns {boolean}
 * @example
 * QCell1.setGrandTotal({
 * 	footer	: [
 * 		 {
 * 				"sido"	: ["시도: " : "groupvalue(0)", "의 Footer"],
 * 				"goongu": ["읍면동 갯수: ", "count('dong')"],
 * 				.
 * 				.
 * 				.
 * 			},
 * 		.
 * 		.
 * 		.
 * 	]
 * });
 */
QBOX.QCELL.BasicQCELL.prototype.setGrandTotal = function(properties){
	var strAPI = this.attr('id') + '.setGrandTotal';
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
			return this._setGrandTotal(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.120
 * @author jklee
 * @description GrandTotal를 해제합니다.
 * @returns {boolean}
 * @example
 * QCell1.clearGrandTotal();
 */
QBOX.QCELL.BasicQCELL.prototype.clearGrandTotal = function(){
	return this._clearGrandTotal();
};

/**
 * @since QCELL v2.1.143
 * @author jklee
 * @description 입력받은 정보를 이용하여 QCELL의 데이터를 계층화(Tree)합니다.
 * @param {Object} properties - 계층화 정보
 * @param {Array.<Object>} properties.columns - 계층화 할 컬럼들의 정보<br><br>
 * <b>통계함수</b>
 * <table>
 * 	<thead>
 * 		<tr>
 * 			<th>Name</th>
 * 			<th>Parameters</th>
 * 			<th>Description</th>
 * 			<th>Return Type</th>
 * 		</tr>
 * 	</thead>
 * 	<tbody>
 * 		<tr>
 * 			<td>childcount</td>
 * 			<td>없음</td>
 * 			<td>직계 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>count</td>
 * 			<td>없음</td>
 * 			<td>전체 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>countif</td>
 * 			<td>countif(colkey, value)</td>
 * 			<td>전체 자식노드들 중에서 지정한 컬럼의 데이터가 기준값과 동일한 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>sum</td>
 * 			<td>sum(colkey)</td>
 * 			<td>전체 자식노드 데이터들의 총합(colkey값 미입력 시 데이터를 표시 할 컬럼의 키값으로 설정)</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>average</td>
 * 			<td>average(colkey)</td>
 * 			<td>전체 자식노드 데이터들의 평균(colkey값 미입력 시 데이터를 표시 할 컬럼의 키값으로 설정)</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>groupvalue</td>
 * 			<td>groupvalue(grouplevel)</td>
 * 			<td>그룹 헤더/푸터가 그려진 기준이 되는 그룹의 값</td>
 * 			<td>string</td>
 * 		</tr>
 *	</tbody>
 * </table>
 * @param {string} properties.columns[].key - 계층화 할 컬럼의 키값
 * @param {boolean} [properties.columns[].expand=true] - 펼침 여부 설정
 * @param {Object.<key:string, celldata:Array>} [properties.columns[].header={}] - 계층화 시 표시 할 그룹 헤더 행 정보
 * @param {string} properties.columns[].header.key - 그룹 헤더 행에 데이터를 표시 할 컬럼의 키값
 * @param {Array.<string>} properties.columns[].header.celldata - 그룹 헤더 행에 표시 할 텍스트 데이터 배열(텍스트 or <b>통계함수</b>)
 * @param {Object.<key:string, celldata:Array>} [properties.columns[].footer={}] - 계층화 시 표시 할 그룹 푸터 행 정보
 * @param {string} properties.columns[].footer.key - 그룹 푸터 행에 데이터를 표시 할 컬럼의 키값
 * @param {Array.<string>} properties.columns[].footer.celldata - 그룹 푸터 행에 표시 할 텍스트 데이터 배열(텍스트 or <b>통계함수</b>)
 * @returns {boolean}
 * @example
 * QCell1.setTree({
 * 	
 * 	columns	: [
 * 		{
 * 			key	: "sido",
 * 			expand	: true,
 * 			footer	: {
 * 				"sido"	: ["시도: " : "groupvalue(0)", "의 Footer"],
 * 				"goongu": ["읍면동 갯수: ", "count('dong')"],
 * 				.
 * 				.
 * 				.
 * 			}
 * 		},
 * 		{
 * 			key	: "goongu",
 * 			expand	: false,
 * 			footer	: {
 * 				"sido"	: ["군구: " : "groupvalue(0)", "의 Footer"],
 * 				"goongu": ["읍면동 갯수: ", "count('dong')"],
 * 				.
 * 				.
 * 				.
 * 			}
 * 		},
 * 		.
 * 		.
 * 		.
 * 	]
 * });
 */

QBOX.QCELL.BasicQCELL.prototype.setTree = function(properties){
	var strAPI = this.attr('id') + '.setTree';
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
			return this._setTree(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.143
 * @author jklee
 * @description 해당 위치에 새로운 트리 노드를 추가합니다.
 * @param {Array} 추가 해야할 키 값 배열
 * @param {Object} 추가해 해야 할 실 데이터  
 * @returns {boolean}
 * @example
 * QCell1.insertTreeNode(["관리기능","시스템관리","제공기관 관리","test4"],
				{
					"code": "MN000025",
					"lev1": '관리기능',
					"lev2": '시스템관리',
					"lev3": '제공기관 관리',
					"lev4": 'test4',
					"lev5": '',
					"lev6": '',
					"useYn": "Y",
					"level": 4,
					"initYn": "Y",
					"searchYn": "Y",
					"newYn": "Y",
					"saveYn": "Y",
					"delYn": "Y",
					"seq": 2,
				  });
 */
QBOX.QCELL.BasicQCELL.prototype.insertTreeNode = function(arrKey, objData,strPosition){
	var strAPI = this.attr('id') + '.insertTreeNode';
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isObject(objData) && QBOX._.isArray(arrKey) ){
			return this._insertTreeNode(arrKey, objData,strPosition);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.143
 * @author jklee
 * @description 해당 위치에 트리 노드를 하위를 포함 하여 삭제 합니다..
 * @param {Array} 삭제 해야할 키 값 배열  
 * @returns {boolean}
 * @example
 * QCell1.removeTreeNode(["관리기능","시스템관리","제공기관 관리","test4"]);
 */
QBOX.QCELL.BasicQCELL.prototype.removeTreeNode = function(arrKey){
	var strAPI = this.attr('id') + '.removeTreeNode';
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if( QBOX._.isArray(arrKey) ){
			return this._removeTreeNode(arrKey);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.147
 * @author jklee
 * @description 해당 위치에 트리 노드의 데이터를 변경 합니다.
 * @param {Array} 변경 해야할 키 값 배열
 * @param {objData} 변경 해야할 키 값 배열     
 * @returns {boolean}
 * @example
 * QCell1.updateTreeNode(["관리기능","시스템관리","제공기관 관리","test4"],{key1:'data1', key2:'data2'});
 */
QBOX.QCELL.BasicQCELL.prototype.updateTreeNode = function(arrKey,objData){
	var strAPI = this.attr('id') + '.updateTreeNode';
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if( QBOX._.isArray(arrKey) ){
			return this._updateTreeNode(arrKey,objData);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
* @since QCELL v2.1.144
* @author jklee
* @description Tree 의 상태값을 가져 옵니다.
* @param {String} 가져올 상태값
* @returns {String}
* @example
* QCell1.getTreeState();
*/
QBOX.QCELL.BasicQCELL.prototype.getTreeState = function(strState){
	var strAPI = this.attr('id') + '.getTreeState';
	
	if(QBOX._.isString(strState) || strState === undefined ){
		return this._getTreeState(strState);
	} else{
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
	}
	
	return '';
};
/**
* @since QCELL v2.1.144
* @author jklee
* @description Tree 의 상태값을 초기화 합니다..
* @returns {boolean}
* @example
* QCell1.clearTreeState();
*/
QBOX.QCELL.BasicQCELL.prototype.clearTreeState = function(){
	return this._clearTreeState();
};

/**
 * @since QCELL v2.1.5
 * @author sonymaker
 * @description 입력받은 정보를 이용하여 QCELL의 데이터를 그룹화(Groupping)합니다.
 * @param {Object} properties - 그룹화 정보
 * @param {string} [properties.type="normal"] - 그룹화 타입("normal" | "tree")
 * @param {boolean} [properties.hidekeydata=false] - 그룹화 타입이 "tree"일 때 그룹화 할 컬럼의 데이터의 숨김 여부 (v.2.1.47부터 적용)
 * @param {Array.<Object>} properties.columns - 그룹화 할 컬럼들의 정보<br><br>
 * <b>통계함수</b>
 * <table>
 * 	<thead>
 * 		<tr>
 * 			<th>Name</th>
 * 			<th>Parameters</th>
 * 			<th>Description</th>
 * 			<th>Return Type</th>
 * 		</tr>
 * 	</thead>
 * 	<tbody>
 * 		<tr>
 * 			<td>childcount</td>
 * 			<td>없음</td>
 * 			<td>직계 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>count</td>
 * 			<td>없음</td>
 * 			<td>전체 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>countif</td>
 * 			<td>countif(colkey, value)</td>
 * 			<td>전체 자식노드들 중에서 지정한 컬럼의 데이터가 기준값과 동일한 자식노드들의 갯수</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>sum</td>
 * 			<td>sum(colkey)</td>
 * 			<td>전체 자식노드 데이터들의 총합(colkey값 미입력 시 데이터를 표시 할 컬럼의 키값으로 설정)</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>average</td>
 * 			<td>average(colkey)</td>
 * 			<td>전체 자식노드 데이터들의 평균(colkey값 미입력 시 데이터를 표시 할 컬럼의 키값으로 설정)</td>
 * 			<td>number</td>
 * 		</tr>
 * 		<tr>
 * 			<td>groupvalue</td>
 * 			<td>groupvalue(grouplevel)</td>
 * 			<td>그룹 헤더/푸터가 그려진 기준이 되는 그룹의 값</td>
 * 			<td>string</td>
 * 		</tr>
 *	</tbody>
 * </table>
 * @param {string} properties.columns[].key - 그룹화 할 컬럼의 키값
 * @param {boolean} [properties.columns[].expand=true] - "tree" 그룹화 타입 사용 시 펼침 여부 설정("normal" 그룹화 타입 사용 시 사용불가)
 * @param {Object.<key:string, celldata:Array>} [properties.columns[].header={}] - 그룹화 시 표시 할 그룹 헤더 행 정보
 * @param {string} properties.columns[].header.key - 그룹 헤더 행에 데이터를 표시 할 컬럼의 키값
 * @param {Array.<string>} properties.columns[].header.celldata - 그룹 헤더 행에 표시 할 텍스트 데이터 배열(텍스트 or <b>통계함수</b>)
 * @param {Object.<key:string, celldata:Array>} [properties.columns[].footer={}] - 그룹화 시 표시 할 그룹 푸터 행 정보
 * @param {string} properties.columns[].footer.key - 그룹 푸터 행에 데이터를 표시 할 컬럼의 키값
 * @param {Array.<string>} properties.columns[].footer.celldata - 그룹 푸터 행에 표시 할 텍스트 데이터 배열(텍스트 or <b>통계함수</b>)
 * @returns {boolean}
 * @example
 * QCell1.setHierarchy({
 * 	column:
 * 		{
 * 			key	: "sido",
 * 			expand	: true,
 * 			footer	: {
 * 				"sido"	: ["시도: " : "groupvalue(0)", "의 Footer"],
 * 				"goongu": ["읍면동 갯수: ", "count('dong')"],
 * 				.
 * 				.
 * 				.
 * 			}
 * 		}
 * });
 */
QBOX.QCELL.BasicQCELL.prototype.setHierachy = function(properties){
	var strAPI = this.attr('id') + '.setHierarchy';
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
			return this._setHierachy(properties);
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};


/**
 * @since QCELL v2.1.7
 * @author seongdeuk1985
 * @description contextmenu에서 비활성화할 메뉴의 id를 설정합니다.
 * @param {Array} ids - 비활성화할 contextmenu의 id의 배열
 * @returns {boolean}
 * @example
 * QCell1.setDisableContextmenu(['contextmenu-1', '...']);
 */
QBOX.QCELL.BasicQCELL.prototype.setDisableContextmenu = function(ids){
	var strAPI = this.attr('id') + '.setDisableContextmenu',
	check = true;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isArray(ids)){
			for(var i=0; i<ids.length; i++){
				if(QBOX._.isString(ids[i]) === false){
					check = false;
				}
			}
			
			if(check){
				return this._setDisableContextmenu(ids);
			}
			else{
				QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
			}
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.7
 * @author seongdeuk1985
 * @description contextmenu에서 비활성화 된 메뉴 중 활성화 할 메뉴의 id를 설정합니다.
 * @param {Array} ids - 활성화할 contextmenu의 id의 배열
 * @returns {boolean}
 * @example
 * QCell1.setAbleContextmenu(['contextmenu-1', '...']);
 */
QBOX.QCELL.BasicQCELL.prototype.setAbleContextmenu = function(ids){
	var strAPI = this.attr('id') + '.setAbleContextmenu',
	check = true;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isArray(ids)){
			for(var i=0; i<ids.length; i++){
				if(QBOX._.isString(ids[i]) === false){
					check = false;
				}
			}
			
			if(check){
				return this._setAbleContextmenu(ids);
			}
			else{
				QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
			}
		} else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.8
 * @author seongdeuk1985
 * @description contextmenu를 설정합니다.
 * @param {Object} obj - 설정할 contextmenu
 * @returns {boolean}
 * @example
 * QCell1.setContextmenu({
 *		header: {
 * 			id: "...",
			contents:
			[
				{},...,{}
			]
 *		},
 *		data: {
 *			base: {
 *				id: "...",
				contents:
				[
					{},...,{}
				]
 *			},
 *			except: [
 *				{col:..., id: "...", contents:[{},...,{}]},
 *				{col:..., id: "...", contents:[{},...,{}]}
 *			]
 *		}
 * });
 */
QBOX.QCELL.BasicQCELL.prototype.setContextmenu = function(obj){
	var strAPI = this.attr('id') + '.setContextmenu',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isObject(obj) === false || QBOX._.isArray(obj)){
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
		else {
			this._initContextMenu();
			bool = this._setContextMenu(obj);
		}
	}
	
	return bool;
};

/**
 * @since QCELL v2.1.8
 * @author seongdeuk1985
 * @description 현재 마우스 커서가 위치한 Contextmenu의 id를 반환합니다.
 * @returns {string}
 * @example
 * QCell1.getContextmenuId();
 */
QBOX.QCELL.BasicQCELL.prototype.getContextmenuId = function(){
	return this._getContextmenuId();
};
/**
 * @since QCELL v2.1.40
 * @author jklee
 * @description 컬럼별 필터를 설정합니다.
 * @param {number} col - 열 인덱스 
 * @param {Any} filter 데이터
 * @returns {boolean}
 * @example
 * QCell1.filter([3,['data1','data2'...]);
 */
QBOX.QCELL.BasicQCELL.prototype.filter = function(col,values){
	var strAPI = this.attr('id') + '.filter',
	check = true;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isArray(values) || QBOX._.isObject(values)){
			
			if(QBOX._.isNumber(col)){
				return this._filter(col,values);
				
			}else{
				QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
			}
			
		} else {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.152
 * @author jklee
 * @description 컬럼별 필터를 설정합니다.
 * @param {number} col - 열 인덱스 거나 key 값 
 * @param {Any} filter 데이터
 * @returns {boolean}
 * @example
 * QCell1.filterEx([3,['data1','data2'...]);
 */
QBOX.QCELL.BasicQCELL.prototype.filterEx = function(col,values){
	var strAPI = this.attr('id') + '.filterEx',
	check = true;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isArray(values) || QBOX._.isObject(values)){
			
			if(QBOX._.isNumber(col) || QBOX._.isString(col) ){
				return this._filter(col,values);
				
			}else{
				QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
			}
			
		} else {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.40
 * @author jklee
 * @description 컬럼별 필터를 해제합니다..
 * @param {number} col - 열 인덱스 
 * @returns {boolean}
 * @example
 * QCell1.resetFilter(3);
 */
QBOX.QCELL.BasicQCELL.prototype.resetFilter = function(col){
	var strAPI = this.attr('id') + '.resetFilter',
	check = true;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
			
		if(QBOX._.isNumber(col)){
			return this._resetFilter(col);
			
		}else{
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
			

	}
	
	return false;
};

/**
 * @since QCELL v2.1.152
 * @author jklee
 * @description 컬럼별 필터를 해제합니다..
 * @param {number} col - 열 인덱스 
 * @returns {boolean}
 * @example
 * QCell1.resetFilter(3);
 */
QBOX.QCELL.BasicQCELL.prototype.resetFilterEx = function(col){
	var strAPI = this.attr('id') + '.resetFilterEx',
	check = true;
	
	//if(arguments.length < 1){
//		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	//} else{
			
		if(QBOX._.isNumber(col) || QBOX._.isString(col) || col === undefined){
			return this._resetFilter(col);
			
		}else{
		
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
			

	//}
	
	return false;
};
/* BasicQCELL의 속성 초기값 정의 */
QBOX.QCELL.config = QBOX._.extend(QBOX._.clone(QBOX.QCELL.config), {
	'width'				: '100%',
	'height'			: '100%',
	'moduletype'		: 'basic',
	'rowheaders'		: [],
	'frozenrows'		: 0,
	'frozenbottomrows'	: 0,
	'frozenbottomstyle'	: '',
	'makefrozenbottomdata'	: false,	
	'frozencols'		: 0,
	'highlightrepeat'	: 0,
	'rowheight'			: {header:40, data:40, footer:40},
	'data'				: {type:'object', input:[]},
	'events'			: {},
	'selectmode'		: 'cells',
	'merge'				: {header:'none',data:'none'},
	'copy'				: false,
	'paste'				: false,
	'pagination'		: {},
	'group'			: {
		type			: 'normal',
		expand		: [],
		showpanel	: false,
		header		: {},
		footer		: {}
	},
	'emptymessage'		: '',
	'contextmenu'		: {header: {},data: {}},
	'useGroupUI'		: false,
	'original'			: false,
	'bottompanel'		: false,
	'bottompanelheight'	: 40,
	'bottompanelstyle'	: 'excel',
	'useheadersort'		: false,
	'useheadercolmove'	: false,
	'excelexportwithformat' : false,
	'usetooltipinellipsis' :false,
	'policy'			: 'dynamic',
	'rowheaderssort'	: []
});
QBOX.QCELL.isForceDynamic = false;
QBOX.QCELL.def.msg = QBOX._.extend(QBOX._.clone(QBOX.QCELL.def.msg), {
	kr	: {
		err	: {
			PARAM_COUNT	: "매개변수의 개수를 확인하세요.",
			PARAM_TYPE	: "매개변수의 데이터타입을 확인하세요.",
			FILE_EXT_NOT_XLSX : "엑셀 파일이 아니거나 파일의 확장자가 'xlsx'가 아닙니다. 확인하여 주십시오."
		}
	},
	en	: {
		err	: {
			PARAM_COUNT	: "Please check parameter's count.",
			PARAM_TYPE	: "Please check parameter's type.",
			FILE_EXT_NOT_XLSX : "Please check, This File is not Excel File or File`s extension is not 'xlsx'."
		}
	}
});

QBOX.QCELL.BasicQCELL.create = function(properties){
	if(QBOX.QCELL.hasInstance(properties.id)){
		QBOX.QCELL.deleteInstance(properties.id);
	}

	return this._create(properties);
};

QBOX.QCELL.BasicQCELL._create = function(properties){
	if(this._checkRequiredProps(properties) && this._checkValidationOfProps(properties)){
		return new this(this._adjustProps(properties));
	}
	return null;
};

QBOX.QCELL.BasicQCELL._checkRequiredProps = function(properties){
	var result = true;
	if(QBOX._.isObject(properties) && QBOX._.isArray(properties) === false){
		var arrRequiredProps = ['id', 'parentid', 'columns'];
		for(var i = 0, nLength = arrRequiredProps.length; i < nLength; i++ ){
			var key = arrRequiredProps[i];
			if(properties[key] === undefined){
				QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property.');
				result = false;
				break;
			}
		}
		arrRequiredProps.RT_clear();
		arrRequiredProps = null;
	} else{
		QBOX.QCELL.log('err', 'QCELL.create', 'Please check first parameter\'s type is "object".');
		result = false;
	}
	return result;
};

QBOX.QCELL.BasicQCELL._checkValidationOfProps = function(properties){
	var result = true;
	QBOX.$.each(properties, function(key, val){
		result = QBOX.QCELL.BasicQCELL._checkValidationOfProp(key, val);
		return result;
	});
	return result;
};

QBOX.QCELL.BasicQCELL._checkValidationOfProp = function(key, val){
	var result = true, defaultmsg = true, datatype = '';
	switch(key){
		/* string type */
		case 'id': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			}

			break;
		}
		case 'parentid': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			} else{
				var heParent = document.getElementById(val);
				if(QBOX._.isElement(heParent)){
					if(QBOX.$(heParent).is(':visible') === false){
						//QBOX.QCELL.log('err', 'QCELL.create', 'Please check that "parent" element is visible.');
						//result = false;
						//defaultmsg = false;
					}
				} else{
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check that "' + key + '" property is "element".');
					result = false;
					defaultmsg = false;
				}
			}

			break;
		}
		case 'width': case 'height': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				if(QBOX._.isNumber(val) === false){//'width'나 'height'값이 string이나 number가 아닌 경우
					result = false;
				}
			} else{
				if(val.replace(/[-\.0-9]/g, '').replace(/px/, '').replace(/%/, '').length > 0){//width,height값 체크(숫자, 'px', '%')
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property. This property can use "number" or "px" or "%" as value.');
					result = false;
					defaultmsg = false;
				}
			}

			break;
		}
		case 'rowheader': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			} else{
				if(val !== 'none' && val !== 'sequence' && val !== 'reverse' && val != 'checkbox'&& val != 'state' && val != 'custom'  && val != 'radio'){
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property. This property can use "sequence" or "reverse" or "checkbox" or "state"  or "custom" as value.');
					result = false;
					defaultmsg = false;
				}
			}

			break;
		}

		case 'selectmode': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			} else{
				switch(val){
					case 'cells': case 'cell': case 'rows': case 'row': case 'cols': case 'col': case 'group': {
						break;
					}
					default: {
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property. This property can use "free" or "row" or "rows" or "col" or "cols" or "group" as value.');
						result = false;
						defaultmsg = false;
						break;
					}
				}
			}

			break;
		}

		case 'onloadurl': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			}

			break;
		}

		/* number type */
		case 'frozenrows': case 'frozenbottomrows': case 'frozencols': case 'highlightrepeat': {
			if(QBOX._.isNumber(val) === false){
				datatype = 'number';
				result = false;
			}
			break;
		}
		
		/* boolean type */
		case 'copy': case 'paste': case 'useGroupUI': case 'original': {
			datatype = 'boolean';
			if(QBOX._.isBoolean(val) === false){
				result = false;
			}
			break;
		}

		/* array type */
		case 'columns': {
			datatype = 'array';
			if(QBOX._.isArray(val) === false){
				result = false;
			}
			break;
		}
		case 'rowheaders': {
			datatype = 'array';
			if(QBOX._.isArray(val) === false){
				result = false;
			} else{
				if(QBOX._.every(val, function(rowheadertype) {return (rowheadertype === 'sequence' || rowheadertype ===  'reverse' || rowheadertype === 'checkbox' || rowheadertype === 'radio' || rowheadertype === 'state' || rowheadertype === 'custom');}) === false){
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property. It can use "sequence" or "reverse" or "checkbox" or "radio" or "state"  or "custom" .');
					result = false;
					defaultmsg = false;
				}
			}
			break;
		}

		/* object type */
		case 'data': {
			datatype = 'object';
			if(QBOX._.isObject(val) === false || QBOX._.isArray(val)){
				result = false;
			} else{
				if(QBOX._.every(QBOX._.keys(val), function(key_of_data){return key_of_data === 'type' || key_of_data === 'input';}) === false){
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property. This property can use "type" or "input" as key.');
					result = false;
					defaultmsg = false;
				} else{
					QBOX.$.each(val, function(key_of_data, val_of_data){
						if(key_of_data === 'type'){
							if(QBOX._.isString(val_of_data) === false){
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_data + '" property. This property\'s type is "string".');
								result = false;
								defaultmsg = false;
								return false;
							}
						} else if(key_of_data === 'input'){
							if(QBOX._.isArray(val_of_data) === false){
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_data + '" property. This property\'s type is "array".');
								result = false;
								defaultmsg = false;
								return false;
							}
						} else{
							return;
						}
					});
				}
			}

			break;
		}
		case 'rowheight':{
			datatype = 'object';
			if(QBOX._.isObject(val) === false || QBOX._.isArray(val)){
				result = false;
			} else{
				if(QBOX._.every(QBOX._.keys(val), function(key_of_rowheight){return key_of_rowheight === 'header' || key_of_rowheight === 'data' || key_of_rowheight === 'footer';}) === false){
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property. This property can use "header" or "data" or "footer" as key.');
					result = false;
					defaultmsg = false;
				} else{
					QBOX.$.each(val, function(key_of_rowheight, val_of_rowheight){
						if(QBOX._.isNumber(val_of_rowheight) === false){
							QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_rowheight + '" property. This property\'s type is "number".');
							result = false;
							defaultmsg = false;
							return false;
						}
					});
				}
			}

			break;
		}

		case 'events': {
			datatype = 'object';

			if(QBOX._.isObject(val) === false || QBOX._.isArray(val)){
				result = false;
			} else{
				if(QBOX._.every(val, function(handler, eventname){return typeof eventname === 'string' && QBOX._.isFunction(handler);}) === false){
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property. This property\'s value is "Function".');
					result = false;
					defaultmsg = false;
					return false;
				}
			}

			break;
		}

		case 'group': {
			datatype = 'object';

			if(QBOX._.isObject(val) === false || QBOX._.isArray(val)){
				result = false;
			} else{
				QBOX.$.each(val, function(key_of_group, val_of_group){
					if(key_of_group === 'showpanel'){
					 	if(QBOX._.isBoolean(val_of_group) === false){
					 		QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_group + '" property. This property\'s type is "boolean".');
					 		result = false;
					 		defaultmsg = false;
					 		return false;
					 	}
					} else if(key_of_group === 'type'){
						if(QBOX._.isString(val_of_group) === false){
							QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_group + '" property. This property\'s type is "string".');
							result = false;
							defaultmsg = false;
							return false;
						}
					} else if(key_of_group === 'expand' || key_of_group === 'header' || key_of_group === 'footer'){
						if(QBOX._.isObject(val_of_group) === false || QBOX._.isArray(val_of_group)){
							QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_group + '" property. This property\'s type is "object".');
							result = false;
							defaultmsg = false;
							return false;
						}
					} else{
						return;
					}
				});
			}

			break;
		}
		
		case 'contextmenu': {
			datatype = 'object';
			
			if(QBOX._.isObject(val) === false || QBOX._.isArray(val)){
				result = false;
			}
			else{
				QBOX.$.each(val, function(key_of_contextmenu, val_of_contextmenu){
					if(key_of_contextmenu === 'id'){
					 	if(QBOX._.isString(val_of_contextmenu) === false){
					 		QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '" property. This property\'s type is "string".');
					 		result = false;
					 		defaultmsg = false;
					 		return false;
					 	}
					}
					else if(key_of_contextmenu === 'contents'){
					 	if(QBOX._.isArray(val_of_contextmenu) === false){
					 		QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '" property. This property\'s type is "array".');
					 		result = false;
					 		defaultmsg = false;
					 		return false;
					 	} else {
					 		QBOX._.each(val_of_contextmenu, function(arr){
								QBOX.$.each(arr, function(key_of_arr_contextmenu, val_of_arr_contextmenu){
									if(key_of_arr_contextmenu === 'header'){
										if(QBOX._.isObject(val_of_arr_contextmenu) === false){
											QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_arr_contextmenu + '" property. This property\'s type is "boolean".');
											result = false;
											defaultmsg = false;
											return false;
										}
										else{
											QBOX.$.each(val_of_arr_contextmenu, function(key_contextmenu, val_contextmenu){
												if(key_contextmenu === 'divine'){
													if(QBOX._.isBoolean(val_contextmenu) === false){
														QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_contextmenu + '" property. This property\'s type is "boolean".');
														result = false;
														defaultmsg = false;
														return false;
													}
												}
												if(key_contextmenu === 'disabled'){
													if(QBOX._.isBoolean(val_contextmenu) === false){
														QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_contextmenu + '" property. This property\'s type is "boolean".');
														result = false;
														defaultmsg = false;
														return false;
													}
												}
												else if(key_contextmenu === 'icon'){
													if(QBOX._.isString(val_contextmenu) === false){
														QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_contextmenu + '" property. This property\'s type is "string".');
														result = false;
														defaultmsg = false;
														return false;
													}
												}
												else if(key_contextmenu === 'label'){
													if(QBOX._.isString(val_contextmenu) === false){
														QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_contextmenu + '" property. This property\'s type is "string".');
														result = false;
														defaultmsg = false;
														return false;
													}
												}
												else if(key_contextmenu === 'items'){
													if(QBOX._.isArray(val_contextmenu) === false){
														QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_contextmenu + '" property. This property\'s type is "array".');
														result = false;
														defaultmsg = false;
														return false;
													}
												}
												else if(key_contextmenu === 'callback'){
													if(QBOX._.isFunction(val_contextmenu) === false && (QBOX._.isString(val_contextmenu) === false || QBOX._.isFunction(window[val_contextmenu]) === false) ){
														QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_contextmenu + '" property. This property\'s type is "function".');
														result = false;
														defaultmsg = false;
														return false;
													}
												}
											});
										}
									}
									else if(key_of_arr_contextmenu === 'data'){
										if(QBOX._.isObject(val_of_arr_contextmenu) === false){
											QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_arr_contextmenu + '" property. This property\'s type is "boolean".');
											result = false;
											defaultmsg = false;
											return false;
										}
										else{
											QBOX.$.each(val_of_arr_contextmenu, function(key_context, val_context){
												if(key_context === 'base'){
													QBOX.$.each(val_context, function(key_contextmenu, val_contextmenu){
														if(key_contextmenu === 'divine'){
															if(QBOX._.isBoolean(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "boolean".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														if(key_contextmenu === 'disabled'){
															if(QBOX._.isBoolean(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "boolean".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														else if(key_contextmenu === 'icon'){
															if(QBOX._.isString(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "string".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														else if(key_contextmenu === 'label'){
															if(QBOX._.isString(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "string".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														else if(key_contextmenu === 'items'){
															if(QBOX._.isArray(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "array".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														else if(key_contextmenu === 'callback'){
															if(QBOX._.isFunction(val_contextmenu) === false && (QBOX._.isString(val_contextmenu) === false || QBOX._.isFunction(window[val_contextmenu]) === false) ){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "function".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
													});
												}
												else if(key_context === 'except'){
													QBOX.$.each(val_context, function(key_contextmenu, val_contextmenu){
														if(key_contextmenu === 'col'){
															if(QBOX._.isNumber(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "number".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														if(key_contextmenu === 'divine'){
															if(QBOX._.isBoolean(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "boolean".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														if(key_contextmenu === 'disabled'){
															if(QBOX._.isBoolean(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "boolean".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														else if(key_contextmenu === 'icon'){
															if(QBOX._.isString(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "string".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														else if(key_contextmenu === 'label'){
															if(QBOX._.isString(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "string".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														else if(key_contextmenu === 'items'){
															if(QBOX._.isArray(val_contextmenu) === false){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "array".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
														else if(key_contextmenu === 'callback'){
															if(QBOX._.isFunction(val_contextmenu) === false && (QBOX._.isString(val_contextmenu) === false || QBOX._.isFunction(window[val_contextmenu]) === false) ){
																QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_contextmenu + '.' + key_context + '.' + key_contextmenu + '" property. This property\'s type is "function".');
																result = false;
																defaultmsg = false;
																return false;
															}
														}
													});
												}
											});
										}
									}
								});
							});
					 	}
					}
				});
			}
			
			break;
		}

		case 'pagination': {
			datatype = 'object';
			if(QBOX._.isArray(val) || QBOX._.isObject(val) === false){
				result = false;
			} else{
				QBOX.$.each(val, function(key_of_pagination, val_of_pagination){
					switch (key_of_pagination) {
						// array
						case 'unitlist': {
							datatype = 'array';

							if(QBOX._.isArray(val_of_pagination) === false){
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_pagination + '" property. This property\'s type is "array".');
								result = false;
								defaultmsg = false;
								return false;
							}
							break;
						}
						// object
						case 'param': {
							datatype = 'object';

							if(QBOX._.isObject(val_of_pagination) === false){
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_pagination + '" property. This property\'s type is "object".');
								result = false;
								defaultmsg = false;
								return false;
							}
							break;
						}
						// number
						case 'pageunit':
						case 'pageIndex':
						case 'pagecount': {
							datatype = 'number';

							if(QBOX._.isNumber(val_of_pagination) === false){
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_pagination + '" property. This property\'s type is "number".');
								result = false;
								defaultmsg = false;
								return false;
							}
							break;
						}
						// string
						case 'url': {
							datatype = 'string';

							if(QBOX._.isString(val_of_pagination) === false){
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_pagination + '" property. This property\'s type is "string".');
								result = false;
								defaultmsg = false;
								return false;
							}
							break;
						}
						case 'mode': {
							datatype = 'string';

							if(QBOX._.isString(val_of_pagination) === false) {
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_pagination + '" property. This property\'s type is "string".');
								result = false;
								defaultmsg = false;
								return false;
							} else if((val_of_pagination === 'simple' || val_of_pagination === 'extend') === false) {
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property. This property can use "simple" or "extend".');
								result = false;
								defaultmsg = false;
								return false;
							}
							break;
						}
						// boolean
						case 'load':
						case 'extendmove':
						case 'loadonce':
						case 'totalsort':
						case 'initsort': {
							datatype = 'boolean';

							if(QBOX._.isBoolean(val_of_pagination) === false){
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '.' + key_of_pagination + '" property. This property\'s type is "boolean".');
								result = false;
								defaultmsg = false;
								return false;
							}
							break;
						}

						default: break;
					}
				});
			}
			break;
		}
		/* *************** 선택 속성 체크 *************** */
		default : break;
	}

	if(result === false && defaultmsg){
		QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property\'s type is "' + datatype + '".');
	}

	return result;
};

QBOX.QCELL.BasicQCELL._adjustProps = function(properties){
	//QBOX.QCELL.config: 전체 사용자 속성
	//properties: 사용자가 입력한 속성
	//QBOX.QCELL.BasicQCELL._adjustProp()을 이용하여 사용자가 입력한 속성값을 보정 후 사용자가 입력하지 않은 속성들은 기본값으로 설정되도록 QBOX.QCELL.config와 합쳐준다.

	var result = QBOX._.mapObject(properties, function(val, key){
		return QBOX.QCELL.BasicQCELL._adjustProp(key, val);
	});

	if(result.rowheader !== undefined && result.rowheader !== 'none'){
		result.rowheaders = [result.rowheader];
		delete result.rowheader;
	}

	return QBOX._.extendOwn(QBOX._.clone(QBOX.QCELL.config), result);
};

QBOX.QCELL.BasicQCELL._adjustProp = function(key, val){
	var result = this._getDefaultValueOfProp(key);

	if(val !== undefined){
		switch(key){
			/* *************** 선택 속성 체크 *************** */
			//case로 정의되어 있지 않은 속성들은 default:{}부분으로 동작한다.
			/* string type */
			case 'width': case 'height': {
				if(QBOX._.isNumber(val) || (QBOX._.isString(val) && val.indexOf('%') === -1 && val.indexOf('px') === -1)){
					result = val + 'px';
				} else{
					result = val;
				}
				break;
			}
			/* boolean type */
			/* number type */
			/* array type */
			/* object type */
			case 'data': {
					result = {
							type	: (val.type === undefined || (val.type !== 'object' && val.type !== 'array')) ? result.type : val.type,
							input	: (val.input === undefined) ? result.input : val.input
						};

				break;
			}
			case 'rowheight': {
				result = {
					header	: (val.header === undefined) ? result.header : val.header,
					data: (val.data === undefined) ? result.data : val.data,
					footer	: (val.footer === undefined) ? result.footer : val.footer
				};

				break;
			}
			case 'group': {
				result = {
					showpanel	: (val.showpanel === undefined) ? result.showpanel : val.showpanel,
					type		: (val.type === undefined || ((val.type !== 'normal' && val.type !== 'tree'))) ? result.type : val.type,
					expand		: (val.expand === undefined) ? result.expand : val.expand,
					header		: (val.header === undefined) ? result.header : val.header,
					footer		: (val.footer === undefined) ? result.footer : val.footer
				};

				break;
			}
			default: {
				result = val;
				break;
			}
		}
	}

	return result;
};

QBOX.QCELL.BasicQCELL._getDefaultValueOfProp = function(key){
	var result = QBOX.QCELL.config[key];

	if(QBOX._.isArray(result) || QBOX._.isObject(result) && QBOX._.isArray(result) === false){
		return QBOX._.clone(result);
	}
	return result;
};

QBOX.QCELL.def.cssprefix = 'rt-qc-';
QBOX.QCELL.def.cellstyle = 'cell-style';
QBOX.QCELL.def.textstyle = 'text-style';
QBOX.QCELL.def.wrapstyle = 'wrap-style';
QBOX.QCELL.def.singlestyle = '-style';

QBOX.QCELL.def.type = QBOX._.extend(QBOX.QCELL.def.type, {
	STATIC					: 'static',
	INPUT					: 'input',
	INPUTBUTTON				: 'inputbutton',
	HTML					: 'html',
	CHART					: 'chart',	
	CHECKBOX				: 'checkbox',
	SELECTMENU				: 'selectmenu',
	TEXTAREA				: 'textarea',
	DATEPICKER				: 'datepicker',
	IMAGE					: 'image',
	RADIO					: 'radio',
	MULTICHECKBOX			: 'multicheckbox',
	NUMBER					: 'number',
	SLIDER					: 'slider',
	BUTTON					: 'button',
	EDITOR					: 'editor',
	INPUT_DATEPICKER		: 'inputdatepicker',
	
	INVISIBLE				: 'invisible'
});

QBOX.QCELL.def.rowgroup = QBOX._.extend(QBOX.QCELL.def.rowgroup, {
	
});

QBOX.QCELL.def.css = QBOX._.extend(QBOX.QCELL.def.css, {
	TYPE_STATIC_STYLE						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.STATIC + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_INPUT_STYLE						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.INPUT + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_INPUT_EDIT_STYLE					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.INPUT + '-edit-' + QBOX.QCELL.def.cellstyle,	
	TYPE_HTML_STYLE							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.HTML + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_CHECKBOX_STYLE						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.CHECKBOX + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_RADIO_STYLE						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.RADIO + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_SELECTMENU_STYLE					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.SELECTMENU + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_TEXTAREA_STYLE						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.TEXTAREA + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_DATEPICKER_STYLE					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.DATEPICKER + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_IMAGE_STYLE						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.IMAGE + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_MULTICHECKBOX_STYLE				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.MULTICHECKBOX + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_NUMBER_STYLE						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.NUMBER + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_SLIDER_STYLE						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.SLIDER + '-' + QBOX.QCELL.def.cellstyle,
	TYPE_BUTTON_STYLE						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.BUTTON + '-' + QBOX.QCELL.def.cellstyle,

	TYPE_INPUT_TEXT_STYLE					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.INPUT + '-' + QBOX.QCELL.def.textstyle,
	TYPE_TEXTAREA_TEXT_STYLE				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.TEXTAREA + '-' + QBOX.QCELL.def.textstyle,
	TYPE_NUMBER_TEXT_STYLE					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.NUMBER + '-' + QBOX.QCELL.def.textstyle,
	
	TYPE_DATEPICKER_WRAP_STYLE				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.DATEPICKER + '-' + QBOX.QCELL.def.wrapstyle,
	TYPE_SELECTMENU_WRAP_STYLE				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.SELECTMENU + '-' + QBOX.QCELL.def.wrapstyle,
	TYPE_CHECKBOX_WRAP_STYLE				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.CHECKBOX + '-' + QBOX.QCELL.def.wrapstyle,
	TYPE_MULTICHECKBOX_WRAP_STYLE			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.MULTICHECKBOX + '-' + QBOX.QCELL.def.wrapstyle,
	TYPE_HTML_WRAP_STYLE					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.HTML + '-' + QBOX.QCELL.def.wrapstyle,
	TYPE_SLIDER_WRAP_STYLE					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.SLIDER + '-' + QBOX.QCELL.def.wrapstyle,
	TYPE_BUTTON_WRAP_STYLE					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.BUTTON + '-' + QBOX.QCELL.def.wrapstyle,
	TYPE_EDITOR_WARP_STYLE					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.EDITOR + '-' + QBOX.QCELL.def.wrapstyle,
	
	TYPE_STATIC_CELL						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.STATIC + '-type-cell',
	TYPE_INPUT_CELL							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.INPUT + '-type-cell',
	TYPE_HTML_CELL							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.HTML + '-type-cell',
	TYPE_CHECKBOX_CELL						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.CHECKBOX + '-type-cell',
	TYPE_RADIO_CELL							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.RADIO + '-type-cell',
	TYPE_SELECTMENU_CELL					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.SELECTMENU + '-type-cell',
	TYPE_TEXTAREA_CELL						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.TEXTAREA + '-type-cell',
	TYPE_DATEPICKER_CELL					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.DATEPICKER + '-type-cell',
	TYPE_INPUTDATEPICKER_CELL				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.INPUT_DATEPICKER + '-type-cell',
	TYPE_IMAGE_CELL							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.IMAGE + '-type-cell',
	TYPE_MULTICHECKBOX_CELL					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.MULTICHECKBOX + '-type-cell',
	TYPE_NUMBER_CELL						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.NUMBER + '-type-cell',
	
	TYPE_SLIDER_CELL						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.SLIDER + '-type-cell',
	TYPE_BUTTON_CELL						: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.BUTTON + '-type-cell',
	
	TYPE_SLIDER_SINGLE_STYLE				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.SLIDER + QBOX.QCELL.def.singlestyle,
	TYPE_SLIDER_RESULT_SINGLE_STYLE			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.SLIDER + '-result' + QBOX.QCELL.def.singlestyle,
	TYPE_BUTTON_SINGLE_STYLE				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.BUTTON + QBOX.QCELL.def.singlestyle,
	TYPE_BUTTON_LABEL_SINGLE_STYLE			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.BUTTON + '-label' + QBOX.QCELL.def.singlestyle,
	
	TYPE_EDITOR_SINGLE_STYLE				: QBOX.QCELL.def.csspx + QBOX.QCELL.def.singlestyle,
	
	TYPE_DATEPICKER_SINGLE_STYLE			: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.DATEPICKER + QBOX.QCELL.def.singlestyle,
	TYPE_DATEPICKER_SINGLE_DATE_STYLE		: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.DATEPICKER + '-date' + QBOX.QCELL.def.singlestyle,
	TYPE_DATEPICKER_SINGLE_IMG_STYLE		: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.DATEPICKER + '-img' + QBOX.QCELL.def.singlestyle,
	
	TYPE_INVISIBLE_SINGLE_STYLE				: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.INVISIBLE + QBOX.QCELL.def.singlestyle,
	
	TYPE_DATEPICKER							: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.DATEPICKER + '-type',
	TYPE_INPUT_DATEPICKER					: QBOX.QCELL.def.cssprefix + QBOX.QCELL.def.type.INPUT_DATEPICKER + '-type'
	
});
QBOX.QCELL.module = 'normal';

/**
 * @since QCELL v1.0.0
 * @description CRUD용 QCELL 클래스
 * @constructor
 */
QBOX.QCELL.NormalQCELL = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.BasicQCELL.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.NormalQCELL, QBOX.QCELL.BasicQCELL);

QBOX.QCELL.NormalQCELL.prototype._initMOL = function(){
	QBOX.QCELL.BasicQCELL.prototype._initMOL.call(this);
	
	QBOX.util.addMethod(this, '_dataCellValue', function(nRow, nCol, val){//setter
		//직접 사용 금지, 반드시 _cellValue()를 이용하여 호출해야 함.
		try{
			var heCell = this._getCellDOM(nRow, nCol);
			var originKey = 'rt_qcell_initdata';
			
			if(this.attr('currentdata')[nRow - this.attr('headerrows')][originKey] === undefined){
				this.attr('currentdata')[nRow - this.attr('headerrows')][originKey] = QBOX._.clone(this.attr('currentdata')[nRow - this.attr('headerrows')]);
			}
			
			this.attr('currentdata')[nRow - this.attr('headerrows')][this._getKeyOfCol(nCol)] = val;
			
			if(QBOX._.isElement(heCell)){
				if(val === undefined){
					QBOX.util.textContent(heCell, '');
					this._setAriaLabel(heCell,nRow,nCol,'');
				} else 	if(this._isBottomPanel(heCell)){
					if(this._getColType(nCol)==='checkbox' && (val === true || val === false)){
						val = '';
					}
					if(val === undefined){
						QBOX.util.textContent(heCell, '');						
					}else{
						QBOX.util.textContent(heCell, val);						
					}
					this._setAriaLabel(heCell,nRow,nCol,val);
				} else{					
					var target = heCell.getElementsByTagName('input')[0];
					switch (this._getColType(nCol)) {
						case 'selectmenu': {
							var targetJson = {};
							
							this.attr('currentdata')[nRow - this.attr('headerrows')][this._getKeyOfCol(nCol)] = val;
							
							QBOX.$.each(this._getColElement(nCol).attr('input'), function(idx, obj){
								QBOX.$.each(obj, function(key, value){
									if( key === "value" && val === value ){
										targetJson = obj;
										return false;
									}
								});
							});
							
							if(targetJson !==undefined && targetJson.label !== undefined) {
								QBOX.util.textContent(heCell, targetJson.label);
							}
							this._setAriaLabelEx(heCell,nRow,nCol,false);
							break;
						}
						case 'checkbox': {
							var checkedvalue = this._getColElement(nCol).attr('checkedvalue'),
							uncheckedvalue = this._getColElement(nCol).attr('uncheckedvalue');
							if(target === undefined){
								this._getColElement(nCol)._show(heCell,nRow,nCol);
								target = heCell.getElementsByTagName('input')[0];
							}							
							if(checkedvalue === val) {
								target.checked = true;
								target.value = val;
							} else if(uncheckedvalue === val) {
								target.checked = false;
								target.value = val;
							}
							//this._setAriaLabelEx(heCell,nRow,nCol,false);
							break;
						}
						case 'image': {
							target = heCell.getElementsByTagName('img')[0];
							if(!QBOX._.isUndefined(target)){
								if(QBOX._.isString(val)){
									target.src = val;
								}
							}
							this._setAriaLabelEx(heCell,nRow,nCol,false);
							break;
						}
						case 'html' :{
							this._getColElement(nCol)._show(heCell, nRow, nCol);
							this._setAriaLabelEx(heCell,nRow,nCol,false);
							break;
						}
						case 'chart' :{
							this._getColElement(nCol)._show(heCell, nRow, nCol);
							this._setAriaLabelEx(heCell,nRow,nCol,false);
							break;
						}
						case 'inputbutton' : {
							this._getColElement(nCol)._showDataLabel(heCell,nRow,nCol,val);
							this._setAriaLabelEx(heCell,nRow,nCol,false);
							break;
						}
						case 'datepicker' : {
							this._getColElement(nCol)._showDataLabel(heCell,nRow,nCol,val);
							this._setAriaLabelEx(heCell,nRow,nCol,false);
							break;
						}
						
						default: {
							val = this._showDataFormat(nRow,nCol,val);
							QBOX.util.textContent(heCell, val);
							this._setAriaLabel(heCell,nRow,nCol,val);
							break;
						}
					}
					
					
				}
			}
			if(this.attr('pagesyncorgindata') === true){
				if(this.attr('currentdata')[nRow - this.attr('headerrows')].rt_qc_page_state === undefined ){
					this.attr('currentdata')[nRow - this.attr('headerrows')].rt_qc_page_state = 'u';
				}else if(this.attr('currentdata')[nRow - this.attr('headerrows')].rt_qc_page_state !== 'i'){
					this.attr('currentdata')[nRow - this.attr('headerrows')].rt_qc_page_state = 'u';
				}
			}
			if(this.getRowState(nRow) !== 'i' && this.getRowState(nRow) !== 'd'){
				
				var bCheck = false;
				var objOrigin = this.attr('currentdata')[nRow - this.attr('headerrows')],
				objInit = objOrigin[originKey],originState = this.getRowState(nRow);
				
				for(var key in objOrigin){
					if(originKey === key)
						continue;
					if(objInit[key] !== objOrigin[key]){
						bCheck = true;
						break;
					}
				}
				
				if(bCheck === true){
					if(originState !== 'u')
						this._updateRowState(nRow, 'u');
				}else{
					if(originState !== 'n'){
						this.removeRowState(nRow);
						delete this.attr('currentdata')[nRow - this.attr('headerrows')][originKey];						
					}
				}
				
			}
				
			
			return true;
		} catch(e){
			QCELL.log('err', 'QCELL.NormalQCELL._dataCellValue', e.message);
			return false;
		}
	});
};

QBOX.QCELL.NormalQCELL.prototype._initTag = function(){
	this.tag('QBOX.QCELL.NormalQCELL');
};

QBOX.QCELL.NormalQCELL.prototype._initAttrs = function(properties){
	QBOX.QCELL.BasicQCELL.prototype._initAttrs.call(this, properties);
	
	/* Editing 관련 속성*/
	this.attr('oneclickedit', properties.oneclickedit, 'boolean');
	this.attr('editcolids', [], 'array');								//edit 상태인 컬럼 ids
	
	/* 셀 인덱스 관련 속성*/
	this.attr('idxinfo', QBOX._.extend(this.attr('idxinfo'), {
		state : {						//멀티업데이트 정보가 있는 인덱스 정보
			row : new _QHashtable(),		//3 : 'd' or 'i' or 'u'
			col : new _QHashtable()
		}
	}), 'object');
	//valuechanged 정보 저장
	this.attr('idxinfo', QBOX._.extend(this.attr('idxinfo'), {
		valuechanged : {				
			row : new _QHashtable(),		
			col : new _QHashtable()
		}
	}), 'object');
	
	this.attr('idxinfo', QBOX._.extend(this.attr('idxinfo'), {
		celldisabled : {				
			row : new _QHashtable(),		
			col : new _QHashtable()
		}
	}), 'object');
	this.attr('idxinfo', QBOX._.extend(this.attr('idxinfo'), {
		cellinvisible : {				
			row : new _QHashtable(),		
			col : new _QHashtable()
		}
	}), 'object');
	
	this.attr('deletedrowsdata', [], 'array');//삭제된 행의 데이터를 저장
	
	this.attr('staticrowsinfo', [], 'array');
	
	/* 상태정보 관련 속성 */
	var statetype = properties.statetype === undefined ? 'immediate' : properties.statetype;
	this.attr('statetype', statetype, 'string');//'immediate' || 'later', 상태정보 컨트롤 타입을 설정
	/*
	 1. 바로 동기화 시(immediate)
		- delete된 정보를 "states"에 담아 둘 필요가 없다. -> "delete"된 정보를 모아두는 속성 추가 필요
		- delete된 행 정보들을 따로 관리한다.
		- delete되면 "states"를 동기화 해 주어야 한다. -> "delete"된 행 이후의 행 동기화 정보의 인덱스를 -1처리한다.
		- insert되면 "states"에 기록하고 "states"를 동기화 해 주어야 한다. -> "insert"된 행 이후의 행 동기화 정보의 인덱스를 +1처리한다.
		- update되면 "states"에 기록한다.
	 2. 신호등 처리 시(later)
		- delete된 정보를  "states"에 기록한다.
		- delete된 행 정보들을 따로 관리하지 않는다. -> "delete"된 정보를 모아두는 속성 추가 필요없음
		- delete되어도 "states"를 동기화 할 필요가 없다.
		- insert되면 "states"에 기록하고 "states"를 동기화 해 주어야 한다. -> "insert"된 행 이후의 행 동기화 정보의 인덱스를 +1처리한다.
		- update되면 "states"에 기록한다.
	*/
	
	/*
	 * syncinfo => {
	 * 		row : {
	 * 			3 : [
	 * 				'style',
	 * 				'state'
	 * 			]
	 * 		},
	 * 		col : {
	 * 			5 : [
	 * 				'style',
	 * 				'state'
	 * 			]
	 * 		}
	 * }
	 * */
	
	this._initAttr('delkeymode',properties.delkeymode,'string');
	
	this._initAttr('setstatewithapi',properties.setstatewithapi,'boolean');
};

QBOX.QCELL.NormalQCELL.prototype._initAttr = function(key, val, type){
	this.attr(key, val === undefined ? QBOX.QCELL.config[key] : val, type);
};

QBOX.QCELL.NormalQCELL.prototype._clearAttrs = function(){
	QBOX.QCELL.BasicQCELL.prototype._clearAttrs.call(this);
	
	//onMouseEnter, onMouseLeave 처리 시 document에 등록되었던 이벤트 제거
	QBOX.$(document).off('mousedown.' + this.attr('id'));
};

QBOX.QCELL.NormalQCELL.QCellCol = function(props){
	if(QBOX.util.checkType(props, 'object') === false){return null;}
	QBOX.Base.call(this, props);
};
QBOX.util.inherit(QBOX.QCELL.NormalQCELL.QCellCol, QBOX.QCELL.BasicQCELL.QCellCol);

QBOX.util.addMethod(QBOX.QCELL.NormalQCELL.QCellCol, 'create', function(properties){
	return new QBOX.QCELL.NormalQCELL.QCellCol(this._adjustProps(properties));
});
QBOX.util.addMethod(QBOX.QCELL.NormalQCELL.QCellCol, 'create', function(col, properties){
	return this._create(col, properties);
});

QBOX.QCELL.NormalQCELL.QCellCol.prototype._initMOL = function(){
	QBOX.QCELL.BasicQCELL.QCellCol.prototype._initMOL.call(this);
};

QBOX.QCELL.NormalQCELL.QCellCol.prototype._initTag = function(){
	this.tag('QBOX.QCELL.NormalQCELL.QCellCol');
};

QBOX.QCELL.NormalQCELL.QCellCol.prototype._init = function(props){
	QBOX.QCELL.BasicQCELL.QCellCol.prototype._init.call(this, props);
	
	this._createColElement();
};

QBOX.QCELL.NormalQCELL.QCellCol.prototype._initAttrs = function(props){
	QBOX.QCELL.BasicQCELL.QCellCol.prototype._initAttrs.call(this, props);
	
	this.attr('colelement', null, 'object');
	
	this._initAttr('type', props.type, 'string');
	this._initAttr('disabled', props.disabled, 'boolean');
	this._initAttr('mask', props.options.mask, 'object');
	this._initAttr('html',  props.options.html, 'object');
	this._initAttr('chart',  props.options.chart, 'object');
	this._initAttr('invisibled', props.options.invisibled, 'boolean');
	this._initAttr('celldisabled', [], 'array');
	this._initAttr('cellinvisible', [], 'array');
	
	this._initAttr('tabindex' , props.tabindex , 'boolean');
	
	// 컬럼별 required 사용 여부	
	var bRequired =  props.options.required === undefined ? false : props.options.required;
	this._initAttr('required',  bRequired, 'boolean');	
};

QBOX.QCELL.NormalQCELL.QCellCol.prototype._initAttr = function(key, val, type){
	QBOX.QCELL.BasicQCELL.QCellCol.prototype._initAttr.call(this, key, val, type);
};

/* NormalQCELL.QCellCol의 속성 초기값 정의 */
QBOX.QCELL.colconfig = QBOX._.extend(QBOX._.clone(QBOX.QCELL.colconfig), {
	/* string type */
	/* boolean type */
	disabled	: false,
	invisibled	: false,
	/* number type */
	/* array type */
	/* object type */
	options : {},
	/* function type */
	html		: {
		data	: null,
		datacallback : null,
		header	: null
	},
	tabindex	: true
});

/*
QBOX.QCELL.NormalQCELL.QCellCol.create = function(col, properties){
	return this._create(col, properties);
};
*/
QBOX.QCELL.NormalQCELL.QCellCol._create = function(col, properties){
	if(this._checkRequiredProps(col, properties) && this._checkValidationOfProps(col, properties)){
		return new QBOX.QCELL.NormalQCELL.QCellCol(this._adjustProps(properties));
	}
	return null;
};

QBOX.QCELL.NormalQCELL.QCellCol._checkRequiredProps = function(col, properties){
	if(QBOX.QCELL.BasicQCELL.QCellCol._checkRequiredProps(col, properties)){
		return true;
	}
	return false;
};

QBOX.QCELL.NormalQCELL.QCellCol._checkValidationOfProps = function(col, properties){
	var result = false;
	if(QBOX.QCELL.BasicQCELL.QCellCol._checkValidationOfProps(col, properties)){
		QBOX.$.each(properties, function(key, val){
			result = QBOX.QCELL.NormalQCELL.QCellCol._checkValidationOfProp(col, key, val);
			return result;
		});
	}
	return result;
};

QBOX.QCELL.NormalQCELL.QCellCol._checkValidationOfProp = function(col, key, val){
	var result = true, defaultmsg = true, datatype = '';
	switch(key){
		/* *************** 필수 속성 체크 *************** */
		/* array type */
		/* object type */
		
		/* *************** 선택 속성 체크 *************** */
		/* string type */
		case 'type': {
			datatype = 'string';
			if(QBOX._.isString(val) === false){
				result = false;
			} else{
				switch(val){
					case 'input': case 'textarea': case 'datepicker': case 'selectmenu': case 'image': case 'checkbox': case 'number': case 'static': case 'html': case 'chart': case 'multicheckbox': case 'slider': case 'button': case 'editor': case 'inputbutton': case 'inputdatepicker':{
						break;
					}
					default: {
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '" property. This property can use "input" or "textarea" or "datepicker" or "selectmenu" or "image" or "checkbox" or "number" or "html" or "chart" or "multicheckbox" or "slider" or "button" or "editor" as value.');
						result = false;
						defaultmsg = false;
						break;
					}
				}
			}
			break;
		}
		/* array type */
		/* object type */
		case 'options': {
			// type html
			if(val !== undefined && QBOX._.isObject(val) === false || QBOX._.isArray(val) === true){
				datatype = 'object';
				result = false;
			}
			else {
				// type input
				if(val.maxlength !== undefined && QBOX._.isNumber(val.maxlength) === false){
					datatype = 'number';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.maxlength'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				
				else if(val.numrange !== undefined && QBOX._.isString(val.numrange) === false){
					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.numrange'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				else if(QBOX._.isString(val.numrange) === true){
					var expinput = /^([+-]?\d*(\.?\d*))(\:)([+-]?\d*(\.?\d*))$/;
					
 					if(expinput.test(val.numrange) === false) {
 						datatype = 'string';
 	 					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.numrange'+ '"\'s data setting.');
 	 					result = false;
 	 					defaultmsg = false;
 					}
 				}
				
				else if( val.limit !== undefined && val.limit !== null ) {
					if(val.limit !== undefined && QBOX._.isObject(val.limit) === false){
						datatype = 'object';
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.limit'+ '"\'s type is "' + datatype + '".');
						result = false;
						defaultmsg = false;
					}
					else {
						if(QBOX._.isString(val.limit.type) === false){
							datatype = 'string';
							QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.limit.type'+ '"\'s type is "' + datatype + '".');
							result = false;
							defaultmsg = false;
						} else if(val.limit.type === "all" && val.limit.type === "string" && val.limit.type ===  "number" && val.limit.type === "other") {
							QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.limit.type'+ '"\'s val is "' + "string or number or other" + '".');
							result = false;
							defaultmsg = false;
						} else if(val.limit.type === "other") {
							if(val.limit.expreg !== undefined && QBOX._.isString(val.limit.expreg) === false) {
								datatype = 'string';
								QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.limit.expreg'+ '"\'s type is "' + datatype + '".');
								result = false;
								defaultmsg = false;
							}
						}
					}
				}
				else if (val.exclude !== undefined && val.exclude !== null){
					if(val.exclude !== undefined && QBOX._.isArray(val.exclude) === false){
						datatype = 'array';
						QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.exclude'+ '"\'s type is "' + datatype + '".');
						result = false;
						defaultmsg = false;
					}					
					
				}
				
				// type html
				else if( val.html !== undefined && val.html !== null ) {
					if( val.html !== undefined && QBOX._.isObject(val.html) === false || QBOX._.isArray(val.html) === true ){
						datatype = 'object';
						result = false;
					} else {
						if( val.html.data !== undefined && QBOX._.isFunction(val.html.data) === false ){
							datatype = 'function';
							result = false;
						} else if( val.html.header !== undefined && QBOX._.isFunction(val.html.header) === false ){
							datatype = 'function';
							result = false;
						} else if( val.html.datacallback !== undefined && QBOX._.isFunction(val.html.datacallback) === false ){
							datatype = 'function';
							result = false;
						}
					}
				}
				
				/*
				// type editor
				else if( val.editor !== undefined && val.editor !== null ) {
					if( val.editor !== undefined && QBOX._.isObject(val.editor) === false || QBOX._.isArray(val.editor) === true ){
						datatype = 'object';
						result = false;
					} else {
						if( val.editor.data !== undefined && QBOX._.isFunction(val.editor.data) === false ){
							datatype = 'function';
							result = false;
						}
					}
				}
				*/
				
				// type textarea
 				else if(val.textareawidth !== undefined && QBOX._.isString(val.textareawidth) === false){
					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.textareawidth'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				// type datepicker
 				else if(val.dateformat !== undefined && QBOX._.isString(val.dateformat) === false){
 					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.dateformat'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
				
 				else if(val.timeformat !== undefined && QBOX._.isString(val.timeformat) === false){
 					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.timeformat'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
				
 				else if(val.timetype !== undefined && QBOX._.isString(val.timetype) === false){
 					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.timetype'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
				
 				else if(val.timeseparator !== undefined && QBOX._.isString(val.timeseparator) === false){
 					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.separator'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
				
 				else if(QBOX._.isString(val.timetype) === true) {
 					switch(val.timetype) {
 						case 'none': case 'with': case 'only': {
 							break;
 						}
 						default: {
 							QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.timetype." This property can use "none" or "with" or "only" as value.');
							result = false;
							defaultmsg = false;
							break;
 						}
 					}
 				}
				
 				else if(val.locale !== undefined && QBOX._.isString(val.locale) === false){
 					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.locale'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
				
 				else if(val.yearrange !== undefined && QBOX._.isString(val.yearrange) === false){
 					datatype = 'string';
 					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.yearrange'+ '"\'s type is "' + datatype + '".');
 					result = false;
 					defaultmsg = false;
 				}
 				else if(QBOX._.isString(val.yearrange) === true){
 					var exptext = /^(((c\-)[0-9]{1,4})(\:)(c\+)[0-9]{1,4})|((\-)[0-9]{1,4}(\:)(\+)[0-9]{1,4})|([0-9]{1,4}(\:)[0-9]{1,4})$/;
 					
 					if(exptext.test(val.yearrange) === false) {
 						datatype = 'string';
 	 					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.yearrange'+ '"\'s data setting.');
 	 					result = false;
 	 					defaultmsg = false;
 					}
 				}
				
 				else if(val.changeyear !== undefined && QBOX._.isBoolean(val.changeyear) === false){
 					datatype = 'boolean';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.changeyear'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
				
 				else if(val.changemonth !== undefined && QBOX._.isBoolean(val.changemonth) === false){
 					datatype = 'boolean';
 					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.changemonth'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
				
				// type selectmenu
 				else if(val.input !== undefined && QBOX._.isArray(val.input) === false){
 					datatype = 'array';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.input'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
 				else if(val.itemcount !== undefined && QBOX._.isNumber(val.itemcount) === false){
 					datatype = 'number';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.itemcount'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
 				else if(val.selectedEnd !== undefined && QBOX._.isBoolean(val.selectedEnd) === false){
 					datatype = 'boolean';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.selectedEnd'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
 				else if(val.selectclickopen !== undefined && QBOX._.isBoolean(val.selectclickopen) === false){
 					datatype = 'boolean';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.selectclickopen'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
				
				// type checkbox
				else if( val.wholeselect !== undefined && QBOX._.isBoolean(val.wholeselect) === false ) {
					datatype = 'boolean';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.wholeselect'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				else if( val.checkedvalue !== undefined && (QBOX._.isBoolean(val.checkedvalue) || QBOX._.isString(val.checkedvalue)) === false ) {
					datatype = 'boolean or string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.checkedvalue'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				else if( val.uncheckedvalue !== undefined && (QBOX._.isBoolean(val.uncheckedvalue) || QBOX._.isString(val.uncheckedvalue)) === false ) {
					datatype = 'boolean or string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.uncheckedvalue'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				// type image
				else if( val.imagealt !== undefined && QBOX._.isString(val.imagealt) === false ) { 
					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.imagealt'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				} 
				else if( val.imageheight !== undefined && QBOX._.isString(val.imageheight) === false ) {
					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.imageheight'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				} 
				else if( val.imagewidth !== undefined && QBOX._.isString(val.imagewidth) === false ) {
					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.imagewidth'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				} 
				else if( val.imagestyle !== undefined && QBOX._.isObject(val.imagestyle) === false ) {
					datatype = 'object';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.imagestyle'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				} 
				else if( val.imageclick !== undefined && QBOX._.isString(val.imageclick) === false ) {
					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.imageclick'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				else if( val.imageuri !== undefined && QBOX._.isString(val.imageuri) === false ) {
					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.imageuri'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				else if( val.imageerroruri !== undefined && QBOX._.isString(val.imageerroruri) === false ) {
					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.imageerroruri'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				
				else if(val.buttonwidth !== undefined && QBOX._.isString(val.buttonwidth) === false){
 					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.buttonwidth'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
 				}
				else if(QBOX._.isString(val.buttonwidth) && (val.buttonwidth.replace(/[-\.0-9]/g, '').replace(/px/, '').replace(/%/, '').length > 0)){ //buttonwidth값 체크(숫자, 'px', '%')
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.buttonwidth'+ '" property. This property can use "number" or "px" or "%" as value.');
					result = false;
					defaultmsg = false;
				}
				else if(val.buttonheight !== undefined && QBOX._.isString(val.buttonheight) === false){
 					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.buttonheight'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
					
 				}
				else if(QBOX._.isString(val.buttonheight) && (val.buttonheight.replace(/[-\.0-9]/g, '').replace(/px/, '').replace(/%/, '').length > 0)){ //buttonheight값 체크(숫자, 'px', '%')
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.buttonheight'+ '" property. This property can use "number" or "px" or "%" as value.');
					result = false;
					defaultmsg = false;
				}
				else if(val.buttonposition !== undefined && QBOX._.isString(val.buttonposition) === false){
					/*
 					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.buttonposition'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
					*/
					val.buttonposition = 'left';
 				}
				else if(QBOX._.isString(val.buttonposition)){
					switch(val.buttonposition){
						case 'left': case 'right': case 'center': {
							break;
						}
						default: {
							QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.buttonlabel'+ '" property. This property can use "left" or "right" or "center" as value.');
							result = false;
							defaultmsg = false;
							break;
						}
					}
				}
				else if(val.buttonlabel !== undefined && QBOX._.isString(val.buttonlabel) === false){
					datatype = 'string';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.buttonlabel'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
				else if(val.buttonclick !== undefined && QBOX._.isFunction(val.buttonclick) === false){
					datatype = 'function';
					QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '.buttonclick'+ '"\'s type is "' + datatype + '".');
					result = false;
					defaultmsg = false;
				}
			}
			break;
		}
		
		default : {
			break;
		}		
	}
	
	if( result === false && defaultmsg ){
		QBOX.QCELL.log('err', 'QCELL.create', 'Please check "columns[' + col + '].' + key + '"\'s type is "' + datatype + '".');
	}
	
	return result;
};

QBOX.QCELL.NormalQCELL.QCellCol._adjustProps = function(properties){
	var result = QBOX._.mapObject(QBOX.QCELL.BasicQCELL.QCellCol._adjustProps(properties), function(val, key){
		return QBOX.QCELL.NormalQCELL.QCellCol._adjustProp(key, val);
	});
	
	return QBOX._.extendOwn(QBOX._.clone(QBOX.QCELL.colconfig), result);
};

QBOX.QCELL.NormalQCELL.QCellCol._adjustProp = function(key, val){
	var result = null;
	if(val === undefined){
		result = QBOX.QCELL.BasicQCELL._getDefaultValueOfProp(key);
	} else{
		switch(key){
			/* *************** 필수 속성 체크 *************** */
			/* *************** 선택 속성 체크 *************** */
			//case로 정의되어 있지 않은 속성들은 default:{}부분으로 동작한다.
			/* string type */
			/* boolean type */
			case 'disabled': {
				if(QBOX._.isBoolean(val) === true) {
					result = val;
				} else {
					result = false; //초기값 false로 설정
				}
				break;
			}
			/* number type */
			/* array type */
			/* object type */
			
			default: {                                             
				result = val;
				break;
			}
		}
	}
	return result;
};
QBOX.QCELL.NormalQCELL.QCellCol.prototype._createColElement = function(){
	var strParentID = this.attr('parent').attr('id'),
	strColID = this.attr('id'),
	strPrefix = strParentID + '_' + strColID + '_',
	objColElementProps = {
		colid		: strColID,
		parentid	: strParentID,
		parent		: this.attr('parent'),
		options		: this.attr('options'),
		html		: this.attr('html'),
		chart		: this.attr('chart'),
		disabled	: this.attr('disabled'),
		invisible	: this.attr('invisible')
	};
	
	switch(this.attr('type')){
		case 'input': {
			objColElementProps.id = strPrefix + 'input';
			this.attr('colelement', new QBOX.QCELL.Input(objColElementProps), 'object');
			break;
		}
		case 'inputbutton': {
			objColElementProps.id = strPrefix + 'inputbutton';
			this.attr('colelement', new QBOX.QCELL.InputButton(objColElementProps), 'object');
			break;
		}
		case 'textarea': {
			objColElementProps.id = strPrefix + 'textarea';
			this.attr('colelement', new QBOX.QCELL.Textarea(objColElementProps), 'object');
			break;
		} 
		case 'datepicker':{
			objColElementProps.id = strPrefix + 'datepicker';
			this.attr('colelement', new QBOX.QCELL.Datepicker(objColElementProps), 'object');
			break;
		} 
		case 'selectmenu':{
			objColElementProps.id = strPrefix + 'selectmenu';
			this.attr('colelement', new QBOX.QCELL.Selectmenu(objColElementProps), 'object');
			break;
		} 
		case 'image':{
			objColElementProps.id = strPrefix + 'image';
			this.attr('colelement', new QBOX.QCELL.Image(objColElementProps), 'object');	
			break;
		}
		case 'checkbox':{
			objColElementProps.id = strPrefix + 'checkbox';
			this.attr('colelement', new QBOX.QCELL.Checkbox(objColElementProps), 'object');
			break;
		}
		case 'html':{
			objColElementProps.id = strPrefix + 'html';
			this.attr('colelement', new QBOX.QCELL.Html(objColElementProps), 'object');
			break;
		}
		case 'chart':{
			objColElementProps.id = strPrefix + 'chart';
			this.attr('colelement', new QBOX.QCELL.Chart(objColElementProps), 'object');
			break;
		}
		case 'multicheckbox':{
			objColElementProps.id = strPrefix + 'multicheckbox';
			this.attr('colelement', new QBOX.QCELL.Multicheckbox(objColElementProps), 'object');
			break;
		}
		case 'number':{
			objColElementProps.id = strPrefix + 'number';
			this.attr('colelement', new QBOX.QCELL.Number(objColElementProps), 'object');
			break;
		}
		case 'slider':{
			objColElementProps.id = strPrefix + 'slider';
			this.attr('colelement', new QBOX.QCELL.Slider(objColElementProps), 'object');
			break;
		}
		case 'button':{
			objColElementProps.id = strPrefix + 'button';
			this.attr('colelement', new QBOX.QCELL.Button(objColElementProps), 'object');
			break;
		}
		case 'editor':{
			objColElementProps.id = strPrefix + 'editor';
			this.attr('colelement', new QBOX.QCELL.Editor(objColElementProps), 'object');
			break;
		} 
		case 'inputdatepicker':{
			objColElementProps.id = strPrefix + 'inputdatepicker';
			this.attr('colelement', new QBOX.QCELL.InputDatepicker(objColElementProps), 'object');
			break;
		} 
		default: {
			break;
		}
	}
};

QBOX.QCELL.ColElement = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.Element.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.ColElement, QBOX.Element);

QBOX.QCELL.ColElement.prototype._initTag = function(){
	this.tag('QBOX.QCELL.ColElement');
};

QBOX.QCELL.ColElement.prototype._init = function(properties){
	QBOX.Element.prototype._init.call(this, properties);
	
	this._createElement();
	this._initEvent();
};

QBOX.QCELL.ColElement.prototype._initAttrs = function(param){
	QBOX.Element.prototype._initAttrs.call(this, param);
	this.attr('parent', param.parent, 'object');
	
	this.attr('colid', param.colid, 'string');
	if(param.options !== undefined)
	this.titlekey = param.options.titlekey;
};

QBOX.QCELL.ColElement.prototype._createElement = function(){
	
};

QBOX.QCELL.ColElement.prototype._initEvent = function(){
	
};

QBOX.QCELL.ColElement.prototype._show = function(){
	
};

QBOX.QCELL.ColElement.prototype._hide = function(){
	
};

QBOX.QCELL.ColElement.prototype.show = function(){
	
};

QBOX.QCELL.ColElement.prototype.hide = function(){
	
};

QBOX.QCELL.ColElement.prototype._changeMergeCellValue = function(nRow, nCol, strValue, objFormat){
	var objParent = this.attr('parent'), objIndex = objParent._findNextCell(nRow, nCol, 'up'),
	nCols = objParent.attr('cols'), nRows = objParent.attr('rows'),
	nFrozenBottomRows = objParent.attr('frozenbottomrows'),
	nHeaderRows = objParent.attr('headerrows'), nFrozenRows = objParent.attr('frozenrows'),
	nHeaderCols = objParent.attr('headercols'), nFrozenCols = objParent.attr('frozencols'),
	strOriginValue = objParent._cellValue(nRow, nCol), strColType = objParent._getColType(nCol),
	strDataFormat, heCell,	i, j;
	
	switch(objParent.attr('merge').data){
		case 'row': {
			if(nCol < nFrozenCols + nHeaderCols){//frozencols 영역안의 병합셀인 경우
				for(j = objIndex.col; j < nFrozenCols + nHeaderCols; j++){
					if(strOriginValue === objParent._cellValue(nRow, j)){
						objParent._cellValue(nRow, j, strValue);
						
						if(QBOX._.isObject(objFormat)) {
							strDataFormat = objParent._showDataFormat(nRow,j, strValue === undefined ? '' : strValue);
							heCell = objParent._getCellDOM(nRow, j);

							switch(strColType){
								case 'number' : case 'input': case 'slider': {									
									if(heCell !== null){
										QBOX.util.textContent(heCell, strDataFormat);
									}
									break;
								}
								case 'datepicker': case 'inputbutton': {									
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strDataFormat);
									}
									break;
								}
								
							}
						} else{
							switch(strColType){
								case 'selectmenu': {
									heCell = objParent._getCellDOM(nRow, j);
									
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strValue);
									}
									break;
								}
							}
						}
					} else{
						break;
					}
				}
			} else{
				for(j = objIndex.col; j < nCols; j++){
					if(strOriginValue === objParent._cellValue(nRow, j)){
						objParent._cellValue(nRow, j, strValue);
						
						if(QBOX._.isObject(objFormat)) {
							strDataFormat = objParent._showDataFormat(nRow,j, strValue === undefined ? '' : strValue);
							heCell = objParent._getCellDOM(nRow, j);
							
							switch(strColType){
								case 'number' : case 'input': case 'slider': {									
									if(heCell !== null){
										QBOX.util.textContent(heCell, strDataFormat);
									}
									break;
								}
								case 'datepicker': case 'inputbutton': {
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strDataFormat);
									}
									break;
								}
								
							}
						} else{
							switch(strColType){
								case 'selectmenu': {
									heCell = objParent._getCellDOM(nRow, j);
									
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strValue);
									}
									break;
								}
							}
						}
					} else{
						break;
					}
				}
			}
			break;
		}
		case 'col': {
			if(nRow < nFrozenRows + objParent.attr('headerrows')){//frozenrows 영역안의 병합셀인 경우
				for(i = objIndex.row; i < nFrozenRows + objParent.attr('headerrows'); i++){
					if(strOriginValue === objParent._cellValue(i, nCol)){
						objParent._cellValue(i, nCol, strValue);
						
						if(QBOX._.isObject(objFormat)) {
							strDataFormat = objParent._showDataFormat(i,nCol, strValue === undefined ? '' : strValue);
							heCell = objParent._getCellDOM(i, nCol);
							
							switch(strColType){
								case 'number' : case 'input': case 'slider': {
									if(heCell !== null){
										QBOX.util.textContent(heCell, strDataFormat);
									}
									break;
								}
								case 'datepicker': case 'inputbutton': {
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strDataFormat);
									}
									break;
								}
								
							}
						} else{
							switch(strColType){
								case 'selectmenu': {
									heCell = objParent._getCellDOM(i, nCol);
									
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strValue);
									}
									break;
								}
							}
						}
					} else{
						break;
					}
				}
			} else if(nRow >= objParent.attr('rows') - objParent.attr('frozenbottomrows')){//frozenbottomrows 영역안의 병합셀인 경우
				for(i = objIndex.row; i < nRows; i++){
					if(strOriginValue === objParent._cellValue(i, nCol)){
						objParent._cellValue(i, nCol, strValue);
						
						if(QBOX._.isObject(objFormat)) {
							switch(strColType){
								case 'number' : case 'input': case 'slider': {									
									if(heCell !== null){
										QBOX.util.textContent(heCell, strDataFormat);
									}
									break;
								}
								case 'datepicker': case 'inputbutton': {									
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strDataFormat);
									}
									break;
								}
								
							}
						} else{
							switch(strColType){
								case 'selectmenu': {
									heCell = objParent._getCellDOM(i, nCol);
									
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strValue);
									}
									break;
								}
							}
						}
					} else{
						break;
					}
				}
			} else{
				for(i = objIndex.row; i < objParent.attr('rows') - objParent.attr('frozenbottomrows'); i++){
					if(strOriginValue === objParent._cellValue(i, nCol)){
						objParent._cellValue(i, nCol, strValue);
						
						if(QBOX._.isObject(objFormat)) {
							switch(strColType){
								case 'number' : case 'input': case 'slider': {									
									if(heCell !== null){
										QBOX.util.textContent(heCell, strDataFormat);
									}
									break;
								}
								case 'datepicker':case 'inputbutton':  {									
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strDataFormat);
									}
									break;
								}
								
							}
						} else{
							switch(strColType){
								case 'selectmenu': {
									heCell = objParent._getCellDOM(i, nCol);
									
									if(heCell !== null){
										objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strValue);
									}
									break;
								}
							}
						}
					} else{
						break;
					}
				}
			}
			break;
		}
		case 'group': {
			var arrIndexofGroupData = [];
			
			if(nRow < nFrozenRows + objParent.attr('headerrows')){//frozenrows 영역안의 병합셀인 경우
				for(i = objIndex.row; i < nFrozenRows + objParent.attr('headerrows'); i++){
					if(objIndex.row === objParent._findNextCell(i, nCol, 'up').row && strOriginValue === objParent._cellValue(i, nCol)){
						arrIndexofGroupData.push(i);
					} else{
						break;
					}
				}
			} else if(nRow >= objParent.attr('rows') - objParent.attr('frozenbottomrows')){//frozenbottomrows 영역안의 병합셀인 경우
				for(i = objIndex.row; i < nRows; i++){
					if(objIndex.row === objParent._findNextCell(i, nCol, 'up').row && strOriginValue === objParent._cellValue(i, nCol)){
						arrIndexofGroupData.push(i);
					} else{
						break;
					}
				}
			} else{
				for(i = objIndex.row; i < objParent.attr('rows') - objParent.attr('frozenbottomrows'); i++){
					if(objIndex.row === objParent._findNextCell(i, nCol, 'up').row && strOriginValue === objParent._cellValue(i, nCol)){
						arrIndexofGroupData.push(i);
					} else{
						break;
					}
				}
			}
			
			for(i = 0; i < arrIndexofGroupData.length; i++){
				objParent._cellValue(arrIndexofGroupData[i], nCol, strValue);
				
				if(QBOX._.isObject(objFormat)) {
					strDataFormat = objParent._showDataFormat(arrIndexofGroupData[i],nCol, strValue === undefined ? '' : strValue);
					heCell = objParent._getCellDOM(arrIndexofGroupData[i], nCol);
					
					switch(strColType){
						case 'number' : case 'input': case 'slider': {
							if(heCell !== null){
								QBOX.util.textContent(heCell, strDataFormat);
							}
							break;
						}
						case 'datepicker': case 'inputbutton': {
							
							if(heCell !== null){
								objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strDataFormat);
							}
							break;
						}
					
					}
				} else{
					switch(strColType){
						case 'selectmenu': {
							heCell = objParent._getCellDOM(arrIndexofGroupData[i], nCol);
							
							if(heCell !== null){
								objParent._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, strValue);
							}
							break;
						}
					}
				}
			}
			break;
		}
	}
};
QBOX.QCELL.Checkbox = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Checkbox, QBOX.QCELL.ColElement);

QBOX.QCELL.Checkbox.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Checkbox');
};
QBOX.QCELL.Checkbox.prototype._createDiv = function(bHeader){
	var css = QBOX.QCELL.def.css;
	var heDiv = document.createElement('div'),
	heCheckbox = document.createElement('input'),
	heLabel = document.createElement('label'),
	objParent = this.attr('parent');
	if(this.attr('likeradio') === true){
		heCheckbox.setAttribute("type", "radio");
	}else{
		heCheckbox.setAttribute("type", "checkbox");	
	}
	
	if(this.attr('showheaderlabel') !== true){
		heLabel.setAttribute("aria-hidden", "true");
	}
	
	heCheckbox.setAttribute('name', this.attr('id'));
	//heCheckbox.className += QBOX.QCELL.def.css.TYPE_CHECKBOX_WRAP_STYLE;
	heCheckbox.className += QBOX.QCELL.def.css.COLHEADER_CHECKBOX;
	
	heLabel.setAttribute('for', this.attr('id'));
	if(bHeader){
		heDiv.className +=' ' + css.COLHEADER_CHECKBOX;	
	}else{
		heDiv.className += css.TYPE_CHECKBOX_WRAP_STYLE + ' ' + css.COLHEADER_CHECKBOX;
	}
	
	heDiv.appendChild(heCheckbox);
	//if(this.attr('showheaderlabel') === true)
	heDiv.appendChild(heLabel);
	
	if(objParent.attr('useall')|| objParent.attr('usetreeall'))
		heCheckbox.setAttribute('tabindex', '0');
	
	return heDiv;
};
QBOX.QCELL.Checkbox.prototype._createElement = function(){
	try {
		this.attr('headerelement',this._createDiv(true),'element' );		
		this._setElement(this._createDiv());
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Checkbox.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Checkbox.prototype._initEvent = function(){
	//console.log(this.attr('element'));
	var strEvent = 'click',objParent = this.attr('parent');
	strEvent = objParent.attr('useall') === true  || objParent.attr('usetreeall') === true? strEvent + ' focusin keydown' : strEvent;
	
	QBOX.$(this.attr('element')).on(strEvent, {target : this}, QBOX.st.eventProcess);
	QBOX.$(this.attr('headerelement')).on(strEvent, {target : this}, QBOX.st.eventProcess);
};

QBOX.QCELL.Checkbox.prototype._defaultAction = function(event){
	switch (event.type){
		case 'click':		this.onClick(event);		break;
		case 'focusin':		this.onFocusIn(event);		break;
		case 'keydown':		this.onKeyDown(event);		break;
		default:										break;
	}
};

QBOX.QCELL.Checkbox.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	this.attr('tabindex', -1, 'number');
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	this._extendAttrs(param.options);
};

QBOX.QCELL.Checkbox.prototype._extendAttrs = function(options) {
	try {
		var type = true;
		
		if(QBOX._.isUndefined(options.checkedvalue) && 
			QBOX._.isUndefined(options.uncheckedvalue) &&
			!QBOX._.isUndefined(QBOX.QCELL.config.options) &&
			!QBOX._.isUndefined(QBOX.QCELL.config.options.checkedvalue)&&
			!QBOX._.isUndefined(QBOX.QCELL.config.options.uncheckedvalue)){
			options.checkedvalue = QBOX.QCELL.config.options.checkedvalue;
			options.uncheckedvalue = QBOX.QCELL.config.options.uncheckedvalue;
		}
			
		if(QBOX._.isUndefined(options.checkedvalue) && QBOX._.isUndefined(options.uncheckedvalue)){ // checkedvalue와 uncheckedvalue는 둘다 설정되어야 설정값 사용 가능
			// checkedvalue와 uncheckedvalue이 설정이 안되어 있으면 각각 true, false가 기본값
			
			options.checkedvalue = true;
			options.uncheckedvalue = false;				
			
		} else {
			if(QBOX._.isString(options.checkedvalue) && QBOX._.isString(options.uncheckedvalue)){
				type = false;
			} else if(QBOX._.isBoolean(options.checkedvalue) && QBOX._.isBoolean(options.uncheckedvalue)){
				type = true;
			} else{
				if( !(QBOX._.isUndefined(options.checkedvalue)) && !(QBOX._.isUndefined(options.uncheckedvalue)) ) {
					QBOX.QCELL.log('err', 'QCELL.Checkbox', 'checkedvalue and uncheckedvalue props is only support "stirng" or "boolean" types.');
				} else {
					QBOX.QCELL.log('err', 'QCELL.Checkbox', 'checkedvalue and uncheckedvalue props is not same type, so setting default Boolean type "true" and "false".');
				}
				
				options.checkedvalue = true;
				options.uncheckedvalue = false;
			}
		}
		
		//type값이 true이면 속성 유형이 boolean
		//false이면 속성 유형이 string
		this.attr('checkedvalue', options.checkedvalue, type === true ? 'boolean' : 'string');
		this.attr('uncheckedvalue', options.uncheckedvalue, type === true ? 'boolean' : 'string');
		
		if(QBOX._.isUndefined(options.wholeselect)){ // 전체 선택 속성 wholeselect 이 설정이 안되어 있으면 기본값인 false로 설정
			options.wholeselect = false;
		} else{
			if(QBOX._.isBoolean(options.wholeselect) === false) { // wholeselect 속성값이 boolean이 아닐 때
				QBOX.QCELL.log('err', 'QCELL.Checkbox', 'wholeselect property type is "boolean".');
				options.wholeselect = true;
			}
		}
		
		if(QBOX._.isUndefined(options.likeradio)){ // 전체 선택 속성 wholeselect 이 설정이 안되어 있으면 기본값인 false로 설정
			options.likeradio = false;
		} else{
			if(QBOX._.isBoolean(options.likeradio) === false) { // wholeselect 속성값이 boolean이 아닐 때
				QBOX.QCELL.log('err', 'QCELL.Checkbox', 'selectone property type is "boolean".');
				options.likeradio = false;
			}
		}
		
		this.attr('usefixedcheckbox', options.wholeselect, 'boolean');
		this.attr('likeradio', options.likeradio, 'boolean');
		
		this.attr('showheaderlabel',options.showheaderlabel, 'boolean');
		
		//this.attr('titlekey',options.titlekey  === undefined  ? '':options.titlekey ,'string' );
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Checkbox.prototype._extendAttrs', e.message);
		return false;
	}
};

QBOX.QCELL.Checkbox.prototype._headershow = function(heCell, nRow, nCol){
	try {
		var objParent = this.attr('parent'),
		strValue = objParent._cellValue(nRow, nCol),
		heElement = QBOX.$(this.attr('headerelement')).clone(true).get(0),
		wholeSelect = this.attr('usefixedcheckbox'),
		likeRadio = this.attr('likeradio'),
		headerRows = objParent.attr('headerrows'),
		checkedValue = objParent._getColElement(nCol).attr('checkedvalue'),
		heCheckbox = heElement.childNodes[0],heLabel = heElement.childNodes[1],
		strHeader = objParent._cellValue(headerRows -1 , nCol);
		
		strHeader = strHeader === undefined || strHeader === '' ? nCol + '' : strHeader;
		
		heCell.innerHTML = ''; //heCell child 초기화
		
		heElement.setAttribute('data-row', nRow);
		heElement.setAttribute('data-col', nCol);
		heCheckbox.setAttribute('data-row', nRow);
		heCheckbox.setAttribute('data-col', nCol);
		heCheckbox.title = strHeader +'열 전체 선택';
		
		heElement.className += ' ' + QBOX.QCELL.def.css.COLHEADER_AREA;
		heCheckbox.className += ' ' + QBOX.QCELL.def.css.COLHEADER_AREA;
		
		if(nRow === (headerRows - 1) && wholeSelect && !likeRadio){ // 마지막 header에서 전체 checkbox 생성
			heCheckbox.name = heCheckbox.name + '_all';
			
			// 모든 데이터가 check 값이면 headercheckbox check
			var checklength = 0;
			for(j = 0, j_len = objParent.attr('rows')-objParent.attr('headerrows'); j < j_len; j++) { // 전체 데이터 확인
				if(objParent.attr('currentdata')[j][objParent._getKeyOfCol(nCol)] === checkedValue){ // check가 되어 있으면 checklength 1씩증가
					checklength++;
				}
			}
			if(checklength === objParent.attr('currentdata').length && objParent.attr('currentdata').length > 0){ // 현재 화면의 데이터와 checklength 값이 동일하면
				heCheckbox.checked = true;
			}
			
			/*
			heCheckbox.style.position = 'absolute';
			heCheckbox.style.top = parseInt(QBOX.$(heCell).css('height')) / 4 +'px';
			heCheckbox.style.left = parseInt(QBOX.$(heCell).css('width')) / 2 - 10 + 'px';
			*/
			
			if(this.attr('showheaderlabel') === true){
				
				heLabel.setAttribute('data-row', nRow);
				heLabel.setAttribute('data-col', nCol);
				heLabel.className += ' ' + QBOX.QCELL.def.css.COLHEADER_AREA;
				
				var arrData = strValue.split('\n');
				var strTemp = '';
				if( arrData.length > 0){
					heElement.style.display = 'flex';
					heElement.style.justifyContent = 'center';
					heElement.style.alignItems = 'center';	
					var heDiv = document.createElement('div');
					for(var xt = 0; xt < arrData.length; xt++){
						if(xt !== 0){
							strTemp = strTemp +'<br/>' ;
							var heBr = document.createElement('br');
							heDiv.appendChild(heBr);
						}
						var heSpan = document.createElement('span');
						var heSpanText = document.createTextNode(arrData[xt]);
						
						heSpan.setAttribute('data-row', nRow);
						heSpan.setAttribute('data-col', nCol);
						
						heDiv.setAttribute('data-row', nRow);
						heDiv.setAttribute('data-col', nCol);
						
						heSpan.appendChild(heSpanText);
						heDiv.appendChild(heSpan);
					}		

					heLabel.appendChild(heDiv);					
				}else{
					var heText = document.createTextNode(strValue);
					heLabel.appendChild(heText);				
				}		
			}
			
			heCell.appendChild(heElement);
			
			if(objParent._getQCellCol(nCol).attr('move')){						
				heCell.appendChild(objParent._getColHeaderDragDropArea());
			}
			
			if(objParent._getQCellCol(nCol).attr('search')){						
				heCell.appendChild(objParent.attr('colsearcharea').clone(true).get(0));
			}
			
			if(objParent._getQCellCol(nCol).attr('sort')){				
				heCell.appendChild(objParent._getDefaultSortArea(nCol));
			}
			
			if(objParent._getQCellCol(nCol).attr('resize')){						
				heCell.appendChild(objParent._getColResizeArea());
			}
			
			if(objParent._getQCellCol(nCol).attr('filter')){						
				heCell.appendChild(objParent._getFilterArea(nCol));
			}
			
			
		} else{
			if(strValue === undefined)
				strValue = '';
			
			var arrData2 = strValue.split('\n');
			
			if(objParent.attr('useall') || objParent.attr('usetreeall')){
				heCell.setAttribute('aria-hidden' , 'true');
			}				

			if( arrData2.length > 0){
				
				heCell.style.display = 'flex';
				heCell.style.justifyContent = 'center';
				heCell.style.alignItems = 'center';	
				
				var heDiv2 = document.createElement('div');
				
				for(var xts = 0; xts < arrData2.length; xts++){
					if(xts){

						var heBr2 = document.createElement('br');
						heDiv2.appendChild(heBr2);
					}
					var heSpan2 = document.createElement('span');
					var heSpanText2 = document.createTextNode(arrData2[xts]);
					
					heSpan2.setAttribute('data-row', nRow);
					heSpan2.setAttribute('data-col', nCol);
					
					heDiv2.setAttribute('data-row', nRow);
					heDiv2.setAttribute('data-col', nCol);
					
					heSpan2.appendChild(heSpanText2);
					heDiv2.appendChild(heSpan2);
				}	
				heCell.appendChild(heDiv2);
					
			}else{
				QBOX.util.textContent(heCell, strValue);	
			}	
			
		}
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Checkbox._headershow', e.message);
		return false;
	}
};

QBOX.QCELL.Checkbox.prototype._show = function(heCell, nRow, nCol){
	try {
		var objParent = this.attr('parent'),
		css = QBOX.QCELL.def.css,
		strValue = objParent._cellValue(nRow, nCol),
		heElement = QBOX.$(this.attr('element')).clone(true).get(0),
		checkedValue = this.attr('checkedvalue'),
		//uncheckedValue = this.attr('uncheckedvalue'),
		likeRadio = this.attr('likeradio'),
		objCellDisabled = objParent._getQCellCol(nCol).attr('celldisabled')[nRow],
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow],
		heCheckbox = heElement.childNodes[0];
		
		if(objParent._showDisableText(heCell,nRow,nCol)){
			return;
		}
		
		if(objParent._isBottomPanel(heCell)){
			QBOX.util.textContent(heCell, '');
			/*
			if(strValue === true || strValue === false){
				strValue = '';
			}
			if(strValue === 'true' || strValue === 'false'){
				strValue = '';
			}
			QBOX.util.textContent(heCell, strValue);
			*/
			return;
		}			
		
		heCell.innerHTML = ''; // heCell child 초기화
		
		heElement.setAttribute('data-row', nRow);
		heElement.setAttribute('data-col', nCol);
		heCheckbox.setAttribute('data-row', nRow);
		heCheckbox.setAttribute('data-col', nCol);
		
		//heCheckbox.setAttribute("type", "checkbox");
		//heCheckbox.setAttribute('name', this.attr('id'));
		
		if(likeRadio){
			QBOX.util.addClass(heCheckbox, css.TYPE_RADIO_STYLE);
		}
		
		if(strValue === checkedValue){ // 좌표데이터(row, col)와 checkbox의 선택값이 일치하면 checked 표시
			heCheckbox.checked = true;
			objParent.attr('isFocussing',true,'boolean');
			if(likeRadio && (objParent.attr('useall') || objParent.attr('usetreeall'))){
				setTimeout(function(){
					heCheckbox.focus();
					objParent.attr('isFocussing',false,'boolean');
				},0);
			}else{
				objParent.attr('isFocussing',false,'boolean');
			}
			
			//heElement.value = checkedValue;
			//heParent.attr('currentdata')[nRow - heParent.attr('headerrows')][heParent._getKeyOfCol(nCol)] = checkedValue;
		}
		/*
		else{ // 일치하는 데이터가 없을 시 좌표데이터 unchecked 갱신
			//heElement.value = uncheckedValue;
			//heParent.attr('currentdata')[nRow - heParent.attr('headerrows')][heParent._getKeyOfCol(nCol)] = uncheckedValue;
		}
		*/
		var objData;
		if(this.titlekey !== null && QBOX._.isFunction(this.titlekey) === true){
			objData = objParent.getRowData(nRow);
			if(objData !== undefined){
				var strTitle = this.titlekey(nRow,nCol,objData);
				if(strTitle !== undefined && strTitle !== ''){
					if(objParent.attr('useall') || objParent.attr('usetreeall') )
						heCheckbox.setAttribute('title',strTitle);
					else
						heCheckbox.setAttribute('aria-label',strTitle);
				}
			}
		}else if(this.titlekey !== null && this.titlekey !== '' && this.titlekey !== undefined ){
			objData = objParent.getRowData(nRow);
			if(objData !== undefined){
				if(objParent.attr('useall') || objParent.attr('usetreeall') )
					heCheckbox.setAttribute('title',objData[this.titlekey] !== undefined ? objData[this.titlekey] : '');
				else
					heCheckbox.setAttribute('aria-label',objData[this.titlekey] !== undefined ? objData[this.titlekey] : '');
			}
		}

		// disabled 속성이 true 일 때
		if(objCellDisabled){
			QBOX.$(heCheckbox).attr('disabled', objCellDisabled);
		}
		else {
			QBOX.$(heCheckbox).removeAttr('disabled');
		}
		
		/*
		heCheckbox.style.position = 'absolute';
		heCheckbox.style.top = parseInt(QBOX.$(heCell).css('height')) / 4 +'px';
		heCheckbox.style.left = parseInt(QBOX.$(heCell).css('width')) / 2 - 10 + 'px';
		*/
		
		QBOX.util.addClass(heCheckbox, css.TYPE_CHECKBOX_STYLE);
		heCell.innerHTML = ''; //heCell child 초기화
		heCell.appendChild(heElement);
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Checkbox._show', e.message);
		return false;
	}
};

QBOX.QCELL.Checkbox.prototype._isHeaderCheckbox = function(nCol) { // 해당 열에 전체 선택 체크박스의 선택 생성 여부를 반환
	var objParent = this.attr('parent'), 
	heColTarget = objParent._getColElement(nCol),
	result = false;
	
	if(heColTarget.attr('usefixedcheckbox')) {
		result = true;
	}
	
	return result;
};

QBOX.QCELL.Checkbox.prototype._getHeaderCheckedState = function(nCol) { // 해당 열에 전체 선택 체크박스의 선택 여부를 반환
	var strAPI = this.attr('id') + '._getHeaderCheckedState',
	objParent = this.attr('parent');
	
	if(this._isHeaderCheckbox(nCol)) {		
		return objParent._getColElement(nCol).attr('_checkedstate') === null ? false : objParent._getColElement(nCol).attr('_checkedstate');
	} else {
		QBOX.QCELL.log('err', strAPI, objParent.attr('msg').err.NOT_HAVE_HEADER_CHECKBOX);
		return;
	}
};

QBOX.QCELL.Checkbox.prototype._setHeaderChecked = function(nCol, state) { // header의 전체 체크박스의 체크 및 체크해제의 선택값
	var strAPI = this.attr('id') + '._setHeaderChecked', 
	objParent = this.attr('parent'),
	nRow = objParent.attr('headerrows')-1;
	
	if(this._isHeaderCheckbox(nCol)) {
		this._HeaderCheckBoxChecked(nRow, nCol, state);
	} else {
		QBOX.QCELL.log('err', strAPI, objParent.attr('msg').err.NOT_HAVE_HEADER_CHECKBOX);
		return;
	}
};

QBOX.QCELL.Checkbox.prototype._outerClick = function(nRow, nCol, bState){ //checkbox의 parent인 div영역을 클릭하였을 때
	var objParent =  this.attr('parent'),
	objParentElement = objParent._getCellDOM(nRow, nCol),
	heTargetElement = objParentElement.childNodes[0].childNodes[0],
	checkedValue = objParent._getColElement(nCol).attr('checkedvalue'),
	uncheckedValue = objParent._getColElement(nCol).attr('uncheckedvalue'),
	likeradio = objParent._getColElement(nCol).attr('likeradio'),
	//strDisabled = objParent._getColDisabled(nCol),
	j, j_len,
	heTargetCell, headerCheckbox,
	objCellDisabled = objParent._getQCellCol(nCol).attr('celldisabled')[nRow],
	nFocusRow = objParent.getIdx('row','focus'),nFocusCol = objParent.getIdx('col','focus');
	
	objParent._clearFocusAllCSS();
	
	if(QBOX._.isElement(heTargetElement)){
		objParent._onScrollHideEditCellsDOM();
		objParent._clearSelection();
		objParent._updateIdx ('focus',-1,-1);
		if( QBOX._.isBoolean(objCellDisabled) === false || objCellDisabled === false) {
			if( bState === true || (QBOX._.isUndefined(bState) && heTargetElement.checked === false) ) { // checkbox 선택
				if(QBOX.util.hasClass(objParentElement, QBOX.QCELL.def.css.CELL_VIEWPORT)){ // viewport 영역
					if(likeradio === true){ // radio type과 같이 하나만 선택 여부
						// 동일한 이름의 checkbox 전체 해제
						//QBOX.$('input[type="checkbox"][name="'+heTargetElement.getAttribute('name')+'"]').prop('checked', false);
						for(j = 0, j_len = objParent.attr('rows')-objParent.attr('headerrows'); j < j_len; j++) { // 전체 데이터 중 checkbox 열의 값에 checkbox 선택해제 설정 값 입력
							objParent.attr('currentdata')[j][objParent._getKeyOfCol(nCol)] = uncheckedValue;
						}
						
						// 현재 선택한 checkbox에만 선택값 적용
						heTargetElement.checked = true;
						heTargetElement.value = checkedValue;
						objParent._cellValue(nRow, nCol, checkedValue);
					}
					else{ // 여러개 선택가능 일반 checkbox
						heTargetElement.checked = true;
						heTargetElement.value = checkedValue;
						objParent._cellValue(nRow, nCol, checkedValue);
						
						if(this._isHeaderCheckbox(nCol)){ // 현재 영역의 header에 checkbox가 있다면
							// 현재 열에서 check된 데이터의 수와 전체 데이터 수가 같다면 header checkbox에 check처리
							var checklength = 0;
							for(j = 0, j_len = objParent.attr('rows')-objParent.attr('headerrows'); j < j_len; j++) { // 전체 데이터 확인
								
								if(objParent.attr('currentdata')[j][objParent._getKeyOfCol(nCol)] === checkedValue){ // check가 되어 있으면 checklength 1씩증가
									checklength++;
								}
							}
							
							if(checklength === objParent.attr('currentdata').length){ // 현재 화면의 데이터와 checklength 값이 동일하면
								heTargetCell = objParent._getCellDOM(objParent.attr('headerrows')-1, nCol);
								headerCheckbox = heTargetCell.childNodes[0].childNodes[0];
								
								headerCheckbox.checked = true; // headercheckbox check 처리
								this.attr('_checkedstate', true, 'boolean');
							}
						}
					}
					
					objParent._selectCell(nRow, nCol);
					objParent._focusCell(nRow, nCol);
					objParent._scrollToFocusCell(nRow,nCol);
					objParent._processValueChanged(nRow,nCol);
					objParent._treecheckbox(nRow,nCol,true);
				}
				else{ // header 영역
					this._HeaderCheckBoxChecked(nRow, nCol, true);
					if(nFocusRow !== -1 && nFocusCol !== -1){
						objParent._selectCell(nFocusRow, nFocusCol);
						objParent._focusCell(nFocusRow, nFocusCol);
					}
				}
				
			}
			else if ( bState === false || (QBOX._.isUndefined(bState) && heTargetElement.checked === true) ) { // checkbox 선택 해제
				if(QBOX.util.hasClass(objParentElement, QBOX.QCELL.def.css.CELL_VIEWPORT)){ // viewport 영역
					if(likeradio === true){ // radio type과 같이 하나만 선택 여부
						// 동일한 이름의 checkbox 전체 해제
						//QBOX.$('input[type="checkbox"][name="'+heTargetElement.getAttribute('name')+'"]').prop('checked', false);
						for(j = 0, j_len = objParent.attr('rows')-objParent.attr('headerrows'); j < j_len; j++) { // 전체 데이터 중 checkbox 열의 값에 checkbox 선택해제 설정 값 입력
							objParent.attr('currentdata')[j][objParent._getKeyOfCol(nCol)] = uncheckedValue;
						}
						
						// 현재 선택한 checkbox에만 선택값 적용
						heTargetElement.checked = true;
						heTargetElement.value = checkedValue;
						objParent._cellValue(nRow, nCol, checkedValue);
					}
					else{ // 여러개 선택가능 일반 checkbox
						heTargetElement.checked = false;
						heTargetElement.value = uncheckedValue;
						objParent._cellValue(nRow, nCol, uncheckedValue);
						
						if(this._isHeaderCheckbox(nCol)){ // 현재 영역의 header에 checkbox가 있다면
							// header checkbox가 check되어 있으면 uncheck 처리
							heTargetCell = objParent._getCellDOM(objParent.attr('headerrows')-1, nCol);
							headerCheckbox = heTargetCell.childNodes[0].childNodes[0];
							
							if(headerCheckbox.checked){ // headercheckbox가 check 되어 있으면
								headerCheckbox.checked = false; // headercheckbox uncheck
							}
							this.attr('_checkedstate', false, 'boolean');
						}
					}
					
					objParent._selectCell(nRow, nCol);
					objParent._focusCell(nRow, nCol);
					objParent._scrollToFocusCell(nRow,nCol);
					objParent._processValueChanged(nRow,nCol);
					objParent._treecheckbox(nRow,nCol,false);
				}
				else{ // header 영역
					this._HeaderCheckBoxChecked(nRow, nCol, false);
					if(nFocusRow !== -1 && nFocusCol !== -1){
						objParent._selectCell(nFocusRow, nFocusCol);
						objParent._focusCell(nFocusRow, nFocusCol);
					}
				}
				
			}
		}
	}
};

QBOX.QCELL.Checkbox.prototype._HeaderCheckBoxChecked = function(nRow, nCol, bState){ // header의 전체 체크박스의 선택, 선택해제 처리
	var objParent = this.attr('parent'),
	objParentElement = objParent._getCellDOM(nRow, nCol),	
	checkedValue = objParent._getColElement(nCol).attr('checkedvalue'),
	uncheckedValue = objParent._getColElement(nCol).attr('uncheckedvalue'),
	arrCheckboxs = [],	
	result = true, i, j, i_len, j_len,
	targetCell,
	tRow = -1, tCol = -1,
	bInvisible = false, bDisable = false,
	bPanel = objParent.attr('frozenbottomstyle') === 'panel' ? true : false;
	
	if( !(QBOX._.isUndefined(bState)) && !(bState) ) { // bState 값에 의한 강제 checkbox 선택, 선택해제 처리
		result = !result;
	}
	
	objParent._getColElement(nCol).attr('_checkedstate', result, 'boolean');
	
	if(objParentElement !== null && objParentElement !== undefined){
		var heTargetElement = objParentElement.childNodes[0].childNodes[0],
		strName = heTargetElement.name.replace('_all', '');
		arrCheckboxs = document.getElementsByName(strName);
		heTargetElement.checked = result;		
	}	
	
	for(i = 0, i_len = arrCheckboxs.length; i < i_len; i++) { // 현재 화면 내의 checkbox의 선택 처리.
		targetCell = arrCheckboxs[i].parentNode;
		tRow = targetCell.getAttribute('data-row');
		tCol = targetCell.getAttribute('data-col');
		
		bInvisible = objParent._getQCellCol(tCol).attr('cellinvisible')[tRow];
		bDisable = objParent._getQCellCol(tCol).attr('celldisabled')[tRow];
		
		if(!bInvisible && !bDisable){
			arrCheckboxs[i].checked = result;
		}
	}
	for(j = objParent.attr('headerrows'), j_len = objParent.attr('rows'); j < j_len; j++){
		
		if(bPanel === true && objParent.getCellDataEx(j,'rt_qc_fbrd') === true)
			continue;
		
		//해당 셀 값이 'checkedvalue' , 'uncheckedValue' 둘중 아무것도 아닐 경우  uncheckedValue 로 보정.
		if(objParent._cellValue(j, nCol) !== checkedValue && objParent._cellValue(j, nCol) !== uncheckedValue){
			objParent.attr('currentdata')[j - objParent.attr('headerrows')][objParent._getKeyOfCol(nCol)] = uncheckedValue;
		}
		
		bInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[j];
		bDisable = objParent._getQCellCol(nCol).attr('celldisabled')[j];
		
		var obj = objParent.getRowData(j);
		if(obj !== undefined && (obj._rtqc_state === 'gt' || obj.rt_qc_header === true ||
				obj.rt_qc_footer === true	)){
			continue;
		}
		
		if(!bInvisible && !bDisable){
			if(result){
				objParent._cellValue(j, nCol, checkedValue);
			} else {
				objParent._cellValue(j, nCol, uncheckedValue);
			}
		}
	}
	
	
	
	objParent._processValueChanged(nRow,nCol);
	
};
QBOX.QCELL.Checkbox.prototype.onKeyDown = function(event){ //checkbox를 직접 클릭하였을 때
	var objParent = this.attr('parent') , vsinfo = objParent.attr('vsinfo');
	var strKeyCode = event.keyCode;
	
	if(objParent.attr('useall') || objParent.attr('usetreeall')){
		if(vsinfo.bVScroll){
			var nRow = Number(event.currentTarget.parentNode.getAttribute('data-row'));
			var nCol =Number(event.currentTarget.parentNode.getAttribute('data-col'));
			
			if(isNaN(nRow) || isNaN(nCol))
				return;
			
			if((strKeyCode === QBOX.def.key.UP || strKeyCode === QBOX.def.key.LEFT )&& nRow === vsinfo.nStartRow){
				event.stopPropagation();
				event.preventDefault();
				//console.log('up');
				return;
			}else if((strKeyCode === QBOX.def.key.UP || strKeyCode === QBOX.def.key.LEFT )&& nRow === vsinfo.nTopRow ){
				console.log('test');
				var tempRow = nRow-1;				
				//objParent.focusCell(tempRow,nCol);
				//
				objParent._scrollTop(tempRow-1);

				setTimeout(function(){
					//console.log(tempRow);
					var heCell = objParent._getCellDOM(tempRow+1,nCol);
					
					if(heCell !== null){
						var heChild = heCell.getElementsByTagName('input')[0];
						
						if(heChild !== undefined)
							heChild.focus();
						
					}
					
				},100);
				event.stopPropagation();
				event.preventDefault();
				return;
			}
			if((strKeyCode === QBOX.def.key.DOWN ||strKeyCode === QBOX.def.key.RIGHT ) && nRow === vsinfo.nEndRow){
				event.stopPropagation();
				event.preventDefault();
				//console.log('down');
				return;
			}else if((strKeyCode === QBOX.def.key.DOWN ||strKeyCode === QBOX.def.key.RIGHT ) && nRow === vsinfo.nBottomRow){
				event.stopPropagation();
				event.preventDefault();
				//console.log('down');
				return;
			}
			if(objParent.attr('isFocussing')){
				event.stopPropagation();
				event.preventDefault();
				//console.log('test');
			}			
		}
		
	}
	
};
QBOX.QCELL.Checkbox.prototype.onClick = function(event){ //checkbox를 직접 클릭하였을 때
	var objParent =  this.attr('parent'),heTargetElement = event.target,
	nRow = Number(heTargetElement.parentNode.getAttribute('data-row')),
	nCol = Number(heTargetElement.parentNode.getAttribute('data-col'));	
	
	if(event.target.tagName === "LABEL"){
		heTargetElement = event.target.parentElement.firstElementChild;		
	}else if(event.target.tagName === "SPAN"){
		heTargetElement = event.target.parentElement.parentElement.parentElement.firstElementChild;
		heTargetElement.checked = !heTargetElement.checked;
	}
	
	if(QBOX._.isElement(heTargetElement)){
		if(!isNaN(nRow) && !isNaN(nCol)){
			objParent._updateIdx('click', nRow, nCol);
		}
		if(QBOX.util.hasClass(heTargetElement, QBOX.QCELL.def.css.TYPE_CHECKBOX_WRAP_STYLE)){ // click 이벤트가 발생한 영역이 checkbox를 감싸고 있는 영역이라면
			heTargetElement = heTargetElement.childNodes[0];			
			if(heTargetElement.checked) {
				this._outerClick(nRow, nCol, false);
			} else {
				this._outerClick(nRow, nCol, true);
			}
			
		}
		else{
			
			if(heTargetElement.checked) {
				this._outerClick(nRow, nCol, true);
			} else {
				this._outerClick(nRow, nCol, false);
			}
			
		}
	}
};
QBOX.QCELL.Checkbox.prototype.onFocusIn = function(event){ //checkbox를 직접 클릭하였을 때
	var objParent =  this.attr('parent'),heTargetElement = event.target,
	nRow = Number(heTargetElement.parentNode.getAttribute('data-row')),
	nCol = Number(heTargetElement.parentNode.getAttribute('data-col')),
	objVSInfo= objParent.attr('vsinfo'),objHSInfo = objParent.attr('hsinfo');	
	
	if(objParent.attr('useall')|| objParent.attr('usetreeall')){
		if(nRow !== -1 && nCol !== -1){
			if(nRow >= objParent.getRows('header')){	
				if(this.attr('likeradio'))
					return;				
				
				objParent._focusCell(nRow,nCol);
				objParent._scrollToFocusCell(nRow,nCol);
			}else{
				objParent._scrollLeft(nCol);
			}
		}		
	}
};
QBOX.QCELL.Datepicker = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Datepicker, QBOX.QCELL.ColElement);

QBOX.QCELL.Datepicker.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Datepicker');
};

QBOX.QCELL.Datepicker.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	this.attr('showkey', false, 'boolean');
	this.attr('visible', false, 'boolean');
	this.attr('changeyear', param.options.changeyear === undefined ? false : param.options.changeyear, 'boolean');
	this.attr('changemonth', param.options.changemonth === undefined ? false : param.options.changemonth, 'boolean');
	
	this.attr('insertdata', '', 'string');
	this.attr('dateformat', param.options.dateformat === undefined ? 'YYMMDD' : param.options.dateformat, 'string');
	this.attr('locale', param.options.locale === undefined ? 'ko' : param.options.locale, 'string');
	this.attr('yearrange', param.options.yearrange === undefined ? 'c-10:c+10' : param.options.yearrange, 'string');
	
	this.minDate = param.options.mindate === undefined ? null : param.options.mindate;
	this.maxDate = param.options.maxdate === undefined ? null : param.options.maxdate;
	
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	
	this.attr('format', param.options.format, 'object');
	
	this.attr('timetype', param.options.timetype === undefined ? 'none' : param.options.timetype, 'string');
	this.attr('timeformat', param.options.timeformat === undefined ? 'HHmmss' : param.options.timeformat, 'string');
	if(QBOX.$.timepicker !== undefined)
		this.attr('timeseparator', param.options.timeseparator === undefined ? QBOX.$.timepicker._defaults.separator : param.options.timeseparator, 'string');
	
	this.attr('dateimage', param.options.dateimage === undefined ? '' : param.options.dateimage, 'string');
	this.attr('dateimageside', param.options.dateimageside === undefined ? 'right' : param.options.dateimageside, 'string');
	this.attr('dateimageonly', param.options.dateimageonly === undefined ? false : param.options.dateimageonly, 'boolean');
	
	this.attr('direction', param.options.direction, 'string');
	
	this.attr('validator', param.options.validator, 'function');
	this.attr('initdate', param.options.initdate, 'string');
};

QBOX.QCELL.Datepicker.prototype._createElement = function(){
	try{
		var heDiv = document.createElement('div');
		heDiv.setAttribute('id', this.attr('id'));
		heDiv.className += QBOX.QCELL.def.css.TYPE_DATEPICKER_WRAP_STYLE;
		
		this._setElement(heDiv);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Datepicker.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Datepicker.prototype._initEvent = function(){
	
};

QBOX.QCELL.Datepicker.prototype._defaultAction = function(event){
	
};

QBOX.QCELL.Datepicker.prototype._show = function(heCell){
	try{
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = parseInt(heCell.getAttribute('data-row')),
		nCol = parseInt(heCell.getAttribute('data-col')),
		
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow],
		objCellDisabled = objParent._getQCellCol(nCol).attr('celldisabled')[nRow],
		$container = objParent.attr('elementpool').get('$container'),
		objElement = this,
		locale = this.attr('locale'),
		timetype = this.attr('timetype');
		this.attr('useinitdate', false, 'boolean');
		var strValue = objParent._cellValue(nRow, nCol) === undefined ? '' : QBOX.util.replaceAll(objParent._cellValue(nRow, nCol),'/','');
		objParent._onScrollHideEditCellsDOM();
		if(strValue === '' || strValue === undefined){
			strValue = this.attr('initdate') !== null && this.attr('initdate') !== '' ? this.attr('initdate') : ''; 
			
			if(strValue !== ''){
				this.attr('useinitdate', true, 'boolean');
			}
		}
		var options = {
			defaultDate		: strValue,
			changeYear		: this.attr('changeyear'),
			changeMonth		: this.attr('changemonth'),
			dateFormat		: this.attr('dateformat').toLowerCase(),
			yearRange		: this.attr('yearrange'),
			minDate 		: this.minDate,
			maxDate 		: this.maxDate,
			firstDay		: 0,
			onSelect		: function(strResult, inst){
				objElement.attr('insertdata', strResult, 'string');
				objElement.attr('isselect' , true, 'boolean');
				objElement._hide(heCell, 'api');
			},
			showButtonPanel: true,
			showAnim : 'fold'
		};
		
		if(objCellDisabled){
			return true;
		}
		
		QBOX.$.datepicker.setDefaults(QBOX.$.datepicker.regional[locale]);
		
		if(timetype == "none") {
			QBOX.$(heElement).datepicker(options);
		}
		else {
			strValue = typeof strValue != 'undefined' ? strValue : '';
			var timeseparator = this.attr('timeseparator'),
			timeformat = this.attr('timeformat'),
			dt = typeof strValue != 'undefined' ? strValue.split(timeseparator)[0] : '',// 전체 시간 데이터에서 timeseparator 있는 부분 전까지
			tm = strValue.replace(dt+timeseparator, ''),					// 전체 시간 데이터에서 변수 dt에서 timeseparator를 포함하여 제거한 나머지
			objFormat = this.attr('format'),
			tOptions = {
				defaultDate		: dt,										// 기본 날짜 데이터 설정
				timeFormat		: this.attr('timeformat'),					// timeFormat 설정
				showButtonPanel	: true,										// 하단 버튼 패널 표시
				onSelect		: function(strResult, inst){
					objElement.attr('insertdata', strResult, 'string');
					if(QBOX._.isObject(objFormat)) {
						strDataFormat = objParent._showDataFormat(nRow,nCol, strResult === undefined ? '' : strResult);
						QBOX.util.textContent(heCell, strDataFormat);
					}
				}
			};
			
			if(QBOX.$.timepicker !== undefined){
				QBOX.$.timepicker.setDefaults(QBOX.$.timepicker.regional[locale]); // locale 설정
				QBOX.$.timepicker.setDefaults({separator: timeseparator}); // separator 설정				
			}
			
			
			QBOX._.extend( options, QBOX._.extend( tOptions, QBOX.$.datepicker.parseTime(timeformat, tm, {}) )); // tOptions, 시간정보를 options에 확장 설정
			
			if(timetype == "with") {
				QBOX.$(heElement).datetimepicker(options).off('click').on('click', function(e){ // click 이벤트 제거 후 생성
					if(QBOX.$(e.target).hasClass('rt-qc-ui-datepicker-close')){ // 닫기 버튼 클릭 시
						objElement._hide(heCell);
					}
				});
			}
			else if(timetype == "only") {
				QBOX.$(heElement).timepicker(options).off('click').on('click', function(e){ // click 이벤트 제거 후 생성
					if(QBOX.$(e.target).hasClass('rt-qc-ui-datepicker-close')){ // 닫기 버튼 클릭 시
						objElement._hide(heCell);
					}
				});
			}
		}
		
		$container.append(heElement);
		heCell.focus();
		
		this._calculateTopNLeft(heElement, heCell);
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		this.attr('visible', true, 'boolean');
		this.attr('insertdata', strValue, 'string');
		this.attr('isselect' , false, 'boolean');
		
		objParent._addEditColId(this.attr('colid'));
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		QBOX.$(heElement.getElementsByClassName('rt-qc-ui-datepicker-close')[0]).bind('click',function(){objElement._hide(heCell);});
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Datepicker.prototype._show', e.message);
		return false;
	}
};
QBOX.QCELL.Datepicker.prototype._hidesub = function(objParent, strEventType){	
	this.attr('isselect' , false, 'boolean');
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	this.attr('visible', false, 'boolean');
	this.attr('showkey', false, 'boolean');		
	this.attr('insertdata', '', 'string');
	
	objParent._removeEditColId(this.attr('colid'));	
};
QBOX.QCELL.Datepicker.prototype._hide = function(heCell, strEventType){
	try{
		if(heCell === null)
			return;		
		
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = this.attr('row'),
		nCol = this.attr('col'),
		strValue = this.attr('insertdata'),
		objFormat = this.attr('format'), strDataFormat, fnValdator = this.attr('validator');
		
		if(nRow === -1 || nCol === -1){
			return;
		}		
		
		var bValid = true;
		

		
		QBOX.$(heElement).datepicker('destroy');
		QBOX.$(heElement).detach();
		
		if(this.attr('isselect') === true && fnValdator){
			this._hidesub(objParent);
			fnValdator(nRow,nCol,strValue);			 
			return;
		}
		if(this.attr('isselect') !== true && this.attr('useinitdate') === true){
			if(strValue === this.attr('initdate')){
				this._hidesub(objParent);		
				
				return;
			}
		}
		this.attr('isselect' , false, 'boolean');
	
		
		// datetimepicker와 timepicker는 destory 함수가 없어서 실행전 off로 click 이벤트 제거
		
		if(strValue !== objParent._cellValue(nRow, nCol)){
			if(objParent.attr('merge').data === 'none' || QBOX._.isUndefined(objParent.attr('merge').data) || objParent._getColDataMergeCol(nCol)=== false){
				objParent._cellValue(nRow, nCol, strValue);
				this._showDataLabel(heCell, nRow, nCol, strValue);
				
				if(QBOX._.isObject(objFormat)) {
					//strDataFormat = objParent._showDataFormat(nCol, strValue === undefined ? '' : strValue);
					//QBOX.util.textContent(heCell, strDataFormat);
					this._showDataLabel(heCell, nRow, nCol, strValue === undefined ? '' : strValue);
				}
			} else{
				this._changeMergeCellValue(nRow, nCol, strValue, objFormat);
			}
			objParent._processValueChanged(nRow, nCol);
		} else{
			//undefined 가 아닐 때 동작
			if(strValue !== undefined){
				if(QBOX._.isObject(objFormat)) {
					//strDataFormat = objParent._showDataFormat(nCol, strValue === undefined ? '' : strValue);
					//QBOX.util.textContent(heCell, strDataFormat);
					this._showDataLabel(heCell, nRow, nCol, strValue === undefined ? '' : strValue);
				} else{
					//QBOX.util.textContent(heCell, strValue);
					this._showDataLabel(heCell, nRow, nCol, strValue === undefined ? '' : strValue);
				}			
			}
		}
		
		//2017-12-15(sai1515): ie8 에서는 container에 focus를 주고 CELL DIV에 focus를 할 필요가 있음.
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
		}
		if(QBOX.browser.name !== 'msie')
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		else{
			QBOX.$(heCell).focus();
		}			
		this._hidesub(objParent);
		if(objParent.attr('useall')){
			var bFocus = objParent.attr('hideedit') === true ? false: true;
			objParent._setAriaLabelEx(heCell,nRow,nCol,bFocus);
		}
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Datepicker.prototype._hide', e.message);
		return false;
	}
};

QBOX.QCELL.Datepicker.prototype._calculateTopNLeft = function(heElement, heCell){
	var objParent = this.attr('parent'),
	nCellHeight = parseInt(QBOX.$(heCell).css('height')), nCalendarHeight = parseFloat(QBOX.$(heElement).children().css('height')),
	nTop = parseInt(QBOX.$(heCell).css('top')) + objParent.attr('layoutsize').colheader.offsetHeight + nCellHeight,
	nCellPosTop = parseInt(QBOX.$(heCell).position().top),
	nBot = 0, makeTop = true,
	nCellWidth = parseInt(QBOX.$(heCell).css('width')), nCalendarWidth = parseFloat(QBOX.$(heElement).css('width')),
	nLeft = parseInt(QBOX.$(heCell).css('left')) + objParent.attr('layoutsize').rowheader.offsetWidth,
	scrollY =  window.scrollY === undefined ? 0 : window.scrollY;
	
	if(this.attr('direction') === 'down'){
		QBOX.$(heElement).css({top: nTop});
		QBOX.$(heElement).css({bottom: 'auto'});		
	} else if(this.attr('direction') === 'up')	{
		nBot = objParent.attr('layoutsize').root.offsetHeight - nCellPosTop - nCellHeight;
		QBOX.$(heElement).css({bottom: nBot});
		QBOX.$(heElement).css({top: 'auto'});	
	}else{
		if(nCellPosTop && objParent.attr('layoutsize').root.offsetHeight < (nTop + nCalendarHeight)){
			if(window.pageYOffset + heCell.getBoundingClientRect().top + nCalendarHeight + nTop > window.innerHeight + scrollY){
				nBot = objParent.attr('layoutsize').root.offsetHeight - nCellPosTop - nCellHeight;
				QBOX.$(heElement).css({bottom: nBot});
				QBOX.$(heElement).css({top: 'auto'});	
			}else{
				makeTop = false;
				nBot = objParent.attr('layoutsize').root.offsetHeight - nCellPosTop - nCellHeight;
				QBOX.$(heElement).css({bottom: nBot});
				QBOX.$(heElement).css({top: 'auto'});
				
			}
		} else {
			//down
			if(objParent.attr('layoutsize').root.offsetHeight > (nTop + nCalendarHeight)){
				QBOX.$(heElement).css({top: nTop});
				QBOX.$(heElement).css({bottom: 'auto'});
			}else{
				if(window.pageYOffset + heCell.getBoundingClientRect().top + nCalendarHeight + nTop > window.innerHeight + scrollY){
					nBot = objParent.attr('layoutsize').root.offsetHeight - nCellPosTop - nCellHeight;
					QBOX.$(heElement).css({bottom: nBot});
					QBOX.$(heElement).css({top: 'auto'});
				}else{
					QBOX.$(heElement).css({top: nTop});
					QBOX.$(heElement).css({bottom: 'auto'});
					
				}			
			}

		}
		
		if(makeTop === false && nBot < nCalendarHeight && nTop < nCalendarHeight){
			if(window.pageYOffset + heCell.getBoundingClientRect().top + nCalendarHeight < window.innerHeight + scrollY){
				QBOX.$(heElement).css({top: nTop});
				QBOX.$(heElement).css({bottom: 'auto'});			
			}

		}		
	}
	

	
	if(objParent.attr('layoutsize').root.offsetWidth < (nLeft + nCalendarWidth)){
		if((nLeft + nCalendarWidth - objParent.attr('layoutsize').root.offsetWidth < nCellWidth ) )
			nLeft -= nCalendarWidth - nCellWidth;
		else
			nLeft -= (nCalendarWidth - nCellWidth) *1.5;
	}
	
	QBOX.$(heElement).css({left: nLeft});
};
QBOX.QCELL.Datepicker.prototype._showDataLabel = function(heCell, nRow, nCol, data){
	try{
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		
		
		var objParent = this.attr('parent'),
		dateimage = this.attr('dateimage'),
		dateimageside = this.attr('dateimageside'),
		dateimageonly = this.attr('dateimageonly'),
		strDataFormat = objParent._showDataFormat(nRow,nCol, data),
		strColStyleEditorData = objParent._getQCellCol(nCol).attr('colstyleeditordata'),
		heDiv = document.createElement('div'),
		heImg = document.createElement('img'),
		strVal, clicktype = 'dblclick',
		imgSize = 0;
		QBOX.$(heDiv).css({'height': QBOX.$(heCell).height()+'px'});
		
		if(objParent._isBottomPanel(heCell)){
			if(data === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, data);
			
			return;
		}
		
		if(objParent._showDisableText(heCell,nRow,nCol)){
			return;
		}		
		
		
		var heInnerDiv8 = heDiv.cloneNode(),
		heInnerDiv2 = heDiv.cloneNode();
		
		heDiv.setAttribute('data-row', nRow);
		heDiv.setAttribute('data-col', nCol);
		
		
		QBOX.util.addClass(heDiv, QBOX.QCELL.def.css.TYPE_DATEPICKER_SINGLE_STYLE);
		QBOX.util.addClass(heDiv, QBOX.QCELL.def.css.TYPE_DATEPICKER);
		QBOX.util.addClass(heInnerDiv8, QBOX.QCELL.def.css.TYPE_DATEPICKER_SINGLE_DATE_STYLE);
		QBOX.util.addClass(heInnerDiv8, QBOX.QCELL.def.css.TYPE_DATEPICKER);
		QBOX.util.addClass(heInnerDiv2, QBOX.QCELL.def.css.TYPE_DATEPICKER_SINGLE_IMG_STYLE);
		QBOX.util.addClass(heInnerDiv2, QBOX.QCELL.def.css.TYPE_DATEPICKER);
		
		strVal = strDataFormat;
		if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
			strVal = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
		}
		
		if(objParent.attr('oneclickedit')){
			clicktype = 'click';
		}
		
		heInnerDiv8.innerHTML = strVal;
		
		if(dateimage !== ''){
			imgSize = 25;
			
			heImg.src = dateimage;
			
			heInnerDiv2.appendChild(heImg);
			QBOX.$(heInnerDiv2).css('width', imgSize+'px');
			QBOX.$(heInnerDiv2.childNodes[0]).off(clicktype).on(clicktype, {target : this}, this.onClick);
		}
		
		QBOX.$(heInnerDiv8).css('width', 'calc( 100% - '+imgSize+'px )');
		
		QBOX.$(heInnerDiv8).css('float', 'left');
		QBOX.$(heInnerDiv2).css('float', 'right');
		if(dateimageside === 'left'){
			QBOX.$(heInnerDiv8).css('float', 'right');
			QBOX.$(heInnerDiv2).css('float', 'left');
		}
		
		heDiv.appendChild(heInnerDiv8);
		heDiv.appendChild(heInnerDiv2);
		
		if(dateimageonly === false){
			QBOX.$(heInnerDiv8).off(clicktype).on(clicktype, {target : this}, this.onClick);
		}
		
		QBOX.$(heCell).empty();
		
		objParent._setAriaLabel(heCell,nRow,nCol,strDataFormat);
		
		heCell.appendChild(heDiv);
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.NormalQCELL.Datepicker._showDataLabel', e.message);
		return false;
	}
};

QBOX.QCELL.Datepicker.prototype.onClick = function(event){ //checkbox를 직접 클릭하였을 때
	var heTargetElement = event.target,
	nRow = Number(heTargetElement.parentNode.getAttribute('data-row')),
	nCol = Number(heTargetElement.parentNode.getAttribute('data-col')),
	THAT = event.data.target,
	objParent = THAT.attr('parent'),
	heElement = objParent._getCellDOM(nRow, nCol);
	
	if(nRow === 0 && nCol === 0) {
		var heParent = heTargetElement.parentNode;
		nRow = Number(heParent.parentNode.getAttribute('data-row'));
		nCol = Number(heParent.parentNode.getAttribute('data-col'));
		heElement = objParent._getCellDOM(nRow, nCol);
	}
	
	THAT._show(heElement);
};
QBOX.QCELL.Html = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Html, QBOX.QCELL.ColElement);

QBOX.QCELL.Html.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Html');
};

QBOX.QCELL.Html.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	param.options.html = param.options.html === undefined ? {} : param.options.html;
	
	this.attr('renderer', param.options.html.data, 'function');				//<td>태그에 삽입할 html을 반환하는 콜백 함수를 정의하는 속성
	this.attr('afterrenderer', param.options.html.datacallback, 'function');	//renderder 콜백 함수 수행 이후에 수행되는 콜백 함수를 정의하는 속성
	this.attr('headerrenderer', param.options.html.header, 'function');
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
};

QBOX.QCELL.Html.prototype._headershow = function(heCell, nRow, nCol){
	try {
		var objParent = this.attr('parent'),
		strValue = objParent._cellValue(nRow, nCol),
		heColHtml = objParent._getColHtml(nCol);
		
		heCell.addClass += QBOX.QCELL.def.css.TYPE_HTML_CELL;
		
		if( QBOX._.isFunction(this.attr('headerrenderer')) && QBOX._.isFunction(heColHtml.header) ) {
			var hData = heColHtml.header(objParent, nRow, nCol, QBOX._.isUndefined(strValue) === true ? '' : strValue);
			if( QBOX._.isString(hData) ) {
				heCell.innerHTML = hData;
			}
		} else {
			//headerCallback function 이 없을 경우 일반 header 처럼 처리.
			heCell.innerHTML = objParent._getHeaderCellSpan(strValue,nRow,nCol);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Html._headershow', e.message);
		return false;
	}
};

QBOX.QCELL.Html.prototype._show = function(heCell, nRow, nCol){
	try {
		var objParent = this.attr('parent'),
		strValue = objParent._cellValue(nRow, nCol),
		heColHtml = objParent._getColHtml(nCol),
		currentData = objParent.attr('currentdata'),
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow];
		
		heCell.addClass += QBOX.QCELL.def.css.TYPE_HTML_CELL;
		
		strValue = objParent._showDataFormat(nRow,nCol, strValue);
		
		if(objParent._isBottomPanel(heCell)){
			if(strValue === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, strValue);
			
			return true;
		}			
		var obj = currentData[nRow - objParent.attr('headerrows')] === undefined? {} : currentData[nRow - objParent.attr('headerrows')];
		var strDataFormat = strValue;
		
		if( QBOX._.isFunction(this.attr('renderer')) && QBOX._.isFunction(heColHtml.data) ) {
			var vData = heColHtml.data(objParent, nRow, nCol, QBOX._.isUndefined(strValue) === true ? '' : strValue, obj);
			if( QBOX._.isString(vData) ) {
				heCell.innerHTML = vData;
				strDataFormat = $(heCell).text();
			}
			
			if( QBOX._.isFunction(this.attr('afterrenderer')) && QBOX._.isFunction(heColHtml.datacallback) ) {
				setTimeout(function(){
					heColHtml.datacallback(objParent, nRow, nCol, QBOX._.isUndefined(strValue) === true ? '' : strValue, obj);					
				},0);
			}
		} else {
			QBOX.util.textContent(heCell, strValue);
		}
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		objParent._setAriaLabel(heCell,nRow,nCol,strDataFormat);
		
		if(objParent.attr('useall') === true || objParent.attr('usetreeall') === true){
			QBOX.$(heCell).bind('focusin', function(e){
				if(objParent.attr('isClick') === true)
					return;
				
				//objParent.focusCell(nRow,nCol,0);
				//objParent._scrollToFocusCell(nRow,nCol);
			});
			
		}
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Html._show', e.message);
		return false;
	}
};
QBOX.QCELL.Image = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Image, QBOX.QCELL.ColElement);

QBOX.QCELL.Image.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Image');
};

QBOX.QCELL.Image.prototype._createElement = function(){
	try {
		var heImg = document.createElement('img');
		heImg.setAttribute('name', this.attr('id'));
		this._setElement(heImg);
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Image.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Image.prototype._initEvent = function(){
	QBOX.$(this.attr('element')).on('click', {target : this}, QBOX.st.eventProcess);
};

QBOX.QCELL.Image.prototype._defaultAction = function(event){
	switch (event.type){
		case 'click':		this.onClick(event);		break;
		default:										break;
	}
};

QBOX.QCELL.Image.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	this._extendAttrs(param.options);
};

QBOX.QCELL.Image.prototype._extendAttrs = function(options) {
	try {
		var type = true;
		if( !(QBOX._.isUndefined(options.imagealt)) && !(QBOX._.isString(options.imagealt)) ) {
			QBOX.QCELL.log('err', 'QCELL.Image', 'imagealt property type is "string".');
		} else if( !(QBOX._.isUndefined(options.imageheight)) && !(QBOX._.isString(options.imageheight)) ) {
			QBOX.QCELL.log('err', 'QCELL.Image', 'imageheight property type is "string".');
		} else if( !(QBOX._.isUndefined(options.imagewidth)) && !(QBOX._.isString(options.imagewidth)) ) {
			QBOX.QCELL.log('err', 'QCELL.Image', 'imagewidth property type is "string".');
		} else if( !(QBOX._.isUndefined(options.imagestyle)) && !(QBOX._.isObject(options.imagestyle)) ) {
			QBOX.QCELL.log('err', 'QCELL.Image', 'imagestyle property type is "object".');
		} else if( !(QBOX._.isUndefined(options.imageuri)) && !(QBOX._.isString(options.imageuri)) ) {
			QBOX.QCELL.log('err', 'QCELL.Image', 'imageuri property type is "string".');
		} else if( !(QBOX._.isUndefined(options.imageerroruri)) && !(QBOX._.isString(options.imageerroruri)) ) {
			QBOX.QCELL.log('err', 'QCELL.Image', 'imageerroruri property type is "string".');
		} else if( !(QBOX._.isUndefined(options.imageclick)) ) {
			if(QBOX._.isFunction(options.imageclick)) {
				type = true;
			} else if(QBOX._.isString(options.imageclick)) {
				type = false;
			} else {
				QBOX.QCELL.log('err', 'QCELL.Image', 'imageclick property type is "function".');			
			}
		}
		
		this.attr('imagealt', options.imagealt ,'string');
		this.attr('imageheight', options.imageheight ,'string');
		this.attr('imagewidth', options.imagewidth ,'string');
		this.attr('imagestyle', options.imagestyle ,'object');
		this.attr('imageuri', options.imageuri ,'string');
		this.attr('imageerroruri', options.imageerroruri ,'string');
		this.attr('imageclick', options.imageclick , type === true ? 'function' : 'string');
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Image.prototype._extendAttrs', e.message);
		return false;
	}
};

QBOX.QCELL.Image.prototype._show = function(heCell, nRow, nCol){
	try {
		var objParent = this.attr('parent'),
		css = QBOX.QCELL.def.css,
		heElement = QBOX.$(this.attr('element')).clone(true).get(0),
		heCellStyle = heCell.style,
		strValue = objParent._cellValue(nRow, nCol),
		$style = { "max-width": Number(heCellStyle.width.replace("px", "")) - 4 + "px", "max-height":heCellStyle.height },
		objCellDisabled = objParent._getQCellCol(nCol).attr('celldisabled')[nRow],
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow];
		
		heCell.innerHTML = ''; // heCell child 초기화
		
		if(objParent._isBottomPanel(heCell)){
			if(strValue === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, strValue);
			
			return true;
		}	
		
		heElement.src = strValue;
		QBOX.$(heElement).css({'visibility': 'visible'});
		QBOX.$(heElement).css($style);
		
		if(this.attr('imageerroruri') !== undefined ||this.attr('imageerroruri') !== null){
			if( QBOX.$.browser.msie && QBOX.$.browser.version < 9) { // ie8에서 onerror function을 지원하지 않음
				QBOX.$(heElement).on('error', function(e){
					QBOX.$(e.target).css({'visibility': 'hidden'});
				});
			} else {
				heElement.onerror = function(e) {
					QBOX.$(e.target).css({'visibility': 'hidden'});
				};
			}
		} 
		
		QBOX.$.each(objParent._getColOptions(nCol), function(key, val) {
			switch(key) {
				case 'imagealt' : {
					heElement.alt = val;
					break;
				}
				case 'imageheight' : {
					heElement.setAttribute('height', val);
					break;
				}
				case 'imagewidth' : {
					heElement.setAttribute('width', val);
					break;
				}
				case 'imagestyle' : {
					QBOX.$.each(val, function(k, v){
						$style[k] = v.replace(/\;/gi, "");
					});
					QBOX.$(heElement).css($style);
					break;
				}
				case 'imageclick' : {
					// disabled 속성이 false이거나 null 일 때
					if( QBOX._.isBoolean(objCellDisabled) === false || objCellDisabled === false){
						heElement.onclick = function(e) {
							var nRow = parseInt(e.target.parentElement.getAttribute('data-row'));
							var nCol = parseInt(e.target.parentElement.getAttribute('data-col'));
							window[val](e,nRow,nCol);
						};
					}
					break;
				}
				case 'imageuri' : {
					heElement.src = val;
					break;
				}
				case 'imageerroruri' : {
					if( QBOX.$.browser.msie && QBOX.$.browser.version < 9) { // ie8에서 onerror function을 지원하지 않음
						QBOX.$(heElement).on('error', function(e){
							e.target.src = val;
						});
					} else {
						heElement.onerror = function(e) {
							e.target.src = val;
						};
					}
					
					break;
				}
				default: break;
			}
		});
		
		// image tag의 drag 기능을 사용안함
		QBOX.$(heElement).on('dragstart', function(e){e.preventDefault();});
		

		
		QBOX.util.addClass(heCell, css.TYPE_IMAGE_STYLE);
		heCell.appendChild(heElement);
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		
		objParent._setAriaLabel(heCell,nRow,nCol,'');
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Image._show', e.message);
		return false;
	}
};
QBOX.QCELL.Image.prototype._outerClick = function(nRow, nCol) { // 해당 셀의 image click, imageclick이 선언되어 있으면 해당 callback 호출
/*	var heParent = this.attr('parent'),
	heTargetCell = heParent._getCellDOM(nRow, nCol),
	targetImage;
	
	if(heTargetCell.childNodes.length > 0){
		targetImage = heTargetCell.childNodes[0];
		
		if(QBOX._.isElement(targetImage)){
			targetImage.click();
		}
	}
*/	
};


QBOX.QCELL.Image.prototype.onClick = function(event){ //checkbox를 직접 클릭하였을 때
	var heParent = this.attr('parent'),
		heTargetElement = event.target,
		nRow = Number(heTargetElement.parentNode.getAttribute('data-row')),
		nCol = Number(heTargetElement.parentNode.getAttribute('data-col'));
	
	if(QBOX._.isElement(heTargetElement)){
		heParent._clearSelection();
		heParent._selectCell(nRow, nCol);
		heParent._focusCell(nRow, nCol);
	}
};
QBOX.QCELL.Input = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Input, QBOX.QCELL.ColElement);

QBOX.QCELL.Input.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Input');
};

QBOX.QCELL.Input.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	this.attr('visible', false, 'boolean');
	this.attr('showkey', false, 'boolean');	
	
	this.attr('insertdata', [], 'array');
	
	this.attr('maxlength', param.options.maxlength, 'number');
	this.attr('maxbyte', param.options.maxbyte, 'number');
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	
	this.attr('mask', param.options.mask, 'object');
	this.attr('format', param.options.format, 'object');
	this.attr('limit', param.options.limit, 'object');
	this.attr('numrange', param.options.numrange, 'string');
	
	this.attr('exclude', param.options.exclude, 'array');
	
	this.attr('validator', param.options.validator, 'function');	
	this.attr('bkeycode', undefined, 'number'); //before event keycode
	
	this.attr('convert', param.options.convert,'object');
	this.attr('isshow', false, 'boolean');
	
	this.attr('placeholder', param.options.placeholder , 'string');
	
	param.options.inputclass = param.options.inputclass === undefined ? '' : param.options.inputclass;
	if(!QBOX._.isString(param.options.inputclass))
		param.options.inputclass = '';
	
	this.attr('inputclass', param.options.inputclass, 'string');
};

QBOX.QCELL.Input.prototype._createElement = function(){
	try{
		var heInput = document.createElement('input');
		heInput.setAttribute('id', this.attr('id'));
		heInput.className += QBOX.QCELL.def.css.TYPE_INPUT_TEXT_STYLE +' ' + this.attr('inputclass');
		
		this._setElement(heInput);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Input.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Input.prototype._initEvent = function(){
	//blur 이벤트 추가함.
	QBOX.$(this.attr('element')).on('keydown keyup keypress blur paste', {target : this}, QBOX.st.eventProcess);
};

QBOX.QCELL.Input.prototype._defaultAction = function(event){
	var strKeyCode = event.keyCode,
	nBkeycode = this.attr('bkeycode');
	
	switch (event.type){
		case 'keydown':		this.onKeyDown(event);		break;
		case 'keyup':		this.onKeyUp(event);		break;
		case 'blur' :		if(strKeyCode === undefined && this.attr('bkeycode') === undefined) {
								break;
							} else if(nBkeycode === QBOX.def.key.ENTER || nBkeycode === QBOX.def.key.TAB || nBkeycode === QBOX.def.key.ESC) {
								break;
							} else {
								this.onBlur(event);			break;
							}
							break;
		case 'keypress':	this.onKeyPress(event);		break;			
		case 'paste':		this.onPaste(event);
							event.stopPropagation();						
							break;
		
		default:										break;
	}
	//this.attr('bkeycode', strKeyCode, 'number');
};

QBOX.QCELL.Input.prototype._show = function(heCell, strEventType){
	try{
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = parseInt(heCell.getAttribute('data-row')),
		nCol = parseInt(heCell.getAttribute('data-col')),
		data = objParent._cellValue(nRow, nCol) === undefined ? '' : objParent._cellValue(nRow, nCol),
		$cell = QBOX.$(heCell).empty(),
		$viewportinner = objParent.attr('elementpool').get('$viewportinner'),
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow];
		
		if( objParent._isValidEditColId(this.attr('colid'))){
			return;
		}		
		
		if(this.attr('convert') !== null && this.attr('convert') !== undefined ){
			if(this.attr('convert').type === '999'){
				data = QBOX.util.replaceAll(data,'%','');	
			}else if (QBOX._.isFunction(this.attr('convert').callback)){
				data = this.attr('convert').callback.call(this,nRow,nCol,data);
			}
		}
		
		this.attr('isshow', true, 'boolean');
		
		// ie에서 addRow등의 API를 통해 새로운 Row를 추가하고 난 뒤 editmode로 같은 col의 input 호출시 value값 초기화
		QBOX.$(heElement).val(data);
		
//		if(strEventType === 'keydown'){
//			heElement.value = '';
//		} else{
			heElement.value = data;
//		}
		var strHeader = objParent._cellValue(objParent.getRows('header')-1,nCol);
		heElement.setAttribute('aria-label', nRow + '행 ' + strHeader + '열 ' +data);
			
		if(this.attr('placeholder') !== undefined && this.attr('placeholder') !== null )
			heElement.placeholder = this.attr('placeholder');
		
		objParent._showMask(nCol, heElement);
		
		QBOX.$(heElement).css({width:$cell.css('width'), height:$cell.css('height'), left:$cell.css('left'), top:$cell.css('top')});
		
		$viewportinner.append(heElement);
		heElement.focus();
		heElement.select();
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		this.attr('visible', true, 'boolean');
		this.attr('insertdata', [data], 'array');
		
		objParent._addEditColId(this.attr('colid'));
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Input.prototype._show', e.message);
		return false;
	}
};
QBOX.QCELL.Input.prototype._hide = function(heCell, strEventType){
	try{
		if(heCell === null)
			return;		
		
		if(this.attr('isshow') === false && this.attr('parent').attr('oneclickedit') !== true)
			return;
				
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = this.attr('row'),
		nCol = this.attr('col'),
		strValue = heElement.value,
		objFormat = this.attr('format'), fnValdator = this.attr('validator'),
		vCellValue = objParent._cellValue(nRow, nCol),
		strDataFormat;	
		
		if(!QBOX._.isNull(this.attr('maxbyte')) && !QBOX._.isUndefined(this.attr('maxbyte')) && QBOX.util.strbyte.getByteLength(strValue) > this.attr('maxbyte')){
			strValue = QBOX.util.strbyte.cutByteLength(strValue , this.attr('maxbyte'));
		}else if(!QBOX._.isNull(this.attr('maxlength')) && !QBOX._.isUndefined(this.attr('maxlength')) && strValue.length > this.attr('maxlength')){
			strValue = strValue.slice(0, this.attr('maxlength'));
		}
		
		this.attr('isshow', false, 'boolean');
		
		if(nRow === -1 || nCol === -1)
			return;
	
		//if(strEventType === 'keydown'){
		//	strValue = this.attr('insertdata')[0];
		//} else {
		if(objFormat !== undefined)
			strValue = objParent._showUnMask(nCol, strValue,objFormat);
		//}
			
			strValue = strValue === undefined ? '' : strValue;
			strValue = strValue === null ? '' : strValue;			
		
		if(this.attr('convert') !== null && this.attr('convert') !== undefined){
			if(this.attr('convert').type === '999'){
				strValue = strValue + '%';	
			}else if (QBOX._.isFunction(this.attr('convert').afterCallback)){
				strValue = this.attr('convert').afterCallback.call(this,nRow,nCol,strValue);
			}
		}
		
		var heParentElement = heElement.parentElement;
		setTimeout(function(){
			try{
				var x = 0;
				if(heParentElement === undefined)
					return;
				
				if(heParentElement.childNodes === null)
					return;
				
				for(x=0; x< heParentElement.childNodes.length; x++){
					if(heElement === heParentElement.childNodes[x]){
						heParentElement.removeChild(heElement);
						
						if(heParentElement.childNodes === null)
							return;					
						break;
					}					
				}				
			}catch(e){
				return;
			}
		},0);
		
		//QBOX.$(heElement).detach();
		
		if(this.attr('exclude') !== undefined && QBOX._.isArray(this.attr('exclude'))){
			
			this.attr('exclude').forEach(function (exData){
				try{
					if(QBOX._.isString(exData))
						strValue = strValue.split(exData).join('');					
				}catch(e){
					QCELL.log('err', 'QCELL.Input.prototype._hide', e.message);
				}
			});			
		}
		
		var bValid = true;
		if(fnValdator){
			bValid = fnValdator(nRow,nCol,strValue);
		}
		var strOriginValue = strValue,vOriginCellValue = vCellValue;
		
		if( QBOX._.isObject(objFormat) && objFormat.type === 'number' && vCellValue !== '' && vCellValue !== undefined ){
			if(typeof vCellValue === 'string'){
				vCellValue = QBOX.util.replaceAll(vCellValue,',','');	
				strValue = QBOX.util.replaceAll(strValue,',','');	
			}
			vCellValue = isNaN(Number(vCellValue))? 0 : Number(vCellValue);
			strValue = isNaN(Number(strValue))? 0 : Number(strValue);
		}
		if(bValid === true){
			if(strValue !==vCellValue ){				
				if(strValue === '' && vCellValue === undefined	){
					//아무것도 안하고 그냥 Edit 상태 종료
					if( QBOX._.isObject(objFormat) ) {
						strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
						QBOX.util.textContent(heCell, strDataFormat);
					} else{
						QBOX.util.textContent(heCell, strValue);
					}		
					
				}else{
					if( QBOX._.isObject(objFormat) && objFormat.type === 'number' && isNaN(Number(strOriginValue)) ){
						if( QBOX._.isObject(objFormat) ) {
							strDataFormat = objParent._showDataFormat(nRow,nCol, vOriginCellValue === undefined ? '' : vOriginCellValue +'');
							QBOX.util.textContent(heCell, strDataFormat);
						} else{
							QBOX.util.textContent(heCell, vOriginCellValue);
						}							
					}else{
						//valuechanged 상황
						if(objParent.attr('merge').data === 'none' || QBOX._.isUndefined(objParent.attr('merge').data) || objParent._getColDataMergeCol(nCol)=== false){
							objParent._cellValue(nRow, nCol, strValue);
							
							if( QBOX._.isObject(objFormat) ) {
								strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
								QBOX.util.textContent(heCell, strDataFormat);
							}
						} else{
							this._changeMergeCellValue(nRow, nCol, strValue, objFormat);
							objParent._cellValue(nRow, nCol, strValue);
						}
						objParent._processValueChanged(nRow,nCol);
					}
					
				}

			} else{
				if( QBOX._.isObject(objFormat) && objFormat.type === 'number' && strOriginValue === '' && 
						(vOriginCellValue === '' || vOriginCellValue === undefined)){
					QBOX.util.textContent(heCell, strOriginValue);
				}else{
					//값이 변경 안되었을 때
					if( QBOX._.isObject(objFormat) ) {
						strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
						QBOX.util.textContent(heCell, strDataFormat);
					} else{
						QBOX.util.textContent(heCell, strValue);
					}					
				}

			}			
		}else{
			strValue = objParent._cellValue(nRow, nCol);
			
			if( QBOX._.isObject(objFormat) ) {
				strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
				QBOX.util.textContent(heCell, strDataFormat);
			} else{
				QBOX.util.textContent(heCell, strValue);
			}			
		}

		//2017-12-15(sai1515): ie8 에서는 container에 focus를 주고 CELL DIV에 focus를 할 필요가 있음.
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
		}
		// ie 에서 화면 틀어지는 버그 수정함.
		if(QBOX.browser.name !== 'msie')
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		else{
			QBOX.$(heCell).focus();
		}

		this.attr('row', -1, 'number');
		this.attr('col', -1, 'number');
		this.attr('visible', false, 'boolean');
		this.attr('insertdata', [], 'array');
		this.attr('showkey', false, 'boolean');		
		objParent._removeEditColId(this.attr('colid'));
		
		if(objParent.attr('useall') || objParent.attr('usetreeall')){
			var bFocus = objParent.attr('hideedit') === true ? false: true;
			objParent._setAriaLabelEx(heCell,nRow,nCol,bFocus);
		}
		
		return bValid;
	} catch(e){
		QCELL.log('err', 'QCELL.Input.prototype._hide', e.message);
		return false;
	}
};

QBOX.QCELL.Input.prototype.onKeyDown = function(event){
	var heElement = this.attr('element'),
	objParent = this.attr('parent'),
	heCell = objParent._getCellDOM(this.attr('row'), this.attr('col')),
	objMask = objParent._getColElement(this.attr('col')).attr('mask'),
	strKeyCode = event.keyCode,
	data = heElement.value;

	if(strKeyCode === QBOX.def.key.LEFT || strKeyCode === QBOX.def.key.RIGHT||
			strKeyCode === QBOX.def.key.UP || strKeyCode === QBOX.def.key.DOWN){
		event.stopPropagation();
		return;
	}	
	
	this.attr('bkeycode', strKeyCode, 'number');	

	
	if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB){//enter
		if(QBOX._.isObject(objMask)) {
			data = Inputmask.unmask(data, {alias: objMask.alias});
			if(data === null || data === "null") {
				data = "";
			}
		}
		
		var THAT = this;
		
		setTimeout(function(){
			THAT.attr('insertdata', [data], 'array');
			THAT._hide(heCell, event.type);
		},100);
		event.stopPropagation();
		event.preventDefault();
	} else if(strKeyCode === QBOX.def.key.ESC){//esc
		this._hide(heCell, event.type);
	} else if((strKeyCode >= 48 && strKeyCode <= 90) || (strKeyCode >= 96 && strKeyCode <= 111) || (strKeyCode === 229)){
		if(!QBOX._.isNull(this.attr('maxbyte')) && !QBOX._.isUndefined(this.attr('maxbyte')) && QBOX.util.strbyte.getByteLength(data) > this.attr('maxbyte')){
			heElement.value = data.slice(0, -1);
		}else if(!QBOX._.isNull(this.attr('maxlength')) && !QBOX._.isUndefined(this.attr('maxlength')) && data.length > this.attr('maxlength')){
			heElement.value = data.slice(0, -1);
		}
	}
};
QBOX.QCELL.Input.prototype.onKeyPress = function(event){
	var heElement = this.attr('element'),
	objParent = this.attr('parent'),
	objLimit = objParent._getColElement(this.attr('col')).attr('limit');
	
	if(QBOX._.isUndefined(objLimit) === false && QBOX._.isObject(objLimit)){
		if(objLimit.type === 'other'){
			//문자 제외 기능 추가함.
			var val='',i=0;
			if(objLimit.exclude !== undefined){
				var exclude = objLimit.exclude;
				
				val = heElement.value;
				for(i = 0; i < val.length; i++){
					if(exclude.indexOf(val.charAt(i)) !== -1){
						heElement.value = val.substring(0, i) + val.substring(i+1, val.length);
						break;
					}
				}				
			}
		}
	}
};
QBOX.QCELL.Input.prototype.onKeyUp = function(event){
	if(this.attr('col') === -1)
		return;
	
	var heElement = this.attr('element'),
	objParent = this.attr('parent'),
	objLimit = objParent._getColElement(this.attr('col')).attr('limit'),
	objNumRange = objParent._getColElement(this.attr('col')).attr('numrange'),
	strKeyCode = event.keyCode;
	
	if(QBOX._.isUndefined(objLimit) === false && QBOX._.isObject(objLimit)){
		var data = heElement.value;
		if(objLimit.type === 'string'){
			heElement.value = data.replace(/[0-9]/gi,"");
		}
		else if(objLimit.type === 'number'){
			heElement.value = data.replace(/[^0-9\.\,\-]/gi,"");
		}
		else if(objLimit.type === 'other'){
			//문자 제외 기능 추가함.
			var val='',i=0;
			
			if(objLimit.exclude !== undefined){
				var exclude = objLimit.exclude;
				
				val = heElement.value;
				for(i = 0; i < val.length; i++){
					if(exclude.indexOf(val.charAt(i)) !== -1){
						heElement.value = val.substring(0, i) + val.substring(i+1, val.length);
						break;
					}
				}				
			}else if(objLimit.expreg !== undefined){
				var expreg = objLimit.expreg;
				
				val = heElement.value;
				for(i = 0; i < val.length; i++){
					if(expreg.indexOf(val.charAt(i)) === -1){
						heElement.value = val.substring(0, i) + val.substring(i+1, val.length);
						break;
					}
				}				
			}

		}
	}
	
	if((strKeyCode >= 48 && strKeyCode <= 90) || (strKeyCode >= 96 && strKeyCode <= 111) || (strKeyCode === 229)){
		if(!QBOX._.isNull(this.attr('maxbyte')) && !QBOX._.isUndefined(this.attr('maxbyte')) && QBOX.util.strbyte.getByteLength(heElement.value) > this.attr('maxbyte')){
			heElement.value = heElement.value.slice(0, -1);
		}else if(!QBOX._.isNull(this.attr('maxlength')) && !QBOX._.isUndefined(this.attr('maxlength')) && heElement.value.length > this.attr('maxlength')){
			heElement.value = heElement.value.slice(0, -1);
		}
	}
	
	if(QBOX._.isUndefined(objNumRange) === false && QBOX._.isString(objNumRange)) {
		var min = Number(objNumRange.split(":")[0]),
		max = Number(objNumRange.split(":")[1]);
		
		var exptext = /^[+-]?\d*(\.?\d*)$/;
		
		if(exptext.test(heElement.value) === false) {
			heElement.value = "";
		}
		else if(heElement.value < min) {
			heElement.value = min;
		}
		else if(heElement.value > max) {
			heElement.value = max;
		}
	}
	
};
QBOX.QCELL.Input.prototype.onBlur = function(event){
	this.attr('parent')._onScrollHideEditCellsDOM();
};
QBOX.QCELL.Input.prototype.onPaste = function(event){
	var heElement = this.attr('element'),
	objParent = this.attr('parent'),THAT = this;
	
	var orginEvt = event.originalEvent; 
	var content =''; 
	if( orginEvt.clipboardData && orginEvt.clipboardData.getData ){ 
		content = orginEvt.clipboardData.getData('text'); 
	}else if( e.clipboardData && e.clipboardData.getData ){
		content = e.clipboardData.getData('text/plain'); 
	}else if( window.clipboardData && window.clipboardData.getData ){
		content = window.clipboardData.getData('Text'); 
	}
	var strVal = heElement.value === undefined || heElement.value === null ? '' : heElement.value;
	strVal = strVal + content;
	if(!QBOX._.isNull(this.attr('maxbyte')) && !QBOX._.isUndefined(this.attr('maxbyte')) && QBOX.util.strbyte.getByteLength(strVal) > this.attr('maxbyte')){
		setTimeout(function(){
			heElement.value = QBOX.util.strbyte.cutByteLength(strVal,THAT.attr('maxbyte'));	
		});
		
	}else if(!QBOX._.isNull(this.attr('maxlength')) && !QBOX._.isUndefined(this.attr('maxlength')) && strVal.length > this.attr('maxlength')){
		setTimeout(function(){
			heElement.value = strVal.slice(0,THAT.attr('maxlength'));	
		});
		
	}	
		
};
QBOX.QCELL.Selectmenu = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Selectmenu, QBOX.QCELL.ColElement);

QBOX.QCELL.Selectmenu.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Selectmenu');
};

QBOX.QCELL.Selectmenu.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	this.attr('visible', false, 'boolean');
	this.attr('showkey', false, 'boolean');	
	
	this.attr('isopen', false, 'boolean');	
	
	this.attr('insertdata', [], 'array');
	this.attr('input', param.options.input, 'array');
	
	this.attr('position', {}, 'object');
	
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	this.attr('itemheight', -1, 'number');
	this.attr('itemcount', param.options.itemcount, 'number');
	this.attr('selectedEnd', param.options.selectedEnd,'boolean');
	this.attr('selectclickopen', param.options.selectclickopen, 'boolean');
	
	this.attr('inputCallback', param.options.inputCallback, 'function');	//data 설정 callback
	this.attr('direction', param.options.direction, 'string');
};

QBOX.QCELL.Selectmenu.prototype._createElement = function(){
	try{
		var heDiv = document.createElement('div');
		heDiv.setAttribute('id', this.attr('id') + '_wrap');
		heDiv.className += QBOX.QCELL.def.css.TYPE_SELECTMENU_WRAP_STYLE;
		
		this._setElement(heDiv);
		
		this._calculateItemHeight();
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Selectmenu.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Selectmenu.prototype._initEvent = function(){
	var THAT = this;
	QBOX.$(this.attr('element')).on('keydown keyup', {target : this}, function(event){

		switch( event.keyCode){
			case QBOX.def.key.ESC :{
				THAT.attr('parent')._onScrollHideEditCellsDOM();
				event.stopPropagation();
				event.preventDefault();
				break;
			}
			case QBOX.def.key.LEFT :
			case QBOX.def.key.RIGHT :
			case QBOX.def.key.TAB : {
				THAT._defaultSelect();				
				THAT.attr('parent')._onScrollHideEditCellsDOM();
				event.stopPropagation();
				event.preventDefault();
				break;
			}
			case QBOX.def.key.ENTER : {
				if(THAT.attr('showkey') === true){
					THAT.attr('showkey', false, 'boolean');
					return;
				}
				if(THAT.attr('isopen') === true ){
					QBOX.$(THAT.attr('element')).selectmenu("open");
				}else {
					THAT._defaultSelect();
					THAT.attr('parent')._onScrollHideEditCellsDOM();
					event.stopPropagation();
					event.preventDefault();								
				}
				break;
			}
			
			default : {
				return true;
			}
		}			



	
	});// QBOX.st.eventProcess);
};
QBOX.QCELL.Selectmenu.prototype._getDataArray = function(){

	var arrResult ;
	
	if( QBOX._.isFunction(this.attr('inputCallback')) ) {
		var nRow = this.attr('row');
		var nCol = this.attr('col');
		
		if(nRow === -1 || nCol === -1){
			return [];
		}
		
		arrResult = this.attr('inputCallback')(nRow,nCol, this.attr('parent'));
		
		if(arrResult === undefined){
			return [];			
		}
		else{
			return arrResult;
		}
	}else{
		return this.attr('input');		
	}

};
QBOX.QCELL.Selectmenu.prototype._defaultSelect = function(event){
	var arrData = this._getDataArray();
	if(arrData.length === undefined || !arrData.length)
		return;
	
	if(this.attr('insertdata')[0] !== undefined)
		return;
	
	var val = arrData[0].value;
	this.attr('insertdata', [val], 'array');
};
QBOX.QCELL.Selectmenu.prototype._defaultAction = function(event){
//	switch (event.type){
//		case 'keydown':		this.onKeyDown(event);		break;
//		case 'keyup':		this.onKeyUp(event);		break;
//		default:										break;
//	}
};

QBOX.QCELL.Selectmenu.prototype._show = function(heCell, strEventType){
	try{
		var objParent = this.attr('parent'),
		heElement,
		nRow = parseInt(heCell.getAttribute('data-row')),
		nCol = parseInt(heCell.getAttribute('data-col')),
		data = objParent._cellValue(nRow, nCol),
		$cell = QBOX.$(heCell).empty(),
		$container = objParent.attr('elementpool').get('$container'),
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow],
		objElement = this;		
	
		this.attr('insertdata', [data], 'array');
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		
		this._calculateItemHeight();		
		
		this._initSelect();
		heElement = this.attr('element');
		
		$cell.append(heElement);
		heElement.focus();
		this.attr('isopen', false, 'boolean');
		
		if(QCELL.config.htmlselectmenu){
			heElement.getElementsByTagName('select')[0].value = this.attr('parent')._cellValue(nRow, nCol);
			QBOX.$(heElement.getElementsByTagName('select')).css('width',(parseInt($cell.css('width')) - 4) );
			QBOX.$(heElement.getElementsByTagName('select')).css('height',(parseInt($cell.css('height')) - 4) );
			QBOX.$(heElement.getElementsByTagName('select')).bind('change',function(event){
				data = event.target.value;
				
				var arrData = objElement._getDataArray();
				
				for(var i = 0; i < arrData.length; i++){//item.item.value 는 항상 string 으로 갖고 있어서, 값 체크후 알맞은 형태로 변환이 필요.
					if(arrData[i].value === data){
						break;
					} else if((arrData[i].value + '') === data){
						data = Number(data);
						break;
					}
				}
				
				objElement.attr('insertdata', [data], 'array');
				
				QBOX.$(heElement).trigger('selected', [objElement.attr('row'), objElement.attr('col'), data]);
				if(objElement.attr('selectedEnd')){
					objElement._hide(objParent._getCellDOM(objElement.attr('row'), objElement.attr('col')), 'selected');
				}
			});
			
		}else{
			QBOX.$(heElement.getElementsByTagName('select')).selectmenu({
				width	: parseInt($cell.css('width')) - 4,
				position: this._calculatePosition(heCell),
				close : function (event, ui){
					objElement.attr('isopen', false, 'boolean');
				},
				open : function (event, ui){
					objElement.attr('isopen', true, 'boolean');
				},
				select	: function(event, item){
					if(event.keyCode ===QBOX.def.key.LEFT || event.keyCode ===QBOX.def.key.RIGHT){
						return ;
					}					
					
					data = item.item.value;
					
					var arrData = objElement._getDataArray();
					
					for(var i = 0; i < arrData.length; i++){//item.item.value 는 항상 string 으로 갖고 있어서, 값 체크후 알맞은 형태로 변환이 필요.
						if(arrData[i].value === data){
							break;
						} else if((arrData[i].value + '') === data){
							data = Number(data);
							break;
						}
					}
					
					objElement.attr('insertdata', [data], 'array');
					
					QBOX.$(heElement).trigger('selected', [objElement.attr('row'), objElement.attr('col'), item]);
					if(objElement.attr('selectedEnd')){
						objElement._hide(objParent._getCellDOM(objElement.attr('row'), objElement.attr('col')), 'selected');
					}
				}
			});
			
			if(objElement.attr('selectclickopen')){
				QBOX.$(heElement.getElementsByTagName('select')).selectmenu( "open" );
			}	
			
			var spanId = "#"+this.attr('id')+"-button";
			QBOX.$(spanId).focus();
			//2018-01-11(sai1515): selectmenu 위치 보정을 위한 스타일 추가.
			QBOX.$(spanId).css('margin-bottom', '3px');
			
			
			//2018-01-11(sai1515): itemcount 옵션에 따른 height 변경.
			if(!QBOX._.isUndefined(this.attr('itemcount'))){
				QBOX.$(heElement.getElementsByTagName('select')).selectmenu('menuWidget').css('height', this.attr('itemheight'));
			}
		}


		var arrChild =heCell.getElementsByClassName('rt-qc-ui-selectmenu-text');
		
		if(arrChild.length > 0){
			var heChild = arrChild[0];
			var strTitle = objParent._cellValue(objParent.getRows('header')-1, nCol);
			var strData = this._getDataLabel(nRow,nCol);
			heChild.setAttribute('aria-label' , nRow +'행 ' + strTitle +'열 '  + strData);
			
		}
		


		this.attr('visible', true, 'boolean');
		
		objParent._addEditColId(this.attr('colid'));
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Selectmenu.prototype._show', e.message);
		return false;
	}
};

QBOX.QCELL.Selectmenu.prototype._hide = function(heCell, strEventType){
	try{
		if(heCell === null)
			return;
		
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = this.attr('row'),
		nCol = this.attr('col'),
		strValue = this.attr('insertdata')[0];
		
		if(!QCELL.config.htmlselectmenu){
			QBOX.$(heElement.getElementsByTagName('select')).selectmenu('destroy');
		}	
		
		QBOX.$(heElement).remove().html('');
		
		 if(heCell.hasChildNodes()){
			for(var x =0 ; x<heCell.childNodes.length ; x++){
				var heChild = heCell.childNodes[x];
				if(QBOX.$(heChild).hasClass(QBOX.QCELL.def.css.TYPE_SELECTMENU_WRAP_STYLE)){
					heCell.removeChild(heChild);
				}

			}
		 }
		
		if(strValue !== objParent._cellValue(nRow, nCol)){
			if(objParent.attr('merge').data === 'none' || QBOX._.isUndefined(objParent.attr('merge').data) || objParent._getColDataMergeCol(nCol)=== false){
				objParent._cellValue(nRow, nCol, strValue);
				
				this._showDataLabel(heCell,nRow, nCol, strValue);
			} else{
				this._changeMergeCellValue(nRow, nCol, strValue, undefined);
			}
			objParent._processValueChanged(nRow,nCol);
		} else{
			QBOX.util.textContent(heCell, strValue);
			
			this._showDataLabel(heCell, nRow, nCol, strValue);
		}
		
		//2017-12-15(sai1515): ie8 에서는 container에 focus를 주고 CELL DIV에 focus를 할 필요가 있음.
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
		}
		if(QBOX.browser.name !== 'msie')
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		else{
			QBOX.$(heCell).focus();
		}			
		this.attr('row', -1, 'number');
		this.attr('col', -1, 'number');
		this.attr('visible', false, 'boolean');
		this.attr('insertdata', [], 'array');
		this.attr('showkey', false, 'boolean');		
		objParent._removeEditColId(this.attr('colid'));
		if(objParent.attr('useall') || objParent.attr('usetreeall')){
			var bFocus = objParent.attr('hideedit') === true ? false: true;
			objParent._setAriaLabelEx(heCell,nRow,nCol,bFocus);
			QBOX.util.textContent(heCell, strValue);
			
			this._showDataLabel(heCell, nRow, nCol, strValue);			
		}
		var strD = heCell.textContent;
		var THAT = this;
		setTimeout(function(){
			var heDOM = objParent._getCellDOM(nRow,nCol);
			if(heDOM !== null && heDOM !== undefined){
				if(heDOM.textContent !== strD){
					//console.log(nRow + '_' + nCol);
					THAT._showDataLabel(heCell, nRow, nCol, strValue === undefined ? '' : strValue);
				}
			}
		},100);		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Selectmenu.prototype._hide', e.message);
		return false;
	}
};

QBOX.QCELL.Selectmenu.prototype._initSelect = function(){
	try{
		var objParent = this.attr('parent'),
		$div = QBOX.$(this.attr('element')).empty(),
		label, value,
		heSelect = document.createElement('select'),
		heOption = null;
		
		heSelect.setAttribute('id', this.attr('id'));
		heSelect.className =  QBOX.QCELL.def.css.TYPE_SELECTMENU_WRAP_STYLE;
		
		var arrData = this._getDataArray();
		
		for(var i = 0; i < arrData.length; i++ ){
			heOption = document.createElement('option');
			label =arrData[i].label;
			value =arrData[i].value;
			
			heOption.setAttribute('value', value);
			if(value === this.attr('insertdata')[0]){
				heOption.setAttribute('selected', 'selected');
			}
			heOption.innerHTML = label;
			
			QBOX.$(heSelect).append(heOption);
			
			heOption = null;
		}
		
		$div.append(heSelect);
		
		this._setElement($div[0]);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Selectmenu.prototype._initSelect', e.message);
		return false;
	}
};
//2018-01-11(sai1515): itemheight 계산하는 내부 함수.
QBOX.QCELL.Selectmenu.prototype._calculateItemHeight = function(){
	var itemheight = 0, i = 0;
	
	var arrData = this._getDataArray();
	
	if(arrData === undefined){
		this.attr('itemheight', itemheight, 'number');
		return;
	}
	
	if((!QBOX._.isUndefined(this.attr('itemcount')) && this.attr('itemcount') < arrData.length)){
		for(i = 0; i < this.attr('itemcount'); i++){
			if(QBOX.browser.name === 'mozilla' || (QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8)){
				itemheight += 21;
			} else if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber !== 8){
				itemheight += 20;
			} else{
				itemheight += 22;
			}
		}		
		
	} else{
		for(i = 0; i < arrData.length; i++){
			if(QBOX.browser.name === 'mozilla' || (QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8)){
				itemheight += 21;
			} else if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber !== 8){
				itemheight += 20;
			} else{
				itemheight += 22;
			}
		}	
	
	}
	this.attr('itemheight', itemheight, 'number');
};

QBOX.QCELL.Selectmenu.prototype._calculatePosition = function(heCell){
	var objParent = this.attr('parent'),
	nCellHeight = parseInt(QBOX.$(heCell).css('height')),
	nTop = parseInt(QBOX.$(heCell).css('top')) + objParent.attr('layoutsize').colheader.offsetHeight;
	
	if(this.attr('direction') === 'down')
		return {my:"left top", at: "left bottom"};
		
	if(this.attr('direction') === 'up')
		return {my:'left bottom', at: 'left top'};	
	
	
	if(objParent.attr('layoutsize').root.offsetHeight < (nTop + nCellHeight + this.attr('itemheight'))){
		return {my:'left bottom', at: 'left top'};
	} else{
		return {my:"left top", at: "left bottom"};
	}
};

//2018-01-11(sai1515): (selectmenu) label 값으로 표시하기 위한 내부 함수.
QBOX.QCELL.Selectmenu.prototype._showDataLabel = function(heCell, nRow, nCol, data){
	try{
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');	

		
		var objParent = this.attr('parent'),
		//objSelectmenuInput = objParent._getColOptions(nCol).input;
		objSelectmenuInput = this._getDataArray();
		
		
		if(objParent._isBottomPanel(heCell)){
			if(data === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, data);
			
			return;
		}
		
		if(objParent._showDisableText(heCell,nRow,nCol)){
			return;
		}
		
		if(data === undefined){
			data = '';
		}
		
		var strDataFormat = '';
		if(!(QBOX._.isUndefined(objSelectmenuInput)) && !(QBOX._.isNull(objSelectmenuInput))) {
			for(var i = 0; i < objSelectmenuInput.length; i++){
				if(data === objSelectmenuInput[i].value){
					QBOX.util.textContent(heCell, objSelectmenuInput[i].label);
					strDataFormat = objSelectmenuInput[i].label;
					break;
				}
				
				if(i === objSelectmenuInput.length - 1){
					QBOX.util.textContent(heCell, '');
				}
			}
		}
		
		objParent._setAriaLabel(heCell,nRow,nCol,strDataFormat);
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.NormalQCELL.Selectmenu._showDataLabel', e.message);
		return false;
	}
};
QBOX.QCELL.Selectmenu.prototype._getDataLabel = function( nRow, nCol){
	try{
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');			
		
		var objParent = this.attr('parent'),
		data = objParent.getCellData(nRow,nCol),
		//objSelectmenuInput = objParent._getColOptions(nCol).input;
		objSelectmenuInput = this._getDataArray();
		
		if(!(QBOX._.isUndefined(objSelectmenuInput)) && !(QBOX._.isNull(objSelectmenuInput))) {
			for(var i = 0; i < objSelectmenuInput.length; i++){
				if(data === objSelectmenuInput[i].value){
					return objSelectmenuInput[i].label;
				}
				
				if(i === objSelectmenuInput.length - 1){
					return '';
				}
			}
		}
		
		return '';
	} catch (e) {
		QCELL.log('err', 'QCELL.NormalQCELL.Selectmenu._getDataLabel', e.message);
		return '';
	}
};

QBOX.QCELL.Textarea = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Textarea, QBOX.QCELL.ColElement);

QBOX.QCELL.Textarea.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Textarea');
};

QBOX.QCELL.Textarea.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	this.attr('visible', false, 'boolean');
	this.attr('showkey', false, 'boolean');	
	
	this.attr('insertdata', '', 'string');
	this.attr('width', param.options.textareawidth, 'string');
	this.attr('height', '150px', 'string');
	
	this.attr('maxlength', param.options.maxlength, 'number');
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	this.attr('limit', param.options.limit, 'object');
	
	this.attr('exclude', param.options.exclude, 'array');
	
	this.attr('validator', param.options.validator, 'function');
	this.attr('bkeycode', undefined, 'number'); //before event keycode
	
	param.options.inputclass = param.options.inputclass === undefined ? '' : param.options.inputclass;
	if(!QBOX._.isString(param.options.inputclass))
		param.options.inputclass = '';
	
	this.attr('inputclass', param.options.inputclass, 'string');	
	
	this.attr('placeholder', param.options.placeholder , 'string');
};

QBOX.QCELL.Textarea.prototype._createElement = function(){
	try{
		var heTextarea = document.createElement('textarea');
		heTextarea.setAttribute('id', this.attr('id'));
		heTextarea.className += QBOX.QCELL.def.css.TYPE_TEXTAREA_TEXT_STYLE+' ' + this.attr('inputclass');

		QBOX.$(heTextarea).css({width:this.attr('width'), height:this.attr('height')});
		
		this._setElement(heTextarea);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Textarea.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Textarea.prototype._initEvent = function(){
	// blur 이벤트 추가
	QBOX.$(this.attr('element')).on('keydown keyup keypress blur', {target : this}, QBOX.st.eventProcess);
};

QBOX.QCELL.Textarea.prototype._defaultAction = function(event){
	var strKeyCode = event.keyCode,
	nBkeycode = this.attr('bkeycode');
	
	switch (event.type){
		case 'keydown':		this.onKeyDown(event);		break;
		case 'keyup':		this.onKeyUp(event);		break;
		case 'blur' :		if(strKeyCode === undefined && nBkeycode === undefined) {
								break;
							} else if(nBkeycode === QBOX.def.key.ENTER || nBkeycode === QBOX.def.key.TAB || nBkeycode === QBOX.def.key.ESC) {
								break;
							} else {
								this.onBlur(event);			break;
							}
							break;
		case 'keypress':	this.onKeyPress(event);		break;		
		default:										break;
	}
	//this.attr('bkeycode', strKeyCode, 'number');
};

QBOX.QCELL.Textarea.prototype._show = function(heCell, strEventType){
	try{
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = parseInt(heCell.getAttribute('data-row')),
		nCol = parseInt(heCell.getAttribute('data-col')),
		strValue = objParent._cellValue(nRow, nCol) === undefined ? '' : objParent._cellValue(nRow, nCol),
		$cell = QBOX.$(heCell).empty(),
		$container = objParent.attr('elementpool').get('$container'),
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow],
		nTop, nLeft;
		
		if( objParent._isValidEditColId(this.attr('colid'))){
			return;
		}			
		
//		if(strEventType === 'keydown'){
//			heElement.value = '';
//		} else{
			heElement.value = strValue;
//		}
		if(this.attr('placeholder') !== undefined && this.attr('placeholder') !== null )
			heElement.placeholder = this.attr('placeholder');
		if(QBOX._.isUndefined(this.attr('width'))){
			QBOX.$(heElement).css('width', $cell.css('width'));
			this.attr('width', QBOX.$(heElement).css('width'), 'string');
		}
		
		$container.append(heElement);
		heElement.focus();
		heElement.select();
		
		nTop = this._calculateTop(heElement, heCell);
		nLeft = this._calculateLeft(heElement, heCell);
		
		QBOX.$(heElement).css({left:nLeft, top:nTop});
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		this.attr('visible', true, 'boolean');
		this.attr('insertdata', strValue, 'string');
		
		objParent._addEditColId(this.attr('colid'));
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Textarea.prototype._show', e.message);
		return false;
	}
};

QBOX.QCELL.Textarea.prototype._hide = function(heCell, strEventType){
	try{
		if(heCell === null)
			return;		
		
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = this.attr('row'),
		nCol = this.attr('col'),
		strValue = heElement.value,
		fnValdator = this.attr('validator');
		
		if(strEventType === 'keydown'){
			strValue = this.attr('insertdata');
		}
		
		if(this.attr('exclude') !== undefined && QBOX._.isArray(this.attr('exclude'))){			
			this.attr('exclude').forEach(function (exData){
				try{
					if(QBOX._.isString(exData))
						strValue = strValue.split(exData).join('');					
				}catch(e){
					QCELL.log('err', 'QCELL.Textarea.prototype._hide', e.message);
				}
			});			
		}		
		
		var heParentElement = heElement.parentElement;
		setTimeout(function(){
			
			try{
				var x = 0;
				if(heParentElement === undefined)
					return;
				
				if(heParentElement.childNodes === null)
					return;
				
				for(x=0; x< heParentElement.childNodes.length; x++){
					if(heElement === heParentElement.childNodes[x]){
						heParentElement.removeChild(heElement);
						
						if(heParentElement.childNodes === null)
							return;					
						break;
					}					
				}				
			}catch(e){
				return;
			}
		},0);
		
		var bValid = true;
		if(fnValdator){
			bValid = fnValdator(nRow,nCol,strValue);
		}
		
		if(bValid === true){
			if(strValue !== objParent._cellValue(nRow, nCol)){
				if(objParent.attr('merge').data === 'none' || QBOX._.isUndefined(objParent.attr('merge').data) || objParent._getColDataMergeCol(nCol)=== false){
					objParent._cellValue(nRow, nCol, strValue);
				} else{
					this._changeMergeCellValue(nRow, nCol, strValue, undefined);
				}
				objParent._processValueChanged(nRow,nCol);
			} else{
				if(QBOX._.isNull(heCell) === false){ // 스크롤 이동으로 heCell의 DOM 정보가 사라진 경우에는 동작할 필요없음
					QBOX.util.textContent(heCell, strValue);
				}
			}
		}else{
			strValue = objParent._cellValue(nRow, nCol);
			if(QBOX._.isNull(heCell) === false){ // 스크롤 이동으로 heCell의 DOM 정보가 사라진 경우에는 동작할 필요없음
				QBOX.util.textContent(heCell, strValue);
			}
		}	
		
		//2017-12-15(sai1515): ie8 에서는 container에 focus를 주고 CELL DIV에 focus를 할 필요가 있음.
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
			
			htElementPool = null;
		}
		if(QBOX.browser.name !== 'msie')
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		else{
			QBOX.$(heCell).focus();
		}
		
		this.attr('row', -1, 'number');
		this.attr('col', -1, 'number');
		this.attr('visible', false, 'boolean');
		this.attr('insertdata', '', 'string');
		this.attr('showkey', false, 'boolean');
		
		objParent._removeEditColId(this.attr('colid'));
		if(objParent.attr('useall') || objParent.attr('usetreeall')){
			var bFocus = objParent.attr('hideedit') === true ? false: true;
			objParent._setAriaLabelEx(heCell,nRow,nCol,bFocus);
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Textarea.prototype._hide', e.message);
		return false;
	}
};

QBOX.QCELL.Textarea.prototype._calculateTop = function(heElement, heCell){
	var objParent = this.attr('parent'),
	nCellHeight = parseInt(QBOX.$(heCell).css('height')), nTextareaHeight = parseFloat(QBOX.$(heElement).css('height')),
	nTop = parseInt(QBOX.$(heCell).css('top')) + objParent.attr('layoutsize').colheader.offsetHeight;
	
	if(objParent.attr('layoutsize').root.offsetHeight < (nTop + nTextareaHeight)){
		nTop -= nTextareaHeight - nCellHeight;
	}
	
	return nTop;
};

QBOX.QCELL.Textarea.prototype._calculateLeft = function(heElement, heCell){
	var objParent = this.attr('parent'),
	nCellWidth = parseInt(QBOX.$(heCell).css('width')), nTextareaWidth = parseFloat(QBOX.$(heElement).css('width')),
	nLeft = parseInt(QBOX.$(heCell).css('left')) + objParent.attr('layoutsize').rowheader.offsetWidth;
	
	if(objParent.attr('layoutsize').root.offsetWidth < (nLeft + nTextareaWidth)){
		nLeft -= nTextareaWidth - nCellWidth;
	}
	
	return nLeft;
};

QBOX.QCELL.Textarea.prototype.onKeyDown = function(event){
	var heElement = this.attr('element'),
	objParent = this.attr('parent'),
	heCell = objParent._getCellDOM(this.attr('row'), this.attr('col')),
	strKeyCode = event.keyCode,
	strValue = heElement.value;
	
	this.attr('bkeycode', strKeyCode, 'number');
	if(event.altKey === false){
		if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB ){//enter
			var THAT = this;
			
			setTimeout(function(){
				THAT.attr('insertdata', strValue, 'string');			
				THAT._hide(heCell, event.type);				
			},100);
			event.stopPropagation();
			event.preventDefault();
		} else if(strKeyCode === QBOX.def.key.ESC){//esc
			this._hide(heCell, event.type);
		} else if((strKeyCode >= 48 && strKeyCode <= 90) || (strKeyCode >= 96 && strKeyCode <= 111) || (strKeyCode === 229)){
			if(!QBOX._.isNull(this.attr('maxlength')) && !QBOX._.isUndefined(this.attr('maxlength')) && strValue.length > this.attr('maxlength')){
				heElement.value = strValue.slice(0, -1);
			}
		}
	} else{
		if(strKeyCode === QBOX.def.key.ENTER){//enter
			heElement.value += '\r';
		}
	}
};
QBOX.QCELL.Textarea.prototype.onKeyPress = function(event){
	var heElement = this.attr('element'),
	objParent = this.attr('parent'),
	objLimit = objParent._getColElement(this.attr('col')).attr('limit');
	
	if(QBOX._.isUndefined(objLimit) === false && QBOX._.isObject(objLimit)){
		if(objLimit.type === 'other'){
			//문자 제외 기능 추가함.
			var val='',i=0;
			if(objLimit.exclude !== undefined){
				var exclude = objLimit.exclude;
				
				val = heElement.value;
				for(i = 0; i < val.length; i++){
					if(exclude.indexOf(val.charAt(i)) !== -1){
						heElement.value = val.substring(0, i) + val.substring(i+1, val.length);
						break;
					}
				}				
			}
		}
	}
};
QBOX.QCELL.Textarea.prototype.onKeyUp = function(event){
	var heElement = this.attr('element'),
	objParent = this.attr('parent'),
	objLimit = objParent._getColElement(this.attr('col')).attr('limit'),
	strKeyCode = event.keyCode;
	
	if(QBOX._.isUndefined(objLimit) === false && QBOX._.isObject(objLimit)){
		if(objLimit.type === 'string'){
			heElement.value = heElement.value.replace(/[0-9]/gi,"");
		}
		else if(objLimit.type === 'number'){
			heElement.value = heElement.value.replace(/[^0-9\.\,\-]/gi,"");
		}
		else if(objLimit.type === 'other'){
			//문자 제외 기능 추가함.
			var val='',i=0;
			
			if(objLimit.exclude !== undefined){
				var exclude = objLimit.exclude;
				
				val = heElement.value;
				for(i = 0; i < val.length; i++){
					if(exclude.indexOf(val.charAt(i)) !== -1){
						heElement.value = val.substring(0, i) + val.substring(i+1, val.length);
						break;
					}
				}				
			}else if(objLimit.expreg !== undefined){
				var expreg = objLimit.expreg;
				
				val = heElement.value;
				for(i = 0; i < val.length; i++){
					if(expreg.indexOf(val.charAt(i)) === -1){
						heElement.value = val.substring(0, i) + val.substring(i+1, val.length);
						break;
					}
				}				
			}
		}
	}
	
	if((strKeyCode >= 48 && strKeyCode <= 90) || (strKeyCode >= 96 && strKeyCode <= 111) || (strKeyCode === 229)){
		if(!QBOX._.isNull(this.attr('maxlength')) && !QBOX._.isUndefined(this.attr('maxlength')) && heElement.value.length > this.attr('maxlength')){
			heElement.value = heElement.value.slice(0, -1);
		}
	}
};
QBOX.QCELL.Textarea.prototype.onBlur = function(event){
	this.attr('parent')._onScrollHideEditCellsDOM();
};


QBOX.QCELL.Chart = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Chart, QBOX.QCELL.ColElement);

QBOX.QCELL.Chart.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Chart');
};

QBOX.QCELL.Chart.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	if(param.options.chart === undefined )
		return;
	
	var strDataType = param.options.chart.datatype === undefined ? 'data' : param.options.chart.datatype;
	strDataType = strDataType === 'data' ? 'data' : strDataType === 'key' ? 'key' : 'data';
	
	var strChartType = param.options.chart.type === undefined ? 'line' : param.options.chart.type;
	
	switch(strChartType){
		case 'line' : case 'bar' : case 'tristate' :  case 'discrete' : case 'bullet' : case 'pie' : case 'box' :
			break;
		default : strChartType = 'line';
			break;
	}
	
	var arrKeys = param.options.chart.keys === undefined ? [] : param.options.chart.keys; 
	
	this.attr('dataType', strDataType,'string');
	this.attr('chartType', strChartType,'string');
	
	this.attr('keys', arrKeys,'array');
	
	this.attr('customoption', param.options.chart.customoption, 'function');
	this.attr('chartClicked', param.options.chart.chartClicked, 'function');
	this.attr('option', param.options.chart.option,'object');


};

QBOX.QCELL.Chart.prototype._show = function(heCell, nRow, nCol){
	try {
		var objParent = this.attr('parent'),
		vValue = objParent._cellValue(nRow, nCol),
		currentData = objParent.attr('currentdata'),arrData, THAT = this,
		heColChart = objParent._getColChart(nCol),objPrevOption = this.attr('option'),arrKeys = this.attr('keys'),
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow],
		nHeaderRows = objParent.attr('headerrows');
		
		if(objParent._isBottomPanel(heCell)){
			if(data === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, vValue);
			
			return;
		}	
		
		if(this.attr('dataType') === 'data'){
			arrData = vValue;
		}else{
			arrData = [];
			for(var nIndex =0; nIndex<arrKeys.length; nIndex++){
				arrData.push(currentData[nRow-nHeaderRows][arrKeys[nIndex]]);
			}
		}
		if(arrData === undefined || arrData.length === 0)
			return;
		
		if(heCell.firstChild !== null){
			heCell.removeChild(heCell.firstChild);
		}
		
		
		//var heCenter = document.createElement('center');
		var heSpan = document.createElement('span');
		heSpan.style.textAlign = "center";
		//heCenter.appendChild(heSpan);
		heCell.appendChild(heSpan);
		var objOption = {
			'height' : (objParent._getRowHeight(nRow)-10).toString(),
			'width' : (objParent._getColWidth(nCol)-10).toString(),
			'type' : this.attr('chartType')
		};
				
		if(this.attr('chartType') === 'bar' || this.attr('chartType') === 'tristate'){
			objOption.barWidth = objParent._getColWidth(nCol) / (arrData.length +1);
		}else if(this.attr('chartType') === 'pie'){
			objOption.height = objParent._getRowHeight(nRow).toString();
		}else if(this.attr('chartType') === 'discrete'){
			objOption.width = (objParent._getColWidth(nCol)).toString();
		}
		
		if(objPrevOption !== null){
			for(var strKey in objPrevOption ){
				objOption[strKey] = objPrevOption[strKey];
			}
		}
		
		if( QBOX._.isFunction(this.attr('customoption'))){
			objOption= heColChart.customoption(objParent, nRow, nCol,arrData, objOption);
		}
		
		if((objOption.type === 'bar' || objOption.type === 'tristate' ) && objOption.barWidth === undefined){
			objOption.barWidth = objParent._getColWidth(nCol) / (arrData.length +1);
		}
		
		if(objOption.type === 'pie'){
			delete objOption.width;			
		}
		
		setTimeout(function(){			
			QBOX.$(heSpan).sparkline(arrData,objOption);
			QBOX.$(heSpan).bind('sparklineClick', function(ev) {
				objParent._clickCell(nRow,nCol);
				
				if(QBOX._.isFunction(THAT.attr('customoption')) ){
					heColChart.chartClicked(objParent, nRow, nCol,arrData, objOption);
				}
			});
			
			if(heSpan.firstChild !== null){
				heSpan.firstChild.style.verticalAlign= "middle";
				if(objOption.type === 'pie'){
					heSpan.firstChild.style.display = "block";
					heSpan.firstChild.style.margin = "auto";
				}
			}	
		},0);
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Chart._show', e.message);
		return false;
	}
};
QBOX.QCELL.Multicheckbox = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Multicheckbox, QBOX.QCELL.ColElement);

QBOX.QCELL.Multicheckbox.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Multicheckbox');
};

QBOX.QCELL.Multicheckbox.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	this.attr('visible', false, 'boolean');
	this.attr('showkey', false, 'boolean');	
	
	this.attr('isopen', false, 'boolean');
	
	this.attr('insertdata', [], 'array');
	this.attr('input', param.options.input, 'array');
	
	this.attr('position', {}, 'object');
	
	this.attr('width', -1, 'number');
	
	this.attr('tabindex', -1, 'number');
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	
	this.attr('likeradio', param.options.likeradio === undefined ? false : param.options.likeradio, 'boolean');
};

QBOX.QCELL.Multicheckbox.prototype._getDataArray = function(){
	return this.attr('input');
};

QBOX.QCELL.Multicheckbox.prototype._defaultSelect = function(event){
	var arrData = this._getDataArray();
	if(arrData.length === undefined || !arrData.length)
		return;
	
	if(this.attr('insertdata')[0] !== undefined)
		return;
	
	var val = arrData[0].value;
	this.attr('insertdata', [val], 'array');
};

QBOX.QCELL.Multicheckbox.prototype._createElement = function(){
	try {
		var heDiv = document.createElement('div');
		heDiv.setAttribute('id', this.attr('id') + '_wrap');
		heDiv.setAttribute('data-row', this.attr('row'));
		heDiv.setAttribute('data-col', this.attr('col'));
		heDiv.className += QBOX.QCELL.def.css.TYPE_MULTICHECKBOX_WRAP_STYLE;
		//heDiv.className += QBOX.QCELL.def.css.CELL + ' ' + QBOX.QCELL.def.css.CELL_VIEWPORT;
		//heDiv.className += QBOX.QCELL.def.css.CELL_FOCUS + ' ' + QBOX.QCELL.def.css.CELL_SELECT;
		
		this._setElement(heDiv);
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Multicheckbox.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Multicheckbox.prototype._initEvent = function(){
	QBOX.$(this.attr('element')).on('click keyup focusout', {target : this}, QBOX.st.eventProcess);
};

QBOX.QCELL.Multicheckbox.prototype._defaultAction = function(event){
	switch (event.type){
		case 'click':		this.onClick(event);		break;
		case 'keyup':		this.onKeyUp(event);		break;
		case 'focusout':	this.onFocusOut(event);		break;
		default:										break;
	}
};

QBOX.QCELL.Multicheckbox.prototype._initMulticheckbox = function(heCell, nRow, nCol, data){
	try{
		var $div = QBOX.$(this.attr('element')).empty(),
		//objParent = this.attr('parent'),
		heSpan = document.createElement('span'),
		inputArr = this.attr('input'),
		$cell = QBOX.$(heCell).empty(),
		strLength = 0, stdWidth = 25;
		
		this.attr('insertdata', data, 'array');
		
		// checkbox들을 감싸는 가장 외부에 class설정
		$div.addClass(QBOX.QCELL.def.css.CELL);
		$div.addClass(QBOX.QCELL.def.css.CELL_VIEWPORT);
		$div.addClass(QBOX.QCELL.def.css.CELL_FOCUS);
		$div.addClass(QBOX.QCELL.def.css.CELL_SELECT);
		
		// 연결된 데이터의 길이에 맞춰 checkbox와 label생성, label은 checkbox id에 맞춰 for로 생성하여
		// label 클릭시에도 checkbox가 click되도록 생성
		for(var i = 0; i < inputArr.length; i++){
			var heCheckbox = document.createElement('input'),
			heLabel = document.createElement('label'),
			chk = false;
			
			//heCheckbox.className += QBOX.QCELL.def.css.TYPE_MULTICHECKBOX_WRAP_STYLE;
			//heCheckbox.className += QBOX.QCELL.def.css.CELL + ' ' + QBOX.QCELL.def.css.CELL_VIEWPORT;
			heCheckbox.setAttribute("type", "checkbox");
			heCheckbox.setAttribute('name', this.attr('id'));
			heCheckbox.setAttribute('id', this.attr('id')+'-'+i);
			heCheckbox.setAttribute('data-row', nRow);
			heCheckbox.setAttribute('data-col', nCol);
			heCheckbox.className += QBOX.QCELL.def.css.TYPE_MULTICHECKBOX_STYLE;
			if(this.attr('likeradio')){
				heCheckbox.className += ' '+QBOX.QCELL.def.css.TYPE_RADIO_STYLE;
			}
			
			heLabel.setAttribute('for', this.attr('id')+'-'+i);
			heLabel.innerText = inputArr[i].label;
			
			strLength += inputArr[i].label.length;
			
			if(!QBOX._.isUndefined(data)){
				for(var j = 0; j < data.length; j++){
					if(inputArr[i].value === data[j]){
						// setAttribute('selected', 'selected')가 동작되지 않아
						// jQuery방식으로 checkbox에 check표시
						//heCheckbox.setAttribute('selected', 'selected');
						QBOX.$(heCheckbox).prop("checked", true);
						if(this.attr('likeradio') && chk){
							QBOX.$(heCheckbox).prop("checked", false);
						}
						chk = true;
						break;
					}
				}
			}
			
			// span에 처리하는 이유는 cell에서 checkbox의 높낮이와 가운데 정렬 때문
			QBOX.$(heSpan).append(heCheckbox);
			QBOX.$(heSpan).append(heLabel);
		}
		heSpan.style.height = $cell.css('height');
		heSpan.style.lineHeight = $cell.css('height');
		
		$div[0].setAttribute('data-row', nRow);
		$div[0].setAttribute('data-col', nCol);
		
		$div.append(heSpan);
		
		// label 글자하나당 div의 넓이를 결정한다, 최소 100px
		this.attr('width', stdWidth * strLength < 100 ? 100 : stdWidth * strLength, 'number');
		
	} catch(e){
		QCELL.log('err', 'QCELL.Multicheckbox.prototype._initMulticheckbox', e.message);
		return false;
	}
};

QBOX.QCELL.Multicheckbox.prototype._show = function(heCell, nRow, nCol){
	try {
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		data = objParent._cellValue(nRow, nCol),
		$cell = QBOX.$(heCell).empty(),
		$viewportinner = objParent.attr('elementpool').get('$viewportinner'),
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow];
		
		// checkbox를 생성한다
		this._initMulticheckbox(heCell, nRow, nCol, data);
		
		QBOX.$(heElement).css({width:this.attr('width'), height:$cell.css('height')});
		this._adjustPosition(heElement, $cell);
		
		$viewportinner.append(heElement);
		
		QBOX.$(heElement).find('.'+QBOX.QCELL.def.css.TYPE_MULTICHECKBOX_STYLE)[0].focus();
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		this.attr('insertdata', data, 'array');
		
		this.attr('visible', true, 'boolean');
		objParent._addEditColId(this.attr('colid'));
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Multicheckbox._show', e.message);
		return false;
	}
};

QBOX.QCELL.Multicheckbox.prototype._hide = function(heCell, strEventType){
	try{
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = this.attr('row'),
		nCol = this.attr('col'),
		strValue = this.attr('insertdata');
		
		if(strEventType === 'esc'){ // esc키를 누른 경우 데이터 원상 복구
			strValue = this.attr('insertdata');
		}
		
		QBOX.$(heElement).detach();
		
		if(strValue !== objParent._cellValue(nRow, nCol)){
			if(objParent.attr('merge').data === 'none' || QBOX._.isUndefined(objParent.attr('merge').data) || objParent._getColDataMergeCol(nCol)=== false){
				objParent._cellValue(nRow, nCol, strValue);
				
				this._showDataLabel(heCell,nRow, nCol, strValue);
			} else{
				this._changeMergeCellValue(nRow, nCol, strValue, undefined);
			}
			objParent._updateIdx('valuechanged',nRow,nCol);
			objParent._trigger('valuechanged');
		} else{
			//heCell.setAttribute('data-row', nRow);
			//heCell.setAttribute('data-col', nCol);
			
			QBOX.util.textContent(heCell, strValue);
			
			this._showDataLabel(heCell, nRow, nCol, strValue);
		}
		
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
		}
		if(QBOX.browser.name !== 'msie'){
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		}
		else{
			QBOX.$(heCell).focus();
		}
		
		this.attr('row', -1, 'number');
		this.attr('col', -1, 'number');
		this.attr('visible', false, 'boolean');
		this.attr('insertdata', [], 'array');
		this.attr('showkey', false, 'boolean');
		this.attr('isopen', false, 'boolean');
		objParent._removeEditColId(this.attr('colid'));
	} catch(e){
		QCELL.log('err', 'QCELL.Multicheckbox.prototype._hide', e.message);
		return false;
	}
};

QBOX.QCELL.Multicheckbox.prototype._adjustPosition = function(heElement, $cell){
	var objParent = this.attr('parent'), 
	width = parseInt(QBOX.$(heElement).css('width')),
	height = parseInt(QBOX.$(heElement).css('height')),
	left = parseInt($cell.css('left')),
	top = parseInt($cell.css('top')),
	//parentid = 'root-'+this.attr('parentid'),
	//offsetTop = parseInt($('#'+parentid).offset().top),
	//offsetLeft = parseInt($('#'+parentid).offset().left),
	rootOffHeight = objParent.attr('layoutsize').root.offsetHeight,
	rootOffWidth = objParent.attr('layoutsize').root.offsetWidth;
	
	if((left+width) > rootOffWidth) { // 좌우스크롤로 인한 x축 변경
		QBOX.$(heElement).css('right', 0);
	} else {
		QBOX.$(heElement).css('left', left);
	}
	
	if((top+height) > rootOffHeight) {
		QBOX.$(heElement).css('bottom', 0);
	} else {
		QBOX.$(heElement).css('top', top);
	}
};
QBOX.QCELL.Multicheckbox.prototype._showDataLabel = function(heCell, nRow, nCol, data){
	try{
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		
		var objParent = this.attr('parent');
		
		if(objParent._isBottomPanel(heCell)){
			if(data === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, data);
			
			return;
		}	
		
		if(objParent._showDisableText(heCell,nRow,nCol)){
			return;
		}		
		
		var inputArr = this._getDataArray(),
		resArr = [], res = '';
		
		if(!(QBOX._.isUndefined(inputArr)) && !(QBOX._.isNull(inputArr))) {
			if(!QBOX._.isUndefined(data)){
				for(var i = 0; i < data.length; i++){
					for(var j = 0 ; j < inputArr.length; j++){
						if(data[i] === inputArr[j].value){
							resArr[i] = inputArr[j].label;
							break;
						}
						if(j === inputArr.length - 1){
							resArr[i] = '';
						}
					}
				}
				
				for(var k = 0; k < resArr.length; k++){
					if(k === 0){
						res += resArr[k];
					}
					else{
						if(resArr[k-1] !== ''){
							res += ', '+resArr[k];
						}
					}
				}
			}
			
			QBOX.util.textContent(heCell, res);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.NormalQCELL.Multicheckbox._showDataLabel', e.message);
		return false;
	}
};

QBOX.QCELL.Multicheckbox.prototype._setMultiCheckboxCellData = function(heTargetElement){
	var objParent = this.attr('parent'),
	//nRow = Number(heTargetElement.getAttribute('data-row')),
	nCol = Number(heTargetElement.getAttribute('data-col')),
	heColTarget = objParent._getColElement(nCol),
	inputArr = [],
	res = [];
	
	if(heColTarget === null) {
		nCol = Number(heTargetElement.getAttribute('data-col'));
	}
	
	heColTarget = objParent._getColElement(nCol);
	inputArr = heColTarget.attr('input');
	
	if(!QBOX.$(heTargetElement).is('span') && !QBOX.$(heTargetElement).is('div')){ // target element가 span이나 div가 아닐 경우, 즉 checkbox일 때
		heTargetElement = heTargetElement.parentNode;
	}
	
	QBOX.$(heTargetElement).find('input[type="checkbox"]').each(function(idx){
		if(this.checked){
			res.push(inputArr[idx].value);
		}
	});
	
	this.attr('insertdata', res, 'array');
};

QBOX.QCELL.Multicheckbox.prototype._setMultiCheckboxClick = function(target, bState){
	var likeradio = this.attr('likeradio'),
	nm = target.name,
	nRow = parseInt(target.getAttribute('data-row')),
	nCol = parseInt(target.getAttribute('data-col'));
	
	this.attr('row', nRow, 'number');
	this.attr('col', nCol, 'number');
	
	if(likeradio){ // likeradio 사용시(true)
		QBOX.$('input[type="checkbox"][name="'+nm+'"]').prop('checked', false);
		QBOX.$(target).prop('checked', true);
	}
};
QBOX.QCELL.Multicheckbox.prototype.onFocusOut = function(event){
	var heElement = this.attr('element'),
	objParent = this.attr('parent'),
	//objLimit = objParent._getColElement(this.attr('col')).attr('limit'),
	heCell = objParent._getCellDOM(this.attr('row'), this.attr('col')),
	heRelatedTarget = event.relatedTarget;
	
	if(QBOX._.isElement(heRelatedTarget) && !heCell.parentNode.isSameNode(heRelatedTarget)){
		var nRow = Number(heRelatedTarget.getAttribute('data-row')),
		nCol = Number(heRelatedTarget.getAttribute('data-col'));
		
		if(nRow === 0 && nCol === 0){
			this._setMultiCheckboxCellData(heElement);
			this._hide(heCell, event.type);
			heCell.focus();
		}
	} else if(heRelatedTarget === null && this.attr('isopen')){
		this.attr('isopen', false, 'boolean');
		this._hide(heCell, 'esc');
	}
};

QBOX.QCELL.Multicheckbox.prototype.onKeyUp = function(event){
	var objParent = this.attr('parent'),
	//heElement = this.attr('element'),
	//objLimit = objParent._getColElement(this.attr('col')).attr('limit'),
	heCell = objParent._getCellDOM(this.attr('row'), this.attr('col')),
	strKeyCode = event.keyCode,
	bOpen = this.attr('isopen');
	
	if(heCell === null){
		var nRow = parseInt(event.target.getAttribute('data-row')),
		nCol = parseInt(event.target.getAttribute('data-col'));
		heCell = objParent._getCellDOM(nRow, nCol);
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
	}
	
	switch(strKeyCode){
		case QBOX.def.key.ENTER: {
			if(bOpen === false) {
				this.attr('isopen', true, 'boolean');
			} else {
				this.attr('isopen', false, 'boolean');
				this._setMultiCheckboxCellData(event.target);
				this._hide(heCell, event.type);
			}
			break;
		}
		case QBOX.def.key.ESC: {
			this.attr('isopen', false, 'boolean');
			this._hide(heCell, 'esc');
			break;
		}
		case QBOX.def.key.TAB: {
			if(bOpen === false){
				this.attr('isopen', true, 'boolean');
			}
			break;
		}
		default: break;
	}
};
QBOX.QCELL.Multicheckbox.prototype.onClick = function(event){ //checkbox를 직접 클릭하였을 때
	var heTargetElement = event.target,
	nRow = Number(heTargetElement.parentNode.getAttribute('data-row')),
	nCol = Number(heTargetElement.parentNode.getAttribute('data-col')),
	objParent =  this.attr('parent'),
	THAT = this;
	
	// checkbox거나 label일 때
	if(QBOX.util.hasClass(heTargetElement, QBOX.QCELL.def.css.TYPE_MULTICHECKBOX_STYLE) || QBOX.$(heTargetElement).is('label')){
		// multicheckbox의 check, uncheck 정보는 internal\col.js의 _hideEditCellsDOM 내부에서 처리
		// 전체 mouse event에서 click때마다 _hideEditCellsDOM()실행될 때 처리
		this.attr('isopen', true, 'boolean');
		this._setMultiCheckboxClick(heTargetElement, heTargetElement.checked);
	} else { // multicheckbox의 외곽영역 즉, checkbox, label외의 div영역 click시
		nRow = Number(heTargetElement.getAttribute('data-row'));
		nCol = Number(heTargetElement.getAttribute('data-col'));
		
		var target = objParent._getCellDOM(nRow, nCol);
		
		QBOX.$(heTargetElement.parentNode).off('keyup').on('keyup', function(event){
			switch(event.keyCode){
				case QBOX.def.key.ENTER: case QBOX.def.key.ESC:{
					THAT._hide(target, event.type);
					break;
				}
				default: break;
			}
		});
	}
};
QBOX.QCELL.Number = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Number, QBOX.QCELL.Input);

QBOX.QCELL.Number.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Number');
};

QBOX.QCELL.Number.prototype._initAttrs = function(param){
	QBOX.QCELL.Input.prototype._initAttrs.call(this, param);
	
	this.attr('min', param.options.min, 'number');
	this.attr('max', param.options.max, 'number');
	this.attr('step', param.options.step, 'number');	
};

QBOX.QCELL.Number.prototype._createElement = function(){
	try{
		var heNumber = document.createElement('input');
		heNumber.setAttribute('id', this.attr('id'));
		heNumber.setAttribute('type', 'number');
		heNumber.className += QBOX.QCELL.def.css.TYPE_NUMBER_TEXT_STYLE;
		if(this.attr('max') !== undefined && this.attr('max') !== null){
			heNumber.setAttribute('max',this.attr('max'));
		}
		if(this.attr('min') !== undefined && this.attr('min') !== null){
			heNumber.setAttribute('min',this.attr('min'));
		}
		if(this.attr('step') !== undefined && this.attr('step') !== null){
			heNumber.setAttribute('step',this.attr('step'));
		}
		this._setElement(heNumber);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Number.prototype._createElement', e.message);
		return false;
	}
};



QBOX.QCELL.Number.prototype._show = function(heCell, strEventType){
	try{
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = parseInt(heCell.getAttribute('data-row')),
		nCol = parseInt(heCell.getAttribute('data-col')),
		data = objParent._cellValue(nRow, nCol) === undefined ? '' : objParent._cellValue(nRow, nCol),
		$cell = QBOX.$(heCell).empty(),
		$viewportinner = objParent.attr('elementpool').get('$viewportinner'),
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow];
		
		if(isNaN(data)){
			data = 0;
		}
		
		// ie에서 addRow등의 API를 통해 새로운 Row를 추가하고 난 뒤 editmode로 같은 col의 input 호출시 value값 초기화
		if(this.attr('max') !== undefined && this.attr('max') !== null){
			if(data> this.attr('max'))
				data = this.attr('max');
		}
		if(this.attr('min') !== undefined && this.attr('min') !== null){
			if(data < this.attr('min'))
				data = this.attr('min');
		}	
		
		QBOX.$(heElement).val(data);		

		heElement.value = data;
		
		objParent._showMask(nCol, heElement);
		
		QBOX.$(heElement).css({width:$cell.css('width'), height:$cell.css('height'), left:$cell.css('left'), top:$cell.css('top')});
		
		$viewportinner.append(heElement);
		heElement.focus();
		heElement.select();
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		this.attr('visible', true, 'boolean');
		this.attr('insertdata', [data], 'array');
		
		objParent._addEditColId(this.attr('colid'));
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Number.prototype._show', e.message);
		return false;
	}
};

QBOX.QCELL.Number.prototype._hide = function(heCell, strEventType){
	try{
		if(heCell === null)
			return;		
		
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = this.attr('row'),
		nCol = this.attr('col'),
		strValue = heElement.value,
		objFormat = this.attr('format'), fnValdator = this.attr('validator'),
		vCellValue = objParent._cellValue(nRow, nCol),
		strDataFormat;
		
		//if(strEventType === 'keydown'){
		//	strValue = this.attr('insertdata')[0];
		//} else {
			strValue = objParent._showUnMask(nCol, strValue,objFormat);
		//}
		
		if(this.attr('max') !== undefined && this.attr('max') !== null){
			if(strValue> this.attr('max'))
				strValue = this.attr('max');
		}
		if(this.attr('min') !== undefined && this.attr('min') !== null){
			if(strValue < this.attr('min'))
				strValue = this.attr('min');
		}	
		
		QBOX.$(heElement).detach();
		
		if(this.attr('exclude') !== undefined && QBOX._.isArray(this.attr('exclude'))){
			
			this.attr('exclude').forEach(function (exData){
				try{
					if(QBOX._.isString(exData))
						strValue = strValue.split(exData).join('');					
				}catch(e){
					QCELL.log('err', 'QCELL.Number.prototype._hide', e.message);
				}
			});			
		}
		
		var bValid = true;
		if(fnValdator){
			bValid = fnValdator(nRow,nCol,strValue);
		}
		var strOriginValue = strValue,vOriginCellValue = vCellValue;
		
		if( QBOX._.isObject(objFormat) && objFormat.type === 'number'){
			if(typeof vCellValue === 'string'){
				vCellValue = vCellValue.replaceAll(',','');	
				strValue = strValue.replaceAll(',','');	
			}
			vCellValue = isNaN(Number(vCellValue))? 0 : Number(vCellValue);
			strValue = isNaN(Number(strValue))? 0 : Number(strValue);
		}
		
		if(bValid === true){
			if(strValue !== objParent._cellValue(nRow, nCol) ){
				if(strValue === '' && objParent._cellValue(nRow, nCol) === undefined ){
					//아무것도 안하고 그냥 Edit 상태 종료
					if( QBOX._.isObject(objFormat) ) {
						strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
						QBOX.util.textContent(heCell, strDataFormat);
					} else{
						QBOX.util.textContent(heCell, strValue);
					}		
					
				}else{
					//valuechanged 상황
					if(objParent.attr('merge').data === 'none' || QBOX._.isUndefined(objParent.attr('merge').data) || objParent._getColDataMergeCol(nCol)=== false){
						objParent._cellValue(nRow, nCol, strValue);
						
						if( QBOX._.isObject(objFormat) ) {
							strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
							QBOX.util.textContent(heCell, strDataFormat);
						}
					} else{
						this._changeMergeCellValue(nRow, nCol, strValue, objFormat);
					}
					objParent._processValueChanged(nRow,nCol);
				}

			} else{
				//값이 변경 안되었을 때
				if( QBOX._.isObject(objFormat) && objFormat.type === 'number' && strOriginValue === '' && 
						(vOriginCellValue === '' || vOriginCellValue === undefined)){
					QBOX.util.textContent(heCell, strOriginValue);
				}else{
					//값이 변경 안되었을 때
					if( QBOX._.isObject(objFormat) ) {
						strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
						QBOX.util.textContent(heCell, strDataFormat);
					} else{
						QBOX.util.textContent(heCell, strValue);
					}					
				}

			}			
		}else{
			strValue = objParent._cellValue(nRow, nCol);
			
			if( QBOX._.isObject(objFormat) ) {
				strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
				QBOX.util.textContent(heCell, strDataFormat);
			} else{
				QBOX.util.textContent(heCell, strValue);
			}			
		}

		//2017-12-15(sai1515): ie8 에서는 container에 focus를 주고 CELL DIV에 focus를 할 필요가 있음.
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
		}
		// ie 에서 화면 틀어지는 버그 수정함.
		if(QBOX.browser.name !== 'msie')
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		else{
			QBOX.$(heCell).focus();
		}

		this.attr('row', -1, 'number');
		this.attr('col', -1, 'number');
		this.attr('visible', false, 'boolean');
		this.attr('insertdata', [], 'array');
		this.attr('showkey', false, 'boolean');		
		objParent._removeEditColId(this.attr('colid'));
		
		return bValid;
	} catch(e){
		QCELL.log('err', 'QCELL.Number.prototype._hide', e.message);
		return false;
	}
};

QBOX.QCELL.Slider = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Slider, QBOX.QCELL.ColElement);

QBOX.QCELL.Slider.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Slider');
};

QBOX.QCELL.Slider.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	this.attr('min', param.options.min, 'number');
	this.attr('max', param.options.max, 'number');
	this.attr('step', param.options.step, 'number');
	
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	this.attr('insertdata', [], 'array');
	this.attr('validator', param.options.validator, 'function');
};

QBOX.QCELL.Slider.prototype._createElement = function(){
	try{
		var heDiv = document.createElement('div'),
		heSlider = document.createElement('input'),
		heLabel = document.createElement('label');
		
		heSlider.setAttribute('id', this.attr('id'));
		heSlider.setAttribute('type', 'range');
		QBOX.util.addClass(heSlider, QBOX.QCELL.def.css.TYPE_SLIDER_SINGLE_STYLE);
		
		if(this.attr('max') !== undefined && this.attr('max') !== null){
			heSlider.setAttribute('max',this.attr('max'));
		}
		if(this.attr('min') !== undefined && this.attr('min') !== null){
			heSlider.setAttribute('min',this.attr('min'));
		}
		if(this.attr('step') !== undefined && this.attr('step') !== null){
			heSlider.setAttribute('step',this.attr('step'));
		}
		
		heLabel.setAttribute('id', this.attr('id')+'-result');
		QBOX.util.addClass(heLabel, QBOX.QCELL.def.css.TYPE_SLIDER_RESULT_SINGLE_STYLE);
		
		heDiv.appendChild(heSlider);
		heDiv.appendChild(heLabel);
		QBOX.util.addClass(heDiv, QBOX.QCELL.def.css.TYPE_SLIDER_WRAP_STYLE);
		
		this._setElement(heDiv);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Slider.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Slider.prototype._show = function(heCell, strEventType){
	try{
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = parseInt(heCell.getAttribute('data-row')),
		nCol = parseInt(heCell.getAttribute('data-col')),
		data = objParent._cellValue(nRow, nCol) === undefined ? '' : objParent._cellValue(nRow, nCol),
		$cell = QBOX.$(heCell).empty(),
		$viewportinner = objParent.attr('elementpool').get('$viewportinner'),
		heSlider = heElement.childNodes[0],
		heLabel = heElement.childNodes[1],
		currentData = objParent.attr('currentdata'),
		colKey = objParent.attr('colkeys')[nCol],
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow],
		tempData = [];
		
		if(isNaN(data)){
			data = 0;
		}
		
		tempData = QBOX._.pluck(currentData, colKey);
		QBOX._.uniq(tempData);
		tempData = tempData.sort();
		
		// ie에서 addRow등의 API를 통해 새로운 Row를 추가하고 난 뒤 editmode로 같은 col의 input 호출시 value값 초기화
		if(this.attr('max') !== undefined && this.attr('max') !== null){
			if(data> this.attr('max')){
				data = this.attr('max');
			}
			max = parseInt(this.attr('max'));
		} else {
			//max = Math.max.apply(null, tempData);
			max = tempData[tempData.length];
		}
		if(this.attr('min') !== undefined && this.attr('min') !== null){
			if(data < this.attr('min')){
				data = this.attr('min');
			}
			min = parseInt(this.attr('min'));
		} else {
			//min = Math.min.apply(null, tempData);
			min = tempData[0];
		}
		if(this.attr('step') !== undefined && this.attr('step') !== null){
			step = this.attr('step');
		}
		
		heSlider.setAttribute('max',max);
		heSlider.setAttribute('min',min);
		
		heSlider.value = data;
		heSlider.setAttribute('data-value', data);
		
		heLabel.innerHTML = data;
		
		objParent._showMask(nCol, heElement);
		
		QBOX.$(heElement).css({width: $cell.css('width'), height: $cell.css('height'), left: $cell.css('left'), top: $cell.css('top')});
		
		if(QBOX.$.browser.msie){
			heSlider.addEventListener("change", function(e){
				heLabel.innerHTML = '';
				heLabel.innerHTML = this.value;
			});
		}
		else {
			heSlider.addEventListener("input", function(e){
				heLabel.innerHTML = '';
				heLabel.innerHTML = this.value;
			});
		}
		
		$viewportinner.append(heElement);
		heElement.focus();
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		this.attr('insertdata', [data], 'array');
		
		objParent._addEditColId(this.attr('colid'));
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Slider.prototype._show', e.message);
		return false;
	}
};

QBOX.QCELL.Slider.prototype._hide = function(heCell, strEventType){
	try{
		if(heCell === null)
			return;		
		
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = this.attr('row'),
		nCol = this.attr('col'),
		heSlider = heElement.childNodes[0],
		strValue = heSlider.value,
		fnValdator = this.attr('validator');
		
		//if(strEventType === 'keydown'){
		//	strValue = this.attr('insertdata')[0];
		//} else {
			strValue = objParent._showUnMask(nCol, strValue);
		//}
		
		QBOX.$(heElement).detach();
		
		var bValid = true;
		if(fnValdator){
			bValid = fnValdator(nRow,nCol,strValue);
		}
		
		if(bValid === true){
			if(strValue !== objParent._cellValue(nRow, nCol) ){
				if(strValue === '' && objParent._cellValue(nRow, nCol) === undefined ){
					QBOX.util.textContent(heCell, strValue);	
				}else{
					//valuechanged 상황
					if(objParent.attr('merge').data === 'none' || QBOX._.isUndefined(objParent.attr('merge').data) || objParent._getColDataMergeCol(nCol)=== false){
						objParent._cellValue(nRow, nCol, strValue);
						
						QBOX.util.textContent(heCell, strValue);
					} else{
						this._changeMergeCellValue(nRow, nCol, strValue);
					}
					objParent._processValueChanged(nRow,nCol);
				}

			} else{
				QBOX.util.textContent(heCell, strValue);
			}			
		}else{
			strValue = objParent._cellValue(nRow, nCol);
			QBOX.util.textContent(heCell, strValue);		
		}

		//2017-12-15(sai1515): ie8 에서는 container에 focus를 주고 CELL DIV에 focus를 할 필요가 있음.
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
		}
		// ie 에서 화면 틀어지는 버그 수정함.
		if(QBOX.browser.name !== 'msie')
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		else{
			QBOX.$(heCell).focus();
		}

		this.attr('row', -1, 'number');
		this.attr('col', -1, 'number');
		this.attr('insertdata', [], 'array');
		objParent._removeEditColId(this.attr('colid'));
		
		return bValid;
	} catch(e){
		QCELL.log('err', 'QCELL.Slider.prototype._hide', e.message);
		return false;
	}
};
QBOX.QCELL.Button = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Button, QBOX.QCELL.ColElement);

QBOX.QCELL.Button.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Button');
};

QBOX.QCELL.Button.prototype._createElement = function(){
	try {
		var heDiv = document.createElement('div'),
		heButton = document.createElement('input'),
		heLabel = document.createElement('label');
		
		heButton.setAttribute("type", "button");
		heButton.setAttribute('name', this.attr('id'));
		QBOX.util.addClass(heButton, QBOX.QCELL.def.css.TYPE_BUTTON_SINGLE_STYLE);
		QBOX.util.addClass(heButton, this.attr('id')+'-style');
		
		if(QBOX._.isString(this.attr('buttonwidth'))){
			heButton.style.width = this.attr('buttonwidth').indexOf('%') > -1 ? this.attr('buttonwidth') : this.attr('buttonwidth').indexOf('px') > -1 ? this.attr('buttonwidth') : this.attr('buttonwidth') + 'px';
		}
		
		if(QBOX._.isString(this.attr('buttonheight'))){
			heButton.style.height = this.attr('buttonheight').indexOf('%') > -1 ? this.attr('buttonheight') : this.attr('buttonheight').indexOf('px') > -1 ? this.attr('buttonheight') : this.attr('buttonheight') + 'px';
		} else {
			heButton.style.height = '20px';
		}

		if(QBOX._.isString(this.attr('buttonlabel'))){
			heButton.value = this.attr('buttonlabel');
		}			
		
		if(QBOX._.isString(this.attr('buttonposition')) && this.attr('buttonposition') === 'right'){
			heButton.style.float = 'right';
		} else if(this.attr('buttonposition') === 'center') {
			heDiv.style.textAlign = 'center';
		} else {
			heButton.style.float = 'left';
		}
		
		heLabel.setAttribute('for', this.attr('id'));
		QBOX.util.addClass(heLabel, QBOX.QCELL.def.css.TYPE_BUTTON_LABEL_SINGLE_STYLE);
		
		QBOX.util.addClass(heDiv, QBOX.QCELL.def.css.TYPE_BUTTON_WRAP_STYLE);
		//QBOX.util.addClass(heDiv, QBOX.QCELL.def.css.CELL_VIEWPORT);
		//QBOX.util.addClass(heDiv, QBOX.QCELL.def.css.CELL);
		heDiv.appendChild(heButton);
		heDiv.appendChild(heLabel);
		
		this._setElement(heDiv);
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Button.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Button.prototype._initEvent = function(){
	//console.log(this.attr('element'));
	QBOX.$(this.attr('element')).on('click', {target : this}, QBOX.st.eventProcess);
};

QBOX.QCELL.Button.prototype._defaultAction = function(event){
	switch (event.type){
		case 'click':		this.onClick(event);		break;
		default:										break;
	}
};

QBOX.QCELL.Button.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	//this.attr('tabindex', -1, 'number');
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	
	this.attr('buttonwidth', param.options.buttonwidth, 'string');
	this.attr('buttonheight', param.options.buttonheight, 'string');
	this.attr('buttonposition', param.options.buttonposition, 'string');
	this.attr('buttonlabel', param.options.buttonlabel, 'string');
	this.attr('buttonclick', param.options.buttonclick, 'function');
	this.attr('labeltype',param.options.labeltype,'string');
};

QBOX.QCELL.Button.prototype._show = function(heCell, nRow, nCol){
	try {
		var objParent = this.attr('parent'),
		css = QBOX.QCELL.def.css,
		strValue = objParent._cellValue(nRow, nCol) === undefined ? '' : objParent._cellValue(nRow, nCol),
		//strValue = objParent._cellValue(nRow, nCol),
		heElement = QBOX.$(this.attr('element')).clone(true).get(0),
		objCellDisabled = objParent._getQCellCol(nCol).attr('celldisabled')[nRow],
		heButton = heElement.childNodes[0],
		heLabel = heElement.childNodes[1],
		cellHeight = parseInt(QBOX.$(heCell).css('line-height')),
		buttonHeight = parseInt(QBOX.$(heButton).css('height')),
		buttonTop = ((cellHeight - buttonHeight) / 2),
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow],
		THAT = this;
		
		
		if(objParent._isBottomPanel(heCell)){
			if(data === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, strValue);
			
			return true;
		}	
		
		heCell.innerHTML = ''; // heCell child 초기화
		
		if(heButton.style.float === 'left' || heButton.style.float === 'right'){ //left, right일 때 button 위치 조정
			heButton.style.position = 'relative'; // button의 위치 조정
			heButton.style.top = buttonTop + 'px';
		}
		
		heElement.setAttribute('data-row', nRow);
		heElement.setAttribute('data-col', nCol);
		heButton.setAttribute('data-row', nRow);
		heButton.setAttribute('data-col', nCol);
		heLabel.setAttribute('data-row', nRow);
		heLabel.setAttribute('data-col', nCol);
		
		if(QBOX._.isFunction(this.attr('buttonclick'))){
			QBOX.$(heButton).on('click', function(){
				var nRow = parseInt(this.getAttribute('data-row')),
				nCol = parseInt(this.getAttribute('data-col'));
				
				THAT.attr('row', nRow, 'number');
				THAT.attr('col', nCol, 'number');
			});
			heButton.addEventListener('click', THAT.attr('buttonclick').bind(this, objParent, nRow, nCol), false);
		}
		if(this.attr('labeltype') === 'button'){
			heButton.value = strValue;
		}else{
			heLabel.innerHTML = strValue;	
		}		
		
		
		// disabled 속성이 true 일 때
		if(objCellDisabled){
			QBOX.$(heButton).attr('disabled', objCellDisabled);
		}
		else {
			QBOX.$(heButton).removeAttr('disabled');
		}
		
		heCell.appendChild(heElement);
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Button._show', e.message);
		return false;
	}
};


QBOX.QCELL.Button.prototype._outerClick = function(nRow, nCol){
	var objQCell =  this.attr('parent');
	objQCell._selectCell(nRow, nCol);
	objQCell._focusCell(nRow, nCol);
};
QBOX.QCELL.Button.prototype.onClick = function(event){ //checkbox를 직접 클릭하였을 때
	var heTargetElement = event.target,
	nRow = parseInt(heTargetElement.getAttribute('data-row')),
	nCol = parseInt(heTargetElement.getAttribute('data-col'));
	
	if(QBOX._.isElement(heTargetElement)){
		this._outerClick(nRow, nCol);
	}
};
QBOX.QCELL.Editor = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.Editor, QBOX.QCELL.ColElement);

QBOX.QCELL.Editor.prototype._initTag = function(){
	this.tag('QBOX.QCELL.Editor');
};

QBOX.QCELL.Editor.prototype._createElement = function(){
	try {
		var heDiv = document.createElement('div'),
		heTextArea = document.createElement('textarea');
		heTextArea.setAttribute('id', this.attr('id')+'_Editor');
		heTextArea.style.width = '600px';
		heTextArea.style.height = '300px';
		
		heTextArea.className += QBOX.QCELL.def.css.TYPE_EDITOR_STYLE;
		
		heDiv.appendChild(heTextArea);
		QBOX.util.addClass(heDiv, QBOX.QCELL.def.css.TYPE_EDITOR_WARP_STYLE);
		
		this._setElement(heDiv);
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Editor.prototype._createElement', e.message);
		return false;
	}
};

QBOX.QCELL.Editor.prototype._initAttrs = function(param){
	QBOX.QCELL.ColElement.prototype._initAttrs.call(this, param);
	
	this.attr('insertdata', '', 'string');
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	this.attr('editor', {}, 'object');
	
	this.attr('renderer', param.options.html === undefined ? null : param.options.html.data, 'function');				//<td>태그에 삽입할 html을 반환하는 콜백 함수를 정의하는 속성
	
	this.attr('editcellcol', false, 'boolean');
	this.attr('editcellrow', [], 'array');
	this.attr('editorshow', false, 'boolean');
};

QBOX.QCELL.Editor.prototype._show = function(heCell, nRow, nCol){
	try {
		var objParent = this.attr('parent'),
		strValue = objParent._cellValue(nRow, nCol),
		heElement = this.attr('element'),
		$cell = QBOX.$(heCell).clone(true).empty(),
		$container = objParent.attr('elementpool').get('$container'),
		cellData = QBOX.$(objParent._getCellDOM(nRow, nCol)).clone(true).get(0).innerHTML,
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow],
		heEditor = heElement.childNodes[0],
		THAT = this,
		editorWidth = 606,
		editorHeight = 306;
		
		heCell.addClass += QBOX.QCELL.def.css.TYPE_HTML_CELL;
		
		strValue = objParent._showDataFormat(nRow,nCol, strValue);
		
		heEditor.style.width = '606px';
		heEditor.style.height = '306px';
		heEditor.value = cellData;
		
		$container.append(heElement);
		heElement.focus();
		//heElement.select();
		
		var editor = document.getElementById(heEditor.id);
		
		sceditor.create(editor, {
			locale: 'ko',
			plugins: 'undo',
			format: 'xhtml',
			icons: 'monocons',
			emoticonsEnabled: false,
			style: RightTechPath+'QCELL/js/modules/BasicQCELL/lib/sceditor/themes/content/default.min.css',
			emoticonsRoot: RightTechPath+'QCELL/js/modules/BasicQCELL/lib/sceditor/',
			toolbar: 'bold,italic,underline,strike,subscript,superscript,left,center,right,justify,font,size,color,removeformat,cut,copy,paste,pastetext,source',
			fonts: 'Malgun Gothic, NanumGothic, Dotum, Arial,Arial Black,Comic Sans MS,Courier New,Georgia,Impact,Sans-serif,Serif,Times New Roman,Trebuchet MS,Verdana'
		});
		
		QBOX.$(heElement).css(this._calculateColStyleEditorPosition($cell, editorWidth, editorHeight));
		
		var instance = sceditor.instance(editor);
		this.attr('editor', instance, 'object');
		
		// Wysiwyg
		instance.keyPress(function(e){
			THAT.onEditorKeyDown(e);
		}, false, true)
		.keyUp(function(e){
			THAT.onEditorKeyUp(e);
		}, false, true);
		
		// Source
		instance.keyPress(function(e){
			THAT.onKeyDown(e);
		}, true, false).keyUp(function(e){
			THAT.onKeyDown(e);
		}, true, false);
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		objParent._addEditColId(this.attr('colid'));
		
		this.attr('editorshow', true, 'boolean');
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Editor._show', e.message);
		return false;
	}
};

QBOX.QCELL.Editor.prototype._hide = function(heCell, strEventType){
	try{
		if(heCell === null)
			return;
		
		var objParent = this.attr('parent'),
		nRow = parseInt(heCell.getAttribute('data-row')),
		nCol = parseInt(heCell.getAttribute('data-col')),
		instance = this.attr('editor'),
		strValue = this.attr('insertdata'),
		cellData = QBOX.$(objParent._getCellDOM(nRow, nCol)).clone(true).get(0).innerHTML,
		editcellcol = this.attr('editcellcol'),
		editcellrow = this.attr('editcellrow');
		
		instance.destroy();
		QBOX.$(this.attr('element')).remove();
		
		if(strEventType === 'api'){ // esc입력시
			strValue = cellData;
		} else {
			var bSame = false;
			//동일 row, col이 있는지 구해야 함
			
			if(editcellcol){
				QBOX.$.each(editcellrow, function(idx, item){
					if(item.row === nRow){
						bSame = true;
						return false;
					}
				});
				
				if(!bSame){
					editcellrow.push({row: nRow, data: strValue});
				}
			} else {
				this.attr('editcellcol', true, 'boolean');
				editcellrow.push({row: nRow, data: strValue});
			}
			
			heCell.vale = '';
		}
		
		strValue = objParent._showDataFormat(nRow,nCol, strValue);
		heCell.innerHTML = strValue;
		
		//2017-12-15(sai1515): ie8 에서는 container에 focus를 주고 CELL DIV에 focus를 할 필요가 있음.
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
		}
		// ie 에서 화면 틀어지는 버그 수정함.
		if(QBOX.browser.name !== 'msie')
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		else{
			QBOX.$(heCell).focus();
		}
		
		this.attr('row', -1, 'number');
		this.attr('col', -1, 'number');
		this.attr('insertdata', '', 'string');
		objParent._removeEditColId(this.attr('colid'));
		
		this.attr('editorshow', false, 'boolean');
		
		if(strEventType !== 'api'){
			objParent._refresh();
		}
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.Editor.prototype._hide', e.message);
		return false;
	}
};

//editor의 위치 조정
QBOX.QCELL.Editor.prototype._calculateColStyleEditorPosition = function($cell, editorWidth, editorHeight){
	var objQCell = this.attr('parent'),
	nTargetLeft = parseInt($cell.css('left')),
	nTargetTop = parseInt($cell.css('top')), 
	nTargetColWidth = parseInt($cell.css('width')),
	nRootOffsetWidth = objQCell.attr('layoutsize').root.offsetWidth,
	nTargetColHeight = parseInt($cell.css('height')),
	nRootOffsetHeight = objQCell.attr('layoutsize').root.offsetHeight,
	colheaderHeight = objQCell.attr('layoutsize').colheader.offsetHeight,
	rowheaderWidth = objQCell.attr('layoutsize').rowheader.offsetWidth,
	left, top;
	
	if((nTargetLeft + nTargetColWidth + rowheaderWidth + editorWidth) > nRootOffsetWidth){
		left = ((nTargetLeft + nTargetColWidth + rowheaderWidth) - editorWidth + 6) + 'px';
	} else {
		left = (nTargetLeft + rowheaderWidth) + 'px';
	}
	
	if((nTargetTop + nTargetColHeight + colheaderHeight + editorHeight) > nRootOffsetHeight){
		top = ((nTargetTop + colheaderHeight) - editorHeight + 6) + 'px';
	} else {
		top = (nTargetTop + nTargetColHeight + colheaderHeight) + 'px';
	}
	
	return {left: left, top: top};
};
QBOX.QCELL.Editor.prototype._showDataLabel = function(heCell, nRow, nCol, data){
	try{
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		
		
		var objParent = this.attr('parent'),
		strValue = objParent._cellValue(nRow, nCol),
		currentData = objParent.attr('currentdata'),
		objColHtml = objParent._getColHtml(nCol),
		objColStyleEditorAfterData = objParent.attr('qcellcols')[nCol].attr('colstyleeditordata'),
		editcellcol = this.attr('editcellcol'),
		editcellrow = this.attr('editcellrow'),
		bRtn1 = false,
		bRtn2 = false,
		bRtn3 = false,
		rtnStr = '';
		
		if(objParent._isBottomPanel(heCell)){
			if(data === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, data);
			
			return;
		}		
		
		
		heCell.addClass += QBOX.QCELL.def.css.TYPE_HTML_CELL;
		
		strValue = objParent._showDataFormat(nRow,nCol, strValue);
		
		if( QBOX._.isFunction(this.attr('renderer')) && QBOX._.isFunction(objColHtml.data) ) {
			var vData = objColHtml.data(objParent, nRow, nCol, QBOX._.isUndefined(strValue) === true ? '' : strValue, currentData[nRow - objParent.attr('headerrows')]);
			if( QBOX._.isString(vData) ) {
				bRtn1 = true;
				rtnStr = vData;
			}
		}
		
		if(objColStyleEditorAfterData !== ''){
			var nData = objColStyleEditorAfterData.replace('QCELL_COL_DATA', strValue);
			bRtn2 = true;
			rtnStr = nData;
		}
		
		if(editcellcol) {
			QBOX.$.each(editcellrow, function(idx, item){
				if(item.row === nRow){
					bRtn3 = true;
					rtnStr = item.data;
					return false;
				}
			});
		}
		
		if(bRtn1 || bRtn2 || bRtn3){
			heCell.innerHTML = rtnStr;
		} else {
			QBOX.util.textContent(heCell, strValue);
		}
		
		QBOX.$(heCell.childNodes[0]).off('dblclick').on('dblclick', {target : this}, this.onDblClick);
		
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.NormalQCELL.Editor._showDataLabel', e.message);
		return false;
	}
};

QBOX.QCELL.Editor.prototype.onKeyDown = function(event){
	var objParent = this.attr('parent'),
	heCell = objParent._getCellDOM(this.attr('row'), this.attr('col')),
	strKeyCode = event.keyCode,
	instance = this.attr('editor');
	
	if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB ){//enter
		var THAT = this;
		
		setTimeout(function(){
			THAT.attr('insertdata', instance.getSourceEditorValue(), 'string');			
			THAT._hide(heCell, event.type);
		},100);
		
		event.stopPropagation();
		event.preventDefault();
	}
};

QBOX.QCELL.Editor.prototype.onKeyUp = function(event){
	var objParent = this.attr('parent'),
	heCell = objParent._getCellDOM(this.attr('row'), this.attr('col')),
	strKeyCode = event.keyCode,
	instance = this.attr('editor');
	
	if(event.altKey === false){
		if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB ){//enter
			var THAT = this;
			
			setTimeout(function(){
				THAT.attr('insertdata', instance.getSourceEditorValue(), 'string');			
				THAT._hide(heCell, event.type);
			},100);
			
			event.stopPropagation();
			event.preventDefault();
		} else if(strKeyCode === QBOX.def.key.ESC){//esc
			this._hide(heCell, 'api');
		}
	} else{
		if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === 10){//enter
			instance.sourceEditorInsertText('\r');
		}
	}
};

QBOX.QCELL.Editor.prototype.onEditorKeyDown = function(event){
	var objParent = this.attr('parent'),
	//heElement = this.attr('element'),
	heCell = objParent._getCellDOM(this.attr('row'), this.attr('col')),
	strKeyCode = event.keyCode,
	instance = this.attr('editor');
	
	if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB ){//enter
		var THAT = this;
		
		var val = instance.getWysiwygEditorValue();
		instance.setSourceEditorValue(val);
		
		setTimeout(function(){
			THAT.attr('insertdata', instance.getSourceEditorValue(val), 'string');			
			THAT._hide(heCell, event.type);
		},100);
		
		event.stopPropagation();
		event.preventDefault();
	}
};

QBOX.QCELL.Editor.prototype.onEditorKeyUp = function(event){
	var objParent = this.attr('parent'),
	//heElement = this.attr('element'),
	heCell = objParent._getCellDOM(this.attr('row'), this.attr('col')),
	strKeyCode = event.keyCode,
	instance = this.attr('editor');
	
	if(event.altKey === false){
		if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === QBOX.def.key.TAB ){//enter
			var THAT = this;
			
			var val = instance.getWysiwygEditorValue();
			instance.setSourceEditorValue(val);
			
			setTimeout(function(){
				THAT.attr('insertdata', instance.getSourceEditorValue(val), 'string');			
				THAT._hide(heCell, event.type);
			},100);
			
			event.stopPropagation();
			event.preventDefault();
		} else if(strKeyCode === QBOX.def.key.ESC){//esc
			this._hide(heCell, 'api');
		}
	} else{
		if(strKeyCode === QBOX.def.key.ENTER || strKeyCode === 10){//enter
			event.stopPropagation();
			event.preventDefault();
			
			var rangeHelper = instance.getRangeHelper();
			if(QBOX.browser.name === 'msie'){
				var br = document.createElement('br');
				
				rangeHelper.insertNode(br);
				
				var parent = br.parentNode,
				children = parent.childNodes,
				brlen = 0;
				
				for(var i = 0; i < children.length; i++){
					if(children[i].isEqualNode(br)){
						brlen++;
					}
				}
				
				if(brlen == 1){ // ie에선 최초 한번만 brbr 입력, 이후 br 코드 한번으로 줄바꿈 처리됨
					rangeHelper.insertNode(br.cloneNode());
				}
			} else {
				rangeHelper.insertHTML('<br><br>');
			}
		}
	}
};
QBOX.QCELL.Editor.prototype.onDblClick = function(event){ //checkbox를 직접 클릭하였을 때
	var heTargetElement = event.target,
	nRow = Number(heTargetElement.parentNode.getAttribute('data-row')),
	nCol = Number(heTargetElement.parentNode.getAttribute('data-col')),
	THAT = event.data.target,
	objParent = THAT.attr('parent'),
	heElement = objParent._getCellDOM(nRow, nCol);
	
	if(nRow === 0 && nCol === 0) {
		var heParent = heTargetElement.parentNode;
		nRow = Number(heParent.parentNode.getAttribute('data-row'));
		nCol = Number(heParent.parentNode.getAttribute('data-col'));
		heElement = objParent._getCellDOM(nRow, nCol);
	}
	
	objParent._onScrollHideEditCellsDOM();
	
	THAT._show(heElement, nRow, nCol);
};
QBOX.QCELL.InputButton = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.InputButton, QBOX.QCELL.Input);

QBOX.QCELL.InputButton.prototype._initTag = function(){
	this.tag('QBOX.QCELL.InputButton');
};
QBOX.QCELL.InputButton.prototype._initAttrs = function(param){
	QBOX.QCELL.Input.prototype._initAttrs.call(this, param);
	
	this.attr('buttonwidth', param.options.buttonwidth, 'string');
	this.attr('buttonheight', param.options.buttonheight, 'string');
	this.attr('buttonposition', param.options.buttonposition, 'string');
	this.attr('buttonlabel', param.options.buttonlabel, 'string');
	this.attr('buttonclick', param.options.buttonclick, 'function');
	
	if(this.attr('buttonposition') === undefined) {
		this.attr('buttonposition','right','string');
	}
	if(this.attr('buttonwidth') === undefined) {
		this.attr('buttonwidth','20px','string');
	}
	if(this.attr('buttonheight') === undefined) {
		this.attr('buttonheight','20px','string');
	}
	
	this.attr('placeholder', param.options.placeholder , 'string');
	
	this.attr('editable' , param.options.editable ===  false ? false :true , 'boolean');

};

QBOX.QCELL.InputButton.prototype._showDataLabel = function(heCell, nRow, nCol, data){
	try{
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		
		
		heCell.innerHTML = '';
		
		var objParent = this.attr('parent');
		var heButton = document.createElement('button');
		var heSpan = document.createTextNode('data');
		
		if(objParent._isBottomPanel(heCell)){
			if(data === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, data);
			
			return;
		}		
		
	
		if(objParent._isBottomPanel(heCell)){
			if(data === undefined)
				QBOX.util.textContent(heCell, '');
			else
				QBOX.util.textContent(heCell, data);
			
			return;
		}			
		
		QBOX.util.addClass(heButton, QBOX.QCELL.def.css.TYPE_BUTTON_SINGLE_STYLE);
		QBOX.util.addClass(heButton, this.attr('id')+'-style');
		
		if(QBOX._.isString(this.attr('buttonwidth'))){
			heButton.style.width = this.attr('buttonwidth').indexOf('%') > -1 ? this.attr('buttonwidth') : this.attr('buttonwidth').indexOf('px') > -1 ? this.attr('buttonwidth') : this.attr('buttonwidth') + 'px';
		}
		
		if(QBOX._.isString(this.attr('buttonheight'))){
			heButton.style.height = this.attr('buttonheight').indexOf('%') > -1 ? this.attr('buttonheight') : this.attr('buttonheight').indexOf('px') > -1 ? this.attr('buttonheight') : this.attr('buttonheight') + 'px';
		} else {
			heButton.style.height = '20px';
		}
		
		var nHeight = parseInt( QBOX.$(heCell).css('height'))/2 - parseInt( QBOX.$(heButton).css('height'))/2;
		
		if(QBOX._.isString(this.attr('buttonlabel'))){
			heButton.value = this.attr('buttonlabel');
		}
		heButton.style.position = 'absolute';
		heButton.style.right = '1px';
		heButton.style.top = nHeight + 'px';
		heButton.style.cursor = 'pointer';
		
		if(QBOX._.isString(this.attr('buttonposition')) && this.attr('buttonposition') === 'right'){
			heButton.style.float = 'right';
		} else if(this.attr('buttonposition') === 'center') {
			heDiv.style.textAlign = 'center';
		} else {
			heButton.style.float = 'left';
		}
		
		QBOX.$(heButton).bind('click',function(e){
			e.stopPropagation();
			
			objParent._focusCell(nRow, nCol);
			
			switch(objParent.attr('selectmode')){
				case 'row': case 'rows':{
					objParent._clearSelection();
					objParent._selectRow(nRow);
					break;
				}
				case 'col': case 'cols': {
					objParent._clearSelection();
					objParent._selectCol(nCol);
					break;
				}
				default: {//cell, cells
					objParent._clearSelection();
					objParent._selectCell(nRow, nCol);					
					break;
				}
			}
			
			//setTimeout(function(){
					if(QCELL.config.usebuttonclickcallback){
						e.preventDefault();
						objParent._callButtonclickCallback();						
					}else{
						objParent._trigger('buttonclick');	
					}
					
			//},0);
			
		});
		
		
		QBOX.util.textContent(heSpan,data);
		
		heCell.appendChild(heSpan);
		heCell.appendChild(heButton);
		
		objParent._setAriaLabel(heCell,nRow,nCol,data);

		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.NormalQCELL.InputButton._showDataLabel', e.message);
		return false;
	}
};
QBOX.QCELL.InputButton.prototype._show = function(heCell, strEventType){
	try{
		
		if(this.attr('editable') === true){
			QBOX.QCELL.Input.prototype._show.call(this, heCell,strEventType);
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Input.prototype._show', e.message);
		return false;
	}
};
QBOX.QCELL.InputButton.prototype._hide = function(heCell, strEventType){
	try{
		if(heCell === null)
			return;		
		
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = this.attr('row'),
		nCol = this.attr('col'),
		strValue = heElement.value,
		objFormat = this.attr('format'), fnValdator = this.attr('validator'),
		vCellValue = objParent._cellValue(nRow, nCol),
		strDataFormat;
		
		//if(strEventType === 'keydown'){
		//	strValue = this.attr('insertdata')[0];
		//} else {
			strValue = objParent._showUnMask(nCol, strValue,objFormat);
		//}
		
		QBOX.$(heElement).detach();
		
		if(this.attr('exclude') !== undefined && QBOX._.isArray(this.attr('exclude'))){
			
			this.attr('exclude').forEach(function (exData){
				try{
					if(QBOX._.isString(exData))
						strValue = strValue.split(exData).join('');					
				}catch(e){
					QCELL.log('err', 'QCELL.InputButton.prototype._hide', e.message);
				}
			});			
		}
		
		var bValid = true;
		if(fnValdator){
			bValid = fnValdator(nRow,nCol,strValue);
		}
		
		var strOriginValue = strValue,vOriginCellValue = vCellValue;
		
		if( QBOX._.isObject(objFormat) && objFormat.type === 'number'){
			if(typeof vCellValue === 'string'){
				vCellValue = vCellValue.replaceAll(',','');	
				strValue = strValue.replaceAll(',','');	
			}
			vCellValue = isNaN(Number(vCellValue))? 0 : Number(vCellValue);
			strValue = isNaN(Number(strValue))? 0 : Number(strValue);
		}
		
		if(bValid === true){
			if(strValue !== vCellValue ){
				if(strValue === '' && vCellValue === undefined ){
					//아무것도 안하고 그냥 Edit 상태 종료
					if( QBOX._.isObject(objFormat) ) {
						strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
						this._showDataLabel(heCell,nRow,nCol,strDataFormat);						
					} else{
						this._showDataLabel(heCell,nRow,nCol,strValue);
					}		
					
				}else{
					//valuechanged 상황
					if(objParent.attr('merge').data === 'none' || QBOX._.isUndefined(objParent.attr('merge').data) || objParent._getColDataMergeCol(nCol)=== false){
						objParent._cellValue(nRow, nCol, strValue);
						
						if( QBOX._.isObject(objFormat) ) {
							strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
							this._showDataLabel(heCell,nRow,nCol,strDataFormat);
						}
					} else{
						this._changeMergeCellValue(nRow, nCol, strValue, objFormat);
					}
					objParent._processValueChanged(nRow,nCol);
				}

			} else{
				//값이 변경 안되었을 때
				if( QBOX._.isObject(objFormat) && objFormat.type === 'number' && strOriginValue === '' && 
						(vOriginCellValue === '' || vOriginCellValue === undefined)){
					this._showDataLabel(heCell,nRow,nCol,strOriginValue);					
				}else{
					//값이 변경 안되었을 때
					if( QBOX._.isObject(objFormat) ) {
						strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
						this._showDataLabel(heCell,nRow,nCol,strDataFormat);						
					} else{
						this._showDataLabel(heCell,nRow,nCol,strValue);						
					}					
				}

			}			
		}else{
			strValue = vCellValue;
			
			if( QBOX._.isObject(objFormat) ) {
				strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
				this._showDataLabel(heCell,nRow,nCol,strDataFormat);
			} else{
				this._showDataLabel(heCell,nRow,nCol,strValue);
			}			
		}

		//2017-12-15(sai1515): ie8 에서는 container에 focus를 주고 CELL DIV에 focus를 할 필요가 있음.
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
		}
		// ie 에서 화면 틀어지는 버그 수정함.
		if(QBOX.browser.name !== 'msie')
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		else{
			QBOX.$(heCell).focus();
		}

		this.attr('row', -1, 'number');
		this.attr('col', -1, 'number');
		this.attr('visible', false, 'boolean');
		this.attr('insertdata', [], 'array');
		this.attr('showkey', false, 'boolean');		
		objParent._removeEditColId(this.attr('colid'));
		
		return bValid;
	} catch(e){
		QCELL.log('err', 'QCELL.InputButton.prototype._hide', e.message);
		return false;
	}
};
QBOX.QCELL.InputDatepicker = function(properties){
	if(QBOX.util.checkType(properties, 'object') === false){return null;}
	QBOX.QCELL.ColElement.call(this, properties);
};
QBOX.util.inherit(QBOX.QCELL.InputDatepicker, QBOX.QCELL.Input);

QBOX.QCELL.InputDatepicker.prototype._initTag = function(){
	this.tag('QBOX.QCELL.InputDatepicker');
};
QBOX.QCELL.InputDatepicker.prototype._initEvent = function(){
	//blur 이벤트 추가함.
	QBOX.$(this.attr('element')).on('keydown keyup keypress', {target : this}, QBOX.st.eventProcess);
};
QBOX.QCELL.InputDatepicker.prototype._initAttrs = function(param){
	QBOX.QCELL.Input.prototype._initAttrs.call(this, param);
	
	this.attr('showkey', false, 'boolean');
	this.attr('visible', false, 'boolean');
	this.attr('changeyear', param.options.changeyear === undefined ? false : param.options.changeyear, 'boolean');
	this.attr('changemonth', param.options.changemonth === undefined ? false : param.options.changemonth, 'boolean');
	
	this.attr('insertdata', '', 'string');
	this.attr('dateformat', param.options.dateformat === undefined ? 'YYMMDD' : param.options.dateformat, 'string');
	this.attr('locale', param.options.locale === undefined ? 'ko' : param.options.locale, 'string');
	this.attr('yearrange', param.options.yearrange === undefined ? 'c-10:c+10' : param.options.yearrange, 'string');
	
	this.attr('row', -1, 'number');
	this.attr('col', -1, 'number');
	
	this.attr('format', param.options.format, 'object');
	
	this.attr('placeholder', param.options.placeholder , 'string');
	
	this.attr('timetype', param.options.timetype === undefined ? 'none' : param.options.timetype, 'string');
	this.attr('timeformat', param.options.timeformat === undefined ? 'HHmmss' : param.options.timeformat, 'string');
	if(QBOX.$.timepicker !== undefined)
		this.attr('timeseparator', param.options.timeseparator === undefined ? QBOX.$.timepicker._defaults.separator : param.options.timeseparator, 'string');
	
	this.attr('dateimage', param.options.dateimage === undefined ? '' : param.options.dateimage, 'string');
	this.attr('dateimageside', param.options.dateimageside === undefined ? 'right' : param.options.dateimageside, 'string');
	this.attr('dateimageonly', param.options.dateimageonly === undefined ? false : param.options.dateimageonly, 'boolean');
	
	this.attr('direction', param.options.direction, 'string');
};

QBOX.QCELL.InputDatepicker.prototype._createElement = function(){
	try{
		var heInput = document.createElement('input');
		heInput.setAttribute('id', this.attr('id'));
		heInput.className += QBOX.QCELL.def.css.TYPE_INPUT_TEXT_STYLE +' ' + this.attr('inputclass');
		
		this._setElement(heInput);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.InputDatepicker.prototype._createElement', e.message);
		return false;
	}
};
QBOX.QCELL.InputDatepicker.prototype._show = function(heCell, strEventType){
	try{
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = parseInt(heCell.getAttribute('data-row')),
		nCol = parseInt(heCell.getAttribute('data-col')),
		data = objParent._cellValue(nRow, nCol) === undefined ? '' : objParent._cellValue(nRow, nCol),
		$cell = QBOX.$(heCell).empty(),
		$viewportinner = objParent.attr('elementpool').get('$viewportinner'),
		objFormat = this.attr('format'),
		objCellInvisible = objParent._getQCellCol(nCol).attr('cellinvisible')[nRow],
		strValue,
		objElement = this;
		if(this.attr('dateformat').toLowerCase() === 'yymmdd'){
			strValue = data;
		}else{
			if(objFormat !== undefined){
				strValue = objParent._showDataFormat(nRow,nCol, data === undefined ? '' : data);
			}else{
				strValue = data;
			}			
		}
		
		var	options = {
				defaultDate		: strValue,
				changeYear		: this.attr('changeyear'),
				changeMonth		: this.attr('changemonth'),
				dateFormat		: this.attr('dateformat').toLowerCase(),
				yearRange		: this.attr('yearrange'),
				firstDay		: 0,
				onSelect		: function(strResult, inst){
					objElement.attr('insertdata', strResult, 'string');
					objElement._hide(heCell, 'api');
				},
				//showButtonPanel: true,
				showAnim : 'fold'
			};
		
		if(this.attr('convert') !== null && this.attr('convert') !== undefined ){
			if(this.attr('convert').type === '999'){
				data = QBOX.util.replaceAll(data,'%','');	
			}else if (QBOX._.isFunction(this.attr('convert').callback)){
				data = this.attr('convert').callback.call(this,nRow,nCol,data);
			}
		}
		
		this.attr('isshow', true, 'boolean');
		//objParent.attr('isdatepicker',true, 'boolean');
		
		// ie에서 addRow등의 API를 통해 새로운 Row를 추가하고 난 뒤 editmode로 같은 col의 input 호출시 value값 초기화
		//QBOX.$(heElement).val(objParent._showDataFormat(nCol, data === undefined ? '' : data));
		
//		if(strEventType === 'keydown'){
//			heElement.value = '';
//		} else{
			heElement.value = strValue;
//		}
		if(this.attr('placeholder') !== undefined && this.attr('placeholder') !== null )
				heElement.placeholder = this.attr('placeholder');
		objParent._showMask(nCol, heElement);
		
		QBOX.$(heElement).css({width:$cell.css('width'), height:$cell.css('height'), left:$cell.css('left'), top:$cell.css('top')});
		
		QBOX.$(heElement).datepicker(options);
		
		$viewportinner.append(heElement);
		heElement.focus();
		heElement.select();
		
		
		
		this.attr('row', nRow, 'number');
		this.attr('col', nCol, 'number');
		this.attr('visible', true, 'boolean');
		this.attr('insertdata', [data], 'array');
		
		objParent._addEditColId(this.attr('colid'));
		
		if(objCellInvisible){
			objParent._setInitCellInvisible(nRow, nCol);
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.Input.prototype._show', e.message);
		return false;
	}
};


QBOX.QCELL.InputDatepicker.prototype._hide = function(heCell, strEventType){
	try{
		if(heCell === null)
			return;		
		
		if(this.attr('isshow') === false && this.attr('parent').attr('oneclickedit') !== true)
			return;
				
		var objParent = this.attr('parent'),
		heElement = this.attr('element'),
		nRow = this.attr('row'),
		nCol = this.attr('col'),
		strValue = heElement.value,
		objFormat = this.attr('format'), fnValdator = this.attr('validator'),
		strDataFormat,i,strDateFormat;	
		
		this.attr('isshow', false, 'boolean');
	
		//if(strEventType === 'keydown'){
		//	strValue = this.attr('insertdata')[0];
		//} else {
			strValue = objParent._showUnMask(nCol, strValue,objFormat);
		//}
		if(objFormat !== undefined){
			strDateFormat = objFormat.rule.toLowerCase();
			strDateFormat = QBOX.util.replaceAll(strDateFormat,'y','');
			strDateFormat = QBOX.util.replaceAll(strDateFormat,'m','');
			strDateFormat = QBOX.util.replaceAll(strDateFormat,'d','');
			
			for(i = 0 ; i <strDateFormat.length ; i++){
				strValue = QBOX.util.replaceAll(strValue,strDateFormat.charAt(i),'');
			}				
		}

		
		if(this.attr('convert') !== null && this.attr('convert') !== undefined){
			if(this.attr('convert').type === '999'){
				strValue = strValue + '%';	
			}else if (QBOX._.isFunction(this.attr('convert').afterCallback)){
				strValue = this.attr('convert').afterCallback.call(this,nRow,nCol,strValue);
			}
		}

		var heParentElement = heElement.parentElement;		
		
		setTimeout(function(){
			var x = 0;

			if(heParentElement === undefined)
				return;
			
			for(x=0; x< heParentElement.childNodes.length; x++){
				if(heElement === heParentElement.childNodes[x]){
					QBOX.$(heElement).datepicker('hide');
					QBOX.$(heElement).datepicker('destroy');
					QBOX.$(heElement).detach();					
					break;
				}					
			}
		},0);
		
		//QBOX.$(heElement).detach();
		
		if(this.attr('exclude') !== undefined && QBOX._.isArray(this.attr('exclude'))){
			
			this.attr('exclude').forEach(function (exData){
				try{
					if(QBOX._.isString(exData))
						strValue = strValue.split(exData).join('');					
				}catch(e){
					QCELL.log('err', 'QCELL.Input.prototype._hide', e.message);
				}
			});			
		}
		
		var bValid = true;
		if(fnValdator){
			bValid = fnValdator(nRow,nCol,strValue);
		}
		
		if(bValid === true){
			if(strValue !== objParent._cellValue(nRow, nCol) ){
				if(strValue === '' && objParent._cellValue(nRow, nCol) === undefined ){
					//아무것도 안하고 그냥 Edit 상태 종료
					if( QBOX._.isObject(objFormat) ) {
						strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
						QBOX.util.textContent(heCell, strDataFormat);
					} else{
						QBOX.util.textContent(heCell, strValue);
					}		
					
				}else{
					//valuechanged 상황
					if(objParent.attr('merge').data === 'none' || QBOX._.isUndefined(objParent.attr('merge').data)){
						if( QBOX._.isObject(objFormat) ) {
							strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
							QBOX.util.textContent(heCell, strDataFormat);
							if(strDataFormat !== 'Invalid date'){
								objParent._cellValue(nRow, nCol, strValue);
							}
						}else{
							objParent._cellValue(nRow, nCol, strValue);	
						}
												
					} else{
						this._changeMergeCellValue(nRow, nCol, strValue, objFormat);
					}
					objParent._processValueChanged(nRow,nCol);
				}

			} else{
				//값이 변경 안되었을 때
				if( QBOX._.isObject(objFormat) ) {
					strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
					QBOX.util.textContent(heCell, strDataFormat);
				} else{
					QBOX.util.textContent(heCell, strValue);
				}
			}			
		}else{
			strValue = objParent._cellValue(nRow, nCol);
			
			if( QBOX._.isObject(objFormat) ) {
				strDataFormat = objParent._showDataFormat(nRow,nCol, strValue === undefined ? '' : strValue);
				QBOX.util.textContent(heCell, strDataFormat);
			} else{
				QBOX.util.textContent(heCell, strValue);
			}			
		}

		//2017-12-15(sai1515): ie8 에서는 container에 focus를 주고 CELL DIV에 focus를 할 필요가 있음.
		if(QBOX.browser.name === 'msie' && QBOX.browser.versionNumber === 8){
			var htElementPool = objParent.attr('elementpool');
			htElementPool.get('$container').focus();
		}
		// ie 에서 화면 틀어지는 버그 수정함.
		if(QBOX.browser.name !== 'msie')
			QBOX.$(objParent._getCellDOM(objParent._idx('row', 'focus', 'current'), objParent._idx('col', 'focus', 'current'))).focus();
		else{
			QBOX.$(heCell).focus();
		}

		this.attr('row', -1, 'number');
		this.attr('col', -1, 'number');
		this.attr('visible', false, 'boolean');
		this.attr('insertdata', [], 'array');
		this.attr('showkey', false, 'boolean');		
		

		//objParent.attr('isdatepicker',false, 'boolean');
		
		objParent._removeEditColId(this.attr('colid'));
		
		return bValid;
	} catch(e){
		QCELL.log('err', 'QCELL.Input.prototype._hide', e.message);
		return false;
	}
};

QBOX.QCELL.NormalQCELL.prototype._beforeFocusCell = function(){
	this.attr('adjustrow',false,'boolean');
	this._hideEditCellsDOM(); 
};
QBOX.QCELL.NormalQCELL.prototype.onKeyDown = function(event){
	try{
		QBOX.QCELL.BasicQCELL.prototype.onKeyDown.call(this, event);
		
		var target = event.target, keyCode = event.keyCode,
		css = QBOX.QCELL.def.css;
		
		if(QBOX.util.hasClass(target, css.TYPE_INPUT_EDIT_STYLE)){
			target =target.parentElement;
		}
		
		if(QBOX.util.hasClass(target, css.CELL)){
			var nRow = parseInt(target.getAttribute('data-row')), nCol = parseInt(target.getAttribute('data-col')),
			nFocusRow = event.data.target._idx('row', 'focus'), nFocusCol = event.data.target._idx('col', 'focus'),
			htGroupState = this.attr('groupstate');		
			
			// 이벤트의 row 정보와 focus의 row 정보가 틀릴 때 focus row 정보로 변경
			if(nRow !== nFocusRow) {
				nRow = nFocusRow;
			}
			
			// 이벤트의 col 정보와 focus의 col 정보가 틀릴 때 focus col 정보로 변경
			if(nCol !== nFocusCol) {
				nCol = nFocusCol;
			}
			
			if(nRow === -1 || nCol === -1)
				return;
			
			var objCellDisabled = this._getQCellCol(nCol).attr('celldisabled')[nRow],
			bColDisabled = this._getQCellCol(nCol).attr('disabled');
			
			objCellDisabled = objCellDisabled ===undefined ? false:objCellDisabled;
			
			// 이벤트의 target정보와 focus cell정보가 틀릴 때 focus cell정보로 변경 
			if(target !== this._getCellDOM(nFocusRow, nFocusCol)){
				target = this._getCellDOM(nFocusRow, nFocusCol);
			}
			
			if(this._getQCellCol(nCol).attr('celldisabled')[nRow] === false)
				bColDisabled = false;
			
			if(htGroupState !== null){
				if(QBOX._.indexOf(htGroupState.headerrows,nRow) !== -1 || QBOX._.indexOf(htGroupState.footerrows,nRow) !== -1){
					bColDisabled = true;
				}
			}
			
			if(nRow >= this.attr('headerrows') && nCol >= this.attr('headercols')){
				var heCell = this._getCellDOM(nRow,nCol);
				if(this._isBottomPanel(heCell))
					return;
				
				
				switch(this._getColType(nCol)){
					 case 'input': case 'textarea': case 'selectmenu': case 'number': case 'inputbutton':case 'inputdatepicker':{
						if(this._getColElement(nCol).attr('visible') === false){
							//keyCode 값에 따른 분기 처리
							switch(keyCode){
								case QBOX.def.key.F2: case QBOX.def.key.SPACE: case QBOX.def.key.BACKSPACE: case QBOX.def.key.ENTER :{
									
									if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
										this._getColElement(nCol).attr('showkey', true, 'boolean');
										this._getColElement(nCol)._show(target, event.type);
									}									

									event.stopPropagation();
									event.preventDefault();									
									break;
								}
								case QBOX.def.key.LEFT: case QBOX.def.key.RIGHT: case QBOX.def.key.UP: case QBOX.def.key.DOWN: {
									this._onScrollHideEditCellsDOM();									
									event.stopPropagation();
									event.preventDefault();									
									break;
								}	
								default: {
									break;
								}
							}
						}
						break;
					}
					case 'datepicker' : {
						switch(keyCode){
							case QBOX.def.key.SPACE: case QBOX.def.key.ENTER :{
								//if(objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
								if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){
									this._getColElement(nCol)._show(target);
								}
								//}
								event.stopPropagation();
								event.preventDefault();								
								break;
							}						
							case QBOX.def.key.LEFT: case QBOX.def.key.RIGHT: case QBOX.def.key.UP: case QBOX.def.key.DOWN: {
								this._onScrollHideEditCellsDOM();	
								event.stopPropagation();
								event.preventDefault();									
								break;
							}
									
							default: {
								break;
							}
						}
						break;
					}						
					case 'checkbox' : {
						switch(keyCode){
							case QBOX.def.key.SPACE: case QBOX.def.key.ENTER :{
								//if(objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
								if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){
									this._getColElement(nCol)._outerClick(nRow, nCol);
								}
								//}
								event.stopPropagation();
								event.preventDefault();								
								break;
							}
							case QBOX.def.key.LEFT: case QBOX.def.key.RIGHT: case QBOX.def.key.UP: case QBOX.def.key.DOWN: {
								event.stopPropagation();
								event.preventDefault();									
								break;
							}							
							default: {
								break;
							}
						}
						break;
					}
					case 'multicheckbox': {
						if(this._getColElement(nCol).attr('visible') === false){
							//keyCode 값에 따른 분기 처리
							switch(keyCode){
								case QBOX.def.key.F2: case QBOX.def.key.SPACE: case QBOX.def.key.BACKSPACE: case QBOX.def.key.ENTER :{
									if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){// celldisabled속성이 false일 때 각 type의 _show() 동작
										this._getColElement(nCol).attr('showkey', true, 'boolean');
										this._getColElement(nCol)._show(target, nRow, nCol);
									}
									event.stopPropagation();
									event.preventDefault();									
									break;
								}
								case QBOX.def.key.LEFT: case QBOX.def.key.RIGHT: case QBOX.def.key.UP: case QBOX.def.key.DOWN: {
									this._onScrollHideEditCellsDOM();									
									event.stopPropagation();
									event.preventDefault();									
									break;
								}	
								default: {
									break;
								}
							}
						}
						break;
					}
					
					default: {
						switch(keyCode){
							case QBOX.def.key.LEFT: case QBOX.def.key.RIGHT: case QBOX.def.key.SPACE: case QBOX.def.key.ENTER : case QBOX.def.key.UP: case QBOX.def.key.DOWN:{
	
								event.stopPropagation();
								event.preventDefault();								
								break;
							}							
							default: {
								break;
							}
						}
						break;
					}
				}
			}
			
			if(QBOX.def.key.DELETE === keyCode) { // delete key를 눌렀을 때 selected된 cell의 데이터 삭제 기능
				var objQCell = this,
				targetDivId = objQCell.attr('parentid'),
				selectedCells ,
				boolDel = false, // QCELL이 존재하는 div내의 selected cells의 정보 추출
				arrCellDisabled,
				colType;
				
				if(this.attr('delkeymode') === 'select'){
					selectedCells= QBOX.$("#"+targetDivId).find("."+css.CELL_SELECT);
					if(selectedCells.length > 0){
						var arrSelectedRow = this._getIdxInfo('selected', 'row').keys(true),
						arrSelectedCol = this._getIdxInfo('selected', 'col').keys(true);
						
						var nStartRow,nEndRow,nStartCol,nEndCol;
						
						if(arrSelectedRow.length === 0){
							nStartRow = this.attr('headerrows');
							nEndRow = this.attr('rows');
						}else{
							nStartRow = arrSelectedRow[0];
							nEndRow = arrSelectedRow[arrSelectedRow.length-1];
						}
						if(arrSelectedCol.length ===0){
							nStartCol = this.attr('headercols');
							nEndCol = this.attr('cols')-1;
						}else{
							nStartCol = arrSelectedCol[0];
							nEndCol = arrSelectedCol[arrSelectedCol.length-1];
						}
						for(var j=nStartCol; j<=nEndCol;j++){
							arrCellDisabled =this._getQCellCol(j).attr('celldisabled');
							colType = this._getQCellCol(j).attr('type');
							for(var i=nStartRow ; i<= nEndRow; i++){
								objCellDisabled = arrCellDisabled[i];
								objCellDisabled = objCellDisabled ===undefined ? false:objCellDisabled;
								
								if(objCellDisabled === true)
									continue;
								
								switch(colType){
								case 'input': 
								case 'textarea': 
								case 'number' :
								case 'inputbutton' :
								case 'datepicker': 
								case 'inputdatepicker':{
									this._cellValue(i, j, '');
									boolDel = true;
									break;
								}
			
								default: {
									break;
								}
							}
								
							}
						}					
						
					}
				}else if (this.attr('delkeymode') === 'focus') {
					nRow = this.getIdx('row');
					nCol = this.getIdx('col');
					
					if(nRow !== -1 && nCol !== -1){
						arrCellDisabled =this._getQCellCol(nCol).attr('celldisabled');
						colType = this._getQCellCol(nCol).attr('type');
						
						objCellDisabled = arrCellDisabled[nRow];
						objCellDisabled = objCellDisabled ===undefined ? false:objCellDisabled;
						
						if(objCellDisabled === true)
							return;
						
						switch(colType){
							case 'input': 
							case 'textarea': 
							case 'number' :
							case 'inputbutton' :
							case 'datepicker': 
							case 'inputdatepicker':{
								this._cellValue(nRow, nCol, '');
								boolDel = true;
								break;
							}
		
							default: {
								break;
							}
						}

					}	
				}				
				if(boolDel){
					this._processValueChanged(nRow,nCol);
				}
			}
			
		}
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onKeyDown', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype.onMouseWheel = function(event){
	this._onScrollHideEditCellsDOM();
	QBOX.QCELL.BasicQCELL.prototype.onMouseWheel.call(this, event);	
	//this._hideEditCellsDOM();

};

QBOX.QCELL.NormalQCELL.prototype.onMouseDown = function(event){
	try{
		QBOX.QCELL.BasicQCELL.prototype.onMouseDown.call(this, event);

	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onMouseDown', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype.onDblClick = function(event){
	try{
		var target = event.target,tempElement = target,
		css = QBOX.QCELL.def.css,nCol,nRow,bRet = false;
		
		do{
			if(QBOX.util.hasClass(tempElement, css.CELL)){
				nCol = parseInt(tempElement.getAttribute('data-col'));
				nRow = parseInt(tempElement.getAttribute('data-row'));
				
				if(QBOX._.isNumber(nCol) && QBOX._.isNumber(nRow)){
					this._updateIdx('dblclick', nRow, nCol);
					bRet = true;
					break;
				}
			}
			
			tempElement = tempElement.parentElement;
			
		}while(tempElement !== null);
		
		if(bRet === false){
			this._updateIdx('dblclick', -1, -1);
		}
		
		if(QBOX.util.hasClass(target, css.CELL)){
			if(QBOX.util.hasClass(target, css.CELL_VIEWPORT)){
				nCol = parseInt(target.getAttribute('data-col'));
				nRow = parseInt(target.getAttribute('data-row'));
				var nRightColOfScreen = this._getRightColOfScreen(),
				nLeftColOfScreen = this._getLeftColOfScreen(),
				objCellDisabled = this._getQCellCol(nCol).attr('celldisabled')[nRow],
				bColDisabled = this._getQCellCol(nCol).attr('disabled'),
				nCols = this.attr('cols'),htGroupState = this.attr('groupstate'),
				bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false;
				
				
				if(this._isBottomPanel(target))
					return;

				
				if(QBOX.util.isMobile()){
					this._setInputformData(nRow);
					event.stopPropagation();
					event.preventDefault();
					return;
				}
				
				if(this._getQCellCol(nCol).attr('celldisabled')[nRow] === false)
					bColDisabled = false;
				
				if(htGroupState !== null){
					if(QBOX._.indexOf(htGroupState.headerrows,nRow) !== -1 || QBOX._.indexOf(htGroupState.footerrows,nRow) !== -1){
						bColDisabled = true;
					}
				}
				var THAT = this;

				if(bColDisabled !== true){
					if( nCol >= nRightColOfScreen || nCol <=nLeftColOfScreen){				

						

						setTimeout(function(){
							// dblclick을 느리게 했을 때 Layout 깨지는 현상 수정
							if(THAT._idx('col', 'focus') !== nCol)
								return;
							
							switch(THAT._getColType(nCol)){
								case 'input': case 'textarea': case 'selectmenu': case 'number': case 'slider':  case 'inputbutton': case 'inputdatepicker':{
									if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
										THAT._getColElement(nCol)._show(target, event.type);
									}
									break;
								}
								case 'datepicker':{
									if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
										THAT._getColElement(nCol)._show(target);
									}
									break;
								}
								case 'multicheckbox': case 'editor': {
									if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
										THAT._getColElement(nCol)._show(target, nRow, nCol);
									}
									break;
								}
								default: {
									break;
								}
							}
						},200);
							
						return;

					}
					
					if(this.attr('useall') || this.attr('usetreeall')){
						if( nCol <= nRightColOfScreen || nCol >=nLeftColOfScreen){				



						setTimeout(function(){
							// dblclick을 느리게 했을 때 Layout 깨지는 현상 수정
							if(THAT._idx('col', 'focus') !== nCol)
								return;
							
							switch(THAT._getColType(nCol)){
								case 'input': case 'textarea': case 'selectmenu': case 'number': case 'slider':  case 'inputbutton': case 'inputdatepicker':{
									if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
										THAT._getColElement(nCol)._show(target, event.type);
									}
									break;
								}
								case 'datepicker':{
									if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
										THAT._getColElement(nCol)._show(target);
									}
									break;
								}
								case 'multicheckbox': case 'editor': {
									if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
										THAT._getColElement(nCol)._show(target, nRow, nCol);
									}
									break;
								}
								default: {
									break;
								}
							}
						},200);
							
						return;

					}
					}
					
					if(this.attr('oneclickedit') === false && this.attr('adjustrow') === false && this.attr('adjustcol') === false){
						switch(this._getColType(nCol)){
							case 'input': case 'textarea': case 'selectmenu': case 'number': case 'slider': case 'datepicker': case 'inputbutton' :case 'inputdatepicker':{
								if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
									this._getColElement(nCol)._show(target, event.type);
								}
								break;
							}
							/*
							case 'datepicker':  {
								if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
									this._getColElement(nCol)._show(target);
								}
								break;
							}
							*/
							case 'multicheckbox': case 'editor': {
								if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
									this._getColElement(nCol)._show(target, nRow, nCol);
								}
								break;
							}
							default: {
								break;
							}
						}
					}					
				}				
				

			}
		}
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onDblClick', e.message);
	}
};
QBOX.QCELL.NormalQCELL.prototype._getRowFromTarget = function(target){
	var ret;
	do{
		ret = parseInt(target.getAttribute('data-row'));
		if(!isNaN(ret))
			return ret;
		
		target = target.parentNode;
	}while(target !== null);
	return -1;
};
QBOX.QCELL.NormalQCELL.prototype._getColFromTarget = function(target){
	var ret;
	do{
		ret = parseInt(target.getAttribute('data-col'));
		if(!isNaN(ret))
			return ret;
		
		target = target.parentNode;
	}while(target !== null);
	return -1;
};

QBOX.QCELL.NormalQCELL.prototype.onClick = function(event){
	try{
		QBOX.QCELL.BasicQCELL.prototype.onClick.call(this, event);
		
		var target = event.target,		
		css = QBOX.QCELL.def.css,THAT = this,nRow,nCol;
		
		
		// onMouseDown 에서 onClick 으로 위치 이동 단 scroll 이동일때는 동작 아함.
		if(this.attr('isscrollleft') === false){
			if( (QBOX.util.hasClass(target, css.CELL) || QBOX.util.hasClass(target, css.VIEWPORT_INNER)|| QBOX.util.hasClass(target, css.TYPE_DATEPICKER)) ){
				this._hideEditCellsDOM();
			}
		}
		
		if(QBOX.util.hasClass(target, css.CELL) || QBOX.util.hasClass(target, css.TYPE_DATEPICKER)||
				QBOX.util.hasClass(target, css.TYPE_INPUT_EDIT_STYLE)	){ // data 영역
			nRow = this._getRowFromTarget(target);
			nCol = this._getColFromTarget(target);
			
			var objCellDisabled = this._getQCellCol(nCol).attr('celldisabled')[nRow],
			bColDisabled = this._getQCellCol(nCol).attr('disabled'),htGroupState = this.attr('groupstate'),
			bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false;
			
			if(this._isBottomPanel(target))
				return;


			
			if(QBOX.util.isMobile()){
				event.stopPropagation();
				event.preventDefault();
				return;
			}
			
			if(objCellDisabled === false)
				bColDisabled = false;
			
			if(htGroupState !== null){
				if(QBOX._.indexOf(htGroupState.headerrows,nRow) !== -1 || QBOX._.indexOf(htGroupState.footerrows,nRow) !== -1){
					bColDisabled = true;
				}
			}
			
			if(bColDisabled !== true){
				this._updateIdx('dblclick', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
				
				if(QBOX.util.hasClass(target, css.TYPE_DATEPICKER)){
					if(QBOX.util.hasClass(target.parentNode, css.CELL)){
						target = target.parentNode;
					}else if(QBOX.util.hasClass(target.parentNode.parentNode, css.CELL)){
						target = target.parentNode.parentNode;
					}
				}
				
				if(QBOX.util.hasClass(target, css.TYPE_INPUT_EDIT_STYLE)){
					if(QBOX.util.hasClass(target.parentNode, css.CELL)){
						target = target.parentNode;
					}
				}
				
				objCellDisabled = objCellDisabled ===undefined ? false:objCellDisabled;
				if(QBOX.util.hasClass(target, css.CELL_VIEWPORT)){
					// scroll 이동시에는 동작 안하도록 수정

					setTimeout(function(){
					if(THAT.attr('isscrollleft') === false && THAT.attr('oneclickedit') && THAT.attr('adjustrow') === false && THAT.attr('adjustcol') === false){
						THAT._hideEditCellsDOM();
						switch(THAT._getColType(nCol)){
							case 'input': case 'textarea': case 'selectmenu': case 'number': case 'slider': case 'inputbutton' : case 'inputdatepicker':{
								if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
									THAT._getColElement(nCol)._show(target, event.type);
								}
								break;
							}
							case 'datepicker':{
								if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
									THAT._getColElement(nCol)._show(target);
								}
								break;
							}
							case 'multicheckbox': case 'editor': {
								if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
									THAT._getColElement(nCol)._show(target, nRow, nCol);
								}
								break;
							}
							default: {
								break;
							}
						}
					}
					THAT.attr('isscrollleft',false,'boolean');
					switch(THAT._getColType(nCol)){
						case 'checkbox': case 'image': case 'button': {
							if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
								THAT._getColElement(nCol)._outerClick(nRow, nCol);
							}
							break;
						}
						/*
						case 'datepicker':{
							this._focusCell(target);
							this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
							
							break;
						}
						*/
						default: {
							break;
						}
					}
					},200);
				} else if(QBOX.util.hasClass(target, css.CELL_COLHEADER) ){ // header 영역
					if(event.which === QBOX.def.which.LEFT_BUTTON){
						switch(this._getColType(nCol)){
							case 'checkbox': {
								this._getColElement(nCol)._outerClick(nRow, nCol);
								break;
							}
							default: {
								break;
							}
						}
					}
				}				
			}

		} else if(QBOX.util.hasClass(target, css.COLHEADER_AREA)){
			nRow = target.parentNode.getAttribute('data-row');
			nCol = target.parentNode.getAttribute('data-col');
			
			this._updateIdx('click', Number(nRow), Number(nCol));
			//this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
		} else{
			this._updateIdx('dblclick', -1, -1);
		}
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onClick', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype.onMouseEnter = function(event){
	try{
		QBOX.$(document).off('mousedown.' + this.attr('id'));
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onMouseEnter', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype.onMouseLeave = function(event){
	try{
		//2018-06-14(sai1515): 필터UI창의 그리드의 경우 아래의 document 이벤트 바인드 하지 않도록 처리.
		if(this.attr('id') === 'filter-dataindex'){
			return false;
		}
		var bFlag = false;
		QBOX.$(document).bind('mousedown.' + this.attr('id'), {target : this}, function(evt){
			//2018-01-14(sai1515): selectmenu 사용시 item ui가 그리드 바깥 영역에 생성되므로, selectmenu item 영역 클릭시 _hideEditCellsDOM() 함수가 동작되지 않도록 분기 처리.
			//2018-03-28(sai1515): datepicker 컬럼 달력의 ui도 selectmenu와 같은 이유로 인해 조건 추가.
			if((QBOX.util.hasClass(evt.target, 'rt-qc-ui-widget') || QBOX.util.hasClass(evt.target, 'rt-qc-ui-menu-item-wrapper') ||
					QBOX.util.hasClass(evt.target.parentNode, 'rt-qc-ui-datepicker-year') ||
					QBOX.util.hasClass(evt.target.parentNode, 'rt-qc-ui-datepicker-month') ||
					QBOX.util.hasClass(evt.target.parentNode, 'rt-qc-ui-selectmenu') || 
					QBOX.util.hasClass(evt.target.parentNode, 'rt-qc-input-text-style'))  === false){
				var objQCell = evt.data.target;
				objQCell._hideEditCellsDOM();
				QBOX.$(this).unbind(evt);
			}
		});
		
		if(QBOX.util.hasClass(event.target, QBOX.QCELL.def.css.CELL_COLHEADER)){
			this._onScrollHideEditCellsDOM();
			return;
		}
		
		// QCELL영역 밖으로 나갔을 때 모든 editmode 종료, selectmenu에서 마우스 움직일 때 mouseleave 이벤트 방지
		if((QBOX.util.hasClass(event.target, 'rt-qc-ui-widget')  || QBOX.util.hasClass(event.target, QBOX.QCELL.def.css.VIEWPORT) ||
				QBOX.util.hasClass(event.target, QBOX.QCELL.def.css.CELL) ||								
				QBOX.util.hasClass(event.target, 'rt-qc-ui-selectmenu-text') || 
				QBOX.util.hasClass(event.target, 'rt-qc-selectmenu-wrap-style') ||
				QBOX.util.hasClass(event.target, 'rt-qc-input-text-style')	)  === false){
			
			if(this.attr('isdatepicker') === true && QBOX.util.hasClass(event.target, 'hasDatepicker'))
				return;
			
			this._onScrollHideEditCellsDOM();
			bFlag	 = true;
		}		
		
		// selectmenu 제외
		if( (((QBOX.util.hasClass(event.target, QBOX.QCELL.def.css.CELL) || QBOX.util.hasClass(event.target, 'rt-qc-input-text-style')) ||
				event.target.className.indexOf('selectmenu') > -1) &&
				event.toElement !== null &&
				((QBOX.util.hasClass(event.toElement.parentNode, 'rt-qc-ui-selectmenu-menu') ||
				 QBOX.$(event.toElement).is('div') || QBOX.$(event.toElement).is('li')) ) ) === false ){
			if(QCELL.config.htmlselectmenu === false)
			this._onScrollHideEditCellsDOM();
			bFlag	 = true;
		}
		
		if(bFlag === false){
			var nFR = this._getIdxInfo('focus','row').current , nFC = this._getIdxInfo('focus','col').current;
			
			if(nFR !== undefined && nFC !== undefined && nFR !== -1 && nFC !==-1){
				var strColType = this._getColType(nFC);
				if(strColType === 'selectmenu' &&
					!QBOX.util.hasClass(event.target, 'rt-qc-ui-selectmenu-button') && !QBOX.util.hasClass(event.target, 'rt-qc-cell') &&
						!QBOX.util.hasClass(event.target, 'rt-qc-ui-selectmenu-text')){
					
//					 rt-qc-ui-button rt-qc-ui-widget rt-qc-ui-selectmenu-button-open rt-qc-ui-corner-top
					this._onScrollHideEditCellsDOM();
				}
			}
		}		
		
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onMouseLeave', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype.onMouseMove = function(event){
	try{
		QBOX.QCELL.BasicQCELL.prototype.onMouseMove.call(this, event);
		
		var css = QBOX.QCELL.def.css,
		target = event.target,
		nRow = -1, nCol = -1,
		heTargetParent = target.parentNode;
		
		//event.stopPropagation();//QCELL에서 "mousemove" 이벤트 발생 시 window에 건 mousemove가 동작되지 않도록 제어
		
		if(QBOX.util.hasClass(heTargetParent, css.CELL) ){//target이 셀인 경우에만
			nRow = parseInt(heTargetParent.getAttribute('data-row'));
			nCol = parseInt(heTargetParent.getAttribute('data-col'));
			
			if(this._idx('row', 'cursor') != nRow || this._idx('col', 'cursor') != nCol){
				this._updateIdx('cursor', nRow, nCol);//cursor 인덱스를 갱신
				
				if(event.buttons !== 0 && event.which === QBOX.def.which.LEFT_BUTTON && this.attr('mousedown')){//drag 이벤트 발생
					this.onDrag(event);
				}
			}
		}
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onMouseMove', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype.onDrag = function(event){
	try{
		QBOX.QCELL.BasicQCELL.prototype.onDrag.call(this, event);
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onDrag', e.message);
	}
};

/*
QBOX.QCELL.NormalQCELL.prototype.onMouseUp = function(event){
	try{
		QBOX.QCELL.BasicQCELL.prototype.onMouseUp.call(this, event);
		
		var def = QBOX.QCELL.def, strID = this.attr('id'),
		spanId = '#'+def.areaname.SHEETPANEL + '-span-' + strID,
		rows = this.getSelectedRows(), cols = this.getSelectedCols(),
		nRow = -1, nCol = -1;
		
		console.log(rows);
		console.log(cols);
		if(rows.length === 1 && cols.length === 1){
			nRow = rows[0];
			nCol = cols[0];
			
			console.log('click??' + nRow, nCol);
			var val = this._cellValue(nRow, nCol);
			console.log(val);
			QBOX.$(spanId).html(val);
		}
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onMouseUp', e.message);
	}
};
*/
QBOX.QCELL.NormalQCELL.prototype._callButtonclickCallback = function(){
	if(this.attr('buttonclickcallback') !== null && QBOX._.isFunction(this.attr('buttonclickcallback'))){
		
		this._updateIdx('click', this._idx('row', 'cursor'), this._idx('col', 'cursor'));
		var objEvent = {type:'buttonclick', data : this.attr('eventparam_buttonclick')=== null ? {}:this.attr('eventparam_buttonclick')};
		objEvent.data.target = this;
		this.attr('buttonclickcallback').call(this,objEvent);
	}
};

QBOX.QCELL.NormalQCELL.prototype.onResize = function(event){
	try{
		this._onScrollHideEditCellsDOM();
		QBOX.QCELL.BasicQCELL.prototype.onResize.call(this, event);

	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL.onResize', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype._getColElement = function(nCol){
	return this.attr('qcellcols')[nCol].attr('colelement');
};
QBOX.QCELL.NormalQCELL.prototype._getColTitlekey = function(nCol){
	var elem =this.attr('qcellcols')[nCol].attr('colelement');
	return elem !== null ? elem.titlekey : undefined;
};
QBOX.QCELL.NormalQCELL.prototype._getColType = function(nCol){
	return this.attr('qcellcols')[nCol] === undefined ? "static" : this.attr('qcellcols')[nCol].attr('type');
};

QBOX.QCELL.NormalQCELL.prototype._getColHtml = function(nCol){
	return this.attr('qcellcols')[nCol].attr('html');
};
QBOX.QCELL.NormalQCELL.prototype._getColChart = function(nCol){
	return this.attr('qcellcols')[nCol].attr('chart');
};
QBOX.QCELL.NormalQCELL.prototype._getColDisabled = function(nCol){
	return this.attr('qcellcols')[nCol].attr('disabled');
};
QBOX.QCELL.NormalQCELL.prototype._getColMask = function(nCol){
	return this.attr('qcellcols')[nCol].attr('mask');
};
QBOX.QCELL.NormalQCELL.prototype._getColDatatype = function(nCol){
	return this.attr('qcellcols')[nCol].attr('datatype');
};
QBOX.QCELL.NormalQCELL.prototype._getColFneditor= function(nCol){
	return this.attr('qcellcols')[nCol].attr('fneditor');
};

QBOX.QCELL.NormalQCELL.prototype._hideEditCellsDOM = function(){
	var arrEditColIds = this.attr('editcolids');
	//console.log("_hideEditCellsDOM : " + arrEditColIds.length );
	if(arrEditColIds.length > 0){
		var heCell, objColElement;
		this.attr('hideedit', true, 'boolean');
		for(var i = 0; i < arrEditColIds.length; i++){
			objColElement = this._getColElement(this.attr('colidsinfo')[arrEditColIds[i]]);
			heCell = this._getCellDOM(objColElement.attr('row'), objColElement.attr('col'));
			
			// column의 type이 multicheckbox일 때 blur와 같은 이벤트 발생시 현재 데이터 저장
			if(this._getColType(this.attr('colidsinfo')[arrEditColIds[i]]) == 'multicheckbox'){
				objColElement._setMultiCheckboxCellData(objColElement.attr('element'));
			}
			else if(this._getColType(this.attr('colidsinfo')[arrEditColIds[i]]) == 'editor'){
				objColElement._hide(heCell, 'api');
			}
			
			// browser가 ie나 ieedge일 때 col type이 datepicker일 때 chageyear, chagemonth 동작시킬 때 datepicker destroy되는 사항 방지
			// arrEditColsIds에 존재하는 row나 col 정보가 현재 focus row와 col, 둘 중 하나라도 같지 않을 때 동작
			if( (QBOX.browser.name === 'msie' || QBOX.browser.name === 'msedge') && ((objColElement.attr('row') != this._idx('row', 'focus')) || (objColElement.attr('col') != this._idx('col', 'focus'))) ){
				objColElement._hide(heCell, 'api');
			}
			else if(((objColElement.attr('row') != this._idx('row', 'focus')) || (objColElement.attr('col') != this._idx('col', 'focus')))){
				objColElement._hide(heCell, 'api');
			}
		}
		
		heCell = objColElement = null;
	}
	this._removeTooltip();
	this.attr('hideedit', false, 'boolean');	
};

QBOX.QCELL.NormalQCELL.prototype._onScrollHideEditCellsDOM = function(){
	var arrEditColIds = this.attr('editcolids');
	
	//console.log("_onScrollHideEditCellsDOM : " + arrEditColIds.length );
	
	if(arrEditColIds.length > 0){
		var heCell, objColElement;
		this.attr('hideedit', true, 'boolean');	
		for(var i = 0; i < arrEditColIds.length; i++){
			objColElement = this._getColElement(this.attr('colidsinfo')[arrEditColIds[i]]);
			heCell = this._getCellDOM(objColElement.attr('row'), objColElement.attr('col'));
			
			objColElement._hide(heCell, 'api');
		}
		
		heCell = objColElement = null;
	}
	this._removeTooltip();
	this.attr('hideedit', false, 'boolean');	
};
QBOX.QCELL.NormalQCELL.prototype._isValidEditColId = function(strColId){
	var arrEditColIds = this.attr('editcolids'),i;
	
	for(i=0; i<arrEditColIds.length;i++){
		if(arrEditColIds[i] === strColId){
			return true;
		}
	}
	return false;
};
//2017-12-28(sai1515): 현재 edit 상태인 컬럼의 id 들이 모여있는  저장소 'editcolids'에 해당 컬럼id 추가.
QBOX.QCELL.NormalQCELL.prototype._addEditColId = function(strColId){
	var arrEditColIds = this.attr('editcolids');
	
	arrEditColIds.push(strColId);
	arrEditColIds = QBOX._.uniq(arrEditColIds);
	this.attr('editcolids', arrEditColIds, 'array');
};
//2017-12-28(sai1515): 현재 edit 상태인 컬럼의 id 들이 모여있는  저장소 'editcolids'에서 해당 컬럼id 제거.
QBOX.QCELL.NormalQCELL.prototype._removeEditColId = function(strColId){
	var arrEditColIds = this.attr('editcolids');
	
	arrEditColIds = QBOX._.without(arrEditColIds, strColId);
	this.attr('editcolids', arrEditColIds, 'array');
};

QBOX.QCELL.NormalQCELL.prototype._showMask = function(nCol, heElement) {
	try {
		var heMask = this._getColMask(nCol);
		if( !(QBOX._.isUndefined(heMask)) && QBOX._.isObject(heMask) ) {
			if(heMask.alias === 'currency'){
				var obj = {};
				obj.alias = 'currency';				
				obj.prefix = heMask.prefix === undefined ? '' : heMask.prefix;
				obj.digits = heMask.digits === undefined ? 0 : heMask.digits;
				
				QBOX.$(heElement).inputmask(obj);				
			}else{
				QBOX.$(heElement).inputmask({'mask':heMask.alias});
			}


		}
		return true;
	} catch (e) {
		QCELL.log('err', 'QCELL.NormalQCELL._showMask', e.message);
		return false;
	}
};

QBOX.QCELL.NormalQCELL.prototype._showUnMask = function(nCol, strValue,objFormat) {
	var strVal = strValue; 
	try {
		var heMask = this._getColMask(nCol);
		if( !(QBOX._.isUndefined(heMask)) && QBOX._.isObject(heMask) ) {
			if(heMask.alias === 'currency'){
				var obj = {};
				obj.alias = 'currency';				
				obj.prefix = heMask.prefix === undefined ? '' : heMask.prefix;
				obj.digits = heMask.digits === undefined ? 0 : heMask.digits;
				strVal = Inputmask.unmask(strVal, obj);
				return strVal;
			}
			if(QBOX._.isObject(objFormat) && objFormat.type === 'number' && heMask.alias.indexOf('.') !== -1){
				var arrData = strValue.split('.');
				strVal = '';
				for(var i=0;i<arrData.length;i++){
					if(strVal !== ''){
						strVal = strVal + '.';
					}
					strVal = strVal + (Inputmask.unmask(arrData[i], {alias: heMask.alias}) === null ? '0' : Inputmask.unmask(arrData[i], {alias: heMask.alias}));
				}
			}else{
				strVal = Inputmask.unmask(strVal, {alias: heMask.alias});
			}
			
			
			if(strVal === null || strVal === "null") {
				strVal = "";
			}
		}
	} catch (e) {
		QCELL.log('err', 'QCELL.NormalQCELL._showUnMask', e.message);
		strVal = strValue;
	}
	return strVal;
};
QBOX.QCELL.NormalQCELL.prototype._moveCols = function(nBeforeCol, nCount, nAfterCol, /*컬럼의 move속성을 체크하지 않고 강제로 이동시키기 위한 옵션*/bForce){
	this._onScrollHideEditCellsDOM();
	QBOX.QCELL.BasicQCELL.prototype._moveCols.call(this, nBeforeCol, nCount, nAfterCol, /*컬럼의 move속성을 체크하지 않고 강제로 이동시키기 위한 옵션*/bForce);	
};
QBOX.QCELL.NormalQCELL.prototype._setColWidth = function(nCol, nColWidth){
	this._onScrollHideEditCellsDOM();
	QBOX.QCELL.BasicQCELL.prototype._setColWidth.call(this, nCol, nColWidth);
};
QBOX.QCELL.NormalQCELL.prototype._editcell = function(nRow,nCol){
	var objCellDisabled = this._getQCellCol(nCol).attr('celldisabled')[nRow],
	bColDisabled = this._getQCellCol(nCol).attr('disabled'),htGroupState = this.attr('groupstate');
	
	if(bColDisabled === true || objCellDisabled)
		return;
	
	var target = this._getCellDOM(nRow,nCol);
	
	if(target !== null){
		if(this._isBottomPanel( target ))
			return;
		
		this._hideEditCellsDOM();
		switch(this._getColType(nCol)){
			case 'input': case 'textarea': case 'selectmenu': case 'number': case 'slider': case 'inputbutton' : case 'inputdatepicker':{
				if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
					this._getColElement(nCol).attr('showkey', true, 'boolean');
					this._getColElement(nCol)._show(target, '');
				}
				break;
			}
			case 'datepicker':{
				if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
					this._getColElement(nCol)._show(target);
				}
				break;
			}
			case 'multicheckbox': case 'editor': {
				if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
					this._getColElement(nCol)._show(target, nRow, nCol);
				}
				break;
			}
			default: {
				break;
			}
		}
		
		switch(this._getColType(nCol)){
			case 'checkbox': case 'image': case 'button': {
				if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
					this._getColElement(nCol)._outerClick(nRow, nCol);
				}
				break;
			}
			default: {
				break;
			}
		}	
		
	}
	
	
};
/*
QBOX.QCELL.BasicQCELL.prototype._showHeaderRenderer = function(heCell, nRow, nCol, cellData) {
	if( QBOX._.isFunction(this._getColHtml(nCol).header) ) {
		var hData = this._getColHtml(nCol).header(this.attr('id'), nRow, nCol, cellData);
		if( QBOX._.isString(hData) ) {
			heCell.innerHTML = hData;
		}
	} else {
		QBOX.util.textContent(heCell, cellData);
	}
};

QBOX.QCELL.BasicQCELL.prototype._showDataRenderer = function(heCell, nRow, nCol, cellData) {
	if( QBOX._.isFunction(this._getColHtml(nCol).data) ) {
		var vData = this._getColHtml(nCol).data(this.attr('id'), nRow, nCol, cellData, QBOX._.clone(this.attr('currentdata')[nRow - this.attr('headerrows')]));
		if( QBOX._.isString(vData) ) {
			heCell.innerHTML = vData;
		}
		
		if( QBOX._.isFunction(this._getColHtml(nCol).datacallback) ) {
			this._getColHtml(nCol).datacallback(this.attr('id'), nRow, nCol, cellData, QBOX._.clone(this.attr('currentdata')[nRow - this.attr('headerrows')]));
		}
	} else {
		QBOX.util.textContent(heCell, cellData);
	}
};
*/

QBOX.QCELL.NormalQCELL.prototype._createCols = function(){
	return QBOX.QCELL.BasicQCELL.prototype._createCols.call(this);
};

QBOX.QCELL.NormalQCELL.prototype._createHeaderCol = function(colprops){
	try{
		return QBOX.QCELL.NormalQCELL.QCellCol.create(QBOX._.extend(QBOX._.clone(colprops), {
			parent		: this,
			id			: 'col_' + this.attr('qcellcols').length,
			width		: this.attr('headercolwidth') + 'px',
			move		: false
		}));
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._createHeaderCol', e.message);
		return null;
	}
};

QBOX.QCELL.NormalQCELL.prototype._createCol = function(col, colprops){
	try{
		return QBOX.QCELL.NormalQCELL.QCellCol.create(col, QBOX._.extend(QBOX._.clone(colprops), {
			parent		: this,
			id			: 'col_' + this.attr('qcellcols').length
		}));
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._createCol', e.message);
		return null;
	}
};

QBOX.QCELL.NormalQCELL.prototype._createColHeaderCells = function(heDiv){
	try{
		var objHSInfo = this.attr('hsinfo'), css = QBOX.QCELL.def.css,
		htElementPool = this.attr('elementpool'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nHeaderRowHeight = this.attr('rowheight').header,
		arrRowCellMatrix = this.attr('cellmatrix').get('row'),
		arrQCellCols = this.attr('qcellcols'), arrHeaderText = this.attr('headertext'),
		heColHeaderInner = htElementPool.get('colheaderinner'),
		nGap = QBOX.browser.name === 'msie' ? 0 : 2,strId= this.attr('id'),bTab;
		
		for(var i = 0; i < nHeaderRows; i++){
			var nBeforeCellWidth = 0, nRow = i,
			staticrowsinfo = this.attr('staticrowsinfo');
			
			if(arrRowCellMatrix[i] === undefined){//rowheader를 설정하지 않는 경우에는 현재 행에 표시될 셀들의 정보를 담을 배열을 추가해야 한다.
				arrRowCellMatrix.push([]);
			}
			
			for(var j = 0; j < objHSInfo.nDynamicCols; j++){
				var heCell = this._createCell(heDiv),
				nCol = j + nHeaderCols,
				nColWidth = this._getColWidth(nCol),
				strColType = this._getColType(nCol),
				objColStyle = this._getQCellCol(nCol).attr('style');
				
				heCell.setAttribute('data-row', nRow);
				heCell.setAttribute('data-col', nCol);
				heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
				heCell.style.width = nColWidth + 'px';
				heCell.style.height = nHeaderRowHeight + 'px';
				//heCell.style.lineHeight = (nHeaderRowHeight - nGap) + 'px';
			
				heCell.style.display = 'flex';
				heCell.style.justifyContent = 'center';
				heCell.style.alignItems = 'center';
				
				heCell.style.left = nBeforeCellWidth + 'px';
				heCell.style.top = (nHeaderRowHeight * i) + 'px';
				heCell.className += ' ' + css.CELL_COLHEADER + ' ' + css.CELL_HEADERROWS + ' ' + (j < nFrozenCols ? css.CELL_FROZENCOLS : css.CELL_NORMALCOLS) + ' ' + this._getColStyleClassName(nCol, 'header') + ' ' + css.COLHEADER_AREA;
				
				if(!QBOX._.isEmpty(objColStyle)){
					if(QBOX._.isObject(objColStyle.header)){
						var keys = Object.keys(objColStyle.header);
						for(var k = 0; k < keys.length; k++){
							QBOX.$(heCell).css(keys[k], objColStyle.header[keys[k]]);
						}
					}
					this.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
				}
				
				var strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow];
				
				if(strColType === 'checkbox' || strColType === 'html') {
					if(strColType === 'checkbox'){
						heCell.className += ' ' + css.COLHEADER_CELL_CHECKBOX + ' ' + css.COLHEADER_AREA;
					}else{
						if(this.attr('useall') || this.attr('usetreeall')){
							heCell.setAttribute('aria-hidden' , 'true');
						}
					}
					this._getColElement(nCol)._headershow(heCell, nRow, nCol);
					/*
					if(this._getQCellCol(nCol).attr('sort') === false) {
						this._getColElement(nCol)._headershow(heCell, nRow, nCol);
					} else {
						QCELL.log('err', 'QCELL.NormalQCELL._createColHeaderCells', 'can not use "sort" to col type "checkbox" or "html"');
						return false;
					}
					*/
				} else{ // type checkbox, html 이외 text출력
					heCell.innerHTML = this._getHeaderCellSpan(strHeaderCellText,nRow,nCol);
					
					if(this.attr('useall') || this.attr('usetreeall')){
						heCell.setAttribute('aria-hidden' , 'true');
					}
					
					if(nRow === nHeaderRows - 1 || this._isLastHeaderRowMasterCell(nRow, nCol)){
						if(this.attr('useGroupUI')){
							QBOX.$(heCell).draggable({
								helper: this._setGroupMakeHelper,
								revert: 'invalid'
							});
						}
					}
				}
				
				if(nRow === nHeaderRows - 1 || this._isLastHeaderRowMasterCell(nRow, nCol)){
					if(this._getQCellCol(nCol).attr('move')){							
						heCell.appendChild(this._getColHeaderDragDropArea());
					}
					
					if(this._getQCellCol(nCol).attr('search')){						
						heCell.appendChild(this._getColSearchArea());
					}
					
					if(this._getQCellCol(nCol).attr('sort') && (QBOX._.isUndefined(this._getQCellCol(nCol).attr('options').wholeselect) || this._getQCellCol(nCol).attr('options').wholeselect === false) && (strColType !== 'checkbox' || this.attr('paginationinfo').totalsort === false || (QBOX._.isUndefined(this.attr('paginationinfo')) === false && QBOX._.isUndefined(this.attr('paginationinfo').url)))){						
						heCell.appendChild(this._getDefaultSortArea(nCol));
					}
					
					if(this._getQCellCol(nCol).attr('resize')){
						heCell.appendChild(this._getColResizeArea());
					}
					
					if(this._getQCellCol(nCol).attr('filter')){						
						heCell.appendChild(this._getFilterArea(nCol));
					}
					
					if(this._getQCellCol(nCol).attr('editor')){
						heCell.appendChild(this._getColStyleEditorArea());
					}
					
					if(this._getQCellCol(nCol).attr('remove')){
						heCell.appendChild(this._getDefaultRemoveArea(nCol));
						this.attr('useRemoveUI',true, 'boolean');
					}
				}
				
				heColHeaderInner.appendChild(heCell);
				
				arrRowCellMatrix[i].push(heCell);
				
				nBeforeCellWidth += parseFloat(nColWidth);
			}
		}
		this._createDataIndexPool();
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._createColHeaderCells', e.message);
		return false;
	}
};
QBOX.QCELL.NormalQCELL.prototype._getTitleHeader = function(nCol){
	var strHeader = this._cellValue(0,nCol);
	
	var subHeader = '';
	for(var i=1; i < this.getRows('header') ; i++){
		if(subHeader !== '')
			subHeader += ',';
		
		var strTemp = this._cellValue(i,nCol) === undefined ? '' : this._cellValue(i,nCol);
		
		subHeader = subHeader + strTemp;
	}
	
	if(subHeader !== ''){
		subHeader = '( ' + subHeader + ' )';
	}
	
	return strHeader + subHeader;
	
};
QBOX.QCELL.NormalQCELL.prototype._getTitlekey = function(heCell,nRow,nCol,bUp){
	if(nRow < this.attr('headerrows'))
		return;
	
	var objTitlekey = this._getColTitlekey(nCol),css = QBOX.QCELL.def.css,strTitle,	strHeader,nHR = this.getRows('header');
	var strUp = bUp !== true ? ' 수정' : '';
	nHR--;
	
	if(objTitlekey !== null && objTitlekey !==undefined && QBOX._.isFunction(objTitlekey) === true){
		var objData = this.getRowData(nRow);
		if(objData === undefined)
			return;
		
		strTitle = objTitlekey(nRow,nCol,objData);
		if(strTitle === undefined || strTitle === ''){
			strHeader = this._getTitleHeader(nCol);
			strTitle = (nRow - nHR) + '행 ' + strHeader + '열'+ strUp;
		}
		if(QBOX.$(heCell).hasClass(css.CELL)){
			heCell.setAttribute('title',strTitle);		
		}else{
			QBOX.$(heCell).text(strTitle);
		}
	}else{
		strHeader = this._getTitleHeader(nCol);
		strTitle = (nRow - nHR) + '행 ' + strHeader + '열'+ strUp;
		if(QBOX.$(heCell).hasClass(css.CELL)){
			heCell.setAttribute('title',strTitle);		
		}else{
			QBOX.$(heCell).text(strTitle);
		}		
	}
	
};
QBOX.QCELL.NormalQCELL.prototype._resetAriaLabel = function(nCol){
	var objVSinfo = this.attr('vsinfo');
	
	for(var i=objVSinfo.nTopRow ; i<= objVSinfo.nBottomRow; i++){
		
		var heCell = this._getCellDOM(i,nCol);
		if(heCell !== null && heCell !== undefined){
			var strData = this.getCellData(i,nCol);
			strData = strData === undefined ? '' : strData;
			this._setAriaLabel(heCell,i,nCol,strData,false);
		}
		
	}
};
QBOX.QCELL.NormalQCELL.prototype._setAriaLabel = function(heCell,nRow,nCol,strData,bFocus){
	var THAT = this,objGroupState =  this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'), css = QBOX.QCELL.def.css;
	strData = strData === undefined? '' :strData;
	
	if(objGroupState.grouped){
		if(objGroupState.exclude.length > 0){
			var nSize = 0,objRowData = this.getRowData(nRow);
			if(objGroupState.level !== undefined && objRowData !== undefined){
				nSize = objRowData[objGroupState.level];					
			}
			
			if(nSize !== undefined && nSize > 1){
				for(var t=0; t< objGroupState.exclude.length ; t++ ){
					if(objGroupState.exclude[t] === this._getKeyOfCol(nCol)){
						strData = '';
						QBOX.util.textContent(heCell,strData);
						break;
					}
				}				
				
			}
		}
	}
	if(this.attr('useall') || this.attr('usetreeall')){
		var strColType = this._getColType(nCol),heButton;
		
		if(strColType === 'input' || strColType === 'selectmenu'|| strColType === 'datepicker'|| strColType === 'textarea'){
			if(heCell.getElementsByClassName(css.TYPE_INPUT_EDIT_STYLE).length === 0 && !this._isBottomPanel(heCell)){
				heButton = document.createElement('button');
				heButton.setAttribute('tabindex', '0');
				heButton.setAttribute('type', 'button');				
				heButton.className = css.TYPE_INPUT_EDIT_STYLE;
				heCell.appendChild(heButton);
				heButton.onclick = function(e){
					THAT.focusCell(nRow,nCol);
					if(THAT.attr('oneclickedit') !== true){
						setTimeout(function(){
							THAT._editcell(nRow,nCol);
						},100);						
					}					
				};			
				
				heButton.onfocus = function(e){
					THAT._focusCell(nRow,nCol);					
					THAT._scrollToFocusCell(nRow,nCol);

				};
				if(bFocus){
					QBOX.$(heButton).focus();
				}
				this._getTitlekey(heButton,nRow,nCol);
				this._getTitlekey(heCell,nRow,nCol,true);
			}else{
				var heOldButton =heCell.getElementsByClassName(css.TYPE_INPUT_EDIT_STYLE)[0]; 
				if(bFocus === true){
					QBOX.$(heOldButton).focus();
				}
				this._getTitlekey(heOldButton,nRow,nCol);
				this._getTitlekey(heCell,nRow,nCol,true);
			}
		}else{
			this._getTitlekey(heCell,nRow,nCol,true);
		}
		//heCell.setAttribute('aria-hidden','true');
		
	}else{
		var strHeader = this._getTitleHeader(nCol);
		
		heCell.setAttribute('aria-label',nRow+'행 '+strHeader+'열 ');
		
	}
};
QBOX.QCELL.NormalQCELL.prototype._setAriaLabelEx = function(heCell,nRow,nCol,bFocus){
	this._setAriaLabel(heCell,nRow,nCol,$(heCell).text(),bFocus);
};
QBOX.QCELL.NormalQCELL.prototype._createViewPortCells = function(heDiv){
	try{
		var rowgroup = QBOX.QCELL.def.rowgroup, css = QBOX.QCELL.def.css,
		heViewPortInner = this.attr('elementpool').get('viewportinner'),
		arrRowCellMatrix = this.attr('cellmatrix').get('row'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nDataRowHeight = this.attr('rowheight').data, nViewPortClientHeight = this.attr('layoutsize').viewport.clientHeight,
		nViewPortClientWidth = this.attr('layoutsize').viewport.clientWidth,
		nHeaderColWidth = this.attr('headercolwidth'),
		nDynamicRows = this.attr('vsinfo').nDynamicRows, nDynamicCols = this.attr('hsinfo').nDynamicCols,
		nFrozenBottomRowCount = 0,
		nHighlightRepeat = this.attr('highlightrepeat'),
		nCurrentDataCount = arrCurrentData.length,
		emptymessage = this.attr('emptymessage'),
		i,//iterator
		heCell, nColWidth, nBeforeCellWidth,arrDataTextAlign=[], arrUseTextAlign=[],
		j,
		arrData = this.attr('data').input,
		nRowHeaderLength = arrRowHeaders.length,
		nGap = QBOX.browser.name === 'msie' ? 0 : 2,
		bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false,strId= this.attr('id'),bTab;
		
		if(nDynamicRows === 0 && arrData.length === 0) { // data가 없을 시, 생성할 rows가 없을 때
			if(QBOX.$.trim(emptymessage).length > 0 && this.attr('useemptymessage') !== false) { // 설정된 emptymessage가 있을 때
				heCell = this._createEmptymessage(heDiv);
				heViewPortInner.appendChild(heCell);
			}
		} else {
			var cols = this.attr('cols'),
			rows = this.attr('rows');
			
			this._setInitCellDisabled(rows, cols);
			this._setInitCellInvisible(rows, cols);
			
			for(i = 0; i < nDynamicRows; i++){//i:iterator
				var nRow = i + nHeaderRows,
				nRowGroup;
				nBeforeCellWidth = 0;
				
				//1. 틀고정 행/일반 데이터 행/하단 틀고정 행/표시되지 않는 행 식별 
				nRowGroup = this._getRowGroupOfDynamicRows(i);
				
				if(arrRowCellMatrix[nHeaderRows + i] === undefined){
					arrRowCellMatrix.push([]);
				}
				
				if(nRowGroup === rowgroup.FROZENBOTTOM){
					nRow = nCurrentDataCount + nHeaderRows - (nDynamicRows - i);
					nFrozenBottomRowCount += 1;
				}
				
				for(j = 0; j < nDynamicCols; j++){
					var nCol = j + nHeaderCols,
					strColType = this._getColType(nCol),
					keyOfCol = this._getKeyOfCol(nCol),
					cellData,
					objColStyle = this._getQCellCol(nCol).attr('style');
					
					if(i===0){
						arrUseTextAlign.push(this._useDataTextAlign(nCol));
						arrDataTextAlign.push(this._getDataTextAlign(nCol));
					}
					bTab = this._getColTabindex(nCol);
					heCell = this._createCell(heDiv,bTab);
					nColWidth = this._getColWidth(nCol);
					
					heCell.style.width = nColWidth + 'px';
					heCell.style.height = nDataRowHeight + 'px';
					if(arrUseTextAlign[j])heCell.style.textAlign = arrDataTextAlign[j];
					
					if(this._getColWordwrap(nCol)){
						heCell.style.whiteSpace = 'pre-wrap';
					}else{
						heCell.style.lineHeight = (nDataRowHeight - nGap) + 'px';
						//heCell.style.display = 'flex';
						//heCell.style.justifyContent = 'center';
						//heCell.style.alignItems = 'center';
					}
					heCell.style.left = nBeforeCellWidth + 'px';
					heCell.className += ' ' + css.CELL_VIEWPORT + ' ' + (j < nFrozenCols ? css.CELL_FROZENCOLS : css.CELL_NORMALCOLS) + ' ' + this._getColStyleClassName(nCol, 'data');
					heCell.setAttribute('data-row', nRow);
					heCell.setAttribute('data-col', nCol);
					heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
					
					if(!QBOX._.isEmpty(objColStyle)){
						if(QBOX._.isObject(objColStyle.data)){
							var keys = Object.keys(objColStyle.data);
							for(var k = 0; k < keys.length; k++){
								QBOX.$(heCell).css(keys[k], objColStyle.data[keys[k]]);
							}
						}
						this.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
					}
					
					arrRowCellMatrix[nHeaderRows + i].push(heCell);
					if(nRowGroup === rowgroup.FROZENBOTTOM){//FrozenBottomRows영역에 표시 할 행에 속한 cell인 경우
						//FrozenBottomRows영역에 표시할 행의 top은 하단영역에서부터 맞춰준다.
						cellData = arrCurrentData[nRow - nHeaderRows][keyOfCol];
						heCell.style.top = (nViewPortClientHeight - (nDataRowHeight * (nDynamicRows - i))) + 'px';
						if(bPanel === true) {
							strColType = 'static';
							heCell.className += ' ' + css.CELL_FROZENBOTTOMROWS_PANEL;
						}else{
							heCell.className += ' ' + css.CELL_FROZENBOTTOMROWS;
						}
													

					} else{//FrozenRows, 일반 데이터 표시 영역에 표시 할 행에 속한 cell인 경우
						cellData = arrCurrentData[i][keyOfCol];
						heCell.style.top = (nDataRowHeight * i) + 'px';
						heCell.className += ' ' + (nRowGroup === rowgroup.FROZEN ? css.CELL_FROZENROWS : css.CELL_NORMALROWS);
					}
					
					if(nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0)){
						heCell.className += ' ' + css.CELL_HIGHLIGHTREPEAT;
					}
					
					cellData = cellData === undefined ? '' : cellData;
					var strDataFormat = this._showDataFormat(nRow,nCol, cellData);
					
					if(bPanel === true && nRowGroup === rowgroup.FROZENBOTTOM){
						strDataFormat = cellData;
						if(this._getColType(nCol) === 'checkbox' && (strDataFormat === true || strDataFormat === false))
							strDataFormat = '';
					}
					
					switch(strColType){
						case 'input': case 'number': case 'slider': {
							QBOX.util.textContent(heCell, strDataFormat);
							this._setAriaLabel(heCell,nRow,nCol,strDataFormat);
							break;
						}
						case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
							this._getColElement(nCol)._show(heCell, nRow, nCol);
							break;
						}
						case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
							this._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
							break;
						}						
						default: {
							QBOX.util.textContent(heCell, strDataFormat);
							this._setAriaLabel(heCell,nRow,nCol,strDataFormat);
							break;
						}
					}
					
					// cell Type에 따른 구분용 Class 추가
					switch(strColType){
						case 'input': {
							heCell.className += ' ' + css.TYPE_INPUT_CELL;
							break;
						}
						case 'inputbutton': {
							heCell.className += ' ' + css.TYPE_INPUTBUTTON_CELL;
							break;
						}
						case 'textarea': {
							heCell.className += ' ' + css.TYPE_TEXTAREA_CELL;
							break;
						}
						case 'selectmenu': {
							heCell.className += ' ' + css.TYPE_SELECTMENU_CELL;
							break;
						}
						case 'datepicker': {
							heCell.className += ' ' + css.TYPE_DATEPICKER_CELL;
							break;
						}
						case 'inputdatepicker': {
							heCell.className += ' ' + css.TYPE_INPUTDATEPICKER_CELL;
							break;
						}
						case 'checkbox': {
							heCell.className += ' ' + css.TYPE_CHECKBOX_CELL;
							break;
						}
						case 'image': {
							heCell.className += ' ' + css.TYPE_IMAGE_CELL;
							break;
						}
						case 'html': {
							heCell.className += ' ' + css.TYPE_HTML_CELL;
							break;
						}
						case 'chart': {
							heCell.className += ' ' + css.TYPE_CHART_CELL;
							break;
						}
						case 'multicheckbox': {
							heCell.className += ' ' + css.TYPE_MULTICHECKBOX_CELL;
							break;
						}
						case 'number': {
							heCell.className += ' ' + css.TYPE_NUMBER_CELL;
							break;
						}
						case 'slider': {
							heCell.className += ' ' + css.TYPE_SLIDER_CELL;
							break;
						}
						case 'button': {
							heCell.className += ' ' + css.TYPE_BUTTON_CELL;
							break;
						}
						case 'editor': {
							heCell.className += ' ' + css.TYPE_EDITOR_CELL;
							break;
						}
						default: {
							heCell.className += ' ' + css.TYPE_STATIC_CELL;
							break;
						}
					}
					
					heViewPortInner.appendChild(heCell);
					
					nBeforeCellWidth += parseFloat(nColWidth);
				}
			}
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._createViewPortCells', e.message);
		return false;
	}
};

QBOX.QCELL.NormalQCELL.prototype._insertRows = function(nRow, arrData){
	try{		
		var objQCell = this,
		objVSInfo = this.attr('vsinfo'),
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'),
		nCount = arrData.length,
		bVScroll = objVSInfo.bVScroll,
		arrRowheaderData = this.attr('rowheaderdata'),
		arrRowheaderCheck = this.attr('rowheadercheckboxclick'),
		originstate = this.attr('originstate'),nTemp = 0;
		
		if(nRow > arrCurrentData.length && this.attr('makefrozenbottomdata') === true ){
			nRow = arrCurrentData.length; 
		}
		
		this._onScrollHideEditCellsDOM();
		
		this._setAddCellDisabled(nRow);
		this._setAddCellInvisible(nRow);
		
		//1. 데이터 추가
		arrCurrentData.RT_insertArray(nRow - nHeaderRows, arrData);
		
		if(this.attr('pagesyncorgindata') === true){
			var objPaginationInfo = this.attr('paginationinfo');
			nTemp = (objPaginationInfo.pageindex-1 ) * objPaginationInfo.pageunit ;
			
			this.attr('data').input.RT_insertArray ( nRow+nTemp - nHeaderRows ,arrData);
			
			for(var x =0 ;x<nCount ; x++){
				var obj = arrData[x];
				obj.rt_qc_page_state = 'i';
			}
		}
		
		this._updateCurrentData(arrCurrentData);
		arrRowheaderData.RT_insertArray(nRow - nHeaderRows, [{}]);
		arrRowheaderCheck.RT_insertArray(nRow - nHeaderRows, [{}]);
		this._updateRowheaderData(arrRowheaderData, arrRowheaderCheck);
		
		//2. 실제 row UI 생성
		/*if(this._makeRowUI(nCount,true)=== true)
			return;*/
		this._makeRowUI(nCount,true);
		
		//3. Dynamic CSS 제거
		this._clearHighlightRepeatCSS();
		this._clearDynamicCSS('row', 'data');
		
		//4. syncinfo, idxinfo 동기화
		this._updateRowSyncInfo(nRow, nCount, 'i');
		
		//5. 삽입한 행 인덱스들의 state 정보 업데이트
		QBOX._.each(QBOX._.range(nRow, nRow + nCount), function(nInsertedRow, idx){
			objQCell._setRowState(nInsertedRow, 'i');//삽입한 행 state정보를 'i'로 설정
			if(objQCell.attr('original')){
				originstate.i.push({nRow: (nRow - nHeaderRows)});
			}
	

		});
		
		//6. 화면 갱신
		this._refreshDRs();
		
		if(this.attr('percentcolwidth') && bVScroll !== objVSInfo.bVScroll){  
			//"%" colWidth 사용 시 세로스크롤바 표시여부가 행 추가삭제 이전과 달리지는 경우 headerCols를 제외한 모든 컬럼의 colWidth가 변경되어 보정이 필요하다.
			//dynamicRows 추가삭제 후 컬럼 기준 refresh전에 행 기준 refresh를 수행해야 cellDOM에 'data-row'값이 정상적으로 세팅된다.
			this._refreshDCs();
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._insertRows', e.message);
		return false;
	}
};

QBOX.QCELL.NormalQCELL.prototype._deleteRows = function(nRow, nCount){
	try{
		var objQCell = this,
		objVSInfo = this.attr('vsinfo'),
		arrCurrentData = this.attr('currentdata'),
		arrDeletedRowData,
		nHeaderRows = this.attr('headerrows'),
		nRows,
		bVScroll = objVSInfo.bVScroll,
		arrRowheaderData = this.attr('rowheaderdata'),
		arrRowheaderCheck = this.attr('rowheadercheckboxclick'),
		originstate = objQCell.attr('originstate'),
		staticrowsinfo = this.attr('staticrowsinfo'),
		row = -1, n;
		
		this._onScrollHideEditCellsDOM();
		
		this._setDeleteCellDisabled(nRow);
		this._setDeleteCellInvisible(nRow);
		
		nCount = nCount > arrCurrentData.length ? arrCurrentData.length : nCount;
		
		//1. 데이터 제거
		arrDeletedRowData = arrCurrentData.splice(nRow - nHeaderRows, nCount);
		
		if(this.attr('pagesyncorgindata') === true){
			var objPaginationInfo = this.attr('paginationinfo'), nTemp = (objPaginationInfo.pageindex-1 ) * objPaginationInfo.pageunit ;
			
			this.attr('data').input.splice ( nRow+nTemp - nHeaderRows ,nCount);
		}
		
		for(var i = 0, nDeletedRows = arrDeletedRowData.length; i < nDeletedRows; i++){
			if(this._getRowState(nRow + i) !== 'i'){//"insert"상태가 아닌 행을 삭제 시에만 삭제되었다고 "deletedrowsdata" 정보에 추가한다.
				objQCell.attr('deletedrowsdata').push(arrDeletedRowData[i]);
			}
			
			if(objQCell.attr('original')){
				if(this._getRowState(nRow + i) !== 'i'){
					originstate.d.push({nRow: (nRow - nHeaderRows)});
				}else{
					for(n = 0; n < originstate.i.length; n++){
						if(originstate.i[n].nRow === (nRow + i)){
							originstate.i.splice(n, 1);
						}
					}
				}
			}
		}
		
		this._updateCurrentData(arrCurrentData);
		arrRowheaderData.splice(nRow - nHeaderRows, nCount);
		arrRowheaderCheck.splice(nRow - nHeaderRows, nCount);
		this._updateRowheaderData(arrRowheaderData, arrRowheaderCheck);
		
		nRows = this.attr('rows');
		
		//2. focus, selection 처리
		if(this._idx('row', 'focus', 'current') >= nRows || this._getSelectedRows().sort(QBOX.st.desc)[0] >= nRows){//focus가 있는 행의 인덱스가 존재하지 않는 경우, selection된 영역의 하단 행 인덱스가 존재하지 않는 경우
			this._clearFocus();
			this._clearSelection();
		}
		//if(this._idx('row', 'focus', 'current') === nRow){
			this._clearFocus();
			this._clearSelection();			
		//}
		
		//3. 실제 row UI 삭제
		/*if(this._removeRowUI(nCount)=== true)
			return;
		*/
		this._removeRowUI(nCount,true);
		//4. Dynamic CSS 제거
		this._clearHighlightRepeatCSS();
		this._clearDynamicCSS('row', 'data');
		
		//5. syncinfo, idxinfo 동기화
		this._updateRowSyncInfo(nRow, nCount, 'd');
		
		//6. 화면 갱신
		this._refreshDRs();
		
		if(this.attr('percentcolwidth') && bVScroll !== objVSInfo.bVScroll){  
			//"%" colWidth 사용 시 세로스크롤바 표시여부가 행 추가삭제 이전과 달리지는 경우 headerCols를 제외한 모든 컬럼의 colWidth가 변경되어 보정이 필요하다.
			//dynamicRows 추가삭제 후 컬럼 기준 refresh전에 행 기준 refresh를 수행해야 cellDOM에 'data-row'값이 정상적으로 세팅된다.
			this._refreshDCs();
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._deleteRows', e.message);
		return false;
	}
};

QBOX.QCELL.NormalQCELL.prototype._insertStaticRows = function(nRow, arrData){
	try{
		var objQCell = this,
		objVSInfo = this.attr('vsinfo'),
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'),
		nCount = arrData.length,
		bVScroll = objVSInfo.bVScroll,
		arrRowheaderData = this.attr('rowheaderdata'),
		arrRowheaderCheck = this.attr('rowheadercheckboxclick'),
		originstate = this.attr('originstate'),
		staticrowsinfo = this.attr('staticrowsinfo');
		
		if(nRow > this.getRows())
			nRow = this.getRows();
		
		this._onScrollHideEditCellsDOM();
		//1. 데이터 추가
		arrCurrentData.RT_insertArray(nRow - nHeaderRows, arrData);
		
		this._updateCurrentData(arrCurrentData);
		arrRowheaderData.RT_insertArray(nRow - nHeaderRows, [{}]);
		arrRowheaderCheck.RT_insertArray(nRow - nHeaderRows, [{}]);

		if(this.attr('pagesyncorgindata') === true){
			var objPaginationInfo = this.attr('paginationinfo'), nTemp = (objPaginationInfo.pageindex-1 ) * objPaginationInfo.pageunit ;
			
			this.attr('data').input.RT_insertArray ( nRow+nTemp - nHeaderRows ,arrData);
		}		
		
		this._updateRowheaderData(arrRowheaderData, arrRowheaderCheck);
		
		//2. 실제 row UI 생성
		/*if(this._makeRowUI(nCount,true)=== true)
			return;*/
		this._makeRowUI(nCount,true);
		//3. Dynamic CSS 제거
		this._clearHighlightRepeatCSS();
		this._clearDynamicCSS('row', 'data');
		
		//4. syncinfo, idxinfo 동기화
		//this._updateRowSyncInfo(nRow, nCount, 'i');
		
		//5. 삽입한 행 인덱스들의 state 정보 업데이트
		QBOX._.each(QBOX._.range(nRow, nRow + nCount), function(nInsertedRow, idx){
			//objQCell._setRowState(nInsertedRow, 'i');//삽입한 행 state정보를 'i'로 설정
			/*
			if(objQCell.attr('original')){
				originstate.i.push({nRow: (nRow - nHeaderRows)});
			}
			*/
			staticrowsinfo.push({nRow: nInsertedRow}); //staticrow 정보 추가
		});
		
		//6. 화면 갱신
		this._refreshDRs();
		
		if(this.attr('percentcolwidth') && bVScroll !== objVSInfo.bVScroll){  
			//"%" colWidth 사용 시 세로스크롤바 표시여부가 행 추가삭제 이전과 달리지는 경우 headerCols를 제외한 모든 컬럼의 colWidth가 변경되어 보정이 필요하다.
			//dynamicRows 추가삭제 후 컬럼 기준 refresh전에 행 기준 refresh를 수행해야 cellDOM에 'data-row'값이 정상적으로 세팅된다.
			this._refreshDCs();
		}
		
		this.setRowDisable(nRow, true);
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._insertRows', e.message);
		return false;
	}
};

QBOX.QCELL.NormalQCELL.prototype._deleteStaticRows = function(nRow, nCount){
	try{
		var objQCell = this,
		objVSInfo = this.attr('vsinfo'),
		arrCurrentData = this.attr('currentdata'),
		arrDeletedRowData,
		nHeaderRows = this.attr('headerrows'),
		nRows,
		bVScroll = objVSInfo.bVScroll,
		arrRowheaderData = this.attr('rowheaderdata'),
		arrRowheaderCheck = this.attr('rowheadercheckboxclick'),
		originstate = objQCell.attr('originstate'),
		staticrowsinfo = this.attr('staticrowsinfo'),
		row = -1, n,
		nHeaderCols = this.attr('headercols'), nCols = this.attr('cols'),
		css = QBOX.QCELL.def.css;
		
		this._onScrollHideEditCellsDOM();
		
		for(n = nHeaderCols; n < nCols; n++){
			var heCell = this._getCellDOM(nRow, n),
			strColID = this._getColID(n);
			
			if(!QBOX._.isUndefined(heCell)){
				QBOX.util.removeClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
			}
		}
		
		this._setDeleteCellDisabled(nRow);
		this._setDeleteCellInvisible(nRow);
		
		nCount = nCount > arrCurrentData.length ? arrCurrentData.length : nCount;
		
		//1. 데이터 제거
		arrDeletedRowData = arrCurrentData.splice(nRow - nHeaderRows, nCount);
		
		if(this.attr('pagesyncorgindata') === true){
			var objPaginationInfo = this.attr('paginationinfo'), nTemp = (objPaginationInfo.pageindex-1 ) * objPaginationInfo.pageunit ;
			
			this.attr('data').input.splice ( nRow+nTemp - nHeaderRows ,nCount);
		}
		
		for(var i = 0, nDeletedRows = arrDeletedRowData.length; i < nDeletedRows; i++){
			if(this._getRowState(nRow + i) !== 'i'){//"insert"상태가 아닌 행을 삭제 시에만 삭제되었다고 "deletedrowsdata" 정보에 추가한다.
				objQCell.attr('deletedrowsdata').push(arrDeletedRowData[i]);
			}
			
			if(objQCell.attr('original')){
				if(this._getRowState(nRow + i) !== 'i'){
					originstate.d.push({nRow: (nRow - nHeaderRows)});
				}else{
					for(n = 0; n < originstate.i.length; n++){
						if(originstate.i[n].nRow === (nRow + i)){
							originstate.i.splice(n, 1);
						}
					}
				}
			}
			
			for(n = 0; n < staticrowsinfo.length; n++){
				if(staticrowsinfo[n].nRow === (nRow + i)){
					staticrowsinfo.splice(n, 1);
				}
			}
		}
		
		this._updateCurrentData(arrCurrentData);
		arrRowheaderData.splice(nRow - nHeaderRows, nCount);
		arrRowheaderCheck.splice(nRow - nHeaderRows, nCount);
		this._updateRowheaderData(arrRowheaderData, arrRowheaderCheck);
		
		nRows = this.attr('rows');
		
		//2. focus, selection 처리
		if(this._idx('row', 'focus', 'current') >= nRows || this._getSelectedRows().sort(QBOX.st.desc)[0] >= nRows){//focus가 있는 행의 인덱스가 존재하지 않는 경우, selection된 영역의 하단 행 인덱스가 존재하지 않는 경우
			this._clearFocus();
			this._clearSelection();
		}
		//if(this._idx('row', 'focus', 'current') === nRow){
			this._clearFocus();
			this._clearSelection();			
		//}		
		
		//3. 실제 row UI 삭제
		/*if(this._removeRowUI(nCount)=== true)
			return;*/
		this._removeRowUI(nCount,true);
		//4. Dynamic CSS 제거
		this._clearHighlightRepeatCSS();
		this._clearDynamicCSS('row', 'data');
		
		//5. syncinfo, idxinfo 동기화
		this._updateRowSyncInfo(nRow, nCount, 'd');
		this._deleteDStates();
		
		//6. 화면 갱신
		this._refreshDRs();
		
		if(this.attr('percentcolwidth') && bVScroll !== objVSInfo.bVScroll){  
			//"%" colWidth 사용 시 세로스크롤바 표시여부가 행 추가삭제 이전과 달리지는 경우 headerCols를 제외한 모든 컬럼의 colWidth가 변경되어 보정이 필요하다.
			//dynamicRows 추가삭제 후 컬럼 기준 refresh전에 행 기준 refresh를 수행해야 cellDOM에 'data-row'값이 정상적으로 세팅된다.
			this._refreshDCs();
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._deleteStaticRows', e.message);
		return false;
	}
};

QBOX.QCELL.NormalQCELL.prototype._insertRowsEx = function(arrData){
	try{
		/*
		arrData => [
			[3, {"DO_ID":"22369"}],
			[5, {"SGE_CODE":"8000000"}],
			[7, {"SGG_CODE":"760"}]
		];
		*/		
		var objQCell = this,
		objVSInfo = this.attr('vsinfo'),
		arrCurrentData = this.attr('currentdata'),
		arrRows,
		nHeaderRows = this.attr('headerrows'),
		nCount = arrData.length,
		bVScroll = objVSInfo.bVScroll,
		arrRowheaderData = this.attr('rowheaderdata'),
		arrRowheaderCheck = this.attr('rowheadercheckboxclick'),
		originstate = objQCell.attr('originstate');
		
		this._onScrollHideEditCellsDOM();
		
		//1. 행 인덱스 기준 내림차순 정렬 -> 행 인덱스가 큰놈부터 삽입해야 한다.
		/*
		arrData => [
			[7, {"SGG_CODE":"760"}]
			[5, {"SGE_CODE":"8000000"}],
			[3, {"DO_ID":"22369"}],
		];
		*/
		arrData.sort(function(a, b){return b[0] - a[0];});
		
		arrRows = QBOX._.pluck(arrData, 0);
		
		//2. 데이터 추가
		QBOX._.each(arrData, function(arrRowDataInfo){
			arrCurrentData.RT_insert(arrRowDataInfo[0] - nHeaderRows, arrRowDataInfo[1]);
			arrRowheaderData.RT_insertArray(arrRowDataInfo[0] - nHeaderRows, [{}]);
			arrRowheaderCheck.RT_insertArray(arrRowDataInfo[0] - nHeaderRows, [{}]);
			
			if(objQCell.attr('pagesyncorgindata') === true){
				var objPaginationInfo = objQCell.attr('paginationinfo'), nTemp = (objPaginationInfo.pageindex-1 ) * objPaginationInfo.pageunit ;
				
				objQCell.attr('data').input.RT_insertArray ( arrRowDataInfo[0]+nTemp - nHeaderRows , [{rt_qc_page_state:'i'}]);
			}			
		});
		
		this._updateCurrentData(arrCurrentData);
		this._updateRowheaderData(arrRowheaderData, arrRowheaderCheck);
		
		//3. 실제 row UI 생성
		/*if(this._makeRowUI(nCount,true)=== true)
			return;*/
		
		this._makeRowUI(nCount,true);
		
		//4. Dynamic CSS 제거
		this._clearHighlightRepeatCSS();
		this._clearDynamicCSS('row', 'data');
		
		//5. syncinfo, idxinfo 동기화
		this._updateRowSyncInfoEx(arrRows, 'i');
		
		//6. 삽입한 행 인덱스들의 state 정보 업데이트
		QBOX._.each(arrRows, function(nInsertedRow, idx){
			//console.log('nInsertedRow:'+nInsertedRow);
			//console.log('idx:'+idx);
			objQCell._setAddCellDisabled(nInsertedRow);
			objQCell._setAddCellInvisible(nInsertedRow);
			objQCell._setRowState(nInsertedRow +  (nCount - idx - 1), 'i');
			
			if(objQCell.attr('original')){
				originstate.i.push({nRow: (arrRowDataInfo[0] - nHeaderRows)});
			}
		});
		
		//7. 화면 갱신
		this._refreshDRs();
		
		if(this.attr('percentcolwidth') && bVScroll !== objVSInfo.bVScroll){  
			//"%" colWidth 사용 시 세로스크롤바 표시여부가 행 추가삭제 이전과 달리지는 경우 headerCols를 제외한 모든 컬럼의 colWidth가 변경되어 보정이 필요하다.
			//dynamicRows 추가삭제 후 컬럼 기준 refresh전에 행 기준 refresh를 수행해야 cellDOM에 'data-row'값이 정상적으로 세팅된다.
			this._refreshDCs();
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._insertRowsEx', e.message);
		return false;
	}
};

QBOX.QCELL.NormalQCELL.prototype._deleteRowsEx = function(arrRows){
	try{
		/*arrRows => [3, 5, 7];*/
		var objQCell = this,
		objVSInfo = this.attr('vsinfo'),
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'),
		nRows,
		bVScroll = objVSInfo.bVScroll,
		arrRowheaderData = this.attr('rowheaderdata'),
		arrRowheaderCheck = this.attr('rowheadercheckboxclick'),
		originstate = objQCell.attr('originstate');
		
		this._onScrollHideEditCellsDOM();
		
		//1. 행 인덱스 기준 내림차순 정렬 -> 행 인덱스가 큰놈부터 삭제해야 한다.
		/*arrRows => [7, 5, 3];*/
		arrRows.sort(QBOX.st.desc);
		
		var bFind = false,bHeader = false;
		QBOX._.each(arrRows, function(nRow){
			if(nRow-nHeaderRows < 0){
				bHeader	= true;
				return;
			}
				
			if(nRow - nHeaderRows >= arrCurrentData.length ){
				bFind = true;
				return;
			}
		});
		if(bHeader === true)
			return false;
		if(bFind === true)
			return false;	
		
		//2. 데이터 제거
		QBOX._.each(arrRows, function(nRow){
			objQCell._setDeleteCellDisabled(nRow);
			objQCell._setDeleteCellInvisible(nRow);
			var arrDeletedRowData = arrCurrentData.splice(nRow - nHeaderRows, 1);
			arrRowheaderData.splice(nRow - nHeaderRows, 1);
			arrRowheaderCheck.splice(nRow - nHeaderRows, 1);
			
			if(objQCell.attr('pagesyncorgindata') === true){
				var objPaginationInfo = objQCell.attr('paginationinfo'), nTemp = (objPaginationInfo.pageindex-1 ) * objPaginationInfo.pageunit ;
				
				objQCell.attr('data').input.splice ( nRow+nTemp - nHeaderRows ,1);
			}
			
			if(arrDeletedRowData.length > 0 && objQCell._getRowState(nRow) !== 'i'){//"insert"상태가 아닌 행을 삭제 시에만 삭제되었다고 "deletedrowsdata" 정보에 추가한다.
				objQCell.attr('deletedrowsdata').push(arrDeletedRowData[0]);
			}
			
			if(objQCell.attr('original')){
				if(this._getRowState(nRow + i) !== 'i'){
					originstate.d.push({nRow: (nRow - nHeaderRows)});
				}else{
					for(var n = 0; n < originstate.i.length; n++){
						if(originstate.i[n].nRow === (nRow - nHeaderRows)){
							originstate.i.splice(n, 1);
						}
					}
				}
			}
		});
		
		this._updateCurrentData(arrCurrentData);
		this._updateRowheaderData(arrRowheaderData, arrRowheaderCheck);
		
		nRows = this.attr('rows');

		//3. focus, selection 처리
		if(this._idx('row', 'focus', 'current') >= nRows || this._getSelectedRows().sort(QBOX.st.desc)[0] >= nRows){//focus가 있는 행의 인덱스가 존재하지 않는 경우, selection된 영역의 하단 행 인덱스가 존재하지 않는 경우
			this._clearFocus();
			this._clearSelection();
		}
		
		//if(this._idx('row', 'focus', 'current') === nRow){
			this._clearFocus();
			this._clearSelection();			
		//}		
		
		//4. 실제 row UI 삭제

		/*if(this._removeRowUI(arrRows.length)=== true)
			return;*/
		
		this._removeRowUI(arrRows.length,true);
		
		//5. Dynamic CSS 제거
		this._clearHighlightRepeatCSS();
		this._clearDynamicCSS('row', 'data');
		
		//6. syncinfo, idxinfo 동기화
		this._updateRowSyncInfoEx(arrRows, 'd');
		
		//7. 화면 갱신
		this._refreshDRs();
		
		if(this.attr('percentcolwidth') && bVScroll !== objVSInfo.bVScroll){  
			//"%" colWidth 사용 시 세로스크롤바 표시여부가 행 추가삭제 이전과 달리지는 경우 headerCols를 제외한 모든 컬럼의 colWidth가 변경되어 보정이 필요하다.
			//dynamicRows 추가삭제 후 컬럼 기준 refresh전에 행 기준 refresh를 수행해야 cellDOM에 'data-row'값이 정상적으로 세팅된다.
			this._refreshDCs();
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._deleteRowsEx', e.message);
		return false;
	}
};
QBOX.QCELL.NormalQCELL.prototype._checkRequired = function(arrRows){
	try{
		var arrRet = [],
		nStartCol = this.attr('headercols'),
		nStartRow = this.attr('headerrows'),
		nCols = this.attr('cols'),
		nRows = this.attr('rows'),i,j,strValue;
		
		for( j=nStartCol; j<nCols; j++){
			if(this._getQCellCol(j).attr('required')){
				for(i = nStartRow; i< nRows; i++){
					strValue = this._cellValue(i, j);
					
					if(typeof strValue === 'string'){
						strValue = strValue.trim();
						
						if(strValue === '' || strValue === undefined || strValue === null ){
							arrRet.push({'row': i, 'col':j});
						}			
					}else{
						if(strValue === undefined || strValue === null ){
							arrRet.push({'row': i, 'col':j});
						}
					}					
					
				}
			}
		}
		
		return arrRet;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._checkRequired', e.message);
		return [];
	}
};

QBOX.QCELL.NormalQCELL.prototype._processValueChanged = function(nRow,nCol){
	var arrRowHeaders = this.attr('rowheaders'),i,heCell;
	for(i=0;i<arrRowHeaders.length; i++){
		if(arrRowHeaders[i] === 'state'){
			heCell = this._getCellDOM(nRow,i);
			if(heCell !== undefined){
				this._setRowheaderState(heCell,nRow);
			}
		}
	}
	heCell = this._getCellDOM(nRow,nCol);
	if(heCell !==undefined && heCell !== null){
		this._setAriaLabelEx(heCell,nRow,nCol);
	}
	this._updateIdx('valuechanged',nRow,nCol);
	this._trigger('valuechanged');	
	
	if(this.attr('treestate').grouped === true){
		this._setTreeState(nRow,'u');
	}
};

QBOX.QCELL.NormalQCELL.prototype._divisionSubmit = function(url, pageCnt){
	try {
		var totalcnt = 0, pageindex = 0,
		THAT = this, res = function(result){
			result = result instanceof Object ? result : JSON.parse(result);
			totalcnt = result instanceof Object ? result.totalcnt : QBOX._.clone(JSON.parse(result.totalcnt));
			var data = result instanceof Object ? result.data instanceof Object ? QBOX._.clone(result.data) : QBOX._.clone(JSON.parse(result.data)) : QBOX._.clone(JSON.parse(result.data));
			var cnt = THAT.attr('currentdata').length;
			if(cnt + data.length > totalcnt){
				for(var i = totalcnt; i < cnt + data.length; i++){
					data.pop();
				}
			}
			
			THAT._insertRows(THAT.attr('currentdata').length + 1, data);
		};
		do{
			pageindex++;
			QBOX.$.ajax({
				url: url,
				async: false,
				method: 'POST',
				data: {pageindex: pageindex, pagecnt: pageCnt}
			}).done(res);
		}
		while(THAT.attr('currentdata').length < totalcnt);
	}  catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._divisionSubmit', e.message);
		return false;
	}
	
	return true;
};
QBOX.QCELL.NormalQCELL.prototype._getCellLabel = function(nRow, nCol,bBeforeformat){
	var nColType = this._getColType(nCol),
	result = '';
	
	switch(nColType){
		case 'checkbox': case 'image': case 'textarea': {
			result = this._cellValue(nRow, nCol);
			break;
		}
		case 'selectmenu': {
			var objElement = this._getColElement(nCol),
			strValue = this._cellValue(nRow, nCol);
			
			for(var i = 0; i < objElement.attr('input').length; i++){
				if(objElement.attr('input')[i].value === strValue){
					result = objElement.attr('input')[i].label;
				}
			}
			break;
		}
		default: {//input, datepicker, static
			result = QBOX.QCELL.BasicQCELL.prototype._getCellLabel.call(this, nRow, nCol,bBeforeformat);
			break;
		}
	}
	
	return result;
};
QBOX.QCELL.NormalQCELL.prototype._setInitCellDisabled = function(rows, cols){
	for(var c=0; c<cols; c++){ // viewport 생성시 각 col의 속성 celldisabled를 row만큼 false로 배열 처리
		var objColDisabled = this._getQCellCol(c).attr('celldisabled'),
		bColDisabled = this._getQCellCol(c).attr('disabled');
		
		for(var i=0; i<rows; i++){
			objColDisabled.push(bColDisabled);
		}
	}
};

QBOX.QCELL.NormalQCELL.prototype._setAddCellDisabled = function(row){
	var cols = this.attr('cols');
	
	for(var c=0; c<cols; c++){ // viewport 생성시 각 col의 속성 celldisabled를 row만큼 false로 배열 처리
		var objColDisabled = this._getQCellCol(c).attr('celldisabled'),
		bColDisabled = this._getQCellCol(c).attr('disabled');
		
		objColDisabled.splice(row, 0, bColDisabled);
	}
};

QBOX.QCELL.NormalQCELL.prototype._setDeleteCellDisabled = function(row){
	var cols = this.attr('cols');
	
	for(var c=0; c<cols; c++){ // viewport 생성시 각 col의 속성 celldisabled를 row만큼 false로 배열 처리
		var objColDisabled = this._getQCellCol(c).attr('celldisabled');
		
		objColDisabled.splice(row, 1);
	}
};

QBOX.QCELL.NormalQCELL.prototype._setCellDisabled = function(nRow, nCol, bDisable){
	try{
		var htSyncInfoOfRow = this._getSyncInfo('row'),
		htSyncInfoOfCol = this._getSyncInfo('col'),
		htCellDisabledIdxInfoOfRow = this._getIdxInfo('celldisabled', 'row'),
		htCellDisabledIdxInfoOfCol = this._getIdxInfo('celldisabled', 'col'),
		htCellDisabledInfoOfRow,
		htCellDisabledInfoOfCol,
		targetCell,
		objQCell = this,
		nTargetCol = -1,
		cellclick = function(e){
			window[objQCell._getColOptions(nTargetCol).imageclick](e);
		};
		
		if(this._getQCellCol(nCol).attr('type') === 'static'){//rowheader checkbox
			if(this._getCellDOM(nRow, nCol) !== undefined && this._getCellDOM(nRow, nCol) !== null){
				if(this._getCellDOM(nRow, nCol).childNodes.length>0){
					targetCell = this._getCellDOM(nRow, nCol).childNodes[0];
					if(QBOX.util.hasClass(targetCell, QBOX.QCELL.def.css.CELL_ROWHEADER_CHECKBOX)||
							QBOX.util.hasClass(targetCell, QBOX.QCELL.def.css.CELL_ROWHEADER_RADIO)){
						this._setRowheaderDisable(nRow, nCol, bDisable);
						if(bDisable === true){
							targetCell.setAttribute('disabled', 'disabled');
						} else{
							targetCell.removeAttribute('disabled');
						}
					}							
				}				
			}
		}
		else if(this._getQCellCol(nCol).attr('type') === 'checkbox' || this._getQCellCol(nCol).attr('type') === 'button'){ // 컬럼 타입이 checkbox, button인 경우
			if(this._getCellDOM(nRow, nCol) !== undefined && this._getCellDOM(nRow, nCol) !== null){
				if(this._getCellDOM(nRow, nCol).childNodes.length>0){
					targetCell = this._getCellDOM(nRow, nCol).childNodes[0]; // checkbox Element가 하위노드에 존재
					if(targetCell.childNodes.length >0){
						var target = targetCell.childNodes[0]; // checkbox의 구조가 변경되어 1단계 하위노드에 checkbox가 위치
						if(bDisable === true){
							target.setAttribute('disabled', 'disabled');					
						}else{
							target.removeAttribute('disabled');					
						}
						
					}
				}
			}
			
		}
		else if(this._getQCellCol(nCol).attr('type') === 'image'){ // 컬럼 타입이 image인 경우
			if(this._getCellDOM(nRow, nCol) !== undefined && this._getCellDOM(nRow, nCol) !== null){
				if(this._getCellDOM(nRow, nCol).childNodes.length>0){
					targetCell = this._getCellDOM(nRow, nCol).childNodes[0]; // image Element가 하위노드에 존재
					if(bDisable === true){
						targetCell.onclick = null;
					}else{
						if(QBOX._.isUndefined(this._getColOptions(nCol).imageclick) === false){
							nTargetCol = nCol;
							targetCell.onclick = cellclick;
						}					
					}						
				}
			}
		}
		
		this._getQCellCol(nCol).attr('celldisabled')[nRow] = bDisable;
		
		if(htSyncInfoOfRow.containsKey(nRow) === false){
			htSyncInfoOfRow.put(nRow, new _QHashSet());
		}
		htSyncInfoOfRow.get(nRow).add('celldisabled');
		
		if(htCellDisabledIdxInfoOfRow.containsKey(nRow) === false){
			htCellDisabledIdxInfoOfRow.put(nRow, new _QHashtable());
		}
		
		htCellDisabledInfoOfRow = htCellDisabledIdxInfoOfRow.get(nRow);
		
		if(htCellDisabledInfoOfRow.containsKey(nCol)){
			htCellDisabledInfoOfRow.put(nCol, QBOX._.extend(htCellDisabledInfoOfRow.get(nCol), bDisable));
		} else{
			htCellDisabledInfoOfRow.put(nCol, QBOX._.clone(bDisable));
		}
		
		if(htSyncInfoOfCol.containsKey(nCol) === false){
			htSyncInfoOfCol.put(nCol, new _QHashSet());
		}
		htSyncInfoOfCol.get(nCol).add('style');
		
		if(htCellDisabledIdxInfoOfCol.containsKey(nCol) === false){
			htCellDisabledIdxInfoOfCol.put(nCol, new _QHashtable());
		}
		
		htCellDisabledInfoOfCol = htCellDisabledIdxInfoOfCol.get(nCol);
		
		if(htCellDisabledInfoOfCol.containsKey(nRow)){
			htCellDisabledInfoOfCol.put(nRow, QBOX._.extend(htCellDisabledInfoOfCol.get(nRow), bDisable));
		} else{
			htCellDisabledInfoOfCol.put(nRow, QBOX._.clone(bDisable));
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._setCellDisabled', e.message);
		return false;
	}
};

QBOX.QCELL.NormalQCELL.prototype._clearCellDisabled = function(){
	var headerRows = this.attr('headerrows'), headerCols = this.attr('headercols'),
	rows = this.attr('rows'), cols = this.attr('cols'),
	targetCell, nRow, nCol,
	objQCell = this,
	nTargetCol = -1,
	cellclick = function(e){
		window[objQCell._getColOptions(nTargetCol).imageclick](e);
	};
	
	// rowheader
	for(nCol = 0; nCol < headerCols; nCol++){
		for(nRow = headerRows; nRow < rows; nRow++){
			if(this._getQCellCol(nCol).attr('celldisabled')[nRow] === true){
				if(this._getQCellCol(nCol).attr('type') === 'static'){//rowheader checkbox
					if(this._getCellDOM(nRow, nCol) !== undefined && this._getCellDOM(nRow, nCol) !== null){
						if(this._getCellDOM(nRow, nCol).childNodes.length>0){
							targetCell = this._getCellDOM(nRow, nCol).childNodes[0];
							if(QBOX.util.hasClass(targetCell, QBOX.QCELL.def.css.CELL_ROWHEADER_CHECKBOX)||
									QBOX.util.hasClass(targetCell, QBOX.QCELL.def.css.CELL_ROWHEADER_RADIO)){
								this._setRowheaderDisable(nRow, nCol, false);
								targetCell.removeAttribute('disabled');
							}
						}
					}
				}
				this._getQCellCol(nCol).attr('celldisabled')[nRow] = false;
			}
		}
	}
	
	// data
	for(nCol = headerCols; nCol < cols; nCol++){
		for(nRow = headerRows; nRow < rows; nRow++){
			if(this._getQCellCol(nCol).attr('celldisabled')[nRow] === true){
				if(this._getQCellCol(nCol).attr('type') === 'checkbox' || this._getQCellCol(nCol).attr('type') === 'button'){ // 컬럼 타입이 checkbox, button인 경우
					if(this._getCellDOM(nRow, nCol) !== undefined && this._getCellDOM(nRow, nCol) !== null){
						if(this._getCellDOM(nRow, nCol).childNodes.length>0){
							targetCell = this._getCellDOM(nRow, nCol).childNodes[0]; // checkbox Element가 하위노드에 존재
							if(targetCell.childNodes.length >0){
								var target = targetCell.childNodes[0]; // checkbox의 구조가 변경되어 1단계 하위노드에 checkbox가 위치
								target.removeAttribute('disabled');
							}
						}
					}
				}
				else if(this._getQCellCol(nCol).attr('type') === 'image'  ){ // 컬럼 타입이 image인 경우
					if(this._getCellDOM(nRow, nCol) !== undefined && this._getCellDOM(nRow, nCol) !== null){
						if(this._getCellDOM(nRow, nCol).childNodes.length>0){
							targetCell = this._getCellDOM(nRow, nCol).childNodes[0]; // image Element가 하위노드에 존재
							if(QBOX._.isUndefined(this._getColOptions(nCol).imageclick) === false){
								nTargetCol = nCol;
								targetCell.onclick = cellclick;
							}						
						}
					}
				}
				this._getQCellCol(nCol).attr('celldisabled')[nRow] = false;
			}
		}
	}
	
	/*
	for(nRow = 0; nRow < nRows; nRow++){
		for(nCol = 0; nCol < nCols; nCols++){
			if(this._getQCellCol(nCol).attr('celldisabled')[nRow] === true){
				this._getQCellCol(nCol).attr('celldisabled')[nRow] = false;
			}
		}
	}
	*/
};

QBOX.QCELL.NormalQCELL.prototype._setRowheaderDisable = function(nRow, nCol, bDisable){
	var rowheadercheckboxclick = this.attr('rowheadercheckboxclick');
	rowheadercheckboxclick[nRow][nCol] = !bDisable;
};
QBOX.QCELL.NormalQCELL.prototype._checkValidationOfGroupProps = function(objGroupProps){
	var objQCell = this;
	
	return QBOX.QCELL.BasicQCELL.prototype._checkValidationOfGroupProps.call(this, objGroupProps) &&
	QBOX._.every(objGroupProps.columns, function(objGroupColumnProps, nIdx){
		var arrColsOfKey = objQCell._getColsOfKey(objGroupColumnProps.key);
		
		if(arrColsOfKey.length > 0){
			var nCol = arrColsOfKey[0];
			
			return objQCell._checkGroupPossibilityOfCol(nCol);
		}
		return true;
	});
};

QBOX.QCELL.NormalQCELL.prototype._checkGroupPossibilityOfCol = function(nCol){
	var bPossibility = true;
	
	switch(this._getColType(nCol)){
		case 'checkbox': case 'image': case 'html': case 'selectmenu': case 'chart':{
			bPossibility = false;
			break;
		}
		default: {
			break;
		}
	}

	return bPossibility;
};

QBOX.QCELL.NormalQCELL.prototype.onHScroll = function(nScrollLeft){
	//위치 변경. Scroll thumb 을 욺직일때 DOM 이 이미 변경 되어 Edit 상태를 못 다을 수 있다.
	this._onScrollHideEditCellsDOM();	
	QBOX.QCELL.BasicQCELL.prototype.onHScroll.call(this, nScrollLeft);	

};
QBOX.QCELL.NormalQCELL.prototype._setInitCellInvisible = function(rows, cols){
	for(var c=0; c<cols; c++){ // viewport 생성시 각 col의 속성 cellinvisible를 row만큼 false로 배열 처리
		var objColInvisible = this._getQCellCol(c).attr('cellinvisible'),
		bColInvisibled = this._getQCellCol(c).attr('invisibled');
		
		for(var i=0; i<rows; i++){
			objColInvisible.push(bColInvisibled);
		}
	}
};

QBOX.QCELL.NormalQCELL.prototype._setAddCellInvisible = function(row){
	var cols = this.attr('cols');
	
	for(var c=0; c<cols; c++){ // viewport 생성시 각 col의 속성 cellinvisible를 row만큼 false로 배열 처리
		var objColInvisible = this._getQCellCol(c).attr('cellinvisible'),
		bColInvisibled = this._getQCellCol(c).attr('invisibled');
		
		objColInvisible.splice(row, 0, bColInvisibled);
	}
};

QBOX.QCELL.NormalQCELL.prototype._setDeleteCellInvisible = function(row){
	var cols = this.attr('cols');
	
	for(var c=0; c<cols; c++){ // viewport 생성시 각 col의 속성 cellinvisible를 row만큼 false로 배열 처리
		var objColInvisible = this._getQCellCol(c).attr('cellinvisible');
		
		objColInvisible.splice(row, 1);
	}
};

QBOX.QCELL.NormalQCELL.prototype._setCellInvisible = function(nRow, nCol, bInvisible){
	try {
		var htSyncInfoOfRow = this._getSyncInfo('row'),
		htSyncInfoOfCol = this._getSyncInfo('col'),
		htCellInvisibleIdxInfoOfRow = this._getIdxInfo('cellinvisible', 'row'),
		htCellInvisibleIdxInfoOfCol = this._getIdxInfo('cellinvisible', 'col'),
		htCellInvisibleInfoOfRow,
		htCellInvisibleInfoOfCol,
		targetCell;
		
		if(this._getCellDOM(nRow, nCol) !== undefined && this._getCellDOM(nRow, nCol) !== null){
			var heDiv = document.createElement('div');
			heDiv.className += QBOX.QCELL.def.css.TYPE_INVISIBLE_SINGLE_STYLE;
			heDiv.setAttribute('data-row', nRow);
			heDiv.setAttribute('data-col', nCol);
			
			//console.log(nRow, nCol);
			//var heCell = this._getCellDOM(nRow, nCol);
			//console.log(heCell);
			
			if(bInvisible){ // 숨김
				if(this._getCellDOM(nRow, nCol).childNodes.length > 0){
					targetCell = QBOX._.isElement(this._getCellDOM(nRow,nCol).childNodes[0]) ? this._getCellDOM(nRow,nCol).childNodes[0]: this._getCellDOM(nRow, nCol);
					
					if(parseInt(targetCell.getAttribute('data-row')) === nRow){
						if(!QBOX.$(targetCell).hasClass(QBOX.QCELL.def.css.TYPE_INVISIBLE_SINGLE_STYLE)){
							QBOX.$('#cell_'+nRow+'_'+nCol).prepend(heDiv);
							QBOX.$(targetCell).css({'visibility': 'hidden'});
						}
					}
				}
			}else { // 출력
				if(this._getCellDOM(nRow, nCol).childNodes.length > 0){
					targetCell = QBOX._.isElement(this._getCellDOM(nRow,nCol).childNodes[0]) ? this._getCellDOM(nRow,nCol).childNodes[0]: this._getCellDOM(nRow, nCol);
					
					if(parseInt(targetCell.getAttribute('data-row')) === nRow){
						if(QBOX.$(targetCell).hasClass(QBOX.QCELL.def.css.TYPE_INVISIBLE_SINGLE_STYLE)){
							QBOX.$(targetCell).remove();
						}else if(!QBOX.$(targetCell).hasClass(QBOX.QCELL.def.css.TYPE_INVISIBLE_SINGLE_STYLE)){
							QBOX.$(targetCell).css({'visibility': 'visible'});
						}
					}
				}
			}
		}
		
		this._getQCellCol(nCol).attr('cellinvisible')[nRow] = bInvisible;
		
		if(htSyncInfoOfRow.containsKey(nRow) === false){
			htSyncInfoOfRow.put(nRow, new _QHashSet());
		}
		htSyncInfoOfRow.get(nRow).add('celldisabled');
		
		if(htCellInvisibleIdxInfoOfRow.containsKey(nRow) === false){
			htCellInvisibleIdxInfoOfRow.put(nRow, new _QHashtable());
		}
		
		htCellInvisibleInfoOfRow = htCellInvisibleIdxInfoOfRow.get(nRow);
		
		if(htCellInvisibleInfoOfRow.containsKey(nCol)){
			htCellInvisibleInfoOfRow.put(nCol, QBOX._.extend(htCellInvisibleInfoOfRow.get(nCol), bInvisible));
		} else{
			htCellInvisibleInfoOfRow.put(nCol, QBOX._.clone(bInvisible));
		}
		
		if(htSyncInfoOfCol.containsKey(nCol) === false){
			htSyncInfoOfCol.put(nCol, new _QHashSet());
		}
		htSyncInfoOfCol.get(nCol).add('style');
		
		if(htCellInvisibleIdxInfoOfCol.containsKey(nCol) === false){
			htCellInvisibleIdxInfoOfCol.put(nCol, new _QHashtable());
		}
		
		htCellInvisibleInfoOfCol = htCellInvisibleIdxInfoOfCol.get(nCol);
		
		if(htCellInvisibleInfoOfCol.containsKey(nRow)){
			htCellInvisibleInfoOfCol.put(nRow, QBOX._.extend(htCellInvisibleInfoOfCol.get(nRow), bInvisible));
		} else{
			htCellInvisibleInfoOfCol.put(nRow, QBOX._.clone(bInvisible));
		}
		
		return true;
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._setCellInvisible', e.message);
		return false;
	}
	
	return false;
};

QBOX.QCELL.NormalQCELL.prototype._clearCellInvisible = function(){
	var headerRows = this.attr('headerrows'), headerCols = this.attr('headercols'),
	rows = this.attr('rows'), cols = this.attr('cols'),heCell;
	
	for(var nRow = headerRows; nRow < rows; nRow++){
		for(var nCol = headerCols; nCol < cols; nCol++){
			heCell = this._getCellDOM(nRow, nCol);
			if(heCell !== undefined && heCell !== null){
				
				if(heCell.childNodes.length > 0){
					var targetCell = heCell.childNodes[0];
					
					if(QBOX.$(targetCell).hasClass(QBOX.QCELL.def.css.TYPE_INVISIBLE_SINGLE_STYLE)){
						QBOX.$(targetCell).remove();
					}
				}
			}
			
			this._getQCellCol(nCol).attr('cellinvisible')[nRow] = false;
			heCell = null;
		}
	}
};
QBOX.QCELL.NormalQCELL.prototype._singleSort = function(nCol, strSortType, strDataType){
	this._onScrollHideEditCellsDOM();
	this._trigger('beforesort');
	
	var THAT = this;
	
	if(this.attr('paginationinfo').totalsort === true){
		this._movePage(1);
	}
	
	var strColumnKey = QBOX._.isString(nCol)? nCol : this._getKeyOfCol(nCol),
	nHeaderRows = this.attr('headerrows'), nHeaderCols = this.attr('headercols'), nCols = this.attr('cols'), nRows = this.attr('rows'),
	arrCurrentData = this.attr('currentdata'),
	htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row'), htStyleIdxInfoOfCol = this._getIdxInfo('style', 'col'),
	htSyncInfoOfRow = this._getSyncInfo('row'), htSyncInfoOfCol = this._getSyncInfo('col'),
	strStyleIdxInfoKey = 'rt_styleidxinfo', strSyncInfoKey = 'rt_syncinfo', strOriginrowKey = 'rt_originrow',
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	strStateIdxInfoKey = 'rt_stateidxinfo', hsSyncInfoOfRowIdx = new _QHashSet(),
	htCellDisabledIdxInfoOfRow = this._getIdxInfo('celldisabled', 'row'), htCellDisabledIdxInfoOfCol = this._getIdxInfo('celldisabled', 'col'),
	strCellDisabledIdxInfoKey = 'rt_celldisabledidxinfo',
	htCellInvisibleIdxInfoOfRow = this._getIdxInfo('cellinvisible', 'row'), htCellInvisibleIdxInfoOfCol = this._getIdxInfo('cellinvisible', 'col'),
	strCellInvisibleIdxInfoKey = 'rt_cellinvisibleidxinfo',
	i, j, k, nTargetRow;
	
	if(QBOX._.isNumber(nCol)){
		var objFormat = this._getColFormat(nCol);
		
		if(objFormat !== undefined && objFormat !== null &&  objFormat.beforeformat !== undefined && QBOX._.isFunction(objFormat.beforeformat)){
			strColumnKey = '_rt_qc_bf_' +strColumnKey;

		}
		
	}
	
	
	var bTag = false;
	if(this.attr('makefrozenbottomdata') === true){
		if(arrCurrentData.length > 0){
			if(arrCurrentData[arrCurrentData.length-1].rt_qc_fbrd === true){
				arrCurrentData.pop();
				bTag = true;
			}				
			
		}
		
	}	
		
	if(this.attr('isfirstsort') !== true && arrCurrentData.length > 0){
		for(i=0 ; i< arrCurrentData.length ; i++){
			arrCurrentData[i]._rt_qc_s_i = i;
		}
		this.attr('isfirstsort' , true, 'boolean');
	}	
	
	if(htSyncInfoOfRow.size() > 0){// 0. 동기화 필요한 행 추출
		htSyncInfoOfRow.each(function(nRow, hsSyncInfoOfRow){
			if(nRow > arrCurrentData.length)
				return;
			
			QBOX._.each(hsSyncInfoOfRow.values(), function(strSyncName){
				switch(strSyncName){
					case 'style': case 'state': case 'celldisabled': case 'cellinvisible':{
						hsSyncInfoOfRowIdx.add(nRow);
						break;
					}
					default: break;
				}
			});
		});
	}	
	var arrStyle = [];
	if(hsSyncInfoOfRowIdx.values().length > 0){// 동기화 할 내용이 있을 경우 
		var objQCell = this;
		
		objQCell._clearDynamicCSS('row', 'data'); // 동적 스타일 제거
		objQCell._clearCellDisabled(); // celldisabled 제거
		objQCell._clearCellInvisible(); // cellinvisible 제거
		
	
		
		QBOX._.each(hsSyncInfoOfRowIdx.values(), function(nRow){// 1. 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
			if(nRow - nHeaderRows >= 0){
				if(QBOX._.indexOf(htStyleIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 1-1. 스타일 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
					arrCurrentData[nRow - nHeaderRows][strStyleIdxInfoKey] = htStyleIdxInfoOfRow.remove(nRow);
				}
				
				if(QBOX._.indexOf(htStateIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 1-2. 상태 정보 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
					arrCurrentData[nRow - nHeaderRows][strStateIdxInfoKey] = htStateIdxInfoOfRow.remove(nRow);
				}
				
				if(QBOX._.indexOf(htCellDisabledIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 1-3. 셀 Disabled 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
					arrCurrentData[nRow - nHeaderRows][strCellDisabledIdxInfoKey] = htCellDisabledIdxInfoOfRow.remove(nRow);
				}
				
				if(QBOX._.indexOf(htCellInvisibleIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 1-4. 셀 invisible 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
					arrCurrentData[nRow - nHeaderRows][strCellInvisibleIdxInfoKey] = htCellInvisibleIdxInfoOfRow.remove(nRow);
				}
				
				// 1-5. syncinfo 정보 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
				arrCurrentData[nRow - nHeaderRows][strSyncInfoKey] = htSyncInfoOfRow.remove(nRow);
				arrCurrentData[nRow - nHeaderRows][strOriginrowKey] = nRow;
			}

		});
		if(strSortType === 'none'){
			QBOX.util.RT_sortBy	(arrCurrentData,'_rt_qc_s_i', strSortType, strDataType);
		}else{
			QBOX.util.RT_sortBy	(arrCurrentData,strColumnKey, strSortType, strDataType);	
		}
		
		// 2. 데이터 정렬
		//arrCurrentData.RT_sortBy(strColumnKey, strSortType, strDataType);
		
		// 3. 정렬후 행 데이터에 동기화 정보가 있을 경우 동기화 자료구조에 다시 넣어줌
		for(i = 0; i < arrCurrentData.length; i++){
			var htStyleIdxInfo = arrCurrentData[i][strStyleIdxInfoKey],
			htStateIdxInfo = arrCurrentData[i][strStateIdxInfoKey],
			htCellDisabledIdxInfo = arrCurrentData[i][strCellDisabledIdxInfoKey],
			htCellInvisibleIdxInfo = arrCurrentData[i][strCellInvisibleIdxInfoKey],
			hsSyncInfo = arrCurrentData[i][strSyncInfoKey],
			nOriginRow = arrCurrentData[i][strOriginrowKey];
			
			// 3-1. 데이터에서 동기화 정보 제거
			delete arrCurrentData[i][strStyleIdxInfoKey];
			delete arrCurrentData[i][strStateIdxInfoKey];
			delete arrCurrentData[i][strCellDisabledIdxInfoKey];
			delete arrCurrentData[i][strCellInvisibleIdxInfoKey];
			delete arrCurrentData[i][strSyncInfoKey];
			delete arrCurrentData[i][strOriginrowKey];
			
			if(arrCurrentData[i]._rt_qc_style !== undefined){
				for (var sKey in arrCurrentData[i]._rt_qc_style){				
					var nTC = this._getColsOfKey(sKey)[0];
					if(nTC === undefined)
						break;
					var objStyle = QBOX._.clone(arrCurrentData[i]._rt_qc_style[sKey]);
					objStyle.col = nTC;
					objStyle.key = sKey;
					arrStyle.push({row: i+THAT.getRows('header'), style : objStyle});					
				}				
				delete arrCurrentData[i]._rt_qc_style;				
			}
			
			if(hsSyncInfo && nOriginRow){
				// 3-2. row index 스타일 정보 동기화
				if(htStyleIdxInfo){
					// 3-2-1 row index 스타일 정보 동기화
					htStyleIdxInfoOfRow.put(i + nHeaderRows, htStyleIdxInfo);
					
					// 3-2-2. col index 스타일 정보 동기화
					for(j = 0; j < nCols; j++){
						if(htStyleIdxInfoOfCol.get(j) !== null){
							for(k = 0; k < htStyleIdxInfoOfCol.get(j).keys().length; k++){
								nTargetRow = htStyleIdxInfoOfCol.get(j).keys()[k];
								
								if(nTargetRow === nOriginRow){
									htStyleIdxInfoOfCol.get(j).put(i + nHeaderRows, htStyleIdxInfoOfCol.get(j).remove(nTargetRow));
								}
							}
						}
					}
				}
				
				// 3-3. row index 상태 정보 동기화
				if(htStateIdxInfo){
					htStateIdxInfoOfRow.put(i + nHeaderRows, htStateIdxInfo);
				}
				
				// 3-4. row 셀 Disabled 정보 동기화
				if(htCellDisabledIdxInfo){
					// 3-4-1 row index 셀 Disabled 정보 동기화
					htCellDisabledIdxInfoOfRow.put(i + nHeaderRows, htCellDisabledIdxInfo);
					
					// 3-4-2. col index 셀 Disabled 정보 동기화
					for(j = 0; j < nCols; j++){
						if(htCellDisabledIdxInfoOfCol.get(j) !== null){
							for(k = 0; k < htCellDisabledIdxInfoOfCol.get(j).keys().length; k++){
								nTargetRow = htCellDisabledIdxInfoOfCol.get(j).keys()[k];
								
								// disabled 동기화
								if(objQCell._getQCellCol(j).attr('celldisabled')[(i + nHeaderRows)] === false){
									objQCell._setCellDisabled((i + nHeaderRows), j, true);
								}
									
								if(nTargetRow === nOriginRow){
									htCellDisabledIdxInfoOfCol.get(j).put(i + nHeaderRows, htCellDisabledIdxInfoOfCol.get(j).remove(nTargetRow));
								}
							}
						}
					}
				}
				
				// 3-5. row 셀 invisible 정보 동기화
				if(htCellInvisibleIdxInfo){
					// 3-5-1 row index 셀 invisible 정보 동기화
					htCellInvisibleIdxInfoOfRow.put(i + nHeaderRows, htCellInvisibleIdxInfo);
					
					// 3-5-2. col index 셀 invisible 정보 동기화
					for(j = 0; j < nCols; j++){
						if(htCellInvisibleIdxInfoOfCol.get(j) !== null){
							for(k = 0; k < htCellInvisibleIdxInfoOfCol.get(j).keys().length; k++){
								nTargetRow = htCellInvisibleIdxInfoOfCol.get(j).keys()[k];
								
								// invisible 동기화
								if(objQCell._getQCellCol(j).attr('cellinvisible')[(i + nHeaderRows)] === false){
									objQCell._setCellInvisible((i + nHeaderRows), j, true);
								}
								
								if(nTargetRow === nOriginRow){
									htCellInvisibleIdxInfoOfCol.get(j).put(i + nHeaderRows, htCellInvisibleIdxInfoOfCol.get(j).remove(nTargetRow));
								}
							}
						}
					}
				}
				
				// 3-6. syncinfo 정보 동기화
				htSyncInfoOfRow.put(i + nHeaderRows, hsSyncInfo);
			}
		}
	} else{
		// 동기화 할 정보가 없을경우 정렬만 수행
		if(strSortType === 'none'){
			QBOX.util.RT_sortBy	(arrCurrentData,'_rt_qc_s_i', strSortType, strDataType);
		}else{
			QBOX.util.RT_sortBy	(arrCurrentData,strColumnKey, strSortType, strDataType);	
		}
				
//		arrCurrentData.RT_sortBy(strColumnKey, strSortType, strDataType);
	}
	
	// 4-5 syncinfo.col 에 sort flag 삽입
	if(htSyncInfoOfCol.containsKey(nCol) === false){
		htSyncInfoOfCol.put(nCol, new _QHashSet());
	}
	htSyncInfoOfCol.get(nCol).add('sort');
	
	// 4-6 단일 정렬이기 때문에 현재 정렬하는 컬럼 이외의 컬럼에 sort flag가 있을 경우는 제거
	QBOX._.each(htSyncInfoOfCol.keys(), function(nTargetIdx){
		if(nTargetIdx !== nCol){
			if(htSyncInfoOfCol.get(nTargetIdx).contains('sort')){
				htSyncInfoOfCol.get(nTargetIdx).remove('sort');
				
				if(htSyncInfoOfCol.get(nTargetIdx).isEmpty()){
					htSyncInfoOfCol.remove(nTargetIdx);
				}
			}
		}
	});
	
	//this.attr('sortinfo', [[nCol, strSortType, strDataType]], 'array');
	if(QBOX._.isNumber(nCol)){
		setTimeout(function(){THAT.attr('qcellcols')[nCol]._initUserColStyle();
		THAT.attr('qcellcols')[nCol]._initUserColStyle();},0);		
	}
	this._setCurrentData(arrCurrentData,false,true);
	
	//this._refreshDRs();
	
	this._trigger('aftersort');	
	this.attr('isSorting', false, 'boolean');
	
	if(arrStyle.length > 0){
		for(var x=0; x < arrStyle.length ; x++)			
		this.setCellStyle(arrStyle[x].row, arrStyle[x].style.col, arrStyle[x].style.style);
	
	}
	
};

QBOX.QCELL.NormalQCELL.prototype._multiSort = function(arrSortList){
	this._onScrollHideEditCellsDOM();
	this._trigger('beforesort');
	if(this.attr('paginationinfo').totalsort === true){
		this._movePage(1);
	}
	
	var strColumnKey, arrTempSortList = [],
	nHeaderRows = this.attr('headerrows'), nHeaderCols = this.attr('headercols'), nCols = this.attr('cols'),
	arrCurrentData = this.attr('currentdata'),
	htStyleIdxInfoOfRow = this._getIdxInfo('style', 'row'), htStyleIdxInfoOfCol = this._getIdxInfo('style', 'col'),
	htSyncInfoOfRow = this._getSyncInfo('row'), htSyncInfoOfCol = this._getSyncInfo('col'),
	strStyleIdxInfoKey = 'rt_styleidxinfo', strSyncInfoKey = 'rt_syncinfo', strOriginrowKey = 'rt_originrow',
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	strStateIdxInfoKey = 'rt_stateidxinfo', hsSyncInfoOfRowIdx = new _QHashSet(),
	htCellDisabledIdxInfoOfRow = this._getIdxInfo('celldisabled', 'row'), htCellDisabledIdxInfoOfCol = this._getIdxInfo('celldisabled', 'col'),
	strCellDisabledIdxInfoKey = 'rt_celldisabledidxinfo',
	htCellInvisibleIdxInfoOfRow = this._getIdxInfo('cellinvisible', 'row'), htCellInvisibleIdxInfoOfCol = this._getIdxInfo('cellinvisible', 'col'),
	strCellInvisibleIdxInfoKey = 'rt_cellinvisibleidxinfo',
	i, j, k, nTargetRow;
	
	if(this.attr('makefrozenbottomdata') === true){
		if(arrCurrentData.length > 0){
			if(arrCurrentData[arrCurrentData.length-1].rt_qc_fbrd === true){
				arrCurrentData.pop();
			}				
			
		}
		
	}	
	
	if(htSyncInfoOfRow.size() > 0){// 0. 동기화 필요한 행 추출
		htSyncInfoOfRow.each(function(nRow, hsSyncInfoOfRow){
			if(nRow > arrCurrentData.length)
				return;
			
			QBOX._.each(hsSyncInfoOfRow.values(), function(strSyncName){
				switch(strSyncName){
					case 'style': case 'state': case 'celldisabled': case 'cellinvisible':{
						hsSyncInfoOfRowIdx.add(nRow);
						break;
					}
					default: break;
				}
			});
		});
	}
	
	// arrSortList 는 데이터 변경이 되면 안되고 참조용으로만 사용되어야 하기 때문에, clone 처리
	QBOX._.each(arrSortList, function(arrTemp){
		arrTempSortList.push(QBOX._.clone(arrTemp));
	});
	
	// 컬럼 인덱스 -> key 로 변경
	for(i = 0; i < arrTempSortList.length; i++){
		strColumnKey = QBOX._.isString(arrTempSortList[i][0]) ? arrTempSortList[i][0] : this._getKeyOfCol(arrTempSortList[i][0]);
		arrTempSortList[i][0] = strColumnKey;
	}
	
	if(hsSyncInfoOfRowIdx.values().length > 0){// 동기화 할 내용이 있을 경우 
		var objQCell = this;
		
		objQCell._clearDynamicCSS('row', 'data'); // 동적 스타일 제거
		objQCell._clearCellDisabled(); // celldisabled 제거
		objQCell._clearCellInvisible(); // cellinvisible 제거
		
		QBOX._.each(hsSyncInfoOfRowIdx.values(), function(nRow){// 1. 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
			if(QBOX._.indexOf(htStyleIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 1-1. 스타일 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
				arrCurrentData[nRow - nHeaderRows][strStyleIdxInfoKey] = htStyleIdxInfoOfRow.remove(nRow);
			}
			
			if(QBOX._.indexOf(htStateIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 1-2. 상태 정보 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
				arrCurrentData[nRow - nHeaderRows][strStateIdxInfoKey] = htStateIdxInfoOfRow.remove(nRow);
			}
			
			if(QBOX._.indexOf(htCellDisabledIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 1-3. 셀 Disabled 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
				arrCurrentData[nRow - nHeaderRows][strCellDisabledIdxInfoKey] = htCellDisabledIdxInfoOfRow.remove(nRow);
			}
			
			if(QBOX._.indexOf(htCellInvisibleIdxInfoOfRow.keys().sort(QBOX.st.asc), nRow, true) !== -1){// 1-4. 셀 invisible 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
				arrCurrentData[nRow - nHeaderRows][strCellInvisibleIdxInfoKey] = htCellInvisibleIdxInfoOfRow.remove(nRow);
			}
			
			// 1-5. syncinfo 정보 동기화 할 행 데이터에 동기화 정보를 박은뒤, 동기화 자료구조에서 제거
			arrCurrentData[nRow - nHeaderRows][strSyncInfoKey] = htSyncInfoOfRow.remove(nRow);
			arrCurrentData[nRow - nHeaderRows][strOriginrowKey] = nRow;
		});
		QBOX.util.RT_sortBy	(arrCurrentData,arrTempSortList);		
		// 2. 데이터 정렬
		arrCurrentData.RT_sortBy(arrTempSortList);
		
		// 3. 정렬후 행 데이터에 동기화 정보가 있을 경우 동기화 자료구조에 다시 넣어줌
		for(i = 0; i < arrCurrentData.length; i++){
			var htStyleIdxInfo = arrCurrentData[i][strStyleIdxInfoKey],
			htStateIdxInfo = arrCurrentData[i][strStateIdxInfoKey],
			htCellDisabledIdxInfo = arrCurrentData[i][strCellDisabledIdxInfoKey],
			htCellInvisibleIdxInfo = arrCurrentData[i][strCellInvisibleIdxInfoKey],
			hsSyncInfo = arrCurrentData[i][strSyncInfoKey],
			nOriginRow = arrCurrentData[i][strOriginrowKey];
			
			// 3-1. 데이터에서 동기화 정보 제거
			delete arrCurrentData[i][strStyleIdxInfoKey];
			delete arrCurrentData[i][strStateIdxInfoKey];
			delete arrCurrentData[i][strCellDisabledIdxInfoKey];
			delete arrCurrentData[i][strCellInvisibleIdxInfoKey];
			delete arrCurrentData[i][strSyncInfoKey];
			delete arrCurrentData[i][strOriginrowKey];
			
			if(hsSyncInfo && nOriginRow){
				// 3-2. row index 스타일 정보 동기화
				if(htStyleIdxInfo){
					// 3-2-1 row index 스타일 정보 동기화
					htStyleIdxInfoOfRow.put(i + nHeaderRows, htStyleIdxInfo);
					
					// 3-2-2. col index 스타일 정보 동기화
					for(j = 0; j < nCols; j++){
						if(htStyleIdxInfoOfCol.get(j) !== null){
							for(k = 0; k < htStyleIdxInfoOfCol.get(j).keys().length; k++){
								nTargetRow = htStyleIdxInfoOfCol.get(j).keys()[k];
								
								if(nTargetRow === nOriginRow){
									htStyleIdxInfoOfCol.get(j).put(i + nHeaderRows, htStyleIdxInfoOfCol.get(j).remove(nTargetRow));
								}
							}
						}
					}
				}
				
				// 3-3. row index 상태 정보 동기화
				if(htStateIdxInfo){
					htStateIdxInfoOfRow.put(i + nHeaderRows, htStateIdxInfo);
				}
				
				// 3-4. row 셀 Disabled 정보 동기화
				if(htCellDisabledIdxInfo){
					// 3-4-1 row index 셀 Disabled 정보 동기화
					htCellDisabledIdxInfoOfRow.put(i + nHeaderRows, htCellDisabledIdxInfo);
					
					// 3-4-2. col index 셀 Disabled 정보 동기화
					for(j = 0; j < nCols; j++){
						if(htCellDisabledIdxInfoOfCol.get(j) !== null){
							for(k = 0; k < htCellDisabledIdxInfoOfCol.get(j).keys().length; k++){
								nTargetRow = htCellDisabledIdxInfoOfCol.get(j).keys()[k];
								
								// disabled 동기화
								if(objQCell._getQCellCol(j).attr('celldisabled')[(i + nHeaderRows)] === false){
									objQCell._setCellDisabled((i + nHeaderRows), j, true);
								}
								
								if(nTargetRow === nOriginRow){
									htCellDisabledIdxInfoOfCol.get(j).put(i + nHeaderRows, htCellDisabledIdxInfoOfCol.get(j).remove(nTargetRow));
								}
							}
						}
					}
				}
				
				// 3-5. row 셀 invisible 정보 동기화
				if(htCellInvisibleIdxInfo){
					// 3-5-1 row index 셀 invisible 정보 동기화
					htCellInvisibleIdxInfoOfRow.put(i + nHeaderRows, htCellInvisibleIdxInfo);
					
					// 3-5-2. col index 셀 invisible 정보 동기화
					for(j = 0; j < nCols; j++){
						if(htCellInvisibleIdxInfoOfCol.get(j) !== null){
							for(k = 0; k < htCellInvisibleIdxInfoOfCol.get(j).keys().length; k++){
								nTargetRow = htCellInvisibleIdxInfoOfCol.get(j).keys()[k];
								
								// invisible 동기화
								if(objQCell._getQCellCol(j).attr('cellinvisible')[(i + nHeaderRows)] === false){
									objQCell._setCellInvisible((i + nHeaderRows), j, true);
								}
								
								if(nTargetRow === nOriginRow){
									htCellInvisibleIdxInfoOfCol.get(j).put(i + nHeaderRows, htCellInvisibleIdxInfoOfCol.get(j).remove(nTargetRow));
								}
							}
						}
					}
				}
				
				// 3-6. syncinfo 정보 동기화
				htSyncInfoOfRow.put(i + nHeaderRows, hsSyncInfo);
			}
		}
	} else{
		QBOX.util.RT_sortBy	(arrCurrentData,arrTempSortList);		
		// 스타일 동기화 정보가 없을경우 정렬만 수행
		//arrCurrentData.RT_sortBy(arrTempSortList);
	}
	
	// 4-5 syncinfo.col 에 sort flag 삽입
	QBOX._.each(arrSortList, function(arrSortInfo){
		if(htSyncInfoOfCol.containsKey(arrSortInfo[0]) === false){
			htSyncInfoOfCol.put(arrSortInfo[0], new _QHashSet());
		}
		htSyncInfoOfCol.get(arrSortInfo[0]).add('sort');
	});
	
	//this.attr('sortinfo', arrSortList, 'array');
	
	this._setCurrentData(arrCurrentData);
	
	this._trigger('aftersort');	
	this.attr('isSorting', false, 'boolean');
};

QBOX.QCELL.NormalQCELL.prototype._getRowState = function(nRow){
	var htStateIdxInfoOfRow = this._getIdxInfo('state', 'row');
	
	return htStateIdxInfoOfRow.containsKey(nRow) ? htStateIdxInfoOfRow.get(nRow) : 'n';
};

QBOX.QCELL.NormalQCELL.prototype._setRowState = function(nRow, strState){
	//_setRowState()는 단순히 flag만 바꾸는 함수이다.
	var arrRowHeaders = this.attr('rowheaders'), htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	result = false,heCell;
	
	switch(strState){
		case 'i': case 'u': {//'insert', 'update'
			if(this.attr('statetype') === 'later' && strState === 'u'){
				if(this._getRowState(nRow) === 'd')
					break;
			}
			if(strState === 'u' && this._getRowState(nRow) === 'i'){
				break;
			}				
			
			htStateIdxInfoOfRow.put(nRow, strState);
			result = true;
			break;
		}
		case 'd': {//'delete'
			if(this.attr('statetype') === 'later'){//'statetype'이 later일 때만 delete 플래그를 설정할 수 있다.
				htStateIdxInfoOfRow.put(nRow, strState);
				result = true;
			}
			break;
		}
		default: break;
	}
	
	if(result){
		var htSyncInfoOfRow = this._getSyncInfo('row');
		
		if(htSyncInfoOfRow.containsKey(nRow) === false){
			htSyncInfoOfRow.put(nRow, new _QHashSet());
		}
		
		htSyncInfoOfRow.get(nRow).add('state');
	}
	
	for(var i=0;i<arrRowHeaders.length ;i++){
		if(arrRowHeaders[i] === 'state'){
			heCell = this._getCellDOM(nRow,i);
			if(heCell !== undefined && heCell !== null){
				this._setRowheaderState(heCell,nRow);
			}
		}
	}
	
	return result;
};

QBOX.QCELL.NormalQCELL.prototype._removeRowState = function(nRow){
	var htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),arrRowHeaders = this.attr('rowheaders'),
	result = false;
	
	if(htStateIdxInfoOfRow.containsKey(nRow)){
		htStateIdxInfoOfRow.remove(nRow);
		result = true;
	}
	
	if(result){
		var htSyncInfoOfRow = this._getSyncInfo('row');
		
		if(htSyncInfoOfRow.containsKey(nRow)){
			var hsRowSyncInfo = htSyncInfoOfRow.get(nRow);
			
			hsRowSyncInfo.remove('state');
			
			if(hsRowSyncInfo.isEmpty()){
				htSyncInfoOfRow.remove(nRow);
			}
		}
	}
	
	for(var i=0;i<arrRowHeaders.length ;i++){
		if(arrRowHeaders[i] === 'state'){
			heCell = this._getCellDOM(nRow,i);
			if(heCell !== undefined && heCell !== null){
				this._setRowheaderState(heCell,nRow);
			}
		}
	}	

	
	return result;
};

QBOX.QCELL.NormalQCELL.prototype._clearRowStates = function(){
	var htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	htSyncInfoOfRow = this._getSyncInfo('row'),
	arrRowHeaders = this.attr('rowheaders');
	
	QBOX._.each(htStateIdxInfoOfRow.keys(), function(nRow){
		if(htSyncInfoOfRow.containsKey(nRow)){
			var hsRowSyncInfo = htSyncInfoOfRow.get(nRow);
			
			hsRowSyncInfo.remove('state');
			
			if(hsRowSyncInfo.isEmpty()){
				htSyncInfoOfRow.remove(nRow);
			}
		}
	});
	htStateIdxInfoOfRow.clear();
	
	for(var j=0;j<arrRowHeaders.length ;j++){
		if(arrRowHeaders[j] === 'state'){
			for(var i = this.getRows('header'); i< this.getRows(); i++){
				heCell = this._getCellDOM(i,j);
				if(heCell !== undefined && heCell !== null){
					this._setRowheaderState(heCell,i);
				}				
			}
		}
	}	
	
	return true;
};

QBOX.QCELL.NormalQCELL.prototype._updateRowState = function(nRow, strState){
	var result = false;
	
	switch(strState){
		case 'u': {//'update'
			if(this._getRowState(nRow) !== 'i'){
				this._setRowState(nRow, strState);
				result = true;
			}
			break;
		}
		default: {//'insert', 'delete'
			result = this._setRowState(nRow, strState);
			break;
		}
	}
	
	return result;
};

QBOX.QCELL.NormalQCELL.prototype._getState = function(/*"i"|"u"|"d"*/strState){
	var objQCell = this,
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	nHeaderRows = this.attr('headerrows'),
	result;
	
	result = [];//[{row:3, data:{}}, ....]
	
	if(strState === 'd' && this.attr('statetype') !== 'later'){//'statetype'이 'later'가 아닌 경우
		QBOX._.each(this.attr('deletedrowsdata'), function(arrDeletedRowData){
			result.push({row:-1, data:arrDeletedRowData});
		});
	} else{
		htStateIdxInfoOfRow.each(function(nRow, state){
			switch(state){
				case strState: {
					var data = {row:nRow, data:objQCell._getRowData(nRow)};
					if(strState === 'i'){
						result.push(data);
					} else {
						if(objQCell.attr('original')){
							var oridata = objQCell.attr('origindata')[nRow - nHeaderRows];
							if(QBOX._.isMatch(data.data, oridata)){
								data = QBOX._.reject(result[state], function(res){
									return res.row === nRow;
								});
							} else {
								result.push(data);
							}
						} else {
							result.push(data);
						}
					}
					
					break;
				}
				default: break;
			}
		});
	}
	
	result.sort(function(a, b){return a.row - b.row;});
	
	return result;
};

QBOX.QCELL.NormalQCELL.prototype._clearStates = function(){
	var htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	htSyncInfoOfRow = this._getSyncInfo('row'),
	arrRowHeaders = this.attr('rowheaders');
	
	this.attr('deletedrowsdata', [], 'array'); // 삭제된 행 정보 초기화
	
	QBOX._.each(htStateIdxInfoOfRow.keys(), function(nRow){ // 추가, 변경된 행 정보 제거
		if(htSyncInfoOfRow.containsKey(nRow)){
			var hsRowSyncInfo = htSyncInfoOfRow.get(nRow);
			
			hsRowSyncInfo.remove('state');
			
			if(hsRowSyncInfo.isEmpty()){
				htSyncInfoOfRow.remove(nRow);
			}
		}
	});
	htStateIdxInfoOfRow.clear();
	
	for(var j=0;j<arrRowHeaders.length ;j++){
		if(arrRowHeaders[j] === 'state'){
			for(var i = this.getRows('header'); i< this.getRows(); i++){
				heCell = this._getCellDOM(i,j);
				if(heCell !== undefined && heCell !== null){
					this._setRowheaderState(heCell,i);
				}				
			}
		}
	}	
	
	
	return true;
};

QBOX.QCELL.NormalQCELL.prototype._deleteDStates = function(){
	
	if(this.attr('statetype') !== 'later'){
		var deletedrowsdata = this.attr('deletedrowsdata');
		deletedrowsdata.pop();
		//this.attr('deletedrowsdata', deletedrowsdata, 'array');
	}
		
	if(this.attr('original')){
		var originstate = this.attr('originstate');
		originstate.d.pop();
		//this._initAttr('originstate', originstate, 'object');
	}
};

QBOX.QCELL.NormalQCELL.prototype._getStates = function(){
	var objQCell = this,
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	nHeaderRows = this.attr('headerrows'),
	result;
	
	result = {
		d: [],//[{row:-1, data:{}}, ....]
		i: [],//[{row:3, data:{}}, ....]
		u: []//[{row:3, data:{}}, ....]
	};
	
	if(this.attr('statetype') !== 'later'){//'statetype'이 'later'가 아닌 경우
		QBOX._.each(this.attr('deletedrowsdata'), function(arrDeletedRowData){
			result.d.push({row:-1, data:arrDeletedRowData});
		});
	}
	
	htStateIdxInfoOfRow.each(function(nRow, state){
		var data = {row:nRow, data:objQCell._getRowData(nRow)};
		if(state === 'i'){
			result[state].push(data);
		} else {
			if(objQCell.attr('original')){
				var originstate = objQCell.attr('originstate'),
				targetRow = nRow - nHeaderRows,
				j = 0;
				
				//console.log(originstate.d);
				for(j = 0; j < originstate.d.length; j++){
					if(originstate.d[j].nRow <= targetRow){
						targetRow++;
					}
				}
				for(j = 0; j < originstate.i.length; j++){
					if(originstate.i[j].nRow >= targetRow){
						targetRow++;
					}
				}
				
				var oridata = objQCell.attr('origindata')[targetRow];
				if(QBOX._.isMatch(data.data, oridata)){
					data = QBOX._.reject(result[state], function(res){
						return res.row === nRow;
					});
				} else {
					result[state].push(data);
				}
			} else {
				result[state].push(data);
			}
		}
	});
	
	if(this.attr('pagesyncorgindata') === true){
		result.i = [];
		result.u = [];
		
		for(var x=0;x < this.attr('data').input.length; x++){
			var obj = this.attr('data').input[x];
			if(obj.rt_qc_page_state === 'u'){
				result.u.push({row:x , data: QBOX._.clone(this.attr('data').input[x])});
			}else if(obj.rt_qc_page_state === 'i'){
				result.i.push({row:x , data: QBOX._.clone(this.attr('data').input[x])});
			}
		}
	
	}
	
	QBOX._.each(result, function(val, key){
		val.sort(function(a, b){return a.row - b.row;});
	});
	
	return result;
};
QBOX.QCELL.NormalQCELL.prototype._getAllDataStates = function(strStateName, strRowName){
	var objQCell = this,
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	result,i,nHeaderRows = this.attr('headerrows');
	
	if(strStateName === undefined || strStateName === null){
		strStateName = 'm';
	}
	if(strRowName === undefined || strRowName === null){
		strRowName = 'rownum';
	}
	
	result = this.attr('currentdata').RT_clone();
	
	for(i=0;i < result.length; i++){
		result[i][strRowName] = i+ nHeaderRows;
		result[i][strStateName] = '';
	}
	
	htStateIdxInfoOfRow.each(function(nRow, state){
		result[nRow-nHeaderRows][strStateName] = state;
	});	
	
	if(this.attr('statetype') !== 'later'){//'statetype'이 'later'가 아닌 경우
		QBOX._.each(this.attr('deletedrowsdata'), function(arrDeletedRowData){
			
			arrDeletedRowData[strRowName] = -1;
			arrDeletedRowData[strStateName] = 'd';			
			result.push(arrDeletedRowData);
		});
	}
	
	return result;
};
QBOX.QCELL.NormalQCELL.prototype._getAllDataStatesBySep = function(strStateName, strRowName,strRowSep,strColSep){
	var objQCell = this,
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	result,i,nHeaderRows = this.attr('headerrows'),objKeys={},nHeaderCols = this.attr('headercols'),
	nCols = this.attr('cols'),arrKeys =[];
	
	if(strStateName === undefined || strStateName === null){
		strStateName = 'm';
	}
	if(strRowName === undefined || strRowName === null){
		strRowName = 'rownum';
	}
	if(strRowSep === undefined || strRowSep === null){
		strRowSep = '^';
	}
	if(strColSep === undefined || strColSep === null){
		strColSep = '|';
	}	
	
	var arrResult = this._getAllDataStates(strStateName,strRowName);
	var strKeys,rowData,x,index=0;

	for(i=nHeaderCols; i< nCols;i++){
		strKeys = this._getKeyOfCol(i);
		objKeys[strKeys] = 1;
	}
	
	htStateIdxInfoOfRow.each(function(nRow, state){		
		if(state === 'u'){
			rowData = objQCell._getRowData(nRow);			
		
			for(x in rowData){
				objKeys[x] = 1;
			}			
		}
	});	
	
	if(arrResult.length){
		for(i=0; i< arrResult.length ;i++){			
			rowData = arrResult[i];					
			if(rowData[strStateName] === ''){
				for(x in rowData){
					objKeys[x] = 1;
				}
				if(index++ ===3)break;				
			}
		}
	}
	
	var strResult = strStateName + strColSep + strRowName ;
	var j, strData;
	for ( x in objKeys) {
		if(x===strStateName )
			continue;
		if(x===strRowName )
			continue;
		
		arrKeys.push(x);
		strResult += strColSep + x ;
	}
	
	strResult += strRowSep;
	
	for(i=0;i<arrResult.length ; i++){
		rowData = arrResult[i];		
		strResult += rowData[strStateName] + strColSep + rowData[strRowName] ;
		
		for(j=0;j<arrKeys.length; j++){
			strData = rowData[arrKeys[j]] === undefined ? '':rowData[arrKeys[j]];
			strResult += strColSep + strData;
		}
		
		strResult += strRowSep;
		
	}
	
	return strResult;
	
	

};

QBOX.QCELL.NormalQCELL.prototype._getStatesEx = function(propertyName){
	var objQCell = this,
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	result,obj;
	
	propertyName = propertyName === undefined ? 'status' : propertyName;
	
	result = [];
	
	if(this.attr('statetype') !== 'later'){//'statetype'이 'later'가 아닌 경우
		QBOX._.each(this.attr('deletedrowsdata'), function(arrDeletedRowData){
			obj = {row:-1, data:arrDeletedRowData};
			obj[propertyName] = 'd';
			result.push(obj);
		});
	}

	htStateIdxInfoOfRow.each(function(nRow, state){
		obj = {row:nRow, data:objQCell._getRowData(nRow)};
		obj[propertyName] = state;
		result.push(obj);
	});
	result.sort(function(a, b){return a.row - b.row;});
	
	return result;
};

QBOX.QCELL.NormalQCELL.prototype._getStatesBySep = function(rowSep,colSep,arrKeys){
	var objQCell = this,
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	result,obj,propertyName ='_qcellState',strResult = '';
	
	rowSep = rowSep === undefined ? '|' : rowSep;
	colSep = colSep === undefined ? '^' : colSep;
	arrKeys = arrKeys === undefined ? [] : arrKeys;
	
	result = [];
	
	if(this.attr('statetype') !== 'later'){//'statetype'이 'later'가 아닌 경우
		QBOX._.each(this.attr('deletedrowsdata'), function(arrDeletedRowData){
			obj = {row:-1, data:arrDeletedRowData};
			obj[propertyName] = 'd';
			result.push(obj);
		});
	}

	htStateIdxInfoOfRow.each(function(nRow, state){
		obj = {row:nRow, data:objQCell._getRowData(nRow)};
		if(obj.data === undefined)
			return;
		obj[propertyName] = state;
		result.push(obj);
	});
	result.sort(function(a, b){return a.row - b.row;});
	
	var bFirst = true;
	var arrKey = [],i,strValue;
	
	result.forEach(function (objState){
		
		if(bFirst === true){
			arrKey.push('isChecked');
			arrKey.push('tmHeader');
			for(var nCol = objQCell.getCols('header') ; nCol < objQCell.getCols() ; nCol++){
				arrKey.push(objQCell.getKeyOfCol(nCol));
			}
			
			for(var x = 0 ; x< arrKeys.length ; x++){
				arrKey.push(arrKeys[x]);
			}
		}
		
		for(var strKey in objState.data ){
			arrKey.push(strKey);
		}		
		bFirst = false;
	});
	
	arrKey = QBOX._.uniq(arrKey);
	
	strResult = '';
	
	result.forEach(function (objState){		
		if(strResult === ''){
			strResult = 'm' + colSep + 'rownum' + colSep;
			bFirst =true;
		}
		
		if(bFirst === true){			
			for(i=0;i<arrKey.length;i++){
				strResult+=arrKey[i];
				if(i+1 === arrKey.length){
					strResult += rowSep;
				}else{
					strResult += colSep;
				}
			}			
			bFirst = false;
		}
		
		var strRow = objState.row;
		
		strResult+= objState[propertyName] + colSep + strRow + colSep;
		
		for(i=0 ; i< arrKey.length ; i++){
			strValue = objState.data[arrKey[i]];
			if(arrKey[i] === 'isChecked'){
				strValue = strValue === undefined ? 'true' : strValue;
			}else if(arrKey[i] === 'tmHeader'){
				strValue = strValue === undefined ? objState._qcellState.toUpperCase() : strValue;
			}else{
				strValue = strValue === undefined ? '' : strValue;	
			}
			
			strResult+=strValue;
			if(i+1 === arrKey.length){
				strResult += rowSep;
			}else{
				strResult += colSep;
			}			
		}
	});
	
	return strResult;
};

QBOX.QCELL.NormalQCELL.prototype._getFocusRowState = function(){
	var objQCell = this,
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	htFocusIdxInfoOfRow = this._getIdxInfo('focus', 'row'),
	nRow = htFocusIdxInfoOfRow.current > -1 ? htFocusIdxInfoOfRow.current : -1,
	nHeaderRows = this.attr('headerrows'),
	result, text = [], idx = 0;
	
	result = {
		d: [],//[{row:-1, data:{}}, ....]
		i: [],//[{row:3, data:{}}, ....]
		u: []//[{row:3, data:{}}, ....]
	};
	
	if(this.attr('statetype') !== 'later'){//'statetype'이 'later'가 아닌 경우
		QBOX._.each(this.attr('deletedrowsdata'), function(arrDeletedRowData){
			result.d.push({row:-1, data:arrDeletedRowData});
		});
	}
	
	htStateIdxInfoOfRow.each(function(nRow, state){
		var data = {row:nRow, data:objQCell._getRowData(nRow)};
		if(state === 'i'){
			result[state].push(data);
		} else {
			if(objQCell.attr('original')){
				var originstate = objQCell.attr('originstate'),
				targetRow = nRow - nHeaderRows,
				j = 0;
				
				for(j = 0; j < originstate.d.length; j++){
					if(originstate.d[j].nRow <= targetRow){
						targetRow++;
					}
				}
				for(j = 0; j < originstate.i.length; j++){
					if(originstate.i[j].nRow >= targetRow){
						targetRow++;
					}
				}
				
				var oridata = objQCell.attr('origindata')[targetRow];
				if(QBOX._.isMatch(data.data, oridata)){
					data = QBOX._.reject(result[state], function(res){
						return res.row === nRow;
					});
				} else {
					result[state].push(data);
				}
			} else {
				result[state].push(data);
			}
		}
	});
	
	QBOX._.each(result, function(val, key){
		val.sort(function(a, b){return a.row - b.row;});
	});
	
	for(var i = 0; i < Object.keys(result).length; i++){ // i = key, i, d, j
		var key = Object.keys(result)[i];
		for(var j = 0 ; j < result[key].length; j++){
			if(nRow > -1 && result[key][j].row === nRow){
				text[idx] = key;
				idx++;
				//text = key;
				break;
			}
		}
	}
	
	return text;
};

QBOX.QCELL.NormalQCELL.prototype._getSelectRowState = function(row){
	var objQCell = this,
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	htFocusIdxInfoOfRow = this._getIdxInfo('focus', 'row'),
	nRow = htFocusIdxInfoOfRow.current > -1 ? htFocusIdxInfoOfRow.current : -1,
	nHeaderRows = this.attr('headerrows'),
	result, text = [], idx = 0;
	
	result = {
		d: [],//[{row:-1, data:{}}, ....]
		i: [],//[{row:3, data:{}}, ....]
		u: []//[{row:3, data:{}}, ....]
	};
	
	if(this.attr('statetype') !== 'later'){//'statetype'이 'later'가 아닌 경우
		QBOX._.each(this.attr('deletedrowsdata'), function(arrDeletedRowData){
			result.d.push({row:-1, data:arrDeletedRowData});
		});
	}
	
	htStateIdxInfoOfRow.each(function(nRow, state){
		var data = {row:nRow, data:objQCell._getRowData(nRow)};
		if(state === 'i'){
			result[state].push(data);
		} else {
			if(objQCell.attr('original')){
				var originstate = objQCell.attr('originstate'),
				targetRow = nRow - nHeaderRows,
				j = 0;
				
				for(j = 0; j < originstate.d.length; j++){
					if(originstate.d[j].nRow <= targetRow){
						targetRow++;
					}
				}
				for(j = 0; j < originstate.i.length; j++){
					if(originstate.i[j].nRow >= targetRow){
						targetRow++;
					}
				}
				
				var oridata = objQCell.attr('origindata')[targetRow];
				if(QBOX._.isMatch(data.data, oridata)){
					data = QBOX._.reject(result[state], function(res){
						return res.row === nRow;
					});
				} else {
					result[state].push(data);
				}
			} else {
				result[state].push(data);
			}
		}
	});
	
	QBOX._.each(result, function(val, key){
		val.sort(function(a, b){return a.row - b.row;});
	});
	
	for(var i = 0; i < Object.keys(result).length; i++){ // i = key, i, d, j
		var key = Object.keys(result)[i];
		for(var j = 0 ; j < result[key].length; j++){
			if(nRow > -1 && result[key][j].row === row){
				text[idx] = key;
				idx++;
				//text = key;
				break;
			}
		}
	}
	
	return text;
};

QBOX.QCELL.NormalQCELL.prototype._getAllStates = function(){
	var objQCell = this,
	htStateIdxInfoOfRow = this._getIdxInfo('state', 'row'),
	result,oriData,nHeaderRows = this.attr('headerrows'),arrTemp = [];
	
	oriData = this.attr('currentdata').RT_clone();
	
	result = {
		d: [],//[{row:-1, data:{}}, ....]
		i: [],//[{row:3, data:{}}, ....]
		u: [],//[{row:3, data:{}}, ....]
		m: []
	};
	
	if(this.attr('statetype') !== 'later'){//'statetype'이 'later'가 아닌 경우
		QBOX._.each(this.attr('deletedrowsdata'), function(arrDeletedRowData){
			result.d.push({row:-1, data:arrDeletedRowData});
		});
	}
	
	htStateIdxInfoOfRow.each(function(nRow, state){
		var data = {row:nRow, data:objQCell._getRowData(nRow)};
		if(state === 'i'){
			arrTemp.push(data.row);
			result[state].push(data);
		} else {
			if(objQCell.attr('original')){
				var originstate = objQCell.attr('originstate'),
				targetRow = nRow - nHeaderRows,
				j = 0;
				
				//console.log(originstate.d);
				for(j = 0; j < originstate.d.length; j++){
					if(originstate.d[j].nRow <= targetRow){
						targetRow++;
					}
				}
				for(j = 0; j < originstate.i.length; j++){
					if(originstate.i[j].nRow >= targetRow){
						targetRow++;
					}
				}
				
				var oridata = objQCell.attr('origindata')[targetRow];
				if(QBOX._.isMatch(data.data, oridata)){
					data = QBOX._.reject(result[state], function(res){
						return res.row === nRow;
					});
				} else {
					arrTemp.push(data.row);
					result[state].push(data);
				}
			} else {
				arrTemp.push(data.row);
				result[state].push(data);
			}
		}
	});
	
	state = 'm';
	for(var x=0; x< oriData.length ; x++){
		if(arrTemp.indexOf(x+nHeaderRows) !== -1){
			continue;
		}
		result[state].push({'row' : x+ nHeaderRows , 'data' : QBOX._.clone(oriData[x])});
	}
	
	QBOX._.each(result, function(val, key){
		val.sort(function(a, b){return a.row - b.row;});
	});
	
	return result;
};
QBOX.QCELL.NormalQCELL.prototype._updateRowSyncInfo = function (nTargetRow, nCount, /*"insert"|"delete"*/strType){
	var htSyncInfoOfRow = this._getSyncInfo('row');
	
	if(htSyncInfoOfRow.size() > 0){
		var arrSyncInfoRows = htSyncInfoOfRow.keys().sort(QBOX.st.desc);
		
		switch(strType){
			case 'i': {
				var objQCell = this,
				arrPushedRows;
				
				//'insert'시 업데이트해야 하는 'state'정보들의 행 인덱스들 중 큰 값부터 갱신해야 하므로 내림차순 정렬한다.
				//삽입 행 인덱스보다 크거나 같은 행의 state 정보들만 추출
				arrPushedRows = QBOX._.filter(arrSyncInfoRows.sort(QBOX.st.desc), function(nRow){return nRow >= nTargetRow;});
				
				//추출한 행 인덱스들의 값을 증가시켜 동기화한다.
				this._pushRowSyncInfo(arrPushedRows, nCount);
				
				break;
			}
			case 'd': {
				var arrPulledRows;
				
				//삭제된 행들의 syncinfo 정보들을 삭제한다.
				for(var i = 0; i < nCount; i++){
					if(htSyncInfoOfRow.containsKey(nTargetRow + i)){//삭제할 행 인덱스에 syncinfo정보가 있는 경우
						var arrSyncNames = htSyncInfoOfRow.get(nTargetRow + i).values();
						
						for(var j = 0, nLength = arrSyncNames.length; j < nLength; j++){
							var strSyncName = arrSyncNames[j];
							
							switch(strSyncName){
								case 'style': {
									this._removeCellStylesOfRow(nTargetRow + i, false);
									break;
								}
								case 'state': {
									this._removeRowState(nTargetRow + i);
									break;
								}
								default: break;
							}
						}
					}
				}
				
				//'delete'시 업데이트해야 하는 'state'정보들의 행 인덱스들 중 작은 값부터 갱신해야 하므로 오름차순 정렬한다.
				arrSyncInfoRows.reverse();
				
				//삭제된 행 인덱스보다 큰 행의 state 정보들만 추출
				arrPulledRows = QBOX._.filter(arrSyncInfoRows, function(nRow){return nRow >= nTargetRow + nCount;});
				
				//추출한 행 인덱스들의 값을 감소시켜 동기화한다.
				this._pullRowSyncInfo(arrPulledRows, nCount);
				
				break;
			}
			default: break;
		}
	}
};

QBOX.QCELL.NormalQCELL.prototype._updateRowSyncInfoEx = function (arrRows, /*"insert"|"delete"*/strType){
	var htSyncInfoOfRow = this._getSyncInfo('row'),
	nCount = arrRows.length;
	
	if(htSyncInfoOfRow.size() > 0 && nCount > 0){
		var objQCell = this;
		
		switch(strType){
			case 'i': {
				var arrPushList = [],
				arrPushedRows;
				
				//삽입 행 인덱스들 중 가장 작은 값보다 크거나 같은 행의 'state' 정보들만 추출
				//차집합 계산 성능을 위해 일단은 오름차순으로 정렬한다.
				arrPushedRows = QBOX._.filter(htSyncInfoOfRow.keys().sort(QBOX.st.asc), function(nRow){return nRow >= arrRows[nCount - 1];});
				
				QBOX._.each(arrRows, function(nTargetRow, idx){
					//삽입 행 인덱스보다 크거나 같은 행의 'state' 정보들만 추출
					var arrPushedRowsOfTargetRow = QBOX._.filter(arrPushedRows, function(nRow){return nRow >= nTargetRow;});
					
					//성능을 위해 여러번 행 인덱스들의 값을 증가시켜 동기화하지 않고, 한번만 동기화하도록 동기화된 정보들은 검색대상에서 제거한다.
					arrPushedRows.RT_difference(arrPushedRowsOfTargetRow);
					
					//'insert'시 업데이트해야 하는 'state'정보들의 행 인덱스들 중 큰 값부터 갱신해야 하므로 내림차순 정렬한다.
					arrPushedRowsOfTargetRow.reverse();
					
					arrPushList.push(arrPushedRowsOfTargetRow);
				});
				
				QBOX._.each(arrPushList, function(arrPushedRowsOfTargetRow, idx){
					//추출한 행 인덱스들의 값을 증가시켜 동기화한다.
					objQCell._pushRowSyncInfo(arrPushedRowsOfTargetRow, nCount - idx);
				});
				
				break;
			}
			case 'd': {
				var arrPullList = [],
				arrPulledRows;
				
				//삭제된 행들의 syncinfo 정보들을 삭제한다.
				QBOX._.each(arrRows, function(nTargetRow){
					if(htSyncInfoOfRow.containsKey(nTargetRow)){//삭제할 행 인덱스에 syncinfo정보가 있는 경우
						var arrSyncNames = htSyncInfoOfRow.get(nTargetRow).values();
						
						for(var j = 0, nLength = arrSyncNames.length; j < nLength; j++){
							var strSyncName = arrSyncNames[j];
							
							switch(strSyncName){
								case 'style': {
									objQCell._removeCellStylesOfRow(nTargetRow, false);
									break;
								}
								case 'state': {
									objQCell._removeRowState(nTargetRow);
									break;
								}
								default: break;
							}
						}
					}
				});
				
				//삭제된 행 인덱스들 중 가장 작은 값보다 큰 행의 'state' 정보들만 추출
				//차집합 계산 성능을 위해 일단은 오름차순으로 정렬한다.
				arrPulledRows = QBOX._.filter(htSyncInfoOfRow.keys().sort(QBOX.st.asc), function(nRow){return nRow > arrRows[nCount - 1];});
				
				QBOX._.each(arrRows, function(nTargetRow, idx){
					//삭제된 행 인덱스보다 큰 행의 'state' 정보들만 추출
					var arrPulledRowsOfTargetRow = QBOX._.filter(arrPulledRows, function(nRow){return nRow > nTargetRow;});
					
					//성능을 위해 여러번 행 인덱스들의 값을 감소시켜 동기화하지 않고, 한번만 동기화하도록 동기화된 정보들은 검색대상에서 제거한다.
					arrPulledRows.RT_difference(arrPulledRowsOfTargetRow);
					
					//'delete'시 업데이트해야 하는 'state'정보들의 행 인덱스들 중 작은 값부터 갱신해야 하므로 오름차순 정렬한다.
					//arrPulledRowsOfTargetRow.sort(QBOX.st.asc);
					
					arrPullList.push(arrPulledRowsOfTargetRow);
				});
				
				//arrRows의 오름차순으로 pull해야 한다.
				arrPullList.reverse();
				
				QBOX._.each(arrPullList, function(arrPulledRowsOfTargetRow, idx){
					//추출한 행 인덱스들의 값을 감소시켜 동기화한다.
					objQCell._pullRowSyncInfo(arrPulledRowsOfTargetRow, idx + 1);
				});
				
				break;
			}
			default: break;
		}
	}
};

QBOX.QCELL.NormalQCELL.prototype._pushRowSyncInfo = function (arrPushedRows, nCount){
	if(arrPushedRows.length > 0){
		var htSyncInfoOfRow = this._getSyncInfo('row');
		
		if(htSyncInfoOfRow.size() > 0){
			var objQCell = this;
			
			QBOX._.each(arrPushedRows, function(nRow){
				//console.log(nRow, ':', htSyncInfoOfRow.get(nRow).values());
				var hsBeforeSyncInfoOfRow = htSyncInfoOfRow.remove(nRow);
				
				QBOX._.each(hsBeforeSyncInfoOfRow.values(), function(strSyncName){
					//'style', 'state'정보의 행 인덱스들을 업데이트한다.
					switch(strSyncName){
						case 'style': {
							var htStyleIdxInfoOfRow = objQCell._getIdxInfo('style', 'row'),
							htStyleIdxInfoOfCol = objQCell._getIdxInfo('style', 'col'),
							htStyleColIndexOfRow = htStyleIdxInfoOfRow.remove(nRow);
							
							//console.log(htStyleColIndexOfRow.keys());
							htStyleIdxInfoOfRow.put(nRow + nCount, htStyleColIndexOfRow);
							
							QBOX._.each(htStyleColIndexOfRow.keys(), function(nCol){
								var htStyleRowIndexOfCol = htStyleIdxInfoOfCol.get(nCol);
								
								htStyleRowIndexOfCol.put(nRow + nCount, htStyleRowIndexOfCol.remove(nRow));
							});
							
							break;
						}
						case 'state': {
							var htStateIdxInfoOfRow = objQCell._getIdxInfo('state', 'row');
							
							htStateIdxInfoOfRow.put(nRow + nCount, htStateIdxInfoOfRow.remove(nRow));
							
							break;
						}
						default: break;
					}
				});
				
				htSyncInfoOfRow.put((nRow + nCount), hsBeforeSyncInfoOfRow);
			});
		}
	}
};

QBOX.QCELL.NormalQCELL.prototype._pullRowSyncInfo = function (arrPulledRows, nCount){
	if(arrPulledRows.length > 0){
		var htSyncInfoOfRow = this._getSyncInfo('row');
		
		if(htSyncInfoOfRow.size() > 0){
			var objQCell = this;
			
			QBOX._.each(arrPulledRows, function(nRow){
				//console.log(nRow, ':', htSyncInfoOfRow.get(nRow).values());
				var hsBeforeSyncInfoOfRow = htSyncInfoOfRow.remove(nRow);
				
				QBOX._.each(hsBeforeSyncInfoOfRow.values(), function(strSyncName){
					//'style', 'state'정보의 행 인덱스들을 업데이트한다.
					switch(strSyncName){
						case 'style': {
							var htStyleIdxInfoOfRow = objQCell._getIdxInfo('style', 'row'),
							htStyleIdxInfoOfCol = objQCell._getIdxInfo('style', 'col'),
							htStyleColIndexOfRow = htStyleIdxInfoOfRow.remove(nRow);
							
							//console.log(htStyleColIndexOfRow.keys());
							htStyleIdxInfoOfRow.put(nRow - nCount, htStyleColIndexOfRow);
							
							QBOX._.each(htStyleColIndexOfRow.keys(), function(nCol){
								var htStyleRowIndexOfCol = htStyleIdxInfoOfCol.get(nCol);
								
								htStyleRowIndexOfCol.put(nRow - nCount, htStyleRowIndexOfCol.remove(nRow));
							});
							
							break;
						}
						case 'state': {
							var htStateIdxInfoOfRow = objQCell._getIdxInfo('state', 'row');
							
							htStateIdxInfoOfRow.put(nRow - nCount, htStateIdxInfoOfRow.remove(nRow));
							
							break;
						}
						default: break;
					}
				});
				
				htSyncInfoOfRow.put((nRow - nCount), hsBeforeSyncInfoOfRow);
			});
		}
	}
};

QBOX.QCELL.NormalQCELL.prototype._showGrandTotal = function(heCell,nRow,nCol,strData){
	var css = QBOX.QCELL.def.css;
	var obj = this.getRowData(nRow);
	if(obj !== undefined && obj._rtqc_state === 'gt' ){
		QBOX.util.addClass(heCell, css.GRANDTOTAL);
		QBOX.util.textContent(heCell,strData);
	}else{
		QBOX.util.removeClass(heCell, css.GRANDTOTAL);
	}
	this._setAriaLabelEx(heCell,nRow,nCol);
};
QBOX.QCELL.NormalQCELL.prototype._setTDSub = function(heCell,strColType,strDataFormat,cellData,arrRowData){
		switch(strColType){
		case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton' :{
			this._setGroupTreeDataCell(heCell, strDataFormat,arrRowData);
			break;
		}
		default: {
			this._setGroupTreeDataCell(heCell, cellData,arrRowData);
			break;
		}
	}
};
QBOX.QCELL.NormalQCELL.prototype._setTHSub = function(heCell,objNode,strColType,strDataFormat,cellData){
	switch(strColType){
	case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton' : {
		//이벤트가 걸린 tree아이콘과 레벨 별 들여쓰기, 텍스트를 세팅하는 함수 호출(heCell, 레벨정보, 접고펼침정보);
		this._setGroupTreeUICell(heCell, objNode, strDataFormat);
		break;
	}
	default: {
		this._setGroupTreeUICell(heCell, objNode, cellData);
		break;
	}
}
};
QBOX.QCELL.NormalQCELL.prototype._refreshHRs = function(){//HRs -> HeaderRows
	//_refreshHRs()은 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 HeaderRows에 반영하기 위해 사용되는 함수이다.
	//HeaderRows영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshHRs()를 사용해야 한다.
	try{
		var objQCell = this,
		arrHeaderText = this.attr('headertext'),
		arrHeaderRowsCellDOMs = this._getCellGroupDOMs('row', 'header'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'),strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}
		
		/*merge********************************************************************/
		this._clearMergeHeader(); // Merge 정보 클리어
		this._createHeaderMergeInfo();
		/*merge********************************************************************/
		
		QBOX._.each(arrHeaderRowsCellDOMs, function(arrHeaderRowCellDOMs, idx){
			var nRow = idx,
			bStyleRow = objQCell._isCellStyleRow(nRow);
			
			QBOX._.each(arrHeaderRowCellDOMs, function(heCell, idx2){
				if(heCell !== null){//멀티캡션 사용 시 headerCols의 HeaderRows영역은 첫번째 행만 셀 div가 존재한다.
					if(heCell.getAttribute('data-footer') !== 'true'){
						var nCol = parseInt(heCell.getAttribute('data-col'));
						if(isNaN(nCol))
							return;
						var strColType = objQCell._getColType(nCol),
						bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
						strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow];
						
						heCell.setAttribute('data-row', nRow);
						heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
						
						if(nCol >= nHeaderCols){//HeaderCols가 아니면
							if( strColType === 'checkbox' || strColType === 'html') {
								objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
								/*
								if(this._getQCellCol(nCol).attr('sort') === false) {
									objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
								} else {
									QCELL.log('err', 'QCELL.NormalQCELL._refreshHRs', 'can not use "sort" to col type "checkbox" or "html"');
									return false;
								}
								*/
							}  else{
								heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText,nRow,nCol);
								
								if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
									if(objQCell.attr('useGroupUI')){
										QBOX.$(heCell).draggable({
											helper: objQCell._setGroupMakeHelper,
											revert: 'invalid'
										});
									}
								}
							}
							
							if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
								
								if(objQCell._getQCellCol(nCol).attr('move')){
									heCell.appendChild(objQCell._getColHeaderDragDropArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('search')){
									heCell.appendChild(objQCell._getColSearchArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('sort') && (QBOX._.isUndefined(objQCell._getQCellCol(nCol).attr('options').wholeselect) || objQCell._getQCellCol(nCol).attr('options').wholeselect === false) && (strColType !== 'checkbox' || objQCell.attr('paginationinfo').totalsort === false || (QBOX._.isUndefined(objQCell.attr('paginationinfo')) === false && QBOX._.isUndefined(objQCell.attr('paginationinfo').url)))){
									heCell.appendChild(objQCell._getDefaultSortArea(nCol));
								}
								
								if(objQCell._getQCellCol(nCol).attr('resize')){
									heCell.appendChild(objQCell._getColResizeArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('filter')){									
									heCell.appendChild(objQCell._getFilterArea(nCol));
								}
								
								if(objQCell._getQCellCol(nCol).attr('editor')){
									heCell.appendChild(objQCell._getColStyleEditorArea());
								}
								if(objQCell._getQCellCol(nCol).attr('remove')){
									heCell.appendChild(objQCell._getDefaultRemoveArea(nCol));
								}
							}
						}
						
						if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
							objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
						}
					}
				}
			});
		});
		
		/*merge********************************************************************/
		//this._clearMergeHeader(); //머지 정보 설정
		this._updateMergeHeader(); //머지 정보 갱신
		/*merge********************************************************************/
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._refreshHRs', e.message);
	}
};
QBOX.QCELL.NormalQCELL.prototype._getHFNodeLevel = function (objNode,objGroupState,nRow){

	var retobjNode , nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
	
	if(nIdxOfGroupHeaderRow > -1){
		retobjNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
	} else{
		var nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
		
		if(nIdxOfGroupFooterRow > -1){
			retobjNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
		}
	}
	if(retobjNode !== null && retobjNode.level !== undefined)
		return retobjNode.level;
	return 'lev0' ;
};

QBOX.QCELL.NormalQCELL.prototype._refreshHCs = function(){//HCs -> HeaderCols
	//_refreshHCs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 HeaderCols에 반영하기 위해 사용되는 함수이다.
	//HeaderCols영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshHCs()를 사용해야 한다.
	try{
		var css = QBOX.QCELL.def.css,
		objQCell = this,
		arrHeaderColsCellDOMs = this._getCellGroupDOMs('col', 'header'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'),
		nAdjustColWidths = 0,
		staticrowsinfo = this.attr('staticrowsinfo'),
		bMake = true, staticrow = -1,strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}
		
		
		QBOX._.each(arrHeaderColsCellDOMs, function(arrHeaderColCellDOMs, idx){
			var nCol = idx,
			nColWidth = objQCell._getColWidth(nCol),
			nCellLeft = nAdjustColWidths,
			keyOfCol = objQCell._getKeyOfCol(nCol),
			bStyleCol = objQCell._isCellStyleCol(nCol),
			objColStyle = objQCell._getQCellCol(nCol).attr('style');
			
			QBOX._.each(arrHeaderColCellDOMs, function(heCell){
				if(heCell !== null){//멀티캡션 사용 시 headerCols의 HeaderRows영역은 첫번째 행만 셀 div가 존재한다.
					heCell.setAttribute('data-col', nCol);
					heCell.style.left = nCellLeft + 'px';
					if(nColWidth !== parseInt(heCell.style.width)){
						heCell.style.width = nColWidth + 'px';
					}
					
					if(heCell.getAttribute('data-footer') !== 'true'){
						var nRow = parseInt(heCell.getAttribute('data-row')),
						bHeaderRow = nRow < nHeaderRows,
						bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
						strColStyleGroup = bHeaderRow ? 'header' : 'data';
						
						heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
						
						QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
						
						bMake = true;
						if(staticrowsinfo.length > 0){
							for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
								if(staticrowsinfo[staticrow].nRow === nRow){
									bMake = false;
								}
							}
						}
						
						if(!QBOX._.isEmpty(objColStyle)){
							if(QBOX._.isObject(objColStyle[strColStyleGroup])){
								var keys = Object.keys(objColStyle[strColStyleGroup]);
								for(var k = 0; k < keys.length; k++){
									QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
								}
							}
							objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
						}
						
						if(nRow >= nHeaderRows){//HeaderRows가 아니면
							var objPaginationInfo = objQCell.attr('paginationinfo'),
							heCheckbox;
							
							if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									
									if(objQCell._isBottomPanel(heCell)){
										if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
											QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										return;
									}
										
									
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows + nR) : nRow - nHeaderRows + 1);
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
									heCell.innerHTML = '';
									
									if(objQCell._isBottomPanel( heCell ))
										return;
									
									if(bMake){
										heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
										heCell.appendChild(heCheckbox);
										
										if(arrRowHeaders[nCol]==='checkbox')
											heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
										else
											heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;
										
									}
								} else if(arrRowHeaders[nCol] === 'state') {
									if(objQCell._isBottomPanel( heCell  ))
										return;
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									if(objQCell._isBottomPanel( heCell  ))
										return;
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
								
							} else {
								var nPageRow = nRow;
								// multiheader 일 때
								if(nHeaderRows > 1) {
									nPageRow = nRow - (nHeaderRows - 1);
								}
								
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									if(objQCell._isBottomPanel(heCell)){
										if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
											QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										return;
									}
									
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
									
								} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
									heCell.innerHTML = '';
									
									if(objQCell._isBottomPanel( heCell )){
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										return;	
									}
													
									
									if(bMake){
										heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
										heCell.appendChild(heCheckbox);
										
										if(arrRowHeaders[nCol]==='checkbox')
											heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
										else
											heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

									}
								} else if(arrRowHeaders[nCol] === 'state') {
									if(objQCell._isBottomPanel(heCell))
										return;
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									if(objQCell._isBottomPanel(heCell))
										return;
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							}
						}
						
						if(bStyleCell){//셀 스타일을 적용해야 하는 경우
							objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
						}
					}
				}
			});
			
			nAdjustColWidths += nColWidth;
		});
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._refreshHCs', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype._refreshFRs = function(){//FRs -> FrozenRows
	//_refreshFRs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 FrozenRows에 반영하기 위해 사용되는 함수이다.
	//FrozenRows영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshFRs()를 사용해야 한다.
	try{
		var css = QBOX.QCELL.def.css,
		objQCell = this,
		objGroupState =  this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrFrozenRowsCellDOMs = this._getCellGroupDOMs('row', 'frozen'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'),
		nHighlightRepeat = this.attr('highlightrepeat'),
		bIsRowSelectMode = this.attr('selectmode').indexOf('row') > -1 ? true : false,
		cellData,objNode,
		staticrowsinfo = this.attr('staticrowsinfo'),
		bMake = true, staticrow = -1,strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}
		
		/*merge********************************************************************/
		this._clearMergeData(); // Merge 정보 클리어
		this._createDataMergeInfo();
		/*merge********************************************************************/
		
		QBOX._.each(arrFrozenRowsCellDOMs, function(arrFrozenRowCellDOMs, idx){
			var nRow = nHeaderRows + idx,
			nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
			bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
			objNode = null,
			arrRowData = arrCurrentData[nRow - nHeaderRows],
			bFocusRow = objQCell._isFocusRow(nRow),
			bSelectedRow = objQCell._isSelectedRow(nRow),
			bStyleRow = objQCell._isCellStyleRow(nRow),
			bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
			
			bMake = true;
			if(staticrowsinfo.length > 0){
				for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
					if(staticrowsinfo[staticrow].nRow === nRow){
						bMake = false;
					}
				}
			}
			
			if(objGroupState.grouped){
				if(objGroupState.type === 'tree' || objGroupState.type === 'step' ){
					nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
				}
				
				if(nIdxOfGroupTreeUIRow > -1){
					bIsGroupTreeUIRow = true;
					objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
					
					bIsGroupHeaderRow = bIsGroupFooterRow = false;
				} else{
					nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
					
					if(nIdxOfGroupHeaderRow > -1){
						bIsGroupHeaderRow = true;
						objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
						
						bIsGroupFooterRow = false;
					} else{
						nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
						
						if(nIdxOfGroupFooterRow > -1){
							bIsGroupFooterRow = true;
							objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
							
							bIsGroupHeaderRow = false;
						}
					}
				}
			}
			
			QBOX._.each(arrFrozenRowCellDOMs, function(heCell, idx2){
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nCol = parseInt(heCell.getAttribute('data-col')),
					strColID = objQCell._getColID(nCol),
					strColType = objQCell._getColType(nCol),
					keyOfCol = objQCell._getKeyOfCol(nCol),
					bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
					bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
					bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
					heCheckbox,
					strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
					objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow],strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
					
					heCell.setAttribute('data-row', nRow);
					heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
					
					if(nCol < nHeaderCols){
						var objPaginationInfo = objQCell.attr('paginationinfo');
						
						if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								if(objQCell._isBottomPanel(heCell)){
									if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
										QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									}
									return;
								}
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows + nR) : nRow - nHeaderRows + 1);
								
							} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
								heCell.innerHTML = '';
								
								if(objQCell._isBottomPanel( heCell ))
									return;								
								
								if(bMake){
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
									heCell.appendChild(heCheckbox);
									
									if(arrRowHeaders[nCol]==='checkbox')
										heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
									else
										heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

								}
							} else if(arrRowHeaders[nCol] === 'state') {
								if(objQCell._isBottomPanel(heCell))return;
								
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								if(objQCell._isBottomPanel(heCell))return;
								
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
							objQCell._setAriaLabelEx(heCell,nRow,nCol);
						} else {
							var nPageRow = nRow;
							// multiheader 일 때
							if(nHeaderRows > 1) {
								nPageRow = nRow - (nHeaderRows - 1);
							}
							
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {	
								if(objQCell._isBottomPanel(heCell)){
									if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
										QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									}
									return;
								}
								
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
								heCell.innerHTML = '';
								
								if(objQCell._isBottomPanel( heCell ))return;
								
								if(bMake){
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
									heCell.appendChild(heCheckbox);
									
									if(arrRowHeaders[nCol]==='checkbox')
										heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
									else
										heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

								}
							} else if(arrRowHeaders[nCol] === 'state') {
								if(objQCell._isBottomPanel(heCell))return;
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								if(objQCell._isBottomPanel(heCell))return;
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						}
					} else{
						cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
						var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
						strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData);
						
						QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
						
						if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
							if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
								if(objNode.key === strDataFormat && objNode.level + nHeaderCols === nCol){
									//tree 아이콘 표시									
									objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
								} else if(strDataFormat !== ''){
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);									
								} else { // 공백 처리
									QBOX.util.textContent(heCell, strDataFormat);
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								}
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
								var parentGroupRowInfo = {};
								for(var i = 0; i < objGroupState.treeuirows.length; i++){
									if(nRow > objGroupState.treeuirows[i]){
										parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
									} else {
										break;
									}
								}
								
								if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
									//objQCell._setGroupTreeDataCell(heCell, strDataFormat);
								} else {
									switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
								}
								}
							} else {
								if(bIsGroupHeaderRow || bIsGroupFooterRow){							
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}

									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
								}
							}
						} else if(objGroupState.grouped && strColID === strFirstGroupColID  && objGroupState.type === 'tree'){
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
	
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
								}
							}
						} else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									if(parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton' : {
											QBOX.util.textContent(heCell, strDataFormat);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										default: {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								} else {
									QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider': {
											QBOX.util.textContent(heCell, strDataFormat);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'multicheckbox': case 'inputbutton': {
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
	
										default: {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
									
									if(staticrowsinfo.length > 0){
										for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
											if(staticrowsinfo[staticrow].nRow === nRow){
												QBOX.util.addClass(heCell, ' rt-qc-staticrow-' + strColID);
												QBOX.util.textContent(heCell, strDataFormatStatic);
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
									}
									objQCell._showGrandTotal(heCell,nRow,nCol,cellData);

								}
							}
							
						}  else{
							if(bIsGroupHeaderRow || bIsGroupFooterRow){
								if(parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								switch(strColType){
									case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton' : {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
								}
							} else {
								QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											if(bMake){
												QBOX.util.textContent(heCell, strDataFormat);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										if(bMake){
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										if(bMake){
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										
										break;
									}

									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
								
								if(staticrowsinfo.length > 0){
									for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
										if(staticrowsinfo[staticrow].nRow === nRow){
											QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
											QBOX.util.textContent(heCell, strDataFormatStatic);
											break;
										}
									}
								}
								objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
							}
						}
					}
					
					if(objCellInvisible){
						objQCell._setCellInvisible(nRow, nCol, true);
					}
					
					if(nCol >= nHeaderCols){
						if(bHighlightRepeatRow){
							QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
						}
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
					if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
				}
			});
		});
		
		/*merge********************************************************************/
		this._updateMergeData(); //머지 정보 설정
		/*merge********************************************************************/
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._refreshFRs', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype._refreshFBRs = function(){//FBRs -> FrozenBottomRows
	//_refreshFBRs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 FrozenBottomRows에 반영하기 위해 사용되는 함수이다.
	//FrozenBottomRows영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshFBRs()를 사용해야 한다. 
	try{
		var css = QBOX.QCELL.def.css,
		objVSInfo = this.attr('vsinfo'), objQCell = this,
		objGroupState =  this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrFrozenBottomRowsCellDOMs = this._getCellGroupDOMs('row', 'frozenbottom'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'),
		nHighlightRepeat = this.attr('highlightrepeat'),
		bIsRowSelectMode = this.attr('selectmode').indexOf('row') > -1 ? true : false,
		cellData,objNode,
		staticrowsinfo = this.attr('staticrowsinfo'),
		bMake = true, staticrow = -1,
		bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false,strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}
		
		/*merge********************************************************************/
		this._clearMergeData(); // Merge 정보 클리어
		this._createDataMergeInfo();
		/*merge********************************************************************/
		
		QBOX._.each(arrFrozenBottomRowsCellDOMs, function(arrFrozenBottomRowCellDOMs, idx){
			var nRow = objVSInfo.nEndRow + idx + 1,
			nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
			bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
			objNode = null,
			arrRowData = arrCurrentData[nRow - nHeaderRows],
			bFocusRow = objQCell._isFocusRow(nRow),
			bSelectedRow = objQCell._isSelectedRow(nRow),
			bStyleRow = objQCell._isCellStyleRow(nRow),
			bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
			
			bMake = true;
			
			if(nRow <= nHeaderRows)
				return;
			
			if(staticrowsinfo.length > 0){
				for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
					if(staticrowsinfo[staticrow].nRow === nRow){
						bMake = false;
					}
				}
			}
			
			if(objGroupState.grouped){
				if(objGroupState.type === 'tree' || objGroupState.type === 'step'){
					nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
				}
				
				if(nIdxOfGroupTreeUIRow > -1){
					bIsGroupTreeUIRow = true;
					objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
					
					bIsGroupHeaderRow = bIsGroupFooterRow = false;
				} else{
					nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
					
					if(nIdxOfGroupHeaderRow > -1){
						bIsGroupHeaderRow = true;
						objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
						
						bIsGroupFooterRow = false;
					} else{
						nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
						
						if(nIdxOfGroupFooterRow > -1){
							bIsGroupFooterRow = true;
							objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
							
							bIsGroupHeaderRow = false;
						}
					}
				}
			}
			
			QBOX._.each(arrFrozenBottomRowCellDOMs, function(heCell, idx2){
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nCol = parseInt(heCell.getAttribute('data-col')),
					strColID = objQCell._getColID(nCol),
					strColType = objQCell._getColType(nCol),
					keyOfCol = objQCell._getKeyOfCol(nCol),
					bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
					bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
					bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
					nHeaderRows = objQCell.attr('headerrows'),
					strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
					objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow],
					heCheckbox,strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
					
					if(bPanel === true && strColType !== 'checkbox'){
						strColType = 'static';
					}
					
					heCell.setAttribute('data-row', nRow);
					heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
					
					if(nCol < nHeaderCols){
						var objPaginationInfo = objQCell.attr('paginationinfo');
						
						if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {	
								if(objQCell._isBottomPanel(heCell)){
									if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
										QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									}else{
										QBOX.util.textContent(heCell,'');
										objQCell._setAriaLabelEx(heCell,nRow,nCol);										
									}
									return;
								}
								
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows + nR) : nRow - nHeaderRows + 1);
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
								heCell.innerHTML = '';
								
								if(objQCell._isBottomPanel( heCell ))return;
								
								if(bMake){
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
									heCell.appendChild(heCheckbox);
									
									if(arrRowHeaders[nCol]==='checkbox')
										heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
									else
										heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

								}
							} else if(arrRowHeaders[nCol] === 'state') {
								if(objQCell._isBottomPanel(heCell))return;	
								
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								if(objQCell._isBottomPanel(heCell))return;
								
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						} else {
							var nPageRow = nRow;
							// multiheader 일 때
							if(nHeaderRows > 1) {
								nPageRow = nRow - (nHeaderRows - 1);
							}
							
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {				
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
								heCell.innerHTML = '';
								
								if(objQCell._isBottomPanel( heCell ))return;								
								
								if(bMake){
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
									heCell.appendChild(heCheckbox);
									
									if(arrRowHeaders[nCol]==='checkbox')
										heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
									else
										heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

								}
							} else if(arrRowHeaders[nCol] === 'state') {
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						}
					} else{
						cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
						var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
						strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData);
						
						if(bPanel === true ){
							strDataFormat = cellData;
							strDataFormatStatic = cellData;
						}
						
						QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
						
						if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
							
							if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
								if(objNode.key === strDataFormat && objNode.level + nHeaderCols === nCol){
									//tree 아이콘 표시
									objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
								} else if(strDataFormat !== ''){
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else { // 공백 처리
									QBOX.util.textContent(heCell, strDataFormat);
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
								var parentGroupRowInfo = {};
								for(var i = 0; i < objGroupState.treeuirows.length; i++){
									if(nRow > objGroupState.treeuirows[i]){
										parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
									} else {
										break;
									}
								}
								
								if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else {
									switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
								}
							} else {
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}

									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
							}
						} else if(objGroupState.grouped && strColID === strFirstGroupColID && objGroupState.type === 'tree'){
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}

									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
							}
						}    else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									if(parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton' : {
											QBOX.util.textContent(heCell, strDataFormat);
											break;
										}
										default: {
											QBOX.util.textContent(heCell, cellData);
											break;
										}
										
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else {
									QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider':  {
											QBOX.util.textContent(heCell, strDataFormat);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'multicheckbox': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}

										default: {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
							}
							
						} else{
							if(bIsGroupHeaderRow || bIsGroupFooterRow){
								if(parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								switch(strColType){
									case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton' : {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										break;
									}
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										break;
									}
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else {
								QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											if(bMake){
												QBOX.util.textContent(heCell, strDataFormat);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										if(bMake){
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										if(bMake){
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
								
								if(staticrowsinfo.length > 0){
									for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
										if(staticrowsinfo[staticrow].nRow === nRow){
											QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
											QBOX.util.textContent(heCell, strDataFormatStatic);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
								
								objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
								
							}
						}
					}
					
					if(objCellInvisible){
						objQCell._setCellInvisible(nRow, nCol, true);
					}
					
					if(nCol >= nHeaderCols){
						if(bHighlightRepeatRow){
							QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
						}
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
					if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
				}
			});
		});
		
		/*merge********************************************************************/
		this._updateMergeData(); //머지 정보 설정
		/*merge********************************************************************/
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._refreshFBRs', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype._refreshNRs = function(){//NRs -> NormalRows
	//_refreshNRs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 NormalRows에 반영하기 위해 사용되는 함수이다.
	//NormalRows영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshNRs()를 사용해야 한다.
	try{
		var css = QBOX.QCELL.def.css,
		objVSInfo = this.attr('vsinfo'), objQCell = this,
		objGroupState =  this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrNormalRowsCellDOMs = this._getCellGroupDOMs('row', 'normal'),
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'),
		nHighlightRepeat = this.attr('highlightrepeat'),
		bIsRowSelectMode = this.attr('selectmode').indexOf('row') > -1 ? true : false,
		cellData, objNode,
		staticrowsinfo = this.attr('staticrowsinfo'),
		bMake = true, staticrow = -1,strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}		
		
		/*merge********************************************************************/
		this._clearMergeData(); // Merge 정보 클리어
		this._createDataMergeInfo();
		/*merge********************************************************************/
		
		QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, idx){
			var nRow = objVSInfo.nTopRow + idx,
			nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
			bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
			objNode = null,
			arrRowData = arrCurrentData[nRow - nHeaderRows],
			bFocusRow = objQCell._isFocusRow(nRow),
			bSelectedRow = objQCell._isSelectedRow(nRow),
			bStyleRow = objQCell._isCellStyleRow(nRow),
			bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
			
			bMake = true;
			if(staticrowsinfo.length > 0){
				for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
					if(staticrowsinfo[staticrow].nRow === nRow){
						bMake = false;
					}
				}
			}
			
			if(objGroupState.grouped){
				if(objGroupState.type === 'tree' || objGroupState.type === 'step' ){
					nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
				}
				
				if(nIdxOfGroupTreeUIRow > -1){
					bIsGroupTreeUIRow = true;
					objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
					
					bIsGroupHeaderRow = bIsGroupFooterRow = false;
				} else{
					nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
					
					if(nIdxOfGroupHeaderRow > -1){
						bIsGroupHeaderRow = true;
						objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
						
						bIsGroupFooterRow = false;
					} else{
						nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
						
						if(nIdxOfGroupFooterRow > -1){
							bIsGroupFooterRow = true;
							objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
							
							bIsGroupHeaderRow = false;
						}
					}
				}
			}
			
			QBOX._.each(arrNormalRowCellDOMs, function(heCell, idx2){
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nCol = parseInt(heCell.getAttribute('data-col'));
					if(isNaN(nCol)){
						return;
					}
					var strColID = objQCell._getColID(nCol),
					strColType = objQCell._getColType(nCol),
					keyOfCol = objQCell._getKeyOfCol(nCol),
					bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
					bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
					bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
					heCheckbox,
					strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
					objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow],strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
					
					heCell.setAttribute('data-row', nRow);
					heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
					
					if(nCol < nHeaderCols){
						var objPaginationInfo = objQCell.attr('paginationinfo');
						
						if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {	
								if(objQCell._isBottomPanel(heCell)){
									if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
										QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									}
									return;
								}
								
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows+nR) : nRow - nHeaderRows + 1);
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
								heCell.innerHTML = '';
								
								if(objQCell._isBottomPanel( heCell ))return;								
								
								if(bMake){
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
									heCell.appendChild(heCheckbox);
									
									if(arrRowHeaders[nCol]==='checkbox')
										heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
									else
										heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

								}
							} else if(arrRowHeaders[nCol] === 'state') {
								if(objQCell._isBottomPanel(heCell))return;
								
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								if(objQCell._isBottomPanel(heCell))return;
								
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						} else {
							var nPageRow = nRow;
							// multiheader 일 때
							if(nHeaderRows > 1) {
								nPageRow = nRow - (nHeaderRows - 1);
							}
							
							if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
								if(objQCell._isBottomPanel(heCell)){
									if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
										QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									}
									return;
								}
								
								QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
								heCell.innerHTML = '';
								
								if(objQCell._isBottomPanel( heCell ))
									return;
								
								if(bMake){
									heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
									heCell.appendChild(heCheckbox);
									
									if(arrRowHeaders[nCol]==='checkbox')
										heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
									else
										heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

								}
							}else if(arrRowHeaders[nCol] === 'state') {
								if(objQCell._isBottomPanel(heCell))
									return;
								
								objQCell._setRowheaderState(heCell,nRow);
							} else if(arrRowHeaders[nCol] === 'custom') {
								if(objQCell._isBottomPanel(heCell))
									return;
								
								objQCell._setRowheaderCustom(heCell,nRow,nCol);
							}
						}
					} else{
						if(arrRowData !== undefined){
							cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리							
						}else{
							cellData = '';
						}
						
						var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
						strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData);
						
						QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
						
						if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
							if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
								if(objNode.key === strDataFormat && objNode.level + nHeaderCols === nCol){
									//tree 아이콘 표시
									objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
								} else if(strDataFormat !== ''){
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else { // 공백 처리
									QBOX.util.textContent(heCell, strDataFormat);
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
								var parentGroupRowInfo = {};
								for(var i = 0; i < objGroupState.treeuirows.length; i++){
									if(nRow > objGroupState.treeuirows[i]){
										parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
									} else {
										break;
									}
								}
								
								if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else {
									switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											if(objQCell._isBottomPanel(heCell)){
												QBOX.util.textContent(heCell, cellData);
												
											}else{
												QBOX.util.textContent(heCell, strDataFormat);	
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
								}
							} else {
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											if(objQCell._isBottomPanel(heCell)){
												QBOX.util.textContent(heCell, cellData);
												
											}else{
												QBOX.util.textContent(heCell, strDataFormat);	
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
							}
						} else if(objGroupState.grouped && strColID === strFirstGroupColID && objGroupState.type === 'tree'){
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											if(objQCell._isBottomPanel(heCell)){
												QBOX.util.textContent(heCell, cellData);
												
											}else{
												QBOX.util.textContent(heCell, strDataFormat);	
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
							}
						}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									if(parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider':case 'inputbutton' :  {
											if(objQCell._isBottomPanel(heCell)){
												QBOX.util.textContent(heCell, cellData);
												
											}else{
												QBOX.util.textContent(heCell, strDataFormat);	
											}
											break;
										}
										default: {
											QBOX.util.textContent(heCell, cellData);
											break;
										}
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else {
									QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider':  {
											if(objQCell._isBottomPanel(heCell)){
												QBOX.util.textContent(heCell, cellData);
												
											}else{
												QBOX.util.textContent(heCell, strDataFormat);	
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'multicheckbox': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
							}
							
						} else{
							if(bIsGroupHeaderRow || bIsGroupFooterRow){
								if(parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								switch(strColType){
									case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton' : {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											if(objQCell._isBottomPanel(heCell)){
												QBOX.util.textContent(heCell, cellData);
												
											}else{
												QBOX.util.textContent(heCell, strDataFormat);	
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
							} else {
								QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											if(objQCell._isBottomPanel(heCell)){
												QBOX.util.textContent(heCell, cellData);
												
											}else{
												if(bMake){
													QBOX.util.textContent(heCell, strDataFormat);
												} else {
													QBOX.util.textContent(heCell, cellData);
												}
											}
											
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										if(bMake){
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor':case 'inputbutton': {
										if(bMake){
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
								
								if(staticrowsinfo.length > 0){
									for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
										if(staticrowsinfo[staticrow].nRow === nRow){
											QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
											QBOX.util.textContent(heCell, strDataFormatStatic);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
								
								objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
								
							}
						}
					}
					
					if(objCellInvisible){
						objQCell._setCellInvisible(nRow, nCol, true);
					}
					
					if(nCol >= nHeaderCols){
						if(bHighlightRepeatRow){
							QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
						}
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
					if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
				}
			});
		});
		
		/*merge********************************************************************/
		this._updateMergeData(); //머지 정보 설정
		/*merge********************************************************************/
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._refreshNRs', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype._refreshFCs = function(){//FCs -> FrozenCols
	//_refreshFCs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 FrozenCols에 반영하기 위해 사용되는 함수이다.
	//FrozenCols영역에 반영된 동적 변경사항(focus, selection, style)들은 모두 제거하고  _refreshFCs()를 사용해야 한다.
	try{
		var css = QBOX.QCELL.def.css,
		objQCell = this,
		objGroupState =  this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrHeaderText = this.attr('headertext'),
		arrFrozenColsCellDOMs = this._getCellGroupDOMs('col', 'frozen'),
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'),
		nAdjustColWidths,
		bIsColSelectMode = this.attr('selectmode').indexOf('col') > -1 ? true : false,
		cellData, objNode = null,
		staticrowsinfo = this.attr('staticrowsinfo'),
		bMake = true, staticrow = -1,
		bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false,strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}
	
		
		/*merge********************************************************************/
		this._clearMerge(); // Merge 정보 클리어
		this._createMergeInfo();
		/*merge********************************************************************/
		
		nAdjustColWidths = 0;
		QBOX._.each(arrFrozenColsCellDOMs, function(arrFrozenColCellDOMs, idx){
			var nCol = nHeaderCols + idx,
			nColWidth = objQCell._getColWidth(nCol),
			nCellLeft = nAdjustColWidths,
			strColID = objQCell._getColID(nCol),
			strColType = objQCell._getColType(nCol),
			keyOfCol = objQCell._getKeyOfCol(nCol),
			bFirstGroupCol = strColID === strFirstGroupColID ? true : false,
			bFocusCol = objQCell._isFocusCol(nCol),
			bSelectedCol = objQCell._isSelectedCol(nCol),
			bStyleCol = objQCell._isCellStyleCol(nCol),
			strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
			objColStyle = objQCell._getQCellCol(nCol).attr('style'),strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
			
			QBOX._.each(arrFrozenColCellDOMs, function(heCell){
				heCell.setAttribute('data-col', nCol);
				heCell.style.left = nCellLeft + 'px';
				if(nColWidth !== parseInt(heCell.style.width)){
					heCell.style.width = nColWidth + 'px';
				}
				
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nRow = parseInt(heCell.getAttribute('data-row')),
					bHeaderRow = nRow < nHeaderRows,
					bFocusCell = bFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
					bSelectedCell = bHeaderRow ? false : (bSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)) : false),
					bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
					strColStyleGroup = bHeaderRow ? 'header' : 'data',
					strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow],
					objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow];
					
					heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
					
					QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
					
					bMake = true;
					if(staticrowsinfo.length > 0){
						for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
							if(staticrowsinfo[staticrow].nRow === nRow){
								bMake = false;
							}
						}
					}
					
					if(!QBOX._.isEmpty(objColStyle)){
						if(QBOX._.isObject(objColStyle[strColStyleGroup])){
							var keys = Object.keys(objColStyle[strColStyleGroup]);
							for(var k = 0; k < keys.length; k++){
								QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
							}
						}
						objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
					}
					
					if(bHeaderRow){
						if( strColType === 'checkbox' || strColType === 'html') {
							objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
							/*
							if(this._getQCellCol(nCol).attr('sort') === false) {
								objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
							} else {
								QCELL.log('err', 'QCELL.NormalQCELL._refreshFCs', 'can not use "sort" to col type "checkbox" or "html"');
								return false;
							}
							*/
						} else {
							heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText,nRow,nCol);
							
							if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
								if(objQCell.attr('useGroupUI')){
									QBOX.$(heCell).draggable({
										helper: objQCell._setGroupMakeHelper,
										revert: 'invalid'
									});
								}
							}
						}
						
						if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
							if(objQCell._getQCellCol(nCol).attr('move')){
								heCell.appendChild(objQCell._getColHeaderDragDropArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('search')){
								heCell.appendChild(objQCell._getColSearchArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('sort') && (QBOX._.isUndefined(objQCell._getQCellCol(nCol).attr('options').wholeselect) || objQCell._getQCellCol(nCol).attr('options').wholeselect === false) && (strColType !== 'checkbox' || objQCell.attr('paginationinfo').totalsort === false || (QBOX._.isUndefined(objQCell.attr('paginationinfo')) === false && QBOX._.isUndefined(objQCell.attr('paginationinfo').url)))){
								heCell.appendChild(objQCell._getDefaultSortArea(nCol));
							}
							
							if(objQCell._getQCellCol(nCol).attr('resize')){
								heCell.appendChild(objQCell._getColResizeArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('filter')){								
								heCell.appendChild(objQCell._getFilterArea(nCol));
							}
							
							if(objQCell._getQCellCol(nCol).attr('editor')){
								heCell.appendChild(objQCell._getColStyleEditorArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('remove') ){
								heCell.appendChild(objQCell._getDefaultRemoveArea(nCol));
							}
						}
					} else{
						var arrRowData = arrCurrentData[nRow - nHeaderRows];
						if(arrRowData === undefined)
							return;
						cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
						var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
						strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData),
						bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
						nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
						bIsGroupTreeUIRow = false;
						
						QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
						
						if(objQCell._isBottomPanel( heCell )){
							strColType = 'static';	
						}							
						if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
							nIdxOfGroupTreeUIRow = -1; nIdxOfGroupHeaderRow = -1; nIdxOfGroupFooterRow = -1;
							bIsGroupTreeUIRow = false;
							
							nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
							
							if(nIdxOfGroupTreeUIRow > -1){
								bIsGroupTreeUIRow = true;
								objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
								
								bIsGroupHeaderRow = bIsGroupFooterRow = false;
							} else{
								nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
								
								if(nIdxOfGroupHeaderRow > -1){
									bIsGroupHeaderRow = true;
									objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
									
									bIsGroupFooterRow = false;
								} else{
									nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
									
									if(nIdxOfGroupFooterRow > -1){
										bIsGroupFooterRow = true;
										objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
										
										bIsGroupHeaderRow = false;
									}
								}
							}
							
							if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
								if(objNode.key === strDataFormat){
									//tree 아이콘 표시
									objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
								} else if(strDataFormat !== ''){
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else { // 공백 처리
									QBOX.util.textContent(heCell, strDataFormat);
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
								var parentGroupRowInfo = {};
								for(var i = 0; i < objGroupState.treeuirows.length; i++){
									if(nRow > objGroupState.treeuirows[i]){
										parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
									} else {
										break;
									}
								}
								
								if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else {
									switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
								}
							} else {
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
							}
							
						} else if(objGroupState.grouped && bFirstGroupCol && objGroupState.type === 'tree'){
							nIdxOfGroupTreeUIRow = -1; nIdxOfGroupHeaderRow = -1; nIdxOfGroupFooterRow = -1;
							bIsGroupTreeUIRow = false;
										
							if(objGroupState.type === 'tree'){
								nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
							}
							
							if(nIdxOfGroupTreeUIRow > -1){
								bIsGroupTreeUIRow = true;
								objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
								
								bIsGroupHeaderRow = bIsGroupFooterRow = false;
							} else{
								nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
								
								if(nIdxOfGroupHeaderRow > -1){
									bIsGroupHeaderRow = true;
									objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
									
									bIsGroupFooterRow = false;
								} else{
									nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
									
									if(nIdxOfGroupFooterRow > -1){
										bIsGroupFooterRow = true;
										objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
										
										bIsGroupHeaderRow = false;
									}
								}
							}
							
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
							}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
									QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
								objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
								if(objNode !== null){
									objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
								} else{
									
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider': {
											QBOX.util.textContent(heCell, strDataFormat);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'multicheckbox': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
								
							}  else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
							}
						} else{
							if(objGroupState.grouped){
								if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1)
									bIsGroupHeaderRow = true;
								if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1)
									bIsGroupFooterRow = true;								
							}
							
							if(bIsGroupHeaderRow || bIsGroupFooterRow){
								if(parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								if(staticrowsinfo.length > 0){
									for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
										if(staticrowsinfo[staticrow].nRow === nRow){
											strDataFormat = strDataFormatStatic;
											break;
										}
									}
								}
								
								switch(strColType){
									case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										break;
									}
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										break;
									}
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else {
								QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											if(bMake){
												QBOX.util.textContent(heCell, strDataFormat);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										if(bMake){
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor':case 'inputbutton': {
										if(bMake){
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
								
								if(staticrowsinfo.length > 0){
									for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
										if(staticrowsinfo[staticrow].nRow === nRow){
											QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
											QBOX.util.textContent(heCell, strDataFormatStatic);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
								
								objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
							}
						}
					}
					
					if(objCellInvisible){
						objQCell._setCellInvisible(nRow, nCol, true);
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
					if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
				}
			});
			
			nAdjustColWidths += nColWidth;
		});
		
		/*merge********************************************************************/
		this._updateMerge(); //머지 정보 설정
		/*merge********************************************************************/
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._refreshFCs', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype._refreshNCs = function(){//NCs -> NormalCols
	//_refreshNCs()는 스크롤바 이동 시 동기화하기 위해 사용되는 함수가 아니라 적용되지 않은 동적 변경사항을 NormalCols에 반영하기 위해 사용되는 함수이다.
	//NormalCols영역에 반영된 동적 변경사항(focus, selection, style, highlightrepeat)들은 모두 제거하고  _refreshNCs()를 사용해야 한다. 
	try{
		var css = QBOX.QCELL.def.css,
		objHSInfo = this.attr('hsinfo'), objQCell = this, objUpdateInfo = objHSInfo.objUpdateInfo,
		objGroupState =  this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrHeaderText = this.attr('headertext'),
		arrNormalColsCellDOMs = this._getCellGroupDOMs('col', 'normal'),
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
		nAdjustColWidths, nAdjustedLeft,
		bIsColSelectMode = this.attr('selectmode').indexOf('col') > -1 ? true : false,
		cellData,objNode = null,
		staticrowsinfo = this.attr('staticrowsinfo'),
		bMake = true, staticrow = -1,strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}		
		
		/*merge********************************************************************/
		this._clearMerge(); // Merge 정보 클리어
		this._createMergeInfo();
		/*merge********************************************************************/
		
		nAdjustedLeft = objUpdateInfo.objParams.nAdjustedLeft;//이동한 가로스크롤바의 위치가 동적 컬럼을 변경하는 것이 아닌 left값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
		nAdjustColWidths = nFrozenColsWidth;
		QBOX._.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
			var nCol = objHSInfo.nLeftCol + idx,
			nColWidth = objQCell._getColWidth(nCol),
			nCellLeft = nAdjustColWidths - nAdjustedLeft,
			strColID = objQCell._getColID(nCol),
			strColType = objQCell._getColType(nCol),
			keyOfCol = objQCell._getKeyOfCol(nCol),
			bFirstGroupCol = strColID === strFirstGroupColID ? true : false,
			bFocusCol = objQCell._isFocusCol(nCol),
			bSelectedCol = objQCell._isSelectedCol(nCol),
			bStyleCol = objQCell._isCellStyleCol(nCol),
			strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
			objColStyle = objQCell._getQCellCol(nCol).attr('style'),strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
			
			QBOX._.each(arrNormalColCellDOMs, function(heCell){
				heCell.setAttribute('data-col', nCol);
				heCell.style.left = nCellLeft + 'px';
				if(nColWidth !== parseInt(heCell.style.width)){
					heCell.style.width = nColWidth + 'px';
				}
				
				if(heCell.getAttribute('data-footer') !== 'true'){
					var nRow = parseInt(heCell.getAttribute('data-row')),
					bHeaderRow = nRow < nHeaderRows,
					bFocusCell = bFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
					bSelectedCell = bHeaderRow ? false : (bSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)) : false),
					bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
					strColStyleGroup = bHeaderRow ? 'header' : 'data',
					strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow],
					objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow];
					
					heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
					
					QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
					
					bMake = true;
					if(staticrowsinfo.length > 0){
						for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
							if(staticrowsinfo[staticrow].nRow === nRow){
								bMake = false;
							}
						}
					}
					
					if(!QBOX._.isEmpty(objColStyle)){
						if(QBOX._.isObject(objColStyle[strColStyleGroup])){
							var keys = Object.keys(objColStyle[strColStyleGroup]);
							for(var k = 0; k < keys.length; k++){
								QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
							}
						}
						objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
					}
					
					if(bHeaderRow){
						if( strColType === 'checkbox' || strColType === 'html') {
							objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
							/*
							if(this._getQCellCol(nCol).attr('sort') === false) {
								objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
							} else {
								QCELL.log('err', 'QCELL.NormalQCELL._refreshNCs', 'can not use "sort" to col type "checkbox" or "html"');
								return false;
							}
							*/
						} else {
							heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText,nRow,nCol);
							
							if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
								if(objQCell.attr('useGroupUI')){
									QBOX.$(heCell).draggable({
										helper: objQCell._setGroupMakeHelper,
										revert: 'invalid'
									});
								}
							}
						}
						
						if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
							if(objQCell._getQCellCol(nCol).attr('move')){
								heCell.appendChild(objQCell._getColHeaderDragDropArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('search')){
								heCell.appendChild(objQCell._getColSearchArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('sort') && (QBOX._.isUndefined(objQCell._getQCellCol(nCol).attr('options').wholeselect) || objQCell._getQCellCol(nCol).attr('options').wholeselect === false) && (strColType !== 'checkbox' || objQCell.attr('paginationinfo').totalsort === false || (QBOX._.isUndefined(objQCell.attr('paginationinfo')) === false && QBOX._.isUndefined(objQCell.attr('paginationinfo').url)))){
								heCell.appendChild(objQCell._getDefaultSortArea(nCol));
							}
							
							if(objQCell._getQCellCol(nCol).attr('resize')){
								heCell.appendChild(objQCell._getColResizeArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('filter')){								
								heCell.appendChild(objQCell._getFilterArea(nCol));
							}
							
							if(objQCell._getQCellCol(nCol).attr('editor')){
								heCell.appendChild(objQCell._getColStyleEditorArea());
							}
							
							if(objQCell._getQCellCol(nCol).attr('remove')){
								heCell.appendChild(objQCell._getDefaultRemoveArea(nCol));
							}
						}
					} else{
						var arrRowData = arrCurrentData[nRow - nHeaderRows];
						if(arrRowData === undefined)
							return;
						
						cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
						var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
						strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData),
						bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
						nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
						bIsGroupTreeUIRow = false;
						
						if(arrRowData.rt_qc_fbrd === true && nRow === arrCurrentData.length){
							strDataFormat = strDataFormatStatic= cellData;
						}
						
						if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
							nIdxOfGroupTreeUIRow = -1; nIdxOfGroupHeaderRow = -1; nIdxOfGroupFooterRow = -1;
							bIsGroupTreeUIRow = false;
							
							nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
							
							if(nIdxOfGroupTreeUIRow > -1){
								bIsGroupTreeUIRow = true;
								objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
								
								bIsGroupHeaderRow = bIsGroupFooterRow = false;
							} else{
								nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
								
								if(nIdxOfGroupHeaderRow > -1){
									bIsGroupHeaderRow = true;
									objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
									
									bIsGroupFooterRow = false;
								} else{
									nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
									
									if(nIdxOfGroupFooterRow > -1){
										bIsGroupFooterRow = true;
										objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
										
										bIsGroupHeaderRow = false;
									}
								}
							}
							
							if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
								if(objNode.key === strDataFormat && objNode.level + nHeaderCols === nCol){
									//tree 아이콘 표시
									objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
								} else if(strDataFormat !== ''){
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else { // 공백 처리
									QBOX.util.textContent(heCell, strDataFormat);
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
								var parentGroupRowInfo = {};
								for(var i = 0; i < objGroupState.treeuirows.length; i++){
									if(nRow > objGroupState.treeuirows[i]){
										parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
									} else {
										break;
									}
								}
								
								if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else {
									switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
								}
							} else {
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton': {
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
							}
							
						} else if(objGroupState.grouped && bFirstGroupCol  && objGroupState.type === 'tree'){
							nIdxOfGroupTreeUIRow = -1; nIdxOfGroupHeaderRow = -1; nIdxOfGroupFooterRow = -1;
							bIsGroupTreeUIRow = false;
										
							if(objGroupState.type === 'tree' || objGroupState.type === 'step'){
								nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
							}
							
							if(nIdxOfGroupTreeUIRow > -1){
								bIsGroupTreeUIRow = true;
								objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
								
								bIsGroupHeaderRow = bIsGroupFooterRow = false;
							} else{
								nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
								
								if(nIdxOfGroupHeaderRow > -1){
									bIsGroupHeaderRow = true;
									objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
									
									bIsGroupFooterRow = false;
								} else{
									nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
									
									if(nIdxOfGroupFooterRow > -1){
										bIsGroupFooterRow = true;
										objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
										
										bIsGroupHeaderRow = false;
									}
								}
							}
							
							if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
								//tree 아이콘 표시
								objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
							} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
								//탭처리
								objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
							} else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton': {
										objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
							}
						} else if(objGroupState.grouped && objGroupState.type === 'group' &&
								QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
							objNode = objQCell._getGroupNode(arrCurrentData[nRow - nHeaderRows],keyOfCol);
							if(objNode !== null){
								objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
							}else{
								if(objGroupState.grouped){
									if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1)
										bIsGroupHeaderRow = true;
									if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1)
										bIsGroupFooterRow = true;								
								}
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									if(parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
											QBOX.util.textContent(heCell, strDataFormat);
											break;
										}
										default: {
											QBOX.util.textContent(heCell, cellData);
											break;
										}
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else {
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider': {
											QBOX.util.textContent(heCell, strDataFormat);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'multicheckbox': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											QBOX.util.textContent(heCell, cellData);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
							}
							
						} else{
							if(objGroupState.grouped){
								if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1)
									bIsGroupHeaderRow = true;
								if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1)
									bIsGroupFooterRow = true;								
							}
							if(bIsGroupHeaderRow || bIsGroupFooterRow){
								if(parseInt(heCell.getAttribute("data-row")) === nRow){
									QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
									strDataFormat = cellData;
								}
								switch(strColType){
									case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											QBOX.util.textContent(heCell, strDataFormat);
										}
										break;
									}
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										break;
									}
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else {
								switch(strColType){
									case 'static': case 'input': case 'number': case 'slider': {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
										}
										else {
											if(bMake){
												QBOX.util.textContent(heCell, strDataFormat);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
									case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
										if(bMake){
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										
										break;
									}
									case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor':case 'inputbutton': {
										if(bMake){
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
										} else {
											QBOX.util.textContent(heCell, cellData);
										}
										
										break;
									}
									
									default: {
										if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
											heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
										}
										else {
											QBOX.util.textContent(heCell, cellData);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										break;
									}
								}
								
								if(staticrowsinfo.length > 0){
									for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
										if(staticrowsinfo[staticrow].nRow === nRow){
											QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
											QBOX.util.textContent(heCell, strDataFormatStatic);
											break;
										}
									}
								}
								
								objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
							}
						}
					}
					
					if(objCellInvisible){
						objQCell._setCellInvisible(nRow, nCol, true);
					}
					
					if(bFocusCell){//포커스 스타일을 적용해야 하는 경우
						objQCell._addFocusStyleClass(heCell);
					}
					
					if(bSelectedCell){//선택된 셀인 경우
						QBOX.util.addClass(heCell, css.CELL_SELECT);
					}
					
					if(bStyleCell){//셀 스타일을 적용해야 하는 경우
						objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
					}
					if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
				}
			});
			
			nAdjustColWidths += nColWidth;
		});
		
		/*merge********************************************************************/
		this._updateMerge(); //머지 정보 설정
		/*merge********************************************************************/
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._refreshNCs', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype._updateNRs = function(){//NRs -> NormalRows
	//_updateNRs()는 세로스크롤바 이동 시 동기화하기 위해서 사용된다.
	//세로스크롤바 동기화 시 갱신되는 셀들의 행 인덱스는 변경된다. 이전 셀의 동적 변경사항을 제거하는 로직이 필요하다.
	try{
		var css = QBOX.QCELL.def.css,
		objVSInfo = this.attr('vsinfo'), objQCell = this, objUpdateInfo = objVSInfo.objUpdateInfo,
		objGroupState =  this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrNormalRowsCellDOMs = this._getCellGroupDOMs('row', 'normal'),
		arrMovedDynamicRowsCellDOMs = [],
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'), nRows = this.attr('rows'),
		nHeaderCols = this.attr('headercols'),
		nHighlightRepeat = this.attr('highlightrepeat'),
		nDataRowHeight = this.attr('rowheight').data,
		nViewPortOffsetHeight = this.attr('layoutsize').viewport.offsetHeight,
		nFrozenRowsHeight = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
		nFrozenBottomRowsHeight = this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1),
		nAdjustHeight, nAdjustedTop,
		bIsRowSelectMode = this.attr('selectmode').indexOf('row') > -1 ? true : false,
		cellData,nGroupRow =-1,objNode,
		staticrowsinfo = this.attr('staticrowsinfo'),
		bMake = true, staticrow = -1,
		bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false,strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}
		
		if(this.attr('useall') || this.attr('usetreeall')){
			this._updateNRsAll();
			return;
		}				
		/*merge********************************************************************/
		this._clearMergeData(); // Merge 정보 클리어
		this._createDataMergeInfo();
		/*merge********************************************************************/
		
		if(objUpdateInfo.bWholeUpdate){
			nAdjustedTop = objUpdateInfo.objParams.nAdjustedTop;//이동한 세로스크롤바의 위치가 동적 행을 변경하는 것이 아닌 top값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
			nAdjustHeight = nFrozenRowsHeight;
			QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, idx){
				var nBeforeRow = parseInt(arrNormalRowCellDOMs[0].getAttribute('data-row')),
				nRow = objVSInfo.nTopRow + idx,
				nRowHeight = objQCell._getRowHeight(nRow),
				nCellTop = nAdjustHeight - nAdjustedTop,
				nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
				bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
				objNode = null,
				arrRowData = arrCurrentData[nRow - nHeaderRows],
				bBeforeFocusRow = objQCell._isFocusRow(nBeforeRow), bFocusRow = objQCell._isFocusRow(nRow),
				bBeforeSelectedRow = objQCell._isSelectedRow(nBeforeRow), bSelectedRow = objQCell._isSelectedRow(nRow),
				bBeforeStyleRow = objQCell._isCellStyleRow(nBeforeRow), bStyleRow = objQCell._isCellStyleRow(nRow),
				bBeforeHighlightRepeatRow = nHighlightRepeat > 0 && ((nBeforeRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false,
				bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
				
				if(objGroupState.grouped){
					if(objGroupState.type === 'tree' || objGroupState.type === 'step'){
						nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
					}
					
					if(nIdxOfGroupTreeUIRow > -1){
						bIsGroupTreeUIRow = true;
						objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
						
						bIsGroupHeaderRow = bIsGroupFooterRow = false;
					} else{
						nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
						
						if(nIdxOfGroupHeaderRow > -1){
							bIsGroupHeaderRow = true;
							objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
							
							bIsGroupFooterRow = false;
						} else{
							nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
							
							if(nIdxOfGroupFooterRow > -1){
								bIsGroupFooterRow = true;
								objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
								
								bIsGroupHeaderRow = false;
							}
						}
					}
				}
				
				bMake = true;
				if(staticrowsinfo.length > 0){
					for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
						if(staticrowsinfo[staticrow].nRow === nRow){
							bMake = false;
						}
					}
				}
				
				QBOX._.each(arrNormalRowCellDOMs, function(heCell, idx2){
					heCell.setAttribute('data-row', nRow);
					heCell.style.top = nCellTop + 'px';
					if(nRowHeight !== parseInt(heCell.style.height)){
						heCell.style.height = nRowHeight + 'px';
					}
					
					if(heCell.getAttribute('data-footer') !== 'true'){
						var nCol = parseInt(heCell.getAttribute('data-col')),
						strColID = objQCell._getColID(nCol),
						strColType = objQCell._getColType(nCol),
						keyOfCol = objQCell._getKeyOfCol(nCol),
						bBeforeFocusCell = bBeforeFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
						bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
						bBeforeSelectedCell = bBeforeSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nBeforeRow, nCol)): false,
						bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
						bBeforeStyleCell = bBeforeStyleRow ? objQCell._hasCellStyle(nBeforeRow, nCol) : false,
						bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
						heCheckbox,
						strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
						objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow],
						strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
								
						heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
						
						
						if(nCol < nHeaderCols){
							var objPaginationInfo = objQCell.attr('paginationinfo');
							
							if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									if(objQCell._isBottomPanel( heCell )){
										if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
											QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										return;
									}
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows+ nR) : nRow - nHeaderRows + 1);
								} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
									if(objQCell._isBottomPanel( heCell ))
										return;									
									heCell.innerHTML = '';
									
									if(bMake){
										heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
										heCell.appendChild(heCheckbox);
										
										if(arrRowHeaders[nCol]==='checkbox')
											heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
										else
											heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

									}
								} else if(arrRowHeaders[nCol] === 'state') {
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else {
								var nPageRow = nRow;
								// multiheader 일 때
								if(nHeaderRows > 1) {
									nPageRow = nRow - (nHeaderRows - 1);
								}
								
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									if(objQCell._isBottomPanel( heCell )){
										if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
											QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										return;
									}
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
								} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
									if(objQCell._isBottomPanel( heCell ))
										return;									
									heCell.innerHTML = '';
									
									if(bMake){
										heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
										heCell.appendChild(heCheckbox);
										
										if(arrRowHeaders[nCol]==='checkbox')
											heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
										else
											heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

									}
								} else if(arrRowHeaders[nCol] === 'state') {
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							}
						} else{
							cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
							var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
							strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData);
							
							QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
							
							if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
								
								if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
									if(objNode.key === strDataFormat && objNode.level + nHeaderCols === nCol){
										//tree 아이콘 표시
										objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
									} else if(strDataFormat !== ''){
										//탭처리
										objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
									} else { // 공백 처리
										QBOX.util.textContent(heCell, strDataFormat);
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
									var parentGroupRowInfo = {};
									for(var i = 0; i < objGroupState.treeuirows.length; i++){
										if(nRow > objGroupState.treeuirows[i]){
											parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
										} else {
											break;
										}
									}
									
									if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
										//탭처리
										objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
									} else {
										if(staticrowsinfo.length > 0){
											for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
												if(staticrowsinfo[staticrow].nRow === nRow){
													strDataFormat = strDataFormatStatic;
													break;
												}
											}
										}
										switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
									}
								} else {
									if(staticrowsinfo.length > 0){
										for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
											if(staticrowsinfo[staticrow].nRow === nRow){
												strDataFormat = strDataFormatStatic;
												break;
											}
										}
									}
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									
									switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
							} else if(objGroupState.grouped && strColID === strFirstGroupColID  && objGroupState.type === 'tree'){
								if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
									//tree 아이콘 표시
									objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
								} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									
									switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
							}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
									QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
								objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
								if(objNode !== null){
									objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
								}else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										if(parseInt(heCell.getAttribute("data-row")) === nRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
											strDataFormat = cellData;
										}
										switch(strColType){
											case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
												QBOX.util.textContent(heCell, strDataFormat);
												break;
											}
											default: {
												QBOX.util.textContent(heCell, cellData);
												break;
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									} else {
										if(bIsGroupHeaderRow || bIsGroupFooterRow){
											if(parseInt(heCell.getAttribute("data-row")) === nRow){
												QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
												strDataFormat = cellData;
											}
											switch(strColType){
												case 'static': case 'input': case 'datepicker': case 'number': case 'slider':case 'inputbutton': {
													QBOX.util.textContent(heCell, strDataFormat);
													break;
												}
												default: {
													QBOX.util.textContent(heCell, cellData);
													break;
												}
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										} else {
											QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
											switch(strColType){
												case 'static': case 'input': case 'datepicker': case 'number': case 'slider': {
													QBOX.util.textContent(heCell, strDataFormat);
													objQCell._setAriaLabelEx(heCell,nRow,nCol);
													break;
												}
												case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
													objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
													break;
												}
												case 'selectmenu': case 'multicheckbox': case 'inputbutton':{
													objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
													break;
												}
												
												default: {
													QBOX.util.textContent(heCell, strDataFormat);
													objQCell._setAriaLabelEx(heCell,nRow,nCol);
													break;
												}
											}
										}
									}
								}
								
							}  else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									if(parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											break;
										}
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, cellData);
											}
											break;
										}
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else {
									QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
									switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												if(bMake){
													QBOX.util.textContent(heCell, strDataFormat);
												} else {
													QBOX.util.textContent(heCell, cellData);
												}
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											if(bMake){
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
											
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton': {
											if(bMake){
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
											
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
									
									if(staticrowsinfo.length > 0){
										for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
											if(staticrowsinfo[staticrow].nRow === nRow){
												QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
												QBOX.util.textContent(heCell, strDataFormatStatic);
												break;
											} else {
												QBOX.util.removeClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
											}
										}
									}
									
									objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
								}
							}
						}
						
						if(objCellInvisible){
							objQCell._setCellInvisible(nRow, nCol, true);
						}
						
						if(nCol >= nHeaderCols){
							if(bHighlightRepeatRow){
								if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT) === false){
									QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
								}
							} else{
								if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT)){
									QBOX.util.removeClass(heCell, css.CELL_HIGHLIGHTREPEAT);
								}
							}
							
							if(bFocusCell && bBeforeFocusCell === false){//갱신 전에는 포커스 셀이 아니였지만 갱신 후에는 포커스 셀인 경우
								objQCell._addFocusStyleClass(heCell);
							} else if(bBeforeFocusCell && bFocusCell === false){//갱신 전에는 포커스 셀이였지만, 갱신 후에는 포커스 셀이 아닌 경우
								objQCell._removeFocusStyleClass(heCell);
							}
							

						}
	
						if(bSelectedCell && bBeforeSelectedCell === false){//갱신 전에는 선택된 셀이 아니였지만 갱신 후에는 선택된 셀인 경우
							QBOX.util.addClass(heCell, css.CELL_SELECT);
						} else if(bBeforeSelectedCell && bSelectedCell === false){//갱신 전에는 선택된 셀이였지만, 갱신 후에는 선택된 셀이 아닌 경우
							QBOX.util.removeClass(heCell, css.CELL_SELECT);
						}
						
						if(bBeforeStyleCell){//갱신 전에 셀 스타일이 적용되어 있던 경우
							objQCell._removeCellStyleCSS(heCell, objQCell._getCellStyle(nBeforeRow, nCol));
						}
						if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
							objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
						}
						if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
					}
				});
				
				nAdjustHeight += nRowHeight;
			});
		} else{
			var bWholePositionChanged = objUpdateInfo.objParams.bWholePositionChanged,
			nMovedCount = objUpdateInfo.objParams.nMovedCount,
			nCutRowsCount = objUpdateInfo.objParams.nCutRowsCount;
			
			if(nCutRowsCount > 0){
				var nStandardRow;
				
				if(nMovedCount > 0){//세로스크롤바가 아래로 이동했을 때
					arrMovedDynamicRowsCellDOMs = arrNormalRowsCellDOMs.splice(0, nCutRowsCount);
					nAdjustHeight = nFrozenRowsHeight;
					nStandardRow = objVSInfo.nTopRow;
				} else{
					arrMovedDynamicRowsCellDOMs = arrNormalRowsCellDOMs.splice(arrNormalRowsCellDOMs.length - nCutRowsCount, nCutRowsCount);
					nAdjustHeight = nFrozenRowsHeight + this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nTopRow + nCutRowsCount - 1);
					nStandardRow = objVSInfo.nTopRow + nCutRowsCount;
				}
				
				if(!bWholePositionChanged){
					//계속 화면에 표시해야 하는 행들의 셀은 갱신하지 않고 top값만 세팅
					QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, idx){
						var nRow, nRowHeight, nCellTop;
						
						nRow = nStandardRow + idx;
						nRowHeight = objQCell._getRowHeight(nRow);
						nCellTop = nAdjustHeight;
						
						QBOX._.each(arrNormalRowCellDOMs, function(heCell){
							var nCol = parseInt(heCell.getAttribute('data-col')),strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
							heCell.style.top = nCellTop + 'px';
							if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
						});
						
						nAdjustHeight += nRowHeight;
					});
				}
				
				//화면에 표시하지 않아야 하는 행 셀들은 가장 아래에 표시되고 있는 행 아래로 이동시킨 후 갱신해야 한다.
				nStandardRow = nMovedCount > 0 ? objVSInfo.nBottomRow - nCutRowsCount + 1 : objVSInfo.nTopRow;
				nAdjustHeight = nMovedCount > 0 ? nFrozenRowsHeight + this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nBottomRow - nCutRowsCount) : nFrozenRowsHeight;
				QBOX._.each(arrMovedDynamicRowsCellDOMs, function(arrMovedDynamicRowCellDOMs, idx){
					var nBeforeRow = parseInt(arrMovedDynamicRowCellDOMs[0].getAttribute('data-row')),
					nRow = nStandardRow + idx,
					nRowHeight = objQCell._getRowHeight(nRow),
					nCellTop = nAdjustHeight,
					nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
					bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
					objNode = null,
					arrRowData = arrCurrentData[nRow - nHeaderRows],
					bBeforeFocusRow = objQCell._isFocusRow(nBeforeRow), bFocusRow = objQCell._isFocusRow(nRow),
					bBeforeSelectedRow = objQCell._isSelectedRow(nBeforeRow), bSelectedRow = objQCell._isSelectedRow(nRow),
					bBeforeStyleRow = objQCell._isCellStyleRow(nBeforeRow), bStyleRow = objQCell._isCellStyleRow(nRow),
					bBeforeHighlightRepeatRow = nHighlightRepeat > 0 && ((nBeforeRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false,
					bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
					
					if(staticrowsinfo.length > 0){
						for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
							if(staticrowsinfo[staticrow].nRow === nRow){
								bMake = false;
							}
						}
					}
					
					if(objGroupState.grouped){
						if(objGroupState.type === 'tree' || objGroupState.type === 'step'){
							nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
						}
						
						if(nIdxOfGroupTreeUIRow > -1){
							bIsGroupTreeUIRow = true;
							objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
							
							bIsGroupHeaderRow = bIsGroupFooterRow = false;
						} else{
							nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
							
							if(nIdxOfGroupHeaderRow > -1){
								bIsGroupHeaderRow = true;
								objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
								
								bIsGroupFooterRow = false;
							} else{
								nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
								
								if(nIdxOfGroupFooterRow > -1){
									bIsGroupFooterRow = true;
									objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
									
									bIsGroupHeaderRow = false;
								}
							}
						}
					}
					
					QBOX._.each(arrMovedDynamicRowCellDOMs, function(heCell){
						heCell.setAttribute('data-row', nRow);
						if(nRowHeight !== parseInt(heCell.style.height)){
							heCell.style.height = nRowHeight + 'px';
						}
						
						if(!bWholePositionChanged){
							heCell.style.top = nCellTop + 'px';
						}
						
						if(heCell.getAttribute('data-footer') !== 'true'){
							var nCol = parseInt(heCell.getAttribute('data-col')),
							strColID = objQCell._getColID(nCol),
							strColType = objQCell._getColType(nCol),
							keyOfCol = objQCell._getKeyOfCol(nCol),
							bBeforeFocusCell = bBeforeFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
							bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
							bBeforeSelectedCell = bBeforeSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nBeforeRow, nCol)): false,
							bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
							bBeforeStyleCell = bBeforeStyleRow ? objQCell._hasCellStyle(nBeforeRow, nCol) : false,
							bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
							heCheckbox,
							strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
							objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow],
							strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
							
							heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
							
							
							if(nCol < nHeaderCols){
								
								var objPaginationInfo = objQCell.attr('paginationinfo');
								
								if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
									if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
										QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows + nR) : nRow - nHeaderRows + 1);
									} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
										if(objQCell._isBottomPanel( heCell )){
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											return;		
										}								
										heCell.innerHTML = '';
										
										if(bMake){
											heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
											heCell.appendChild(heCheckbox);
											
											if(arrRowHeaders[nCol]==='checkbox')
												heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
											else
												heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

										}
									}else if(arrRowHeaders[nCol] === 'state') {
										objQCell._setRowheaderState(heCell,nRow);
									} else if(arrRowHeaders[nCol] === 'custom') {
										objQCell._setRowheaderCustom(heCell,nRow,nCol);
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else {
									var nPageRow = nRow;
									// multiheader 일 때
									if(nHeaderRows > 1) {
										nPageRow = nRow - (nHeaderRows - 1);
									}
									
									if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {						
										QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
									}else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
										if(objQCell._isBottomPanel( heCell )){
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											return;		
										}
																		
										heCell.innerHTML = '';
										
										if(bMake){
											heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
											heCell.appendChild(heCheckbox);
											
											if(arrRowHeaders[nCol]==='checkbox')
												heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
											else
												heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

										}
									} else if(arrRowHeaders[nCol] === 'state') {
										objQCell._setRowheaderState(heCell,nRow);
									} else if(arrRowHeaders[nCol] === 'custom') {
										objQCell._setRowheaderCustom(heCell,nRow,nCol);
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								}
							} else{
								cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
								var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
								strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData);
								
								QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
								
								if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
									
									if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
										if(objNode.key === strDataFormat && objNode.level + nHeaderCols === nCol){
											//tree 아이콘 표시
											objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
										} else if(strDataFormat !== ''){
											//탭처리
											objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
										} else { // 공백 처리
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
										var parentGroupRowInfo = {};
										for(var i = 0; i < objGroupState.treeuirows.length; i++){
											if(nRow > objGroupState.treeuirows[i]){
												parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
											} else {
												break;
											}
										}
										
										if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
											//탭처리
											objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
										} else {
											switch(strColType){
											case 'static': case 'input': case 'number': case 'slider': {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													QBOX.util.textContent(heCell, strDataFormat);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
											case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
												break;
											}
											case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
												break;
											}
											
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, strDataFormat);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
										}
									} else {
										if(bIsGroupHeaderRow || bIsGroupFooterRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
											strDataFormat = cellData;
										}
										
										switch(strColType){
											case 'static': case 'input': case 'number': case 'slider': {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													QBOX.util.textContent(heCell, strDataFormat);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
											case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
												break;
											}
											case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
												break;
											}
											
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, strDataFormat);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
									}
								} else if(objGroupState.grouped && strColID === strFirstGroupColID  && objGroupState.type === 'tree'){
									
									if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
										//tree 아이콘 표시
										
										objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
									} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
										//탭처리
										objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
									} else{
										if(bIsGroupHeaderRow || bIsGroupFooterRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
											strDataFormat = cellData;
										}
										switch(strColType){
											case 'static': case 'input': case 'number': case 'slider': {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													QBOX.util.textContent(heCell, strDataFormat);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
											case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
												break;
											}
											case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor':case 'inputbutton': {
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
												break;
											}
											
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, strDataFormat);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
									}
								}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
										QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
									objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
									if(objNode !== null){
										objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
									}else{
										if(bIsGroupHeaderRow || bIsGroupFooterRow){
											if(parseInt(heCell.getAttribute("data-row")) === nRow){
												QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
												strDataFormat = cellData;
											}
											switch(strColType){
												case 'static': case 'input': case 'datepicker': case 'number': case 'slider':case 'inputbutton': {
													QBOX.util.textContent(heCell, strDataFormat);
													break;
												}
												default: {
													QBOX.util.textContent(heCell, cellData);
													break;
												}
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										} else {
											QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
											switch(strColType){
												case 'static': case 'input': case 'datepicker': case 'number': case 'slider': {
													QBOX.util.textContent(heCell, strDataFormat);
													objQCell._setAriaLabelEx(heCell,nRow,nCol);
													break;
												}
												case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
													objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
													break;
												}
												case 'selectmenu': case 'multicheckbox': case 'inputbutton':{
													objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
													break;
												}
												
												default: {
													QBOX.util.textContent(heCell, strDataFormat);
													objQCell._setAriaLabelEx(heCell,nRow,nCol);
													break;
												}
											}
										}
									}
									
								}  else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										if(parseInt(heCell.getAttribute("data-row")) === nRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
											strDataFormat = cellData;
										}
										switch(strColType){
											case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													QBOX.util.textContent(heCell, strDataFormat);
												}
												break;
											}
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, cellData);
												}
												break;
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									} else {
										QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
										switch(strColType){
											case 'static': case 'input': case 'number': case 'slider': {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													if(bMake){
														QBOX.util.textContent(heCell, strDataFormat);
													} else {
														QBOX.util.textContent(heCell, cellData);
													}
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
											case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
												if(bMake){
													objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
												} else {
													QBOX.util.textContent(heCell, cellData);
												}
												break;
											}
											case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
												if(bMake){
													objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
												} else {
													QBOX.util.textContent(heCell, cellData);
												}
												break;
											}
											
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, strDataFormat);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
										
										if(staticrowsinfo.length > 0){
											for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
												if(staticrowsinfo[staticrow].nRow === nRow){
													QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
													QBOX.util.textContent(heCell, strDataFormatStatic);
													break;
												} else {
													QBOX.util.removeClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
												}
											}
										}
										
										objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
									}
								}
							}
							
							if(objCellInvisible){
								objQCell._setCellInvisible(nRow, nCol, true);
							}
							
							if(nCol >= nHeaderCols){
								if(bHighlightRepeatRow){
									if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT) === false){
										QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
									}
								} else{
									if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT)){
										QBOX.util.removeClass(heCell, css.CELL_HIGHLIGHTREPEAT);
									}
								}
								
								if(bFocusCell && bBeforeFocusCell === false){//갱신 전에는 포커스 셀이 아니였지만 갱신 후에는 포커스 셀인 경우
									objQCell._addFocusStyleClass(heCell);
								} else if(bBeforeFocusCell && bFocusCell === false){//갱신 전에는 포커스 셀이였지만, 갱신 후에는 포커스 셀이 아닌 경우
									objQCell._removeFocusStyleClass(heCell);
								}
								
	
							}
							if(bSelectedCell && bBeforeSelectedCell === false){//갱신 전에는 선택된 셀이 아니였지만 갱신 후에는 선택된 셀인 경우
								QBOX.util.addClass(heCell, css.CELL_SELECT);
							} else if(bBeforeSelectedCell && bSelectedCell === false){//갱신 전에는 선택된 셀이였지만, 갱신 후에는 선택된 셀이 아닌 경우
								QBOX.util.removeClass(heCell, css.CELL_SELECT);
							}
							
							if(bBeforeStyleCell){//갱신 전에 셀 스타일이 적용되어 있던 경우
								objQCell._removeCellStyleCSS(heCell, objQCell._getCellStyle(nBeforeRow, nCol));
							}
							if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
								objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
							}
							if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
						}
					});
					nAdjustHeight += nRowHeight;
				});
			}
			
			if(bWholePositionChanged){
				//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 셀의 top을 보정해야 하는 경우다.
				if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
					arrNormalRowsCellDOMs = arrNormalRowsCellDOMs.concat(arrMovedDynamicRowsCellDOMs);
					
					if(objVSInfo.nLastPos === objVSInfo.nPos){//viewport의 하단 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우(FrozenBottomRows가 있는 경우, viewport의 끝이 아닌 FrozenBottomRows의 시작점과 맞춰야 한다.)
						nAdjustedTop = nFrozenRowsHeight + this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nEndRow) - (nViewPortOffsetHeight - nFrozenBottomRowsHeight);
					} else{//행의 height만큼 top을 이동시켜야 하는 경우
						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objVSInfo.nLastPos - objVSInfo.nAdjustRows
						nAdjustedTop = this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nTopRow + (objVSInfo.nPos - (objVSInfo.nLastPos - objVSInfo.nAdjustRows)) - 1);
					}
					
				} else{//가로 스크롤바가 왼쪽으로 이동했을 때
					arrNormalRowsCellDOMs = arrMovedDynamicRowsCellDOMs.concat(arrNormalRowsCellDOMs);
					nAdjustedTop = this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nTopRow + (objVSInfo.nAdjustRows - (objVSInfo.nLastPos - objVSInfo.nPos)) - 1);
				}
				
				nAdjustHeight = nFrozenRowsHeight;
				QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, idx){
					var nRow, nRowHeight, nCellTop;
					
					nRow = objVSInfo.nTopRow + idx;
					nRowHeight = objQCell._getRowHeight(nRow);
					nCellTop = nAdjustHeight - nAdjustedTop;
					
					QBOX._.each(arrNormalRowCellDOMs, function(heCell){
						heCell.style.top = nCellTop + 'px';
					});
					
					nAdjustHeight += nRowHeight;
				});
				
				this._setCellGroupDOMs('row', 'normal', arrNormalRowsCellDOMs);
			} else{
				if(nMovedCount > 0){
					this._setCellGroupDOMs('row', 'normal', arrNormalRowsCellDOMs.concat(arrMovedDynamicRowsCellDOMs));
				} else{
					this._setCellGroupDOMs('row', 'normal', arrMovedDynamicRowsCellDOMs.concat(arrNormalRowsCellDOMs));
				}
			}
			
			this._syncCellMatrix('row');				//row의 cellMatrix 기준으로 col의 cellMatrix 동기화
		}
		/*merge********************************************************************/
		this._updateMergeData(); //머지 정보 설정
		/*merge********************************************************************/		
		/*
		 * 무결성 체크
		var arrCellGroupResult = _.map(this._getCellGroupDOMs('row', 'normal'), function(arrRowCells){
			return parseInt(arrRowCells[0].getAttribute('data-row'));
		});
		
		//갱신 후 일반 행들의 행 인덱스 번호가 연속적인 값인지 체크
		for(var i = 0 ; i < arrCellGroupResult.length - 1 ; i++){
			if(arrCellGroupResult[i] + 1 !== arrCellGroupResult[i + 1]){
				console.log('전체갱신, 무결성 깨짐', arrCellGroupResult[i], ', ', arrCellGroupResult[i + 1]);
				break;
			}
		}
		*/
		arrMovedDynamicRowsCellDOMs = null;
		var THAT = this;
		setTimeout(function(){
			THAT._trigger('viewport_changed');	
		});
		
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._updateNRs', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype._updateNCs = function(){//NCs -> NormalCols
	//_updateNCs()는 가로스크롤바 이동 시 동기화하기 위해서 사용된다.
	//가로스크롤바 동기화 시 갱신되는 셀들의 열 인덱스는 변경된다. 이전 셀의 동적 변경사항을 제거하는 로직이 필요하다.
	try{
		var css = QBOX.QCELL.def.css,
		objHSInfo = this.attr('hsinfo'), objQCell = this, objUpdateInfo = objHSInfo.objUpdateInfo,
		objGroupState =  this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrHeaderText = this.attr('headertext'),
		arrNormalColsCellDOMs = this._getCellGroupDOMs('col', 'normal'),
		arrMovedDynamicColsCellDOMs = [],
		arrCurrentData = this.attr('currentdata'),
		nHeaderRows = this.attr('headerrows'),
		nHeaderCols = this.attr('headercols'), nFrozenCols = this.attr('frozencols'),
		nViewPortOffsetWidth = this.attr('layoutsize').viewport.offsetWidth,
		nFrozenColsWidth = this._getSumOfColWidth(nHeaderCols, nHeaderCols + nFrozenCols - 1),
		nAdjustColWidths, nAdjustedLeft,
		bIsColSelectMode = this.attr('selectmode').indexOf('col') > -1 ? true : false,
		cellData,objNode = null,
		staticrowsinfo = this.attr('staticrowsinfo'),
		bMake = true, staticrow = -1,strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}
		
		/*merge********************************************************************/
		this._clearMerge(); // Merge 정보 클리어
		this._createMergeInfo();
		/*merge********************************************************************/
		
		if(objUpdateInfo.bWholeUpdate){
			nAdjustedLeft = objUpdateInfo.objParams.nAdjustedLeft;//이동한 가로스크롤바의 위치가 동적 컬럼을 변경하는 것이 아닌 left값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
			nAdjustColWidths = nFrozenColsWidth;
			QBOX._.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
				var nBeforeCol = parseInt(arrNormalColCellDOMs[0].getAttribute('data-col')),
				nCol = objHSInfo.nLeftCol + idx,
				nColWidth = objQCell._getColWidth(nCol),
				nCellLeft = nAdjustColWidths - nAdjustedLeft,
				strColID = objQCell._getColID(nCol),
				strColType = objQCell._getColType(nCol),
				keyOfCol = objQCell._getKeyOfCol(nCol),
				bFirstGroupCol = strColID === strFirstGroupColID ? true : false,
				bBeforeFocusCol = objQCell._isFocusCol(nBeforeCol), bFocusCol = objQCell._isFocusCol(nCol),
				bBeforeSelectedCol = objQCell._isSelectedCol(nBeforeCol), bSelectedCol = objQCell._isSelectedCol(nCol),
				bBeforeStyleCol = objQCell._isCellStyleCol(nBeforeCol), bStyleCol = objQCell._isCellStyleCol(nCol),
				strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
				objColStyle = objQCell._getQCellCol(nCol).attr('style'),
				strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
				
				QBOX._.each(arrNormalColCellDOMs, function(heCell){
					heCell.setAttribute('data-col', nCol);
					heCell.style.left = nCellLeft + 'px';
					
					if(nColWidth !== parseInt(heCell.style.width)){
						heCell.style.width = nColWidth + 'px';
					}
					//heCell.style.display = 'flex';
					
					if(heCell.getAttribute('data-footer') !== 'true'){
						var nRow = parseInt(heCell.getAttribute('data-row')),
						bHeaderRow = nRow < nHeaderRows,
						bBeforeFocusCell = bBeforeFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
						bFocusCell = bFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
						bBeforeSelectedCell = bHeaderRow ? false : (bBeforeSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nBeforeCol)) : false),
						bSelectedCell = bHeaderRow ? false : (bSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)) : false),
						bBeforeStyleCell = bBeforeStyleCol ? objQCell._hasCellStyle(nRow, nBeforeCol) : false,
						bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
						strColStyleGroup = bHeaderRow ? 'header' : 'data',
						strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow],
						objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow];
						
						if(bHeaderRow)heCell.style.display = 'flex';
						else heCell.style.display = '';
						
						heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
						
						QBOX.util.removeClass(heCell, objQCell._getColStyleClassName(nBeforeCol, strColStyleGroup));
						QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
						
						bMake = true;
						if(staticrowsinfo.length > 0){
							for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
								if(staticrowsinfo[staticrow].nRow === nRow){
									bMake = false;
								}
							}
						}
						
						if(!QBOX._.isEmpty(objColStyle)){
							if(QBOX._.isObject(objColStyle[strColStyleGroup])){
								var keys = Object.keys(objColStyle[strColStyleGroup]);
								for(var k = 0; k < keys.length; k++){
									QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
								}
							}
							objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
						}

						if(bHeaderRow){
							if( strColType === 'checkbox' || strColType === 'html') {
								objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
								/*
								if(this._getQCellCol(nCol).attr('sort') === false) {
									objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
								} else {
									QCELL.log('err', 'QCELL.NormalQCELL._updateNCs', 'can not use "sort" to col type "checkbox" or "html"');
									return false;
								}
								*/
							} else {
								heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText,nRow,nCol);
								
								if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
									if(objQCell.attr('useGroupUI')){
										QBOX.$(heCell).draggable({
											helper: objQCell._setGroupMakeHelper,
											revert: 'invalid'
										});
									}
								}
							}
							
							if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
								if(objQCell._getQCellCol(nCol).attr('move')){
									heCell.appendChild(objQCell._getColHeaderDragDropArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('search')){
									heCell.appendChild(objQCell._getColSearchArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('sort') && (QBOX._.isUndefined(objQCell._getQCellCol(nCol).attr('options').wholeselect) || objQCell._getQCellCol(nCol).attr('options').wholeselect === false) && (strColType !== 'checkbox' || objQCell.attr('paginationinfo').totalsort === false || (QBOX._.isUndefined(objQCell.attr('paginationinfo')) === false && QBOX._.isUndefined(objQCell.attr('paginationinfo').url)))){
									heCell.appendChild(objQCell._getDefaultSortArea(nCol));
								}
								
								if(objQCell._getQCellCol(nCol).attr('resize')){
									heCell.appendChild(objQCell._getColResizeArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('filter')){
									heCell.appendChild(objQCell._getFilterArea(nCol));
								}
								
								if(objQCell._getQCellCol(nCol).attr('editor')){
									heCell.appendChild(objQCell._getColStyleEditorArea());
								}
								
								if(objQCell._getQCellCol(nCol).attr('remove')){
									heCell.appendChild(objQCell._getDefaultRemoveArea(nCol));
								}
							}
						} else{
							var arrRowData = arrCurrentData[nRow - nHeaderRows];
							if(arrRowData === undefined)
								return;
							
							cellData = arrRowData[keyOfCol] === undefined ? '' :arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
							var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
							strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData),
							bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
							nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
							bIsGroupTreeUIRow = false;
							
							QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
							if(objGroupState.grouped){															
								if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1){
									bIsGroupHeaderRow = true;																		
									bIsGroupFooterRow = false;
								} else{									
									if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1){
										bIsGroupFooterRow = true;
										bIsGroupHeaderRow = false;
									}
								}
							}
							
							if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
								nIdxOfGroupTreeUIRow = -1; nIdxOfGroupHeaderRow = -1; nIdxOfGroupFooterRow = -1;
								bIsGroupTreeUIRow = false;
								
								nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
								
								if(nIdxOfGroupTreeUIRow > -1){
									bIsGroupTreeUIRow = true;
									objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
									
									bIsGroupHeaderRow = bIsGroupFooterRow = false;
								} else{
									nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
									
									if(nIdxOfGroupHeaderRow > -1){
										bIsGroupHeaderRow = true;
										objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
										
										bIsGroupFooterRow = false;
									} else{
										nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
										
										if(nIdxOfGroupFooterRow > -1){
											bIsGroupFooterRow = true;
											objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
											
											bIsGroupHeaderRow = false;
										}
									}
								}
								
								if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
									if(objNode.key === strDataFormat && objNode.level + nHeaderCols === nCol){
										//tree 아이콘 표시
										objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
									} else if(strDataFormat !== ''){
										//탭처리
										objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
									} else { // 공백 처리
										QBOX.util.textContent(heCell, strDataFormat);
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
									var parentGroupRowInfo = {};
									for(var i = 0; i < objGroupState.treeuirows.length; i++){
										if(nRow > objGroupState.treeuirows[i]){
											parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
										} else {
											break;
										}
									}
									
									if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
										//탭처리
										objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
									} else {
										switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												if(objQCell._isBottomPanel(heCell))													
													QBOX.util.textContent(heCell, cellData);
												else
													QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, cellData);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
									}
								} else {
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									
									switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												if(objQCell._isBottomPanel(heCell))													
													QBOX.util.textContent(heCell, cellData);
												else
													QBOX.util.textContent(heCell, strDataFormat);
												
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, cellData);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
								
							} else if(objGroupState.grouped && bFirstGroupCol && objGroupState.type === 'tree'){
								nIdxOfGroupTreeUIRow = -1; nIdxOfGroupHeaderRow = -1; nIdxOfGroupFooterRow = -1;
								bIsGroupTreeUIRow = false;
											
								if(objGroupState.type === 'tree'){
									nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
								}
								
								if(nIdxOfGroupTreeUIRow > -1){
									bIsGroupTreeUIRow = true;
									objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
									
									bIsGroupHeaderRow = bIsGroupFooterRow = false;
								} else{
									nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
									
									if(nIdxOfGroupHeaderRow > -1){
										bIsGroupHeaderRow = true;
										objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
										
										bIsGroupFooterRow = false;
									} else{
										nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
										
										if(nIdxOfGroupFooterRow > -1){
											bIsGroupFooterRow = true;
											objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
											
											bIsGroupHeaderRow = false;
										}
									}
								}
								
								if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
									//tree 아이콘 표시
									objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
								} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									
									switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												if(objQCell._isBottomPanel(heCell))													
													QBOX.util.textContent(heCell, cellData);
												else
													QBOX.util.textContent(heCell, strDataFormat);
												
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, cellData);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
							} else if(objGroupState.grouped && objGroupState.type === 'group' &&
									QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
								objNode = objQCell._getGroupNode(arrCurrentData[nRow - nHeaderRows],keyOfCol);
								if(objNode !== null){
									objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
								}else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										if(parseInt(heCell.getAttribute("data-row")) === nRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
											strDataFormat = cellData;
										}
										switch(strColType){
											case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
												if(objQCell._isBottomPanel(heCell))													
													QBOX.util.textContent(heCell, cellData);
												else
													QBOX.util.textContent(heCell, strDataFormat);

												break;
											}
											default: {
												QBOX.util.textContent(heCell, cellData);
												break;
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									} else {
										QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
										switch(strColType){
											case 'static': case 'input': case 'datepicker': case 'number': case 'slider': {
												if(objQCell._isBottomPanel(heCell))													
													QBOX.util.textContent(heCell, cellData);
												else
													QBOX.util.textContent(heCell, strDataFormat);
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
											case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
												break;
											}
											case 'selectmenu': case 'multicheckbox': case 'inputbutton': {
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
												break;
											}
											
											default: {
												QBOX.util.textContent(heCell, cellData);
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
									}
								}
								
							}  else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									if(parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												if(objQCell._isBottomPanel(heCell))													
													QBOX.util.textContent(heCell, cellData);
												else
													QBOX.util.textContent(heCell, strDataFormat);

											}
											break;
										}
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, cellData);
											}
											break;
										}
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else {
									QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
									switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												if(bMake){
													if(objQCell._isBottomPanel(heCell))													
														QBOX.util.textContent(heCell, cellData);
													else
														QBOX.util.textContent(heCell, strDataFormat);

												} else {
													QBOX.util.textContent(heCell, cellData);
												}
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											if(bMake){
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
											
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											if(bMake){
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
											
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, cellData);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
									
									if(staticrowsinfo.length > 0){
										for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
											if(staticrowsinfo[staticrow].nRow === nRow){
												QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
												QBOX.util.textContent(heCell, strDataFormatStatic);
												break;
											} else {
												QBOX.util.removeClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
											}
										}
									}
									
									objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
								}
							}
						}
						
						if(objCellInvisible){
							objQCell._setCellInvisible(nRow, nCol, true);
						}
						
						if(bFocusCell && bBeforeFocusCell === false){//갱신 전에는 포커스 셀이 아니였지만 갱신 후에는 포커스 셀인 경우
							objQCell._addFocusStyleClass(heCell);
						} else if(bBeforeFocusCell && bFocusCell === false){//갱신 전에는 포커스 셀이였지만, 갱신 후에는 포커스 셀이 아닌 경우
							objQCell._removeFocusStyleClass(heCell);
						}
						
						if(bSelectedCell && bBeforeSelectedCell === false){//갱신 전에는 선택된 셀이 아니였지만 갱신 후에는 선택된 셀인 경우
							QBOX.util.addClass(heCell, css.CELL_SELECT);
						} else if(bBeforeSelectedCell && bSelectedCell === false){//갱신 전에는 선택된 셀이였지만, 갱신 후에는 선택된 셀이 아닌 경우
							QBOX.util.removeClass(heCell, css.CELL_SELECT);
						}
						
						if(bBeforeStyleCell){//갱신 전에 셀 스타일이 적용되어 있던 경우
							objQCell._removeCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nBeforeCol));
						}
						if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
							objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
						}
						if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
					}
				});
				
				nAdjustColWidths += nColWidth;
			});
		} else{
			var bWholePositionChanged = objUpdateInfo.objParams.bWholePositionChanged,
			nMovedCount = objUpdateInfo.objParams.nMovedCount,
			nCutColsCount = objUpdateInfo.objParams.nCutColsCount;
			
			if(nCutColsCount > 0){
				var nStandardCol;
				
				if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
					arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(0, nCutColsCount);
					nAdjustColWidths = nFrozenColsWidth;
					nStandardCol = objHSInfo.nLeftCol;
				} else{
					arrMovedDynamicColsCellDOMs = arrNormalColsCellDOMs.splice(arrNormalColsCellDOMs.length - nCutColsCount, nCutColsCount);
					nAdjustColWidths = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + nCutColsCount - 1);
					nStandardCol = objHSInfo.nLeftCol + nCutColsCount;
				}
				
				if(!bWholePositionChanged){
					
					//계속 화면에 표시해야 하는 컬럼들의  셀은 갱신하지 않고 left값만 세팅
					QBOX._.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
						var nCol, nColWidth, nCellLeft;
						
						nCol = nStandardCol + idx;
						nColWidth = objQCell._getColWidth(nCol);
						nCellLeft = nAdjustColWidths;
						
						QBOX._.each(arrNormalColCellDOMs, function(heCell){
							heCell.style.left = nCellLeft + 'px';
						});
						
						nAdjustColWidths += nColWidth;
					});
				}
				
				//화면에 표시하지 않아야 하는 컬럼 셀들은 가장 우측에 표시되고 있는 컬럼 옆으로 이동시킨 후 갱신해야 한다.
				nStandardCol = nMovedCount > 0 ? objHSInfo.nRightCol - nCutColsCount + 1 : objHSInfo.nLeftCol;
				nAdjustColWidths = nMovedCount > 0 ? nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nRightCol - nCutColsCount) : nFrozenColsWidth;
				
				QBOX._.each(arrMovedDynamicColsCellDOMs, function(arrMovedColCellDOMs, idx){
					var nBeforeCol = parseInt(arrMovedColCellDOMs[0].getAttribute('data-col')),
					nCol = nStandardCol + idx,
					nColWidth = objQCell._getColWidth(nCol),
					nCellLeft = nAdjustColWidths,
					strColID = objQCell._getColID(nCol),
					strColType = objQCell._getColType(nCol),
					keyOfCol = objQCell._getKeyOfCol(nCol),
					bFirstGroupCol = strColID === strFirstGroupColID ? true : false,
					bBeforeFocusCol = objQCell._isFocusCol(nBeforeCol), bFocusCol = objQCell._isFocusCol(nCol),
					bBeforeSelectedCol = objQCell._isSelectedCol(nBeforeCol), bSelectedCol = objQCell._isSelectedCol(nCol),
					bBeforeStyleCol = objQCell._isCellStyleCol(nBeforeCol), bStyleCol = objQCell._isCellStyleCol(nCol),
					strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
					objColStyle = objQCell._getQCellCol(nCol).attr('style'),
					strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
					
					QBOX._.each(arrMovedColCellDOMs, function(heCell){						
						heCell.setAttribute('data-col', nCol);
												
						if(nColWidth !== parseInt(heCell.style.width)){
							heCell.style.width = nColWidth + 'px';
						}
						
						if(!bWholePositionChanged){
							heCell.style.left = nCellLeft + 'px';
						}
						
						//heCell.style.display = 'flex';
						
						if(heCell.getAttribute('data-footer') !== 'true'){
							var nRow = parseInt(heCell.getAttribute('data-row')),
							bHeaderRow = nRow < nHeaderRows,
							bBeforeFocusCell = bBeforeFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
							bFocusCell = bFocusCol ? (objQCell._isFocusRow(nRow) ? true : false): false,
							bBeforeSelectedCell = bHeaderRow ? false : (bBeforeSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nBeforeCol)) : false),
							bSelectedCell = bHeaderRow ? false : (bSelectedCol ? (bIsColSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)) : false),
							bBeforeStyleCell = bBeforeStyleCol ? objQCell._hasCellStyle(nRow, nBeforeCol) : false,
							bStyleCell = bStyleCol ? objQCell._hasCellStyle(nRow, nCol) : false,
							strColStyleGroup = bHeaderRow ? 'header' : 'data',
							strHeaderCellText = arrHeaderText[nCol][nRow] === undefined ? '' : arrHeaderText[nCol][nRow],
							objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow];
									
							if(bHeaderRow)heCell.style.display = 'flex';
							else heCell.style.display = '';
							
							heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
							
							QBOX.util.removeClass(heCell, objQCell._getColStyleClassName(nBeforeCol, strColStyleGroup));
							QBOX.util.addClass(heCell, objQCell._getColStyleClassName(nCol, strColStyleGroup));
							
							bMake = true;
							if(staticrowsinfo.length > 0){
								for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
									if(staticrowsinfo[staticrow].nRow === nRow){
										bMake = false;
									}
								}
							}
							
							if(!QBOX._.isEmpty(objColStyle)){
								if(QBOX._.isObject(objColStyle[strColStyleGroup])){
									var keys = Object.keys(objColStyle[strColStyleGroup]);
									for(var k = 0; k < keys.length; k++){
										QBOX.$(heCell).css(keys[k], objColStyle[strColStyleGroup][keys[k]]);
									}
								}
								objQCell.attr('qcellcols')[nCol].attr('style', {header: objColStyle.header, data: objColStyle.data}, 'object');
							}
							
							if(bHeaderRow){
								if( strColType === 'checkbox' || strColType === 'html') {
									objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
									/*
									if(this._getQCellCol(nCol).attr('sort') === false) {
										objQCell._getColElement(nCol)._headershow(heCell, nRow, nCol);
									} else {
										QCELL.log('err', 'QCELL.NormalQCELL._updateNCs', 'can not use "sort" to col type "checkbox" or "html"');
										return false;
									}
									*/
								} else{
									heCell.innerHTML = objQCell._getHeaderCellSpan(strHeaderCellText,nRow,nCol);
									
									if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
										if(objQCell.attr('useGroupUI')){
											QBOX.$(heCell).draggable({
												helper: objQCell._setGroupMakeHelper,
												revert: 'invalid'
											});
										}
									}
								}
								
								if(nRow === nHeaderRows - 1 || objQCell._isLastHeaderRowMasterCell(nRow, nCol)){
									if(objQCell._getQCellCol(nCol).attr('move')){
										heCell.appendChild(objQCell._getColHeaderDragDropArea());
									}
									
									if(objQCell._getQCellCol(nCol).attr('search')){
										heCell.appendChild(objQCell._getColSearchArea());
									}
									
									if(objQCell._getQCellCol(nCol).attr('sort') && (QBOX._.isUndefined(objQCell._getQCellCol(nCol).attr('options').wholeselect) || objQCell._getQCellCol(nCol).attr('options').wholeselect === false) && (strColType !== 'checkbox' || objQCell.attr('paginationinfo').totalsort === false || (QBOX._.isUndefined(objQCell.attr('paginationinfo')) === false && QBOX._.isUndefined(objQCell.attr('paginationinfo').url)))){					
										heCell.appendChild(objQCell._getDefaultSortArea(nCol));
									}
									
									if(objQCell._getQCellCol(nCol).attr('resize')){
										heCell.appendChild(objQCell._getColResizeArea());
									}
									
									if(objQCell._getQCellCol(nCol).attr('filter')){										
										heCell.appendChild(objQCell._getFilterArea(nCol));
									}
									
									if(objQCell._getQCellCol(nCol).attr('editor')){
										heCell.appendChild(objQCell._getColStyleEditorArea());
									}
									
									if(objQCell._getQCellCol(nCol).attr('remove')){
										heCell.appendChild(objQCell._getDefaultRemoveArea(nCol));
									}
								}
							} else{
								var arrRowData = arrCurrentData[nRow - nHeaderRows];
								if(arrRowData === undefined)
									return;
								cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
								var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
								strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData),
								bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
								nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
								bIsGroupTreeUIRow = false;
								
								QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
								if(objGroupState.grouped){															
									if(QBOX._.indexOf(objGroupState.headerrows, nRow, true) > -1){
										bIsGroupHeaderRow = true;																		
										bIsGroupFooterRow = false;
									} else{									
										if(QBOX._.indexOf(objGroupState.footerrows, nRow, true) > -1){
											bIsGroupFooterRow = true;
											bIsGroupHeaderRow = false;
										}
									}
								}
								
								if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
									nIdxOfGroupTreeUIRow = -1; nIdxOfGroupHeaderRow = -1; nIdxOfGroupFooterRow = -1;
									bIsGroupTreeUIRow = false;
									
									nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
									
									if(nIdxOfGroupTreeUIRow > -1){
										bIsGroupTreeUIRow = true;
										objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
										
										bIsGroupHeaderRow = bIsGroupFooterRow = false;
									} else{
										nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
										
										if(nIdxOfGroupHeaderRow > -1){
											bIsGroupHeaderRow = true;
											objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
											
											bIsGroupFooterRow = false;
										} else{
											nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
											
											if(nIdxOfGroupFooterRow > -1){
												bIsGroupFooterRow = true;
												objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
												
												bIsGroupHeaderRow = false;
											}
										}
									}
									
									if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
										if(objNode.key === strDataFormat && objNode.level + nHeaderCols === nCol){
											//tree 아이콘 표시
											objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
										} else if(strDataFormat !== ''){
											//탭처리
											objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
										} else { // 공백 처리
											QBOX.util.textContent(heCell, strDataFormat);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
										var parentGroupRowInfo = {};
										for(var i = 0; i < objGroupState.treeuirows.length; i++){
											if(nRow > objGroupState.treeuirows[i]){
												parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
											} else {
												break;
											}
										}
										
										if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
											//탭처리
											objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
										} else {
											switch(strColType){
											case 'static': case 'input': case 'number': case 'slider': {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													if(objQCell._isBottomPanel(heCell))													
														QBOX.util.textContent(heCell, cellData);
													else
														QBOX.util.textContent(heCell, strDataFormat);

												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
											case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
												break;
											}
											case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
												break;
											}
											
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, cellData);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
										}
									} else {
										if(bIsGroupHeaderRow || bIsGroupFooterRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
											strDataFormat = cellData;
										}
										
										switch(strColType){
											case 'static': case 'input': case 'number': case 'slider': {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													if(objQCell._isBottomPanel(heCell))													
														QBOX.util.textContent(heCell, cellData);
													else
														QBOX.util.textContent(heCell, strDataFormat);

												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
											case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
												break;
											}
											case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
												break;
											}
											
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, cellData);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
									}
									
								} else if(objGroupState.grouped && bFirstGroupCol && objGroupState.type === 'tree'){
									nIdxOfGroupTreeUIRow = -1; nIdxOfGroupHeaderRow = -1; nIdxOfGroupFooterRow = -1;
									bIsGroupTreeUIRow = false;
												
									if(objGroupState.type === 'tree'){
										nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
									}
									
									if(nIdxOfGroupTreeUIRow > -1){
										bIsGroupTreeUIRow = true;
										objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
										
										bIsGroupHeaderRow = bIsGroupFooterRow = false;
									} else{
										nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
										
										if(nIdxOfGroupHeaderRow > -1){
											bIsGroupHeaderRow = true;
											objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
											
											bIsGroupFooterRow = false;
										} else{
											nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
											
											if(nIdxOfGroupFooterRow > -1){
												bIsGroupFooterRow = true;
												objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
												
												bIsGroupHeaderRow = false;
											}
										}
									}
									
									if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
										//tree 아이콘 표시										
										objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
									} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
										//탭처리
										objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
									} else{
										if(bIsGroupHeaderRow || bIsGroupFooterRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
											strDataFormat = cellData;											
										}
										switch(strColType){
											case 'static': case 'input': case 'number': case 'slider': {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													if(objQCell._isBottomPanel(heCell))													
														QBOX.util.textContent(heCell, cellData);
													else
														QBOX.util.textContent(heCell, strDataFormat);

												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
											case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
												break;
											}
											case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
												break;
											}
											
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, cellData);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
									}
								}    else if(objGroupState.grouped && objGroupState.type === 'group' &&
										QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
									objNode = objQCell._getGroupNode(arrCurrentData[nRow - nHeaderRows],keyOfCol);
									if(objNode !== null){
										objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
									}else{
										if(bIsGroupHeaderRow || bIsGroupFooterRow){
											if(parseInt(heCell.getAttribute("data-row")) === nRow){
												QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
												strDataFormat = cellData;
											}
											switch(strColType){
												case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
													if(objQCell._isBottomPanel(heCell))													
														QBOX.util.textContent(heCell, cellData);
													else
														QBOX.util.textContent(heCell, strDataFormat);

													break;
												}
												default: {
													QBOX.util.textContent(heCell, cellData);
													break;
												}
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										} else {
											QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
											switch(strColType){
												case 'static': case 'input': case 'datepicker': case 'number': case 'slider': {
													if(objQCell._isBottomPanel(heCell))													
														QBOX.util.textContent(heCell, cellData);
													else
														QBOX.util.textContent(heCell, strDataFormat);
													objQCell._setAriaLabelEx(heCell,nRow,nCol);
													break;
												}
												case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
													objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
													break;
												}
												case 'selectmenu': case 'multicheckbox': case 'inputbutton':{
													objQCell._getColElement(nCol)._showDataLabel(heCell,nRow,  nCol, cellData);
													break;
												}
												
												default: {
													QBOX.util.textContent(heCell, cellData);
													objQCell._setAriaLabelEx(heCell,nRow,nCol);
													break;
												}
											}
										}
									}
									
								}  else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										if(parseInt(heCell.getAttribute("data-row")) === nRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
											strDataFormat = cellData;
										}
										switch(strColType){
											case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton': {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													if(objQCell._isBottomPanel(heCell))													
														QBOX.util.textContent(heCell, cellData);
													else
														QBOX.util.textContent(heCell, strDataFormat);

												}
												break;
											}
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, cellData);
												}
												break;
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									} else {
										QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
										switch(strColType){
											case 'static': case 'input': case 'number': case 'slider': {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
												}
												else {
													if(bMake){
														if(objQCell._isBottomPanel(heCell))													
															QBOX.util.textContent(heCell, cellData);
														else
															QBOX.util.textContent(heCell, strDataFormat);

													} else {
														QBOX.util.textContent(heCell, cellData);
													}
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
											case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
												if(bMake){
													objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
												} else {
													QBOX.util.textContent(heCell, cellData);
												}
												
												break;
											}
											case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
												if(bMake){
													objQCell._getColElement(nCol)._showDataLabel(heCell,nRow,  nCol, cellData);
												} else {
													QBOX.util.textContent(heCell, cellData);
												}
												
												break;
											}
											
											default: {
												if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
													heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
												}
												else {
													QBOX.util.textContent(heCell, cellData);
												}
												objQCell._setAriaLabelEx(heCell,nRow,nCol);
												break;
											}
										}
										
										if(staticrowsinfo.length > 0){
											for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
												if(staticrowsinfo[staticrow].nRow === nRow){
													QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
													QBOX.util.textContent(heCell, strDataFormatStatic);
													break;
												} else {
													QBOX.util.removeClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
												}
											}
										}
										
										objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
									}
								}
							}
							
							if(objCellInvisible){
								objQCell._setCellInvisible(nRow, nCol, true);
							}
							
							if(bFocusCell && bBeforeFocusCell === false){//갱신 전에는 포커스 셀이 아니였지만 갱신 후에는 포커스 셀인 경우
								objQCell._addFocusStyleClass(heCell);
							} else if(bBeforeFocusCell && bFocusCell === false){//갱신 전에는 포커스 셀이였지만, 갱신 후에는 포커스 셀이 아닌 경우
								objQCell._removeFocusStyleClass(heCell);
							}
							
							if(bSelectedCell && bBeforeSelectedCell === false){//갱신 전에는 선택된 셀이 아니였지만 갱신 후에는 선택된 셀인 경우
								QBOX.util.addClass(heCell, css.CELL_SELECT);
							} else if(bBeforeSelectedCell && bSelectedCell === false){//갱신 전에는 선택된 셀이였지만, 갱신 후에는 선택된 셀이 아닌 경우
								QBOX.util.removeClass(heCell, css.CELL_SELECT);
							}
							
							if(bBeforeStyleCell){//갱신 전에 셀 스타일이 적용되어 있던 경우
								objQCell._removeCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nBeforeCol));
							}
							if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
								objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
							}
							if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
						}
					});
					
					nAdjustColWidths += nColWidth;
				});
			}
			
			if(bWholePositionChanged){
				//스크롤이 이동한만큼 모두 뜯어내지 못했으면 전체 셀의 left를 보정해야 하는 경우다.
				if(nMovedCount > 0){//가로 스크롤바가 오른쪽으로 이동했을 때
					arrNormalColsCellDOMs = arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs);
					
					if(objHSInfo.nLastPos === objHSInfo.nPos){//viewport의 우측 끝 경계선과 마지막 셀의 끝을 맞춰야 하는 경우
						nAdjustedLeft = nFrozenColsWidth + this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nEndCol) - nViewPortOffsetWidth;
					} else{//컬럼의 width만큼 left를 이동시켜야 하는 경우
						//스크롤이 이동한만큼 모두 뜯어낼 수 있는 스크롤의 범위: objHSInfo.nLastPos - objHSInfo.nAdjustCols
						nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nPos - (objHSInfo.nLastPos - objHSInfo.nAdjustCols)) - 1);
					}
				} else{//가로 스크롤바가 왼쪽으로 이동했을 때
					arrNormalColsCellDOMs = arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs);
					nAdjustedLeft = this._getSumOfColWidth(objHSInfo.nLeftCol, objHSInfo.nLeftCol + (objHSInfo.nAdjustCols - (objHSInfo.nLastPos - objHSInfo.nPos)) - 1);
				}
				
				nAdjustColWidths = nFrozenColsWidth;
				QBOX._.each(arrNormalColsCellDOMs, function(arrNormalColCellDOMs, idx){
					var nCol, nColWidth, nCellLeft;
					
					nCol = objHSInfo.nLeftCol + idx;
					nColWidth = objQCell._getColWidth(nCol);
					nCellLeft = nAdjustColWidths - nAdjustedLeft;
					
					QBOX._.each(arrNormalColCellDOMs, function(heCell){
						heCell.style.left = nCellLeft + 'px';
					});
					
					nAdjustColWidths += nColWidth;
				});
				
				this._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs);
			} else{
				if(nMovedCount > 0){
					this._setCellGroupDOMs('col', 'normal', arrNormalColsCellDOMs.concat(arrMovedDynamicColsCellDOMs));
				} else{
					this._setCellGroupDOMs('col', 'normal', arrMovedDynamicColsCellDOMs.concat(arrNormalColsCellDOMs));
				}
			}
			
			this._syncCellMatrix('col');				//col의 cellMatrix 기준으로 row의 cellMatrix 동기화
		}
		
		/*merge********************************************************************/
		this._updateMerge(); //머지 정보 설정
		/*merge********************************************************************/
		
		/*
		 * 무결성 체크
		var arrCellGroupResult = _.map(this._getCellGroupDOMs('col', 'normal'), function(arrColCells){
			return parseInt(arrColCells[0].getAttribute('data-col'));
		});
		
		//갱신 후 일반 열들의 열 인덱스 번호가 연속적인 값인지 체크
		for(var j = 0 ; j < arrCellGroupResult.length - 1 ; j++){
			if(arrCellGroupResult[j] + 1 !== arrCellGroupResult[j + 1]){
				console.log('전체갱신, 무결성 깨짐', arrCellGroupResult[j], ', ', arrCellGroupResult[j + 1]);
				break;
			}
		}
		*/
		arrMovedDynamicColsCellDOMs = null;
		
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._updateNCs', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype._updateNRsAll = function(){//NRs -> NormalRows
	//_updateNRs()는 세로스크롤바 이동 시 동기화하기 위해서 사용된다.
	//세로스크롤바 동기화 시 갱신되는 셀들의 행 인덱스는 변경된다. 이전 셀의 동적 변경사항을 제거하는 로직이 필요하다.
	try{
		var css = QBOX.QCELL.def.css,
		objVSInfo = this.attr('vsinfo'), objQCell = this, objUpdateInfo = objVSInfo.objUpdateInfo,
		objGroupState =  this.attr('groupstate').grouped ? this.attr('groupstate') : this.attr('treestate'),
		strFirstGroupColID = objGroupState.grouped ? objGroupState.columnsinfo.keys(true)[0] : '',
		arrNormalRowsCellDOMs = this._getCellGroupDOMs('row', 'normal'),
		arrMovedDynamicRowsCellDOMs = [],
		arrRowHeaders = this.attr('rowheaders'),
		arrCurrentData = this.attr('currentdata'),
		nCurrentDataCount = arrCurrentData.length,
		nHeaderRows = this.attr('headerrows'), nFrozenRows = this.attr('frozenrows'), nFrozenBottomRows = this.attr('frozenbottomrows'), nRows = this.attr('rows'),
		nHeaderCols = this.attr('headercols'),
		nHighlightRepeat = this.attr('highlightrepeat'),
		nDataRowHeight = this.attr('rowheight').data,
		nViewPortOffsetHeight = this.attr('layoutsize').viewport.offsetHeight,
		nFrozenRowsHeight = this._getSumOfRowHeight(nHeaderRows, nHeaderRows + nFrozenRows - 1),
		nFrozenBottomRowsHeight = this._getSumOfRowHeight(nRows - nFrozenBottomRows, nRows - 1),
		nAdjustHeight, nAdjustedTop,
		bIsRowSelectMode = this.attr('selectmode').indexOf('row') > -1 ? true : false,
		cellData,nGroupRow =-1,objNode,
		staticrowsinfo = this.attr('staticrowsinfo'),
		bMake = true, staticrow = -1,
		bPanel = this.attr('frozenbottomstyle') === 'panel' ? true : false,strId= this.attr('id'),nR = 0;
		
		if(this._isPanel()){
			nR++;
		}
		
				
		/*merge********************************************************************/
		this._clearMergeData(); // Merge 정보 클리어
		this._createDataMergeInfo();
		/*merge********************************************************************/
		
		//if(objUpdateInfo.bWholeUpdate)
		{
			nAdjustedTop = objUpdateInfo.objParams.nAdjustedTop;//이동한 세로스크롤바의 위치가 동적 행을 변경하는 것이 아닌 top값을 보정해야 하는 범위(보정 범위)내에 있을 때의 보정값
			nAdjustHeight = nFrozenRowsHeight;
			
			if(objVSInfo.nEndRow === objVSInfo.nBottomRow){
				if(nAdjustedTop === undefined){
					nAdjustedTop = nFrozenRowsHeight + this._getSumOfRowHeight(objVSInfo.nTopRow, objVSInfo.nEndRow) - (nViewPortOffsetHeight - nFrozenBottomRowsHeight);					
				}
			}
			if(nAdjustedTop === undefined)
				nAdjustedTop = 0;			
			
			QBOX._.each(arrNormalRowsCellDOMs, function(arrNormalRowCellDOMs, idx){
				var nBeforeRow = parseInt(arrNormalRowCellDOMs[0].getAttribute('data-row')),
				nRow = objVSInfo.nTopRow + idx,
				nRowHeight = objQCell._getRowHeight(nRow),
				nCellTop = nAdjustHeight - nAdjustedTop,
				nIdxOfGroupTreeUIRow = -1, nIdxOfGroupHeaderRow = -1, nIdxOfGroupFooterRow = -1,
				bIsGroupTreeUIRow = false, bIsGroupHeaderRow = false, bIsGroupFooterRow = false,
				objNode = null,
				arrRowData = arrCurrentData[nRow - nHeaderRows],
				bBeforeFocusRow = objQCell._isFocusRow(nBeforeRow), bFocusRow = objQCell._isFocusRow(nRow),
				bBeforeSelectedRow = objQCell._isSelectedRow(nBeforeRow), bSelectedRow = objQCell._isSelectedRow(nRow),
				bBeforeStyleRow = objQCell._isCellStyleRow(nBeforeRow), bStyleRow = objQCell._isCellStyleRow(nRow),
				bBeforeHighlightRepeatRow = nHighlightRepeat > 0 && ((nBeforeRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false,
				bHighlightRepeatRow = nHighlightRepeat > 0 && ((nRow - nHeaderRows + 1) % nHighlightRepeat === 0) ? true : false;
				
				if(objGroupState.grouped){
					if(objGroupState.type === 'tree' || objGroupState.type === 'step'){
						nIdxOfGroupTreeUIRow = QBOX._.indexOf(objGroupState.treeuirows, nRow, true);
					}
					
					if(nIdxOfGroupTreeUIRow > -1){
						bIsGroupTreeUIRow = true;
						objNode = objGroupState.treeuirownodes[nIdxOfGroupTreeUIRow];
						
						bIsGroupHeaderRow = bIsGroupFooterRow = false;
					} else{
						nIdxOfGroupHeaderRow = QBOX._.indexOf(objGroupState.headerrows, nRow, true);
						
						if(nIdxOfGroupHeaderRow > -1){
							bIsGroupHeaderRow = true;
							objNode = objGroupState.headerrownodes[nIdxOfGroupHeaderRow];
							
							bIsGroupFooterRow = false;
						} else{
							nIdxOfGroupFooterRow = QBOX._.indexOf(objGroupState.footerrows, nRow, true);
							
							if(nIdxOfGroupFooterRow > -1){
								bIsGroupFooterRow = true;
								objNode = objGroupState.footerrownodes[nIdxOfGroupFooterRow];
								
								bIsGroupHeaderRow = false;
							}
						}
					}
				}
				
				bMake = true;
				if(staticrowsinfo.length > 0){
					for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
						if(staticrowsinfo[staticrow].nRow === nRow){
							bMake = false;
						}
					}
				}
				
				QBOX._.each(arrNormalRowCellDOMs, function(heCell, idx2){
					heCell.setAttribute('data-row', nRow);
					heCell.style.top = nCellTop + 'px';
					if(nRowHeight !== parseInt(heCell.style.height)){
						heCell.style.height = nRowHeight + 'px';
					}
					
					if(heCell.getAttribute('data-footer') !== 'true'){
						var nCol = parseInt(heCell.getAttribute('data-col')),
						strColID = objQCell._getColID(nCol),
						strColType = objQCell._getColType(nCol),
						keyOfCol = objQCell._getKeyOfCol(nCol),
						bBeforeFocusCell = bBeforeFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
						bFocusCell = bFocusRow ? (objQCell._isFocusCol(nCol) ? true : false) : false,
						bBeforeSelectedCell = bBeforeSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nBeforeRow, nCol)): false,
						bSelectedCell = bSelectedRow ? (bIsRowSelectMode ? true : objQCell._isSelectedCell(nRow, nCol)): false,
						bBeforeStyleCell = bBeforeStyleRow ? objQCell._hasCellStyle(nBeforeRow, nCol) : false,
						bStyleCell = bStyleRow ? objQCell._hasCellStyle(nRow, nCol) : false,
						heCheckbox,
						strColStyleEditorData = objQCell._getQCellCol(nCol).attr('colstyleeditordata'),
						objCellInvisible = objQCell._getQCellCol(nCol).attr('cellinvisible')[nRow],
						strTextAlign = objQCell._getDataTextAlign(nCol), bUseDataTextAlign = objQCell._useDataTextAlign(nCol);
								
						heCell.setAttribute('id', strId + '_cell_' + nRow + '_' + nCol);
						
						
						if(nCol < nHeaderCols){
							var objPaginationInfo = objQCell.attr('paginationinfo');
							
							if( QBOX._.isObject(objPaginationInfo) && QBOX._.isEmpty(objPaginationInfo) ) {
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									if(objQCell._isBottomPanel( heCell )){
										if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
											QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										}
										return;
									}
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? nCurrentDataCount - (nRow - nHeaderRows+ nR) : nRow - nHeaderRows + 1);
								} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
									if(objQCell._isBottomPanel( heCell ))
										return;									
									heCell.innerHTML = '';
									
									if(bMake){
										heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
										heCell.appendChild(heCheckbox);
										
										if(arrRowHeaders[nCol]==='checkbox')
											heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
										else
											heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

									}
								} else if(arrRowHeaders[nCol] === 'state') {
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							} else {
								var nPageRow = nRow;
								// multiheader 일 때
								if(nHeaderRows > 1) {
									nPageRow = nRow - (nHeaderRows - 1);
								}
								
								if(arrRowHeaders[nCol] === 'sequence' || arrRowHeaders[nCol] === 'reverse') {
									if(objQCell._isBottomPanel( heCell )){
										if(objQCell.getRowData(nRow).rt_qc_seq !== undefined){
											QBOX.util.textContent(heCell,objQCell.getRowData(nRow).rt_qc_seq);
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
										return;
									}
									QBOX.util.textContent(heCell, arrRowHeaders[nCol] === 'reverse' ? (objPaginationInfo.datacount - ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + (nPageRow - 1))) : ((objPaginationInfo.pageindex - 1) * objPaginationInfo.pageunit + nPageRow) );
								} else if(arrRowHeaders[nCol] === 'checkbox' || arrRowHeaders[nCol] === 'radio') {
									if(objQCell._isBottomPanel( heCell ))
										return;									
									heCell.innerHTML = '';
									
									if(bMake){
										heCheckbox = objQCell._createRowheaderCheckbox(heCell, nRow, nCol,arrRowHeaders[nCol]);
										heCell.appendChild(heCheckbox);
										
										if(arrRowHeaders[nCol]==='checkbox')
											heCell.className += ' '+ css.ROWHEADER_CELL_CHECKBOX;
										else
											heCell.className += ' ' +css.ROWHEADER_CELL_RADIO;

									}
								} else if(arrRowHeaders[nCol] === 'state') {
									objQCell._setRowheaderState(heCell,nRow);
								} else if(arrRowHeaders[nCol] === 'custom') {
									objQCell._setRowheaderCustom(heCell,nRow,nCol);
								}
								objQCell._setAriaLabelEx(heCell,nRow,nCol);
							}
						} else{
							cellData = arrRowData[keyOfCol] === undefined ? '' : arrRowData[keyOfCol]; //null이나 undefined인 경우 공백처리
							var strDataFormat = objQCell._showDataFormat(nRow,nCol, cellData),
							strDataFormatStatic = objQCell._showDataFormatStatic(nCol, cellData);
							
							QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
							
							if(objGroupState.grouped && objGroupState.type === 'step'){ //group이며 step type일 때
								
								if(bIsGroupTreeUIRow){ //접고 펼치기 기능이 있는 GroupTreeUIRow인 경우
									if(objNode.key === strDataFormat && objNode.level + nHeaderCols === nCol){
										//tree 아이콘 표시
										objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
									} else if(strDataFormat !== ''){
										//탭처리
										objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
									} else { // 공백 처리
										QBOX.util.textContent(heCell, strDataFormat);
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){ //header,footer 행이 아닌 데이터 표시 행인 경우
									var parentGroupRowInfo = {};
									for(var i = 0; i < objGroupState.treeuirows.length; i++){
										if(nRow > objGroupState.treeuirows[i]){
											parentGroupRowInfo = objGroupState.treeuirownodes[i]; //데이터의 상위 grouprow정보 획득
										} else {
											break;
										}
									}
									
									if(nCol <= parentGroupRowInfo.level + nHeaderCols){ //현재col index가 group의 level과 같거나 낮을 때 탭 처리
										//탭처리
										objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
									} else {
										if(staticrowsinfo.length > 0){
											for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
												if(staticrowsinfo[staticrow].nRow === nRow){
													strDataFormat = strDataFormatStatic;
													break;
												}
											}
										}
										switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
									}
								} else {
									if(staticrowsinfo.length > 0){
										for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
											if(staticrowsinfo[staticrow].nRow === nRow){
												strDataFormat = strDataFormatStatic;
												break;
											}
										}
									}
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									
									switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
							} else if(objGroupState.grouped && strColID === strFirstGroupColID  && objGroupState.type === 'tree'){
								if(bIsGroupTreeUIRow){//첫번째 그룹 레벨 컬럼의 셀이면서 GroupTreeUIRow인 경우
									//tree 아이콘 표시
									objQCell._setTHSub(heCell,objNode,strColType,strDataFormat,cellData);
								} else if(!(bIsGroupHeaderRow || bIsGroupFooterRow)){//첫번째 그룹 레벨 컬럼의 셀이면서 header/footer 행이 아닌 데이터 표시 행인 경우
									//탭처리
									objQCell._setTDSub(heCell,strColType,strDataFormat,cellData,arrRowData);
								} else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									
									switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton':{
											objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
								}
							}  else if(objGroupState.grouped && objGroupState.type === 'group' &&
									QBOX._.indexOf(objGroupState.columnsinfo.keys(true), strColID ,true) >=0 ){
								objNode = objQCell._getGroupNode(arrRowData,keyOfCol);
								if(objNode !== null){
									objQCell._setGroupUICell(heCell, objNode, strDataFormat);	
								}else{
									if(bIsGroupHeaderRow || bIsGroupFooterRow){
										if(parseInt(heCell.getAttribute("data-row")) === nRow){
											QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
											strDataFormat = cellData;
										}
										switch(strColType){
											case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
												QBOX.util.textContent(heCell, strDataFormat);
												break;
											}
											default: {
												QBOX.util.textContent(heCell, cellData);
												break;
											}
										}
										objQCell._setAriaLabelEx(heCell,nRow,nCol);
									} else {
										if(bIsGroupHeaderRow || bIsGroupFooterRow){
											if(parseInt(heCell.getAttribute("data-row")) === nRow){
												QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
												strDataFormat = cellData;
											}
											switch(strColType){
												case 'static': case 'input': case 'datepicker': case 'number': case 'slider':case 'inputbutton': {
													QBOX.util.textContent(heCell, strDataFormat);
													break;
												}
												default: {
													QBOX.util.textContent(heCell, cellData);
													break;
												}
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
										} else {
											QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
											switch(strColType){
												case 'static': case 'input': case 'datepicker': case 'number': case 'slider': {
													QBOX.util.textContent(heCell, strDataFormat);
													objQCell._setAriaLabelEx(heCell,nRow,nCol);
													break;
												}
												case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
													objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
													break;
												}
												case 'selectmenu': case 'multicheckbox': case 'inputbutton':{
													objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
													break;
												}
												
												default: {
													QBOX.util.textContent(heCell, strDataFormat);
													objQCell._setAriaLabelEx(heCell,nRow,nCol);
													break;
												}
											}
										}
									}
								}
								
							}  else{
								if(bIsGroupHeaderRow || bIsGroupFooterRow){
									if(parseInt(heCell.getAttribute("data-row")) === nRow){
										QBOX.util.addClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev' + objQCell._getHFNodeLevel(objNode,objGroupState,nRow));
										strDataFormat = cellData;
									}
									switch(strColType){
										case 'static': case 'input': case 'datepicker': case 'number': case 'slider': case 'inputbutton':{
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											break;
										}
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, cellData);
											}
											break;
										}
									}
									objQCell._setAriaLabelEx(heCell,nRow,nCol);
								} else {
									QBOX.util.removeClass(heCell, css.GROUPTREEUI_HEADER + ' ' + css.GROUPTREEUI_FOOTER + ' rt-qc-gtui-' + strColID + ' rt-qc-gtui-lev-outer rt-qc-gtui-lev0 rt-qc-gtui-lev1 rt-qc-gtui-lev2 rt-qc-gtui-lev3 rt-qc-gtui-lev4 rt-qc-gtui-lev5');
									switch(strColType){
										case 'static': case 'input': case 'number': case 'slider': {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', strDataFormat);
											}
											else {
												if(bMake){
													QBOX.util.textContent(heCell, strDataFormat);
												} else {
													QBOX.util.textContent(heCell, cellData);
												}
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
										case 'checkbox': case 'image': case 'html': case 'chart': case 'button': {
											if(bMake){
												objQCell._getColElement(nCol)._show(heCell, nRow, nCol);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
											
											break;
										}
										case 'selectmenu': case 'datepicker': case 'multicheckbox': case 'editor': case 'inputbutton': {
											if(bMake){
												objQCell._getColElement(nCol)._showDataLabel(heCell, nRow, nCol, cellData);
											} else {
												QBOX.util.textContent(heCell, cellData);
											}
											
											break;
										}
										
										default: {
											if(strColStyleEditorData.replace('QCELL_COL_DATA', '').length > 0){
												heCell.innerHTML = strColStyleEditorData.replace('QCELL_COL_DATA', cellData);
											}
											else {
												QBOX.util.textContent(heCell, strDataFormat);
											}
											objQCell._setAriaLabelEx(heCell,nRow,nCol);
											break;
										}
									}
									
									if(staticrowsinfo.length > 0){
										for(staticrow = 0; staticrow < staticrowsinfo.length; staticrow++){
											if(staticrowsinfo[staticrow].nRow === nRow){
												QBOX.util.addClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
												QBOX.util.textContent(heCell, strDataFormatStatic);
												break;
											} else {
												QBOX.util.removeClass(heCell, css.STATIC_ROW + ' ' + css.STATIC_ROW + '-' + strColID);
											}
										}
									}
									
									objQCell._showGrandTotal(heCell,nRow,nCol,cellData);
								}
							}
						}
						
						if(objCellInvisible){
							objQCell._setCellInvisible(nRow, nCol, true);
						}
						
						if(nCol >= nHeaderCols){
							if(bHighlightRepeatRow){
								if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT) === false){
									QBOX.util.addClass(heCell, css.CELL_HIGHLIGHTREPEAT);
								}
							} else{
								if(QBOX.util.hasClass(heCell, css.CELL_HIGHLIGHTREPEAT)){
									QBOX.util.removeClass(heCell, css.CELL_HIGHLIGHTREPEAT);
								}
							}


						}
						
						objQCell._removeFocusStyleClass(heCell);
						if(bFocusCell ){//갱신 전에는 포커스 셀이 아니였지만 갱신 후에는 포커스 셀인 경우
							objQCell._addFocusStyleClass(heCell);
						} 						
	
						if(bSelectedCell && bBeforeSelectedCell === false){//갱신 전에는 선택된 셀이 아니였지만 갱신 후에는 선택된 셀인 경우
							QBOX.util.addClass(heCell, css.CELL_SELECT);
						} else if(bBeforeSelectedCell && bSelectedCell === false){//갱신 전에는 선택된 셀이였지만, 갱신 후에는 선택된 셀이 아닌 경우
							QBOX.util.removeClass(heCell, css.CELL_SELECT);
						}
						
						if(bBeforeStyleCell){//갱신 전에 셀 스타일이 적용되어 있던 경우
							objQCell._removeCellStyleCSS(heCell, objQCell._getCellStyle(nBeforeRow, nCol));
						}
						if(bStyleCell){//갱신 후에 셀 스타일을 적용해야 하는 경우
							objQCell._setCellStyleCSS(heCell, objQCell._getCellStyle(nRow, nCol));
						}
						if(bUseDataTextAlign)heCell.style.textAlign = strTextAlign;
					}
				});
				
				nAdjustHeight += nRowHeight;
			});
		} 
		/*merge********************************************************************/
		this._updateMergeData(); //머지 정보 설정
		/*merge********************************************************************/		
		/*
		 * 무결성 체크
		var arrCellGroupResult = _.map(this._getCellGroupDOMs('row', 'normal'), function(arrRowCells){
			return parseInt(arrRowCells[0].getAttribute('data-row'));
		});
		
		//갱신 후 일반 행들의 행 인덱스 번호가 연속적인 값인지 체크
		for(var i = 0 ; i < arrCellGroupResult.length - 1 ; i++){
			if(arrCellGroupResult[i] + 1 !== arrCellGroupResult[i + 1]){
				console.log('전체갱신, 무결성 깨짐', arrCellGroupResult[i], ', ', arrCellGroupResult[i + 1]);
				break;
			}
		}
		*/
		arrMovedDynamicRowsCellDOMs = null;
		var THAT = this;
		setTimeout(function(){
			THAT._trigger('viewport_changed');	
		});
		
	} catch(e){
		QCELL.log('err', 'QCELL.NormalQCELL._updateNRsAll', e.message);
	}
};

QBOX.QCELL.NormalQCELL.prototype.onVScroll = function(nScrollTop){
	//this._hideEditCellsDOM();
	this._onScrollHideEditCellsDOM();	
	QBOX.QCELL.BasicQCELL.prototype.onVScroll.call(this, nScrollTop);
	

};
/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 마지막 행 다음 위치에 행을 추가합니다. 
 * @param {Object} [data={}] - 행 데이터
 * @returns {boolean}
 * @example
 * QCell1.addRow();
 * QCell1.addRow({"name" : "kevin", "age" : "35"});	//QCELL의 data 타입이 "object"인 경우
 * QCell1.addRow(["kevin", "35"]);			//QCELL의 data 타입이 "array"인 경우
 */
QBOX.QCELL.NormalQCELL.prototype.addRow = function(data){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var strAPI = this.attr('id') + '.addRow',
		strDataType = this.attr('data').type;
		
		data = data === undefined ? (strDataType === 'array' ? [] : {}) : data;
		
		if((strDataType === 'array' && QBOX._.isArray(data)) || (strDataType === 'object' && typeof data === 'object' && QBOX._.isArray(data) === false)){
			var bRet = this._insertRows(this.attr('rows'), [data]);
			if(bRet === true){
				var THAT = this;
				setTimeout(function(){
					THAT._trigger('rowinserted');
				},0);
			}
			return bRet;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
		
		return false;
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 마지막 행 다음 위치에 다수의 행을 추가합니다. 
 * @param {number | Array} count_or_data - 행의 개수 또는 행 데이터 배열
 * @returns {boolean}
 * @example
 * QCell1.addRow(3);
 * QCell1.addRows([{"name" : "kevin", "age" : "35"}, {"name" : "jenny", "age" : "28"}]);//QCELL의 data 타입이 "object"인 경우
 * QCell1.addRows([["kevin", "35"], ["jenny", "28"]]);//QCELL의 data 타입이 "array"인 경우
 */
QBOX.QCELL.NormalQCELL.prototype.addRows = function(count_or_data){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var strAPI = this.attr('id') + '.addRows';
		
		if(arguments.length < 1){
			QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		} else{
			if(typeof count_or_data === 'number'){
				return (count_or_data > 0) ? this._insertRows(this.attr('rows'), QBOX._.map(QBOX._.range(count_or_data), function(){return {};})) : false;
			} else if(QBOX._.isArray(count_or_data)){
				var strDataType = this.attr('data').type;
				
				if((strDataType === 'array' && QBOX._.every(count_or_data, function(rowdata){return _QBOX._.isArray(rowdata);})) || 
						(strDataType === 'object' && QBOX._.every(count_or_data, function(rowdata){return (QBOX._.isArray(rowdata) === false && typeof rowdata === 'object');}))){
					var bRet =(count_or_data.length > 0) ? this._insertRows(this.attr('rows'), count_or_data) : false; 
					if(bRet === true){
						var THAT = this;
						setTimeout(function(){
							THAT._trigger('rowinserted');
						},0);
					}
					
					return bRet;
				}
			} else{
				QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
			}
		}
		
		return false;
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 행 인덱스 위치에 행을 삽입합니다. 
 * @param {number} row - 행 인덱스
 * @param {Object} [data={}] - 행 데이터
 * @returns {boolean}
 * @example
 * QCell1.insertRow(3);
 * QCell1.insertRow(3, {"name" : "kevin", "age" : "35"});	//QCELL의 data 타입이 "object"인 경우
 * QCell1.insertRow(3, ["kevin", "35"]);		//QCELL의 data 타입이 "array"인 경우
 */
QBOX.QCELL.NormalQCELL.prototype.insertRow = function(row, data){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var strAPI = this.attr('id') + '.insertRow',
		strDataType = this.attr('data').type;
		
		data = data === undefined ? (strDataType === 'array' ? [] : {}) : data;
		
		if(typeof row === 'number' && (strDataType === 'array' && QBOX._.isArray(data)) || (strDataType === 'object' && typeof data === 'object' && QBOX._.isArray(data) === false)){
			var bRet = (row >= this.attr('headerrows')) ? this._insertRows(row, [data]) : false;
			if(bRet === true){
				var THAT = this;
				setTimeout(function(){
					THAT._trigger('rowinserted');
				},0);
			}
			
			return bRet;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
		
		return false;
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 행 인덱스 위치에 다수의 행을 삽입합니다.
 * @param {number} row - 행 인덱스
 * @param {number | Array} count_or_data - 행의 개수 또는 행 데이터 배열
 * @returns {boolean}
 * @example
 * QCell1.insertRows(3, 2);
 * QCell1.insertRows(3, [{"name" : "kevin", "age" : "35"}, {"name" : "jenny", "age" : "28"}]);//QCELL의 data 타입이 "object"인 경우
 * QCell1.insertRows(3, [["kevin", "35"], ["jenny", "28"]]);//QCELL의 data 타입이 "array"인 경우
 */
QBOX.QCELL.NormalQCELL.prototype.insertRows = function(row, count_or_data){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var strAPI = this.attr('id') + '.insertRows';
		
		if(arguments.length < 2){
			QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		} else{
			if(typeof row === 'number'){
				if(typeof count_or_data === 'number'){
					return (row >= this.attr('headerrows') && count_or_data > 0) ? this._insertRows(row, QBOX._.map(QBOX._.range(count_or_data), function(){return {};})) : false;
				} else if(QBOX._.isArray(count_or_data)){
					var strDataType = this.attr('data').type;
					
					if((strDataType === 'array' && QBOX._.every(count_or_data, function(rowdata){return _QBOX._.isArray(rowdata);})) || 
							(strDataType === 'object' && QBOX._.every(count_or_data, function(rowdata){return (QBOX._.isArray(rowdata) === false && typeof rowdata === 'object');}))){
						
						var bRet = (row >= this.attr('headerrows') && count_or_data.length > 0) ? this._insertRows(row, count_or_data) : false;
						if(bRet === true){
							var THAT = this;
							setTimeout(function(){
								THAT._trigger('rowinserted');
							},0);
						}
						
						return bRet;
					}
				} else{
					QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
				}
			}
		}
		
		return false;
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 다수의 행 인덱스 위치에 행을 삽입합니다.
 * @param {Array} data - 행 인덱스 위치, 행 데이터 배열의 배열
 * @returns {boolean}
 * @example
 * QCell1.insertRowsEx([ [3, {"name" : "kevin", "age" : "35"}], [5,{"name" : "jenny", "age" : "28"}] ]);//QCELL의 data 타입이 "object"인 경우
 * QCell1.insertRowsEx([ [3, ["kevin", "35"]], [5, ["jenny", "28"]] ]);//QCELL의 data 타입이 "array"인 경우
 */
QBOX.QCELL.NormalQCELL.prototype.insertRowsEx = function(data){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var bRet =this._insertRowsEx(data); 
		
		if(bRet === true){
			var THAT = this;
			setTimeout(function(){
				THAT._trigger('rowinserted');
			},0);
		}		
	
		return bRet;
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 마지막 행을 삭제합니다. 
 * @returns {boolean}
 * @example
 * QCell1.removeRow();
 */
QBOX.QCELL.NormalQCELL.prototype.removeRow = function(){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var bRet = this._deleteRows(this.attr('rows') - 1, 1);

		if(bRet === true){
			var THAT = this;
			setTimeout(function(){
				THAT._trigger('rowdeleted');
			},0);
		}			
		
		return bRet; 
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 마지막 행부터 입력받은 개수만큼 행을 삭제합니다. 
 * @param {number} count - 삭제할 행의 개수
 * @returns {boolean}
 * @example
 * QCell1.removeRows(3);
 */
QBOX.QCELL.NormalQCELL.prototype.removeRows = function(count){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var strAPI = this.attr('id') + '.removeRows';
		
		if(arguments.length < 1){
			QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		} else{
			if(typeof count === 'number'){
				var bRet =(count > 0) ? this._deleteRows(this.attr('rows') - count, count) : false;
				if(bRet === true){
					var THAT = this;
					setTimeout(function(){
						THAT._trigger('rowdeleted');
					},0);
				}	
				return bRet;
			} else{
				QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
			}
		}
		
		return false;
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 행 인덱스 위치의 행을 삭제합니다. 
 * @param {number} row - 행 인덱스
 * @returns {boolean}
 * @example
 * QCell1.deleteRow(3);
 */
QBOX.QCELL.NormalQCELL.prototype.deleteRow = function(row){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var strAPI = this.attr('id') + '.deleteRow';
		
		if(arguments.length < 1){
			QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		} else{
			if(typeof row === 'number'){
				var bRet =(row >= this.attr('headerrows')) ? this._deleteRows(row, 1) : false;
				if(bRet === true){
					var THAT = this;
					setTimeout(function(){
						THAT._trigger('rowdeleted');
					},0);
				}					
				return bRet;
			} else{
				QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
			}
		}
		
		return false;
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 행 인덱스 위치부터 설정한 개수만큼 행을 삭제합니다.
 * @param {number} row - 행 인덱스
 * @param {number} count - 삭제할 행의 개수
 * @returns {boolean}
 * @example
 * QCell1.deleteRows(3, 2);
 */
QBOX.QCELL.NormalQCELL.prototype.deleteRows = function(row, count){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var strAPI = this.attr('id') + '.deleteRows';
		
		if(arguments.length < 2){
			QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		} else{
			if(typeof row === 'number' && typeof count === 'number'){
				var bRet =(row >= this.attr('headerrows') && count > 0) ? this._deleteRows(row, count) : false;
				if(bRet === true){
					var THAT = this;
					setTimeout(function(){
						THAT._trigger('rowdeleted');
					},0);
				}					
				
				return bRet;
			} else{
				QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
			}
		}
		
		return false;
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 입력받은 행 인덱스 위치의 행을 삭제합니다.
 * @param {Array} rows - 행 인덱스 배열
 * @returns {boolean}
 * @example
 * QCell1.deleteRowsEx([3,5,7]);
 */
QBOX.QCELL.NormalQCELL.prototype.deleteRowsEx = function(rows){
	//if(_.isEmpty(this.attr('paginationinfo'))){
	var bRet =this._deleteRowsEx(rows);
	if(bRet === true){
		var THAT = this;
		setTimeout(function(){
			THAT._trigger('rowdeleted');
		},0);
	}	
	
		return bRet;
	//}
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 지정한 타입의 행 상태 정보를 반환합니다.
 * @param {string} state - 반환할 행 상태 정보의 타입 ("i" | "u" | "d")
 * @returns {Array}
 * @example
 * QCell1.getState('i');
 */
QBOX.QCELL.NormalQCELL.prototype.getState = function(state){
	var strAPI = this.attr('id') + '.getState',
	result = [];
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof state === 'string'){
			switch(state){
				case 'd': case 'i': case 'u': {
					result = this._getState(state);
					break;
				}
				default: break;
			}
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return result;
};

/**
 * @since QCELL v1.0.0
 * @author sonymaker
 * @description 행 상태 정보들을 반환합니다.
 * @returns {Object}
 * @example
 * QCell1.getStates();
 */
QBOX.QCELL.NormalQCELL.prototype.getStates = function(){
	return this._getStates();
};

/**
 * @since QCELL v2.1.56
 * @author seongdeuk1985
 * @description 삭제정보를 포함한 모든 상태정보를 삭제한다.
 * @returns {boolean}
 * @example
 * QCell1.clearStates();
 */
QBOX.QCELL.NormalQCELL.prototype.clearStates = function(){
	return this._clearStates();
};

/**
 * @since QCELL v2.1.27
 * @author jklee
 * @description 행 상태 정보들을 반환합니다.
 * @param {string} propertyName - (optional) 프로퍼티 명칭
 * @returns {Array}
 * @example
 * QCell1.getStatesEx();
 */
QBOX.QCELL.NormalQCELL.prototype.getStatesEx = function(propertyName){
	return this._getStatesEx(propertyName);
};

/**
 * @since QCELL v2.1.28
 * @author jklee
 * @description 행 상태 정보들을 구분자 형태로 반환합니다.
 * @param {string} rowSep - (optional) 행구분자
 * @param {string} colSep - (optional) 열구분자
 * @param {array} arrKeys - (optional) 추가 해야할 키들  
 * @returns {string}
 * @example
 * QCell1.getStatesBySep();
 */
QBOX.QCELL.NormalQCELL.prototype.getStatesBySep = function(rowSep,colSep,arrKeys){
	return this._getStatesBySep(rowSep,colSep,arrKeys);
};
/**
 * @since QCELL v2.1.39
 * @author jklee
 * @description 모든 행 상태 정보들을 구분자 형태로 반환합니다.
 * @param {string} strStateName - (optional) 상태정보 표시 명
 * @param {string} strRowName - (optional) 행번호 표시 명 
 * @returns {string}
 * @example
 * QCell1.getAllStatesBySep();
 */
QBOX.QCELL.NormalQCELL.prototype.getAllStatesBySep = function(strStateName,strRowName,strRowSep,strColSep){
	return this._getAllDataStatesBySep(strStateName,strRowName,strRowSep,strColSep);
};

/**
 * @since QCELL v2.1.30
 * @author jklee
 * @description 셀을 활성화 / 비활성화 상태로 설정합니다.
 * @param {number} row - 활성화할 행 인덱스
 * @param {number} col - 활성화할 열 인덱스
 * @param {boolean} bDisable - disable 여부
 * @param {string} disable 시 표현 되는 문자열 
 * @returns {boolean}
 * @example
 * QCell1.setCellDisable(3, 2, true, disabletext);
 */
QBOX.QCELL.NormalQCELL.prototype.setCellDisable = function(row, col, bDisable, disabletext){
	var strAPI = this.attr('id') + '.setCellDisable';
	
	if(arguments.length < 3){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isNumber(row) && QBOX._.isNumber(col)){
			this._setCellDisabled(row, col, bDisable);
			
			var arr = this.attr('currentdata');
			var strKey = this._getKeyOfCol(col),objRow;			
			
			if(disabletext !== undefined){
				objRow = arr[row-this.attr('headerrows')];
				if(objRow !== undefined){
					objRow['_rt_qc_d_' + strKey] = disabletext;	
					
					if(bDisable === true){
						var heCell = this._getCellDOM(row,col);
						if(heCell !== null && heCell !== undefined)
							QBOX.util.textContent(heCell,disabletext);					
					}					
				}
			}
			if(bDisable === false){
				objRow = arr[row-this.attr('headerrows')];
				
				if(objRow !== undefined){
					
					if(objRow['_rt_qc_d_' + strKey] !== undefined){
						
						delete objRow['_rt_qc_d_' + strKey];
						this.setCellDataEx(row,strKey, objRow[strKey]);
					}	
				}				
			}
			return true;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.83
 * @author jklee
 * @description 셀들을 활성화 / 비활성화 상태로 설정합니다.
 * @param {number} srow - 활성화할 행 처음 인덱스
 * @param {number} scol - 활성화할 열 처음 인덱스
 * @param {number} erow - 활성화할 행 마지막 인덱스
 * @param {number} ecol - 활성화할 열 마지막 인덱스
 * @param {boolean} bDisable - disable 여부
 * @returns {boolean}
 * @example
 * QCell1.setCellsDisable(3, 2, 5,2,true);
 */
QBOX.QCELL.NormalQCELL.prototype.setCellsDisable = function(srow, scol,erow,ecol, bDisable){
	var strAPI = this.attr('id') + '.setCellsDisable';
	
	if(arguments.length < 5){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isNumber(srow) && QBOX._.isNumber(scol) && QBOX._.isNumber(erow) && QBOX._.isNumber(ecol)){
			var i,j;
			for(i=srow ; i<=erow; i++){
				for(j=scol ; j<=ecol; j++){
					this._setCellDisabled(i, j, bDisable);		
				}
			}
			
			return true;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.56
 * @author seongdeuk1985
 * @description 행을 활성화 / 비활성화 상태로 설정합니다.
 * @param {number} row - 활성화할 행 인덱스
 * @param {boolean} bDisable - disable 여부
 * @param {string} area="data" - 설정할 영역 ("data" | "rowheader" | "all")
 * @returns {boolean}
 * @example
 * QCell1.setRowDisable(3, true);
 */
QBOX.QCELL.NormalQCELL.prototype.setRowDisable = function(row, bDisable, area){
	var strAPI = this.attr('id') + '.setRowDisable';
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isNumber(row) && QBOX._.isBoolean(bDisable)){
			var col;
			var cols = this.attr('cols');
			var stcols = this.attr('headercols');
			
			if(QBOX._.isUndefined(area)){
				area = 'data';
			} else {
				if(!QBOX._.isString(area)){
					QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
					return false;
				}
			}
			
			if(area === "rowheader" || area === "all"){
				for(col = 0; col < stcols; col++){
					this.setCellDisable(row, col, bDisable);
				}
			}
			
			if(area === "data" || area === "all"){
				for(col = stcols; col < cols; col++){
					this.setCellDisable(row, col, bDisable);
				}
			}
			
			return true;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.71
 * @author jklee
 * @description 컬럼을 활성화 / 비활성화 상태로 설정합니다.
 * @param {number} col - 활성화할 열 인덱스
 * @param {boolean} bDisable - disable 여부
 * @returns {boolean}
 * @example
 * QCell1.setColDisable( 2, true);
 */
QBOX.QCELL.NormalQCELL.prototype.setColDisable = function( col, bDisable){
	var strAPI = this.attr('id') + '.setColDisable';
	
	if(arguments.length < 2){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if( QBOX._.isNumber(col)){
			var nHeaderRows = this.attr('headerrows'), nRows = this.attr('rows');
			for(var i=nHeaderRows ; i<nRows; i++){
				this._setCellDisabled(i, col, bDisable);	
			}
			var objCol = this._getQCellCol(col);
			if(objCol !== null){
				objCol.attr('_coldisable' , bDisable, 'boolean');
			}
			return true;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.174
 * @author jklee
 * @description 컬럼을 활성화 / 비활성화 상태를 가져 옵니다..
 * @param {number} col - 활성화할 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.getColDisable( 2);
 */
QBOX.QCELL.NormalQCELL.prototype.getColDisable = function( col){
	var strAPI = this.attr('id') + '.getColDisable';
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if( QBOX._.isNumber(col)){
			var objCol = this._getQCellCol(col);
			if(objCol !== null){
				return objCol.attr('_coldisable') !== null ? objCol.attr('_coldisable') : false;
			}
			
			return false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};
/**
 * @since QCELL v2.1.87
 * @author jklee
 * @description QCELL 활성화 / 비활성화 상태를 반환합니다..
 * @returns {boolean}
 * @example
 * QCell1.getDisable();
 */
QBOX.QCELL.NormalQCELL.prototype.getDisable = function( ){
	return this.attr('bQcellDisable') === true ? true : false;
};
/**
 * @since QCELL v2.1.87
 * @author jklee
 * @description QCELL 활성화 / 비활성화 상태로 설정합니다.
 * @param {boolean} bDisable - disable 여부
 * @returns {boolean}
 * @example
 * QCell1.setDisable(true);
 */
QBOX.QCELL.NormalQCELL.prototype.setDisable = function( bDisable){
	var strAPI = this.attr('id') + '.setDisable';
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{		
		var nHeaderCols = this.attr('headercols'), nCols = this.attr('cols');
		for(var i=nHeaderCols ; i<nCols; i++){
			this.setColDisable(i, bDisable);	
		}
		
		this.attr('bQcellDisable' , bDisable, 'boolean');
		
		return true;
		 
	}
	
	return false;
};

/**
 * @since QCELL v2.1.9
 * @author seongdeuk1985
 * @description edit상태를 확인하고 edit상태이면 종료 설정합니다.
 * @returns {boolean}
 * @example
 * QCell1.closeEditMode();
 */
QBOX.QCELL.NormalQCELL.prototype.closeEditMode = function(){
	this._onScrollHideEditCellsDOM();
	
	return true;
};
/**
 * @since QCELL v2.1.82
 * @author jklee
 * @description 행 상태정보를 반환한다.
 * @param {number} row - 반환할 행 인덱스
 * @returns {string}
 * @example
 * QCell1.getRowState(3);
 */
QBOX.QCELL.NormalQCELL.prototype.getRowState = function(nRow ){
	return this._getRowState(nRow);
};
/**
 * @since QCELL v2.1.26
 * @author jklee
 * @description 행 상태정보를 설정한다.
 * @param {number} row - 설정할 행 인덱스
 * @param {string} state - 설정할 상태값
 * @returns {boolean}
 * @example
 * QCell1.setRowState(3,'d');
 */
QBOX.QCELL.NormalQCELL.prototype.setRowState = function(nRow,strState ){
	return this._setRowState(nRow,strState);
};

/**
 * @since QCELL v2.1.26
 * @author jklee
 * @description 행 상태정보를 삭제한다.
 * @param {number} row - 설정할 행 인덱스
 * @returns {boolean}
 * @example
 * QCell1.removeRowState(3);
 */
QBOX.QCELL.NormalQCELL.prototype.removeRowState = function(nRow){
	return this._removeRowState(nRow);
};


/**
 * @since QCELL v2.1.26
 * @author jklee
 * @description 모든 상태정보를 삭제한다.
 * @returns {boolean}
 * @example
 * QCell1.clearRowStates();
 */
QBOX.QCELL.NormalQCELL.prototype.clearRowStates = function(){
	return this._clearRowStates();
};

/**
 * @since QCELL v2.1.34
 * @author jklee
 * @description required 컬럼을 확인하여 비어 있다면 정보를 반환한다.
 * @returns {Array}
 * @example
 * QCell1.checkRequired();
 */
QBOX.QCELL.NormalQCELL.prototype.checkRequired = function(){
	return this._checkRequired();
};

/**
 * @since QCELL v2.1.54
 * @author seongdeuk1985
 * @description 서버에 정보를 분할submit을 통해, 전체 데이터를 로딩한다.
 * @param {string} url - 서버와 통신할 URL주소
 * @param {number} pageCnt - 서버와 통신할 때마다 전달받을 데이터 갯수
 * @returns {boolean}
 * @example
 * QCell1.divisionSubmit('/divisionSubmitSample.do', 5);
 */
QBOX.QCELL.NormalQCELL.prototype.divisionSubmit = function(url, pageCnt){
	var strAPI = this.attr('id') + '.divisionSubmit';
	
	if(QBOX._.isEmpty(this.attr('paginationinfo'))){
		if(arguments.length < 2){
			QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
		} else{
			if(QBOX._.isString(url) && QBOX._.isNumber(pageCnt)){
				return this._divisionSubmit(url, pageCnt);
			}
			else{
				QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
			}
		}
	} else {
		QCELL.log('err', strAPI, this.attr('msg').err.CAN_NOT_USE_WITH_PAGINATION);
	}
	
	return false;
};

/**
 * @since QCELL v2.1.63
 * @author seongdeuk1985
 * @description 입력받은 행 인덱스 위치에 고정출력 행을 삽입합니다. 
 * @param {number} row - 행 인덱스
 * @param {Object} [data={}] - 행 데이터
 * @returns {boolean}
 * @example
 * QCell1.insertStaticRow(3);
 * QCell1.insertStaticRow(3, {"name" : "kevin", "age" : "35"});	//QCELL의 data 타입이 "object"인 경우
 * QCell1.insertStaticRow(3, ["kevin", "35"]);		//QCELL의 data 타입이 "array"인 경우
 */
QBOX.QCELL.NormalQCELL.prototype.insertStaticRow = function(row, data){
	//if(_.isEmpty(this.attr('paginationinfo'))){
		var strAPI = this.attr('id') + '.insertRow',
		strDataType = this.attr('data').type;
		
		data = data === undefined ? (strDataType === 'array' ? [] : {}) : data;
		
		if(typeof row === 'number' && (strDataType === 'array' && QBOX._.isArray(data)) || (strDataType === 'object' && typeof data === 'object' && QBOX._.isArray(data) === false)){
			return (row >= this.attr('headerrows')) ? this._insertStaticRows(row, [data]) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
		
		return false;
	//}
};

/**
 * @since QCELL v2.1.63
 * @author seongdeuk1985
 * @description 입력받은 행 인덱스 위치의 고정출력 행을 삭제합니다. (일반 행도 삭제가능하나, 반드시 고정출력 행을 삭제할 때 사용해야 한다.)
 * @param {number} row - 행 인덱스
 * @returns {boolean}
 * @example
 * QCell1.deleteStaticRow(3);
 */
QBOX.QCELL.NormalQCELL.prototype.deleteStaticRow = function(row){
	var strAPI = this.attr('id') + '.deleteStaticRow';
	
	if(arguments.length < 1){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(typeof row === 'number'){
			return (row >= this.attr('headerrows')) ? this._deleteStaticRows(row, 1) : false;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.65
 * @author seongdeuk1985
 * @description 포커스된 행의 상태 정보를 반환합니다. 반환할 행 상태 정보의 타입 ("i" | "u" | "d")
 * @returns {Array}
 * @example
 * QCell1.getFocusRowState();
 */
QBOX.QCELL.NormalQCELL.prototype.getFocusRowState = function(){
	return this._getFocusRowState();
};

/**
 * @since QCELL v2.1.65
 * @author seongdeuk1985
 * @description 특정 행의 상태 정보를 반환합니다. 반환할 행 상태 정보의 타입 ("i" | "u" | "d")
 * @param row - 상태 정보를 확인할 행의 인덱스
 * @returns {Array}
 * @example
 * QCell1.getSelectRowState(3);
 */
QBOX.QCELL.NormalQCELL.prototype.getSelectRowState = function(row){
	return this._getSelectRowState(row);
};

/**
 * @since QCELL v2.1.65
 * @author seongdeuk1985
 * @description 셀 내의 데이터를 출력/숨김 상태로 설정합니다.
 * @param {number} row - 출력/숨김 할 행 인덱스
 * @param {number} col - 출력/숨김 할 열 인덱스
 * @param {boolean} bVisible - 출력/숨김 여부
 * @returns {Boolean}
 * @example
 * QCell1.setCellInvisible(2, 1, true);
 */
QBOX.QCELL.NormalQCELL.prototype.setCellInvisible = function(row, col, bVisible){
	var strAPI = this.attr('id') + '.setCellInvisible';
	
	if(arguments.length < 3){
		QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else{
		if(QBOX._.isNumber(row) && QBOX._.isNumber(col) && QBOX._.isBoolean(bVisible)){
			this._setCellInvisible(row, col, bVisible);
			
			//this._getQCellCol(col).attr('cellinvisible')[row] = bVisible;
			
			return true;
		} else{
			QCELL.log('err', strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return false;
};

/**
 * @since QCELL v2.1.75
 * @author seongdeuk1985
 * @description 특정 컬럼의 데이터를 모두 더합니다.
 * @param {number} nCol - 컬럼의 열 인덱스
 * @returns {Number}
 * @example
 * QCell1.getColSum(4);
 */
QBOX.QCELL.NormalQCELL.prototype.getColSum = function(nCol){
	var headerrows = this.attr('headerrows'),
	colkey = this.attr('colkeys')[nCol],
	cnt = 0, THAT = this;
	QBOX.$(this.attr('currentdata')).each(function(idx, rowdata){
		if(!THAT.isStaticRow(idx + headerrows -1)){
			if(QBOX._.isNumber(rowdata[colkey])){
				cnt += parseFloat(rowdata[colkey]);
			}
		}
	});
	return cnt;
};

/**
 * @since QCELL v2.1.75
 * @author seongdeuk1985
 * @description 특정 행이 출력전용 행인 static row인지 확인합니다.
 * @param {number} nCol - 행 인덱스
 * @returns {Number}
 * @example
 * QCell1.isStaticRow(3);
 */
QBOX.QCELL.NormalQCELL.prototype.isStaticRow = function(nRow){
	var staticrowsinfo = this.attr('staticrowsinfo'),
	res = false;
	
	for(var i = 0; i < staticrowsinfo.length; i++){
		if(staticrowsinfo[i].nRow === nRow){
			res = true;
			break;
		}
	}
	
	return res;
};

/**
 * @since QCELL v2.1.90
 * @author jklee
 * @description edit 가능한 Cell 이면 Edit 상태 들어가도록 함..
 * @param {number} row - 행 인덱스
 * @param {number} col - 열 인덱스
 * @returns {boolean }
 * @example
 * QCell1.editCell ( 3, 1)
 */
QBOX.QCELL.NormalQCELL.prototype.editCell = function(nRow,nCol){
	var THAT = this;
	this.focusCell(nRow,nCol);
	this.scrollTop (nRow);
	this.scrollLeft (nCol);
	
	setTimeout(function(){
		
		var objCellDisabled = THAT._getQCellCol(nCol).attr('celldisabled')[nRow],
		target= THAT._getCellDOM(nRow,nCol);
		
		switch(THAT._getColType(nCol)){
		case 'input': case 'textarea': case 'selectmenu': case 'number': case 'slider':  case 'inputbutton':{
			if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
				THAT._getColElement(nCol)._show(target, '');
			}
			break;
		}
		case 'datepicker':{
			if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작
				THAT._getColElement(nCol)._show(target);
			}
			break;
		}
		case 'multicheckbox': case 'editor': {
			if(QBOX._.isUndefined(objCellDisabled) || objCellDisabled === false){ // celldisabled속성이 false일 때 각 type의 _show() 동작 
				THAT._getColElement(nCol)._show(target, nRow, nCol);
			}
			break;
		}
		default: {
			break;
		}
	}
	},200);
	return true;
};
/**
 * @since QCELL v2.1.153
 * @author jklee
 * @description 모든행에 대한 상태 정보들을 반환합니다.
 * @returns {Object}
 * @example
 * QCell1.getStates();
 */
QBOX.QCELL.NormalQCELL.prototype.getAllStates = function(){
	return this._getAllStates();
};

/**
 * @since QCELL v1.0.0
 * @author seongdeuk1985
 * @description QCELL의 특정 열의 전체 선택 체크박스 존재 여부를 반환합니다.
 * @param {number} col - 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.isHeaderCheckbox(1);
 * @ignore
 */
QBOX.QCELL.NormalQCELL.prototype.isHeaderCheckbox = function(col){
	var strAPI = this.attr('id') + '.isHeaderCheckbox',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if( typeof col === "number" && !(QBOX._.isNull(this._getColElement(col))) && this._getColType(col) === 'checkbox' ) {
			bool = this._getColElement(col)._isHeaderCheckbox(col);
		} else {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	} 
	
	return bool;
};

/**
 * @since QCELL v1.0.0
 * @author seongdeuk1985
 * @description QCELL의 특정 열에 전체 선택 체크박스가 존재할 경우, 전체 선택 체크박스의 상태 값을 반환합니다.
 * @param {number} col - 열 인덱스
 * @returns {boolean}
 * @example
 * QCell1.getHeaderCheckedState(1);
 */
QBOX.QCELL.NormalQCELL.prototype.getHeaderCheckedState = function(col){
	var strAPI = this.attr('id') + '.getHeaderCheckedState',
	bool = false;
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if( typeof col === "number" && !(QBOX._.isNull(this._getColElement(col))) && this._getColType(col) === 'checkbox' ) {
			bool = this._getColElement(col)._getHeaderCheckedState(col);
		} else {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	}
	
	return bool;
};

/**
 * @since QCELL v1.0.0
 * @author seongdeuk1985
 * @description QCELL의 특정 열에 전체 선택 체크박스가 존재할 경우, 전체 선택 체크박스의 상태 값을 설정합니다.
 * @param {number} col - 열 인덱스
 * @param {boolean} state - 전체 선택 체크박스 상태 값 (true | false)
 * @returns {void}
 * @example
 * QCell1.setHeaderChecked(1, true);
 */
QBOX.QCELL.NormalQCELL.prototype.setHeaderChecked = function(col, state) {
	var strAPI = this.attr('id') + '.setHeaderChecked';
	
	if(arguments.length < 2){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if( typeof col !== "number") {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		} else if( (QBOX._.isNull(this._getColElement(col))) && this._getColType(col) !== 'checkbox') {
			QBOX.QCELL.log('err', strAPI, this.attr('msg').err.TYPE_NOT_CHECKBOX);
		} else if(typeof state !== "boolean") {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		} else {
			this._getColElement(col)._setHeaderChecked(col, state);
		}
	}
};

/**
 * @since QCELL v1.0.0
 * @author seongdeuk1985
 * @description QCELL의 특정 열의 타입이 "checkbox" 일 때, 선택된 행 인덱스들을 배열로 반환합니다.
 * @param {number} col - 열 인덱스
 * @returns {Array}
 * @example
 * QCell1.getCheckedRows(1);
 */
QBOX.QCELL.NormalQCELL.prototype.getCheckedRows = function(col) {
	var strAPI = this.attr('id') + '.getCheckedRows',
	rtnArr = [];
	
	if(arguments.length < 1){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if( typeof col !== "number") {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		} else if( (QBOX._.isNull(this._getColElement(col))) && this._getColType(col) !== 'checkbox') {
			QBOX.QCELL.log('err', strAPI, this.attr('msg').err.TYPE_NOT_CHECKBOX);
		} else {
			var st = this.attr('headerrows'),
			ed = this.attr('rows'),
			checkedValue = this._getColElement(col).attr('checkedvalue');
			
			for(; st < ed; st++) {
				if( checkedValue === this._cellValue(st, col) ){
					rtnArr.push(st);
				}  
			}
		}
	}
	
	return rtnArr;
};

/**
 * @since QCELL v1.0.51
 * @author seongdeuk1985
 * @description QCELL의 selectmenu Column의 데이터에서 value값을 설정하여, 그에 해당하는 label값을 QCELL에 출력시킵니다.
 * @param {number} row - 행 인덱스
 * @param {number} col - 열 인덱스
 * @param {string | number} val - 설정값
 * @returns {boolean}
 * @example
 * QCell1.setSelectmenuValue(1, 5, '');
*/
QBOX.QCELL.NormalQCELL.prototype.setSelectmenuValue = function(row, col, val){
	var strAPI = this.attr('id') + '.setSelectmenuValue',
	bool = false;
	
	if(arguments.length < 3){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if( QBOX._.isNumber(row) && QBOX._.isNumber(col) && (QBOX._.isString(val) || QBOX._.isNumber(val)) && !(QBOX._.isNull(this._getColElement(col))) && this._getColType(col) === 'selectmenu' ) {
			bool = this._getColElement(col)._showDataLabel(this._getCellDOM(row, col), row, col, val);
		} else {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	} 
	
	return bool;
};
/**
 * @since QCELL v2.1.84
 * @author jklee
 * @description selectmenu Column의 value값으로 label 값 가져오는 API 입니다.
 * @param {number} row - 행 인덱스
 * @param {number} col - 열 인덱스
 * @returns {string}
 * @example
 * QCell1.getSelectmenuLabel(1, 5);
*/
QBOX.QCELL.NormalQCELL.prototype.getSelectmenuLabel = function(row, col){
	var strAPI = this.attr('id') + '.getSelectmenuLabel',
	strRet = '';
	
	if(arguments.length < 2){
		QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_COUNT);
	} else {
		if( QBOX._.isNumber(row) && QBOX._.isNumber(col) && !(QBOX._.isNull(this._getColElement(col))) && this._getColType(col) === 'selectmenu' ) {
			strRet = this._getColElement(col)._getDataLabel(row, col);
		} else {
			QBOX.QCELL.log("err", strAPI, this.attr('msg').err.PARAM_TYPE);
		}
	} 
	
	return strRet;
};

/* NormalQCELL의 속성 초기값 정의 */
QBOX.QCELL.config = QBOX._.extend(QBOX._.clone(QBOX.QCELL.config), {
	'moduletype'		: 'normal',
	'oneclickedit'		: false,
	'htmlselectmenu'	: false,
	'usebuttonclickcallback' : false,
	'delkeymode'		: 'select',
	'setstatewithapi'	: true
});

QBOX.QCELL.def.msg.kr.err = QBOX._.extend(QBOX._.clone(QBOX.QCELL.def.msg.kr.err), {
	TYPE_NOT_CHECKBOX : "지정한 열의 타입은 'checkbox'가 아닙니다.",
	NOT_HAVE_HEADER_CHECKBOX : "지정한 열의 options 중 'wholeselect' 값이 설정되어 있지 않거나 사용 설정된 상태가 아닙니다.",
	CAN_NOT_USE_WITH_PAGINATION: "pagination 속성과 같이 사용할 수 없습니다."
});

QBOX.QCELL.def.msg.en.err = QBOX._.extend(QBOX._.clone(QBOX.QCELL.def.msg.en.err), {
	TYPE_NOT_CHECKBOX : "Please check, This col`s Type. Is a 'checkbox'.",
	NOT_HAVE_HEADER_CHECKBOX : "Please check, This col`s options. Is not set up 'wholeselect' or 'wholeselect' value is not true.",
	CAN_NOT_USE_WITH_PAGINATION: "Please check, can`t use with a 'pagination' attribute."
});
QBOX.QCELL.NormalQCELL.create = function(properties){
	return QBOX.QCELL.BasicQCELL.create.call(this, properties);
};

QBOX.QCELL.NormalQCELL._create = function(properties){
	return QBOX.QCELL.BasicQCELL._create.call(this, properties);
};

QBOX.QCELL.NormalQCELL._checkRequiredProps = function(properties){
	if(QBOX.QCELL.BasicQCELL._checkRequiredProps(properties)){
		return true;
	}
	return false;
};

QBOX.QCELL.NormalQCELL._checkValidationOfProps = function(properties){
	var result = false;
	if(QBOX.QCELL.BasicQCELL._checkValidationOfProps(properties)){
		QBOX.$.each(properties, function(key, val){
			result = QBOX.QCELL.NormalQCELL._checkValidationOfProp(key, val);
			return result;
		});
	}
	return result;
};

QBOX.QCELL.NormalQCELL._checkValidationOfProp = function(key, val){
	var result = true, defaultmsg = true, datatype = '';
	switch(key){
		/* string type */
		
		/* number type */
		
		/* array type */
		
		/* object type */
		
		/* boolean type */
		case 'oneclickedit':{
			datatype = 'boolean';
			if(QBOX._.isBoolean(val) === false){
				result = false;
			}
			
			break;
		}
		
		/* *************** 선택 속성 체크 *************** */
		default : break;
	}
	
	if(result === false && defaultmsg){
		QBOX.QCELL.log('err', 'QCELL.create', 'Please check "' + key + '" property\'s type is "' + datatype + '".');
	}
	
	return result;
};

QBOX.QCELL.NormalQCELL._adjustProps = function(properties){
	var result = QBOX._.mapObject(QBOX.QCELL.BasicQCELL._adjustProps(properties), function(val, key){
		return QBOX.QCELL.NormalQCELL._adjustProp(key, val);
	});
	
	return QBOX._.extendOwn(QBOX._.clone(QBOX.QCELL.config), result);
};

QBOX.QCELL.NormalQCELL._adjustProp = function(key, val){
	var result = null;
	if(val === undefined){
		result = QBOX.QCELL.BasicQCELL._getDefaultValueOfProp(key);
	} else{
		switch(key){
			/* *************** 선택 속성 체크 *************** */
			//case로 정의되어 있지 않은 속성들은 default:{}부분으로 동작한다.
			/* string type */
			/* boolean type */
			/* number type */
			/* array type */
			/* object type */
			default: {
				result = val;
				break;
			}
		}
	}
	return result;
};

window.QCELL = QBOX.QCELL;
